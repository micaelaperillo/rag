let's get started so today's lecture will be super short we've got a 45 minute quiz on uh objectoriented programming classes that kind of stuff so I wanted to give you guys an extra bit of time to work through three programming problems um but uh the the the the actual lecture part um we're going to switch gears a little bit and we're going to start talking about um something more theoretical which is how to figure out whether the programs we write are efficient and how efficient are they okay so we're going to do that today using uh uh the idea of timing our programs and then counting number of operations as I'll describe it in a little bit but first of all a little bit of motivation so um why do we actually care about this topic it's a topic that's uh uh High research area in computer science um so far in this class though we've emphasized correctness right in problem sets the unit tests check for the whether uh that the programs you wrote were correct in quizzes we basically look at how many test cases you pass right and to determine the grade but you know the uh these days we actually have a whole bunch of data coming at us right so we have a lot of data that we need to analyze we need to read we need to visualize um we need to make sense of and so the programs that we write yes they have to be correct which is a large part of it but they also have to be fast right so if it takes a year to analyze you know the a bunch of uh information on YouTube videos nobody's going to really want to wait that long right and so we're going to emphasize uh in the the next three or four lectures I forget exactly how many but the next little section in this class um the idea of how to determine the efficiency of our programs okay so when we're talking about efficiency we can talk about the time efficiency of programs and also the space efficiency of programs and usually there's going to be a trade-off between these two so very rarely these days can you come up with an algorithm that's both efficient in time and space compared to algorithms that are already out there um so usually there's a trade-off and the most uh the best example is the one that we saw with Fibonacci so we saw an uh code that was recursive to calculate Fibonacci so Fibonacci of n was Fibonacci of n minus1 plus Fibonacci of n minus 2 right that was our recursive step um that program uh that that was recursive took something like 30 million steps to calculate Fibonacci of 30 something right it was 30 million uh recursive calls which was pretty slow it took a couple seconds for it to run but then we saw a version with memorization no there's no R missing there it's just me memorization the sort of the process of keeping a memo through a dictionary in that particular case and the memorization idea was that we would take uh some values that we calculate and as we calculate them store them in the memo so in the memorization example we had um we had given up some of our memory right to store these values so that we didn't have to compute them and in the process of doing so we had a program that ran really really quick right much quicker than the plain recursive version that we had originally seen so there's this trade-off right where you have a program that's fast but might store some values and take up more memory or a program that doesn't store anything but then is not going to be as fast it's going to be slower because it needs to keep uh uh Computing a bunch of different values so what we're going to do in this lecture is kind of show you a very simple way of of figuring out how efficient our programs are which is we're just going to time them and then we're going to count the number of operations that these programs take but we're going to do so sort of with the idea in the back of our mind that there's going to be some a better way to to figure out the efficiency of these programs and ultimately we don't really want to figure out the efficiency of an implementation right an implementation means you know you implement uh a a program that you know finds a sum using a while loop I implement the program find to find a sum using a for Loop right those are two different implementations but at their core the algorithms or behind the scenes is going to be the same and so what we what we want to do is to try to figure out how to evaluate algorithms as opposed to these different implementations right because each one of you is going to come up with a completely different implementation for today's quiz right but I don't want to evaluate that I would like to evaluate sort of the algorithms behind the scenes okay so we're going to do like I mentioned we're going to today look at uh measuring uh how long our program takes with an actual timer and then we're going going to also count how many operations our program t uh takes um and then we're not going to look at this other abstract notion we're going to look at that next lecture okay so today's lecture we're going to use another module we've been looking at modules so uh in the past couple lectures already right we've seen um the random module which helps us deal with random numbers we've seen the uh date time module which helps us deal with or was it dat you till something like that which helps us deal with um datetime objects and uh converting dates into objects that were nicely usable today we're going to use the time module right here which will help us uh deal with the system clock okay so if we're timing functions that we run we're going to want to access the system clock to figure out exactly what time we started this function and what time we ended the function so just a little uh thing on you probably already know this how to call uh these functions Within These modules so the modules basically bring in a whole bunch of functions and maybe objects and things like that related to one topic one subject into your code and then to run the uh the um the functions in your code you just use this Donn notation on the module name so if I wanted to use the sign function from the math uh math module I would just say math. sign and then I have access to that sign function right okay so let's start looking at timing a program okay the simplest way to figure out how fast the program runs so we're going to use the time module so I'm importing it here and when I do that python is going to bring in all of these functions related to the time now we're going to look in this particular lecture at three different functions and we're going to time them each of them next lecture we're going to look at a whole bunch more functions just to give you a little bit more practice with timing and Counting operations and then we'll introduce a more abstract notion of this order of growth so the three functions we're going to look at are these ones so Celsius to Fahrenheit my sum and square so Celsius to Fahrenheit pretty self-explanatory it takes in one parameter the number for a Celsius temperature and converts it to Fahrenheit so we did this lecture one just using the formula this function my sum will take in a number X so you know seven or 10 or 100 whatever it is and it uses a loop Loop right so computationally uses this Loop that iterates through each number from zero all the way up to including X and keeps a running total right so it adds I to itself to the total and returns it so of course we could have Rewritten this in a more efficient way by using the the formula right to to calculate the sum what is n n * n plus 1 over two but here we're just doing it using this for Loop and then lastly um is this function called square and this one's going to be even more um inefficient we're going to calculate N squared so the parameter here n will be squared but we're not doing you know return n * n or return NS star star two we're not doing any of that we're actually going to use two nested Loops right so I've got an outer for Loop that goes through the numberers 0 to n not including an inner for Loop that goes through numbers 0 to n not including and this Square sum here adds one to itself every time so effectively we're going through and adding one to that sum n squar times all right so super inefficient but this is where we're at and so how do we actually time these functions so here's the this is basically you know one uh some lines of code in a file so I've got the time uh module imported here I've got the function here I'm going to call the time module and the time function within the time module so this tells me the number of seconds that have passed since January 1st 1970 that's called the um the epoch okay so the beginning of time and computer speak so if I grab how many seconds have uh have passed since that time then T start towards that number of seconds then I'm going to run my function Celsius to Fahrenheit 37 and then I'm going to get the time again down here and subtract the time right now after the function has finished minus the time it was right before I started my function okay so that gives me the the DT and then I just print that out so we can run it together the way I'm going to run it is by actually uh doing a little bit of modularization to this code so I'm have this function and this is the only function I'm actually going to run down here it's my I I call it a Time wrapper it's a wrapper function and it takes in two parameters the first is the actual function I want to run so I'll show you down here you can see I'm running the time wrapper with the name literally the name of the function I want to run this is not a function call it's just the name of my function so that's the first parameter and the second parameter is a whole bunch of different inputs I want to run the function with so this Ln is created up here and it just makes for me the list of all of these inputs so I'm going to run uh Celsius to Fahrenheit with a number one Celsius to Fahrenheit with a number 10 Celsius to Fahrenheit with 100 and so on so these will be all my inputs to my function and so when I call this wrapper Python's just going to replace f with the function that I'm actually running so Celsius to fahid or myum or Square and you can see here for each one of the different inputs I'm going to grab gra the time run the function grab the time again to grab get the DT and then print how long it took so I'll show you what that looks like so here I ran Celsius to Fahrenheit with inputs 1 10 100 1,00 10,000 and so on it was really fast okay it took zero seconds every single time so no matter what the input zero seconds so fast that you know python didn't even tell me exactly how how slow it was and know you know 10 to the9 or whatever it's just 0 seconds and that's in part to the time function but we'll leave it at that it's just very fast okay how about the next function let's do my sum so my sum is not just doing calculations it has a loop right that's a function of the input so our input changes and you might have noticed that as our input got bigger we actually had to wait a little while for this result to come come by so we see down here right or up here when the input's pretty small yes it took zero seconds it's so fast that it didn't even register it but at some point we started to get actual numbers so with a 10,000 it took 099 seconds with 100,000 it took 0.01 with uh uh uh what is this a million yeah with a million it took 05 seconds so we can actually see a little pattern right if we stare at it long enough um especially for the bigger numbers right so down here right these first two are iffy but when we get to a big number like a million we say it took 0.005 seconds when we increase the input by 10 to 10 million the input took 0.5 seconds and when we increased the input by 10 again it took five seconds so we we could guess that when we increase the input again by 10 it will take about 50 seconds to run right and you can even try that out if you'd like to wait for 50 seconds all right that's the my sum function now what about the square remember the square had the two nested for Loops four four and then just a regular addition in there so let's run that all right pretty fast pretty fast square of a th000 is already taking 0.05 or 006 seconds square of 10,000 is now taking 6 seconds what do we notice with one more round if we waited for square of 100,000 we might be able to see a pattern or we can guess the pattern does anyone want wager a guess what the next number should be here can you think about it about 600 yeah about 600 right we're going from 006 to maybe about six so I don't know we could say about 600 I'm certainly not going to wait for 600 seconds and I'm actually not going to make my computer do that just in case it crashes um but yeah it we could guess something like you know on the order of some hundreds right 600 something like that so that's one thing to notice the other thing to notice is that already at 10,000 right where the input is just 10,000 this took 5 Seconds already in the previous uh function here my sum we got uh we had to get to 100 million as my input to run for five seconds right so that's also a big difference here already this program square is taking a really long time to run when the input is not very big okay okay all right so some things to notice about timing and as I said we're going to look at some more programs next lecture I just wanted to give you a general sense of timing programs first of all the green check is good we want all these to be green checks the green check is good because if we have different algorithms they're going to take a different amount of time right the time that it takes for these algorithms to run will be different which is good but if we have different implementations for the same sort of program for the same algorithm that's also going to give us different timings and really in the long run I don't really care about that what I would really like to evaluate is just the algorithm itself because when when we're talking about algorithms there's probably only a handful of algorithms out there in the world right that we can apply to a given problem whereas there's probably thousands of different implementations we can apply to a problem so for example you could have a for Loop versus a y Loop right you could have um creating intermediate variables as an implementation or you could have a list comprehension version of an implementation but underlying all that is going to be just some algorithm that you're trying to implement okay so the running time will vary between different implementations which is not really something I want the running time will also vary between computers if I ran the same programs on a older computer it's probably not going to take 5 Seconds right to run with an put of 100 million it might take 10 or it might take 11 right so the timing is also going to differ between different computers it will also differ between different languages right so jav Java versus python versus C if you know C is very efficient at memory uh management it's going to run very fast whereas if you know if Python's a little bit slower it's going to run slower so again we're actually capturing the timing is capturing Implement uh uh variations between languages and the timing is not very predictable for small inputs so if for some reason right when I was running this Square function here with one I was also running Netflix in the background or my computer decided to update you know something and it decided to just dedicate resources to doing that task at that moment when I'm trying to run this square of one this 0.0 seconds might not be 0.0 seconds it might take away from the time it takes uh the time that it allocates to running my Square program and then what we'll see is that this will no longer be 0.0 it might be 0.1 or something like that so timing programs is not very good it's not very consistent uh with sort of our goal here which is to evaluate algorithms all right let's see if we can do better with the idea of counting the number of operations so rather than focusing on describing our program in terms of human time right one second 05 seconds things like that let's come up with some operations in Python that take onetime unit right and we're going to say that all of these really basic operations we can say that they take the same amount of time I don't care if they're like 10 to the9 seconds or two times 10^ the9 seconds I don't care about that I just know that they're really fast and if they're really fast I can say that each of them just take one unit of time so I'll just count them all as one unit of time so the uh examples of those are mathematical operations right they're pretty fast so no matter whether I'm multiplying dividing adding subtracting taking something to the power of something else I'm going to say that each one of those takes one unit of time right um comparing something so a less than b three greater than four things like that equality also super fast to do also takes one unit of time assigning something so a is equal to three that assignment statement right there also pretty fast to do takes one unit of time and then accessing objects in memory right also pretty fast takes one you know one unit of time so with this new definition of time quote unquote right where we have these units of time let's figure out what these functions actually uh how long these functions actually take so our Celsius to Fahrenheit function has three operations in it right I got a multiplication a division and an addition I don't care s of the little variations that each one of these take to actually do inside computer memory I'm going to say that the Celsius to Fahrenheit program takes three units of time okay so no matter what the input is if I'm converting 0o Celsius or a million Celsius the uh the program will still just take three units of time to complete how about my sum so we'll go through step by step so in my sum I've got one assignment statement here so that's going to be one operation the for Loop here is going to take I and assign it to one of the values in the range right that's just internally what it does so that's going to be one operation each time through the loop and then total plus equals I is going to be two operations because I have total plus I on the right hand side that's one operation and then assigning that back to total is my second operation okay so that's two operations there and that's it but notice our for Loop these three operations here the one for assigning I to be a value here and these two operations here repeat X plus one times right zero all the way up to X that's X plus one total times so how uh um how how long does this program actually take well we count all that up so the one for the total equals zero plus and we're multiplying x + 1 time what the 1 + the 2 which gives us 3x + 4 total operations so now we're noting this in terms of the input which is kind of cool right so now I have this nice little formula where if I know my input is 10 I can actually tell you how many quote unquote units of time this program will take all right how about the square it's going to be very similar so I've got one operation for assignment here this is one operation for putting grabbing the I and making it one of the values in the range similarly for the inner loop one operation there and then Square sum plus equals one for the same reason as this is two operations right one for the right hand side doing the addition and two for making the assignment let's not forget our for Loop Loop right we've got two for Loops here so the inner one will repeat n times and for each one of those uh outer n times we do the inner n times right this led for Loop situation here so the total number of uh time units that this Square will take is the one over here for this Square sum equals zero plus and then I've got these nested for Loops so the outer one goes through n times sorry n times the one operation multiplied by the inner for Loop also n times times what is the operations done in the inner for Loop well it's this one plus these two so the one plus the two so in total 3 n^2 plus one operations okay so let's run this and now that we're counting operations we should be able to see a more uh a better pattern so here's my Celsius to Fahrenheit my sum and square slightly changed because I've got this little counter variable within each function that is going to increment each time I see an operation so obviously for Celsius to Fahrenheit it's always three right so when I do my return I'm just going to return the counter variable and then the regular thing that this function should return as a tle for my sum this counter = 1 is stands for this assignment statement and then each time through the loop I'm going to increment my counter for the three operations right assigning the I to be one of the Val values in the range and then two more for the this total plus equals I so that's going to get incremented each time through the loop and then the square similarly so here's my counter equals one for this uh statement here counter plus equals 1 for grabbing the I as one of these values and then counter plus equals 3 for grabbing the J to be one of these values and incrementing this my so because of where I've placed these counters python will automatically count it all up each for no matter how many Loops I've got so here's my wrapper for counting slightly different than the timing one because now I'm actually going to also keep track of how much uh how many more operations I've done compared to the previous input okay so let me show you what that means let's run Celsius to Fahrenheit with the following inputs so I'm first of all reporting the total number of operations just like I did with timing so always three operations no surprise there that's what we coded up basically but then I'm also reporting here and that's done inside the wrapper function the count wrapper how many more time how many more operations is this based on the previous one so the first one's a little weird but when my input put is 10 times more right I went from 100 to a thousand I've done one more operation no change obviously right because it's always three operations done in total okay so just for comption sake right this is the slide so no matter what happens to the uh to the input here the number of operations in these sort of units of time which we're just counting number of operations is three what about the sum so remember the sum had that for Loop in it let's run that and see how many operations are here okay so first I'm going to report the number of operations so when the input is 100 it's 304 when the input is a th000 it's 3,004 when the inputs 10 10,000 it's 30,4 so that matches up the formula we came up with right 3x + 4 so that's pretty cool and then you can see now here I'm reporting how many more operations is this line based on the previous line so it's about 9.8 times more right so when my input increases by 10 from 100 to 1 th000 I am doing approximately 9.88 times more operations when my input increases from a th000 to 10,000 Again by 10 I'm doing 9988 times more operations okay so we see sort of like a nice little Ste State going on here right where when my input get really really big it looks like I'm approaching approximately 10 times as many operations right when my input is 10 times more this is obviously more apparent when the input is Big because the tiny variations in my formula right the plus4 specifically makes less of an impact when my input is really large and this is kind of going in line with our motivation when the input data is really really big what I'd like to report is sort of the algorithm and how long it takes I don't care that the algorithm takes 3x + 4 or 3x you know times uh 3x as uh uh uh operations right when the input is really big all I care is that it's sort of on the order of X right and that's something we'll get at uh next lecture but this is the big idea here when the input increases by 10 it seems like at steady state uh our number of operations increases by 10 as well so it's sort of this linear relationship all right what about the last function the square so I'm doing something a little special here I have two different inputs I'm going to run the square with so the first one is l2a so I'm going to run square with input 128 256 5 12 10 24 so I'm basically uh increasing my input by two right I'm multiplying my input by two um each each time and then I'm going to run it with l2b where my input increases by 10 each time so we're going to see if we can figure out a relationship between these for the square because that one was a little hard to figure out in just pure timing without actually waiting for you know minutes or or days or you okay so we got something to work with here so here I've got my Square so this first bit here is when my input increased by two and down here just finished is when my input increases by so number of operations when my input increases by two are not so important yes they're big but what I'm really interested in just like what we saw in the my suum example is what happens to this steady state as the input gets really big right how many more operations are we doing and what we can see is that the number of operations as the input gets really big is approximately 10 times sorry four times more in the case where I increase my input by two every round okay so when I increase my input by two the number of operations are going to be four times more well what about when I increase my input by 10 right one 10 100 a th000 and so on again I'm not so interest much interested in number of operations but what happens to the steady state with very few operations it's hard to tell but as we increase it we see that it goes towards approximately 100 right so when my input increases by 10 that takes me to about a hundredfold increase in the number of operations so now do you guys can you guys see the relationship between the input for the square and the number of operations you can right so it's approximately a sort of an N N squared relationship right when my input increases by you know some by when my input is n the number of operations is going to be on the order of n s more so counting uh operations is actually a lot better than timing as we can see right we've eliminated a bunch of those red X's right we no long longer uh we don't longer have to deal with variations between computers because if we're counting this on the computer that's slow or fast we're still counting the same amount of stuff uh languages again it's not going to matter because you'll implement it in the similar way uh small inputs is still sort of iffy right we saw the square was a little bit unpredictable when the input was pretty small right down here um you know 60 then straight up to 90 but we didn't take long to see the stady state so it's actually better than before better than timing it's not zero at least um but now the problem becomes sort of what's the definition of which operations to count notice our functions have a return value do we count the return as an operation technically you should right that's a value that's being passed between functions so that's going to take some time to run but we didn't actually count it in in our example right but you you could if you wanted to so that's where we stand right we've got timing and Counting just as a an initial um uh initial examples next lecture we're going to look at a few more examples with lists and things like that uh just again timing and Counting those functions but again the big idea here is that we're trying to get at evaluating just a handful of different algorithms sort of what's the order uh of growth as the input becomes really really big right because all we're interested in is how scalable are these programs that we're running when the input is really big right when we're dealing with big data and so that's what uh we're going to start talking about next lecture okay