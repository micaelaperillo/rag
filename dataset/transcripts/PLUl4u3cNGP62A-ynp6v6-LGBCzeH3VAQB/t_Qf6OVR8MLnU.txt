okay so last lecture we started talking about the idea of decomposition and abstraction and we talked a little bit about what that means and how it ties into what we've already been doing today we're going to do a real world example of decomposition and abstraction and then we'll see exactly how we can achieve this in Pro programming so let's start by talking about an example in the real world the smartphone so a lot of us have it but for a lot of us it's really just a black box right for me I know it is for most of the people in the world the phone is a black box we basically view the phone in terms of its inputs and in terms of its outputs right so the phone has uh some buttons you can scroll you can touch things um but we don't really know exactly how all of these buttons and scrolling and all these internal workings actually do their job and in fact we don't need to know how they do their job right to us as the user all we really care about is the interface between us and what task we want to achieve okay so what we need to know that Rel that that interface is basically the relationship between the input we give to the um to the phone and the output we get so when we push that button Buton the phone turns off when we push this other button the volume increases okay and so that's the idea of abstraction right the the the the phone basically abstracted away all of those Hardware details all of those implementations that make it actually work for the user right so the user doesn't need to know how it works in order to use it now abstraction actually enables decomp decomposition what does that mean well once we abstract away detail we can have different manufacturers working on different components of the phone to build these different components and if different manufacturers are working to build these hundreds of distinct Parts within the phone separately they need to have some way to put these parts back together and when they're working on their on their pieces separately that's the idea of decomposition how do they know that what they're working on will actually fit in with the rest of the components well they use the idea of decomposition they're basically following a specification they're following a set of inputs that maybe come into their component and a set of outputs that maybe their component needs to give to other components and all these different manufacturers that build that are building these different parts need to know is that interface bit they don't need to know how other manufacturers build their components all they need to know is what functionality those other components have and so all of these different manufacturers can build all these different components the interfaces are going to be sort of standardized so to speak and that's all that they care about so once you know the interface you can come together and put all these different components together to work towards a common goal as in to make a phone work so this is true for Hardware as in the phone example but it's also true for software and that's exactly what we will be doing in this uh in this lecture on functions we're going to achieve decomposition and abstraction in programming so treating code as a black box and making uh a large program kind of splitting it up into these different self-contained Parts okay so in programming we want to suppress details as well right not just in in Hardware like with the phone we want to suppress details in uh in programming as well and we do this using this idea of abstraction so we will be uh writing code as we have already been doing uh with the with the thought that what the code we're writing will be done will be written only once we will have some functional piece of code that will do a very useful task and then after we've written that code and debugged it and made sure it works well we'll treat that code as a black box so from there on out as long as we know what inputs that piece of code needs and what outputs that piece of code gives back to somebody else or to us we don't care exactly how it does it we just care that it is there and it is available for use okay so today's lecture we're going to be seeing how we can actually create these little functional pieces of code we can then give these pieces of code to ourselves we can definitely use these functional pieces of code that we written or we can give them to other people so that they can use them uh as well okay so we're going to write these functional pieces of code uh and we'll call the uh we'll call them functions or procedures and in fact we've already been using functions believe it or not um these three uh are examples of functions we've already been using in Python so max is a function so it's some useful piece of code that when we use it in this particular way it says uh it's taking in two inputs and it gives me back the biggest of those two inputs the middle one ABS is the absolute value function and its input is one number an integer and it gives back to me the absolute value of that number and Len is also a really useful one that we've been uh using with strings and basically its input is a string and its output is going to be how many characters are in the string right so we've already been using functions fun the point of today's lecture is you're going to start to write your own functions uh hopefully useful ones okay so the idea of a function is that we want to abstract away exactly how that function achieves something useful right some useful task and so the way that uh we're going to tell other people how to use our function is using this idea of abstraction and we capture what the function does with these things called specifications um they're also called dock strings and the dock string is kind of like a contract between somebody who creates this useful function and somebody who wants to use the function the person who uses the function might be you the person who wrote it or it might be somebody else and in the contract the things that we're going to mention are what are the inputs to the function so in you know in the length function you know it needs a string um what is the function doing and what is the output of the function what does the function give back to somebody who uses this function and we haven't actually done this explicitly but you've probably seen this as you type uh your code in so here's an example of the absolute value function and it comes up with this little popup here whenever you type it in so for example ABS parenthesis right here or if you hover over a function in your file editor you'll see it pop up this little text box that says the specification or the doc string and here you see exactly sort of the signature of the function so it takes in one input the X the value you want to find the absolute value of and then some text here which is what the function does so the specification of the doc string is literally just a multi-line comment there's nothing special about it as long as you kind of hit those points the inputs what the function does and what the function gives back to you you've written a good uh specification a okay um also I should mention that these contracts even though I call them contract there they're not actually enforced by python so it's really just up to the person who writes the code to make sure that their specification is really um detailed and you your function does what you say you will right so if your function can take in both positive and negative integers for example then you better make sure that the function itself doing whatever task it needs to do can handle both positive and negative integers so once we write these functions we now have these little bits of code that perform some useful task right given some input it'll perform this task and give me back some output and now that we have these different little pieces of functionality we can go ahead and take this large file of code which you might you know write from now on and kind of see exactly which which pieces of code maybe are getting repeated that's a clue that that's something that you can kind of abstract away into a little module AKA a function and then you can just use these functions to break up the code a very large piece of code into smaller little self-contain modules and then the maybe the bulk of the work that the code is doing is just saying hey mod you you know this module please give me this answer and then this module give me this answer and then uh putting those values back together again so these reusable pieces of code are called functions or procedures we're basically going to try to capture some sort of computation uh a very useful task that you'd want to do over and over again and we're going to see some details about how to write functions but essentially it's just going to be code that you've already been writing just written in a special way that makes it reusable Okay so we're going to have to kind of switch the way we've been thinking about code for a bit now that we're introducing functions because right now when we've been writing functions in a file we basically write some code top to bottom and then we think about that code as being executed line by line top to bottom but now that we're creating these things called functions little blocks of code that we can use many times in many different places in our code we're actually going to introduce the idea of defining a function so that means we're going to write a piece of codee and all that piece of code is going to do is tell python that this is a module or a function that exists in my program all we're doing is defining the function but we're not actually going to run the function when we Define it okay and that's kind of the difference that the way that we're going to have to shift our thinking here so when you define a function you just tell python that here's some useful piece of code that exists that does something but it doesn't actually run until you call the function and the cool thing about writing a function is you once you wrote it once you can make a hundred different function calls to that one piece of code that you wrote later on in your program so you can call the function many times with different inputs to give you different outputs but you only had to write it one time so I would compare this to when we write code in a file right when we write code in a file yes we can write a whole bunch of lines but this code isn't running as we're writing it right we have to actually push the Run button to run that file so similarly when we're telling python that I'm going to create this function that does something useful it's not actually running those lines we have to tell python that we want to run this function so the first thing we're going to do in this uh in this lecture is just actually create a function we're gonna I'm going to show you how to define a function so tell python that this function exists and then we'll see how to actually run the function to give us some useful values so the function characteristics are going to be uh the function has to have a name so just like when you create variables right that store some useful value like pi to 20 decimal digits that you want to reuse over and over again we're going to create a function and that name is kind of like a handle for us to refer to this large chunk of code that does something useful for us a function has some inputs called parameters or arguments it could have no inputs or more or one or more and a function should have a doc string so this is the specification again just a multi-line comment that tells the user the person who wants to use this function the inputs what the function does and what the output or the return or whatever this function will do for you and then the body of the function is just python code exactly the kind of code we've already already been writing except not wrapped in a function right so if you found yourself writing a piece of code that did something useful you can totally wrap that in a function and um we'll see how to do that today right so the body of the function is just a bunch of lines of code that do this useful task the only difference in the body is that at some point this function has to end right it has finished its task it figured out a final value this useful thing that's kind of the result of your task and you want to give this value back to somebody who's using this function and we do that using this return keyword as we're going to see in the next slide so here's an example of a really simple function so it's just a definition so again this these lines of code do not run here we're just telling python that we're creating a function that does something so we kick that off with a DF defin keyword so notice it's blue if you type it in your code you'll notice it changes color color um so DF tells python we're defining a function the next is the name of the function so this should be something descriptive usually an action word right because a function does something so you want kind of like an action-y type uh uh name for your function then we have parenthesis and inside the parentheses you have any of the inputs the parameters the arguments to the function right so what should the user give you as input to this function and then of course a Cod so in that line right there the only thing that is sort of customizable quote unquote is the name of the function and the parameters if there's zero parameters you put nothing in there if there's more than one you separate them by commas everything else should be uh is standard the DF the parenthesis and the colon at the end since we have a colon at the end then we uh that means we have to indent the next bit of code um that the indent ation will tell python that the rest of this is part of the function so everything from here on out is part of the function definition so we have our doc string of course um you start with triple quotes and you end it with triple quotes and in it you can write whatever you want just treat it like a comment that's on multiple lines okay and you can see here I've said that this function takes in an input I which I restrict to be a positive integer and then I say what the input uh gives back to the user so it will return true if I is an even number and uh it will return false otherwise okay so I've hit all the points the inputs what the function does and what it gives back to whoever wants this function to run okay um beyond that we have the body of the function so here you notice it's just lines of code that you would have written otherwise right if you g if you were given uh the problem on a quiz that said given I defined for you you write some code that that you know prints true if the number is O is um even and false if the number is odd this is basically lines of code that you would type in the only difference is this little return here right the function is sort of some lines of code that do a task and that task when it finishes has to give something back right it can't just sit there I guess um and the thing that it gives back whoever called whoever wants this function to run is uh is set up by this return statement here okay so if the number is divisible by zero we return true and else we return false so one of these either true or false values will be returned by the function so this is kind of you can think of it like the output of the function okay okay question so far does this make sense again this is just us creating this function inside the computer inside python we're not actually running these lines of code yet okay so if you are given sort of a larger problem I just want to take a couple slides to talk about how you think about writing the function um this was a really easy one so you know obviously it's not that hard to um to write but sort of what is the thought process if you were given a larger problem like in English or something like that and you wanted to translate this into uh a piece of code that does something functionally interesting okay so you think about what the problem is so our problem is given an integer figure out if it's even or odd okay so given this statement you could uh you could come up with the name of this uh piece of code that's functionally interesting so isore even is a good a good name and give and and we can also come up with the inputs for this function right so I we are only given one number so there's no need for this function to take in any other inputs and then using that description we can now start to fill in the doc string that says well our input is going to be a positive integer right we could use sort of math to figure out restrictions on the inputs and then we can write the do the rest of the dock string that tells us what to return and when right what the function is doing and once you have that you can just uh solve the problem so for us we solve the problem by basically saying if the remainder when we divide I by two is zero we return true and otherwise we return false okay so that's some that's code that you could have already written um right without actually this function lecture but now we're putting it in the context of a function definition so we're going to be able to run this function with many different inputs to give us a bunch of different different outputs whether a bunch of these different numbers are um are even or not okay so when we're writing the body of the code the only difference is from what you've been doing is the return statement right instead of printing something out to the console we're going to return a value to somebody who wants to know whether the number I is even or odd the function can also print stuff to the console but the key thing here is you want to return a value to the user and after you wrote code you know right off the bat and you tested and made sure it works you can uh improve the code a little bit so here we're improving it by noticing that i% 2 equal equal Z here is actually already a Boolean right if I is even 3% 2 equal equal Z is true and otherwise it's already false so this line uh these four lines of code basically say if true return true else return false so our Improvement can just be to return whether I percent two equal equal Zer right off the bat okay so here we're going to return either true or return false based on what i is so at this point again sorry I'm if I'm stressing this enough uh too much but it's really important to understand that once we write these lines of code in the context of a function definition these lines of code do not run they basically just sit in Python saying that there are these lines of code that correspond to some function object whose name is is even that's it so what we need to do now is to actually tell python to run these lines of code to do that we make a function call and again we've already been doing function calls just to functions that already exist in Python right just python itself Max absolute Len all that stuff but now we're making a function call to something that we wrote right this nice piece of code that tells us if a number the input is even or not so here I've got an uh I'm going to invoke the name of my function so I'm AKA I'm going to call the name of my function I'm basically just typing in the name of my function in the code parentheses and then the inputs the function expects there's only one right the number I want to figure out if it's even or odd and then that's it right so I've got the name of my function and then all the uh inputs the parameters that this function expects at this point python goes into the function body it runs the function and it returns back a value so whatever the value is associated with the return is that value will immediately be given back to whoever called it what does that mean well that return value will completely replace this function call okay so let's think back to Expressions do you remember when we were learning about python expressions and I said you have something like object operator object like 3 + 2 that was an expression and python went in evaluated that expression and replaced that entire expression by the value five this is exactly the same thing in fact functions are kind of like python Expressions they do something useful right it's just that it's not math or something like that that gets evaluated it's a bunch of lines of code that get evaluated but in the end that function returns back only one value okay and that value replaces the entire function call so this entire function call is going to be basically replaced by uh false right because it's an odd number and the next one is going to be replaced by true right the return from the function so the way that the code looks just this definition of is even and then running a function call is this this is all that we would have in our in our file right so here we have our function definition and then at the same indentation level we have a function call right because it's not the call is not part of the function the call is just making use of the function that we wrote okay so what exactly happens we'll do a little bit of step by step now going a little bit into more detail as to what exactly happens when we make the function call so when we make the function call so again function definition this just tells python we have this this function that does something in in in our in our program and then here we have the function called when as soon as python sees the function call that's when it starts doing something useful up here it just sort of stores this in memory so as soon as it sees the function call is even three it looks at the input parameter to the function call and here you see we have a value right it's an actual tangible object it's not a some random variable it's not something abstract it's a number three the I up here from our function definition is called a formal parameter it's abstract right we wrote the body of the function assuming the user will eventually give us a value for I but in the actual body of the function I is just a variable we're using kind of like in the quizzes right for now I've been I've been saying you know assume you're given some number n that's defined for you write the code assuming you know this number it's the exact same thing we write the code at the body of the function assuming we know a value for I so when python sees this function call with three it goes into the body of the function and says all right what are my parameters there's only one it's I and it's going to map them one by one to all the uh actual parameters given in the function call so basically just Maps I to three and then it executes the body of the function so it replaces everywhere you see I so it might have a longer bit of code here but here we just have one line it replaces I with three so we have 3% 2 equal equal Z now we have a tangible value right false so this expression is replaced with false and so this line of code here will return false and as soon as python sees that return value it immediately exits the function and gives back the value that you're returning to whoever called it so this entire function call here will be replaced by false okay that was very step by step but does it make sense okay so this is a program that doesn't do anything right if somebody were to write this program and run it it doesn't actually show anything to the user that's because in our program it's like we had just written a line of code that said false does that get printed to the output no right right what we need to do is do something useful now that we have the result of a function call so one useful thing we can do is to actually print the result of the function call right so here we have print and then I have my function call I had up here I'm just sticking it inside the print statement and python will as before evaluate is even three this is replaced with false and this line essentially becomes print false okay and so the way this looks in our actual code is this right so here I have um uh this is even function the uh inefficient way of writing it I've got two function calls here but if I run the code it doesn't print anything right I need to do something useful with them and one useful thing we can do is to print the result of these function calls so now that I've wrapped these calls inside a print statement I see the output in my console okay so we're writing so we're kind of separating ourselves right when we're writing code now one we're defining a function some code that does something useful and then two we're using this function that we wrote to make function calls and the beauty about writing the function is we only write it once and debug it once but now we can write run run it as many times as we'd like without functions we'd find ourselves copying and pasting right that piece of code that does something useful in many places in our code which could lead to errors the code is hard to modify it's hard to debug you might all that stuff okay okay I'll give you a chance to try this out for about a minute so let's have you write this code so here I'm giving you the function specification most of the time I'll give it to you even in quizzes I want you to write for me a function called divor by this one takes two parameters um both integers greater than zero n and d and this function will return true if D divides n evenly and false if it does not divide uh n evenly right so if you test it out with those two values the first one should give us false and the second one should give us true so as usual this is down in the python file so we have around line 28 is is where you should start typing in your code does anyone have a start for me should be very similar to what we just yeah and like equal Z then print true print false okay so let's run the function oh let's just do it with one so the first one I'm expecting to print false it does print false but it also prints this weird none right after it actually this is something we want we're going to talk about uh next lecture but does anyone know an improvement we can make to the code Yes Yes actually you're right so instead of printing true right remember it's a function we want it to give us back the value true right so instead of printing we'll do a return true and we don't need the parentheses in this case and then we'll do a return false right so now we don't have that weird none right after it that's something I want I was going to talk about next lecture but basically when we had prints here what did the function return did it have a return statement inside it no right and so if there's no return statement inside the function python automatically returns this special none okay this is something we'll talk about next lecture more in detail but yeah the return true return false is is correct here yes return yeah yeah you don't need the return uh the if else just like before so we can just do return um this directly right then we can run it with the other one so the second one should actually return true but it returned false does anyone know the problem yeah yes exactly so actually we want the remainder when we divide uh n by D right so this is just flipped around and percent D equal equals zero yeah so it's a good thing we had two test cases to test for that and you don't have to test them with such big numbers you could obviously test them with some smaller numbers um as well so let's zoom out a little bit and talk about how how exactly functions are stored in memory right because I mentioned this thing about defining a function and that just doesn't do anything really that we can see but what exactly happens in memory well let's think about what happens when we create variables so when we create a is equal to three inside memory or the program scope again we'll talk about this next lecture but you can think of this as the memory what happens is a becomes a variable that's bound to Value three b equals 4 is a variable B bound to value four and C is going to be bound to Value seven clear right we already know this what happens when we create a function so again this is something I might write in a code file the top bit is my function definition so as soon as python sees this DF keyword everything that's indented that's part of the function definition in the body is essentially just some code right to the to python it does not care at this point what that code is or what that code does all it knows is that there is a function object and functions are actually objects in Python there is a function object whose name is is even that is all it knows when we get to this point here in the code right after we Define the function right right before a equals okay so we think about the function as kind of like a variable quote unquote it's not actually a variable but it's like a variable whose name is is even and it points to it's bound to some code in memory and we don't care what that code is right now because we might never use it we only care what the code is when we make function calls so down here is where the action actually happens when we make our function calls I have a is going to be as usual a variable right that's going to be bound to some value so the function definition is kind of just like a black box right once you wrote it once and you know it works you don't care anymore how it actually achieves its task all you care is that it takes in a number and tells you whether that number is even or odd via true false okay so down here where we make our function calls we're just using our Black Box okay and we're using the Black Box by making function calls so a is going to be a variable that's bound to the value returned by is even so it's going to be uh based on the function call false and then here I have another function call I'm using this useful piece of uh code that I wrote up here and B is going to be a variable that's bound to true and C is going to be a variable that's bound to True right does that make sense it's kind of separating the code we write which doesn't run until we actually make function calls that's that's the thing about functions and that's how it helps us write more um more robust code so now here we can have a more complex piece of code where we're using the function that we wrote okay not just making a function call and printing the result but we're actually using it inside a more interesting program so here I've got a program that will print for me the numbers between and 10 and it'll print whether that number is odd or even so if you were just to read this code it's pretty easy to read right we have a loop that goes through the numbers one to 10 not including 10 and then I have this if is even well that's cool here I'm using the function that I wrote kind of just in the middle of another piece of code right which is fine because as I said you know a few slides ago go p uh function calls are basically just Expressions right they get run they get evaluated you get one value back out of them and then that value replaces the function call so that's fine let's use the is even uh result the return from the is even method inside a conditional if I uh if if calling is even with I returns true that means if the number is even we print that value comma even else we print that value comma odd so here I'm not defining a function notice it's not wrapped in the DF or anything like that I'm just using a function that I already wrote so inside here just comment that out this is the code we just had on the slide so again notice it's not within it's not wrapped within a function it's just a loop that tells me uh the numbers one at a time whether they're odd or even right so prints one comma yeah what are you doing when you select like everything in a common make it oh when I select everything I just use um spiders like ability to com so I do control one or command one probably on a Mac and it just comments and uncomment things in batch yeah very useful yeah and so this code is now very easy to modify right I can just choose a 100 and then I can run it again and it gives me the numbers uh one through 100 odd or even and you can imagine using your is even function in a more complex setting right and is even is a really simple function to write but again you can imagine writing a more complex function and then that complex function isn't a whole chunk of code that just gets stuck into this program this loop it's going to be a function that you call that you can just easily uh read the specification for and you don't need to completely uh um understand how it works in order to use it okay so we're going to go through one other example um to write a little function and this will also showcase kind of the uh best practices for writing a function and writing code especially maybe in a quiz situation or something like that how to write incremental code how to test it a little bit at a time and so on so the last example I want to go through is I want to uh write some code that c that adds all the odd integers between and including A and B might be something you're on a quiz um what uh the first thing you do when you're faced with such a task is to think about a nice name for the function so some odd or some odds is a reasonable name the inputs to the function well I've got two end points I want to Su OD numbers in between so the inputs might well be my two end points and then what is the thing your function achieves right well in the end it's going to give me some sum so let's call that sum a variable sum of underscore odds and we'll return it at the end of our function and in between we're going to have some code okay so first thing to do is to not write code right away when you're faced with a task again on a quiz or something like that it's best to take a piece of paper write a little bit one example and try to think about how you'd solve it not like a human would because for us we would immediately F know the sum right it's very easy for hum identify the solutions to these problems but try to think about how you would write how what kind of a recipe would work for this would you Loop would you have a conditional would you use a for Loop or a while loop and a bunch of other uh Concepts that we'll learn about in in uh in the following lectures but the key thing is to just not write code right away so if we TR start with a really simple example on paper we can say let's choose end points uh a is two and B is four on paper I would probably write out two three four in a row right so I know the numbers I need to look at I would say two is my a four is my B I need to look at every one of these numbers one at a time reasonable I can do another example sorry and I know what the answer should be so I figure out what the answer should be so that when I write my code I actually know what uh I'm looking for I look at another example let's say a little bit more complicated a bigger range a is 2 b is 7 I try to use the same strategy I use used same recipe I used to solve that simpler example in this harder one so again I'm going to write out all the numbers between two and seven inclusive this is my first this is my last and my strategy was to go through one at a time and if it's odd I take it to my running sum and add it to my running sum and if it's even I don't I ignore it okay and again I know the answer for this should be 15 so with these two examples in mind I can start writing code but instead of writing code for for the big problem that might include some nuances or some edge cases I can actually try to solve a similar problem right so instead of summing all the odd numbers between A and B let's just sum all the numbers between a and b and see if we can get code right working for that once we do figuring out the odd ones should be a small tweak to our code okay so if we start with figuring out the sum of all the odd numbers between an including A and B that sounds like a loop because I knew when I wrote my exam example on paper I'd have to touch each number between an including A and B right so I know I need to Loop through uh every one of these values while or a for Loop your choice in the slides I'll do both just to see what it looks like so with a for loop it's easy it's just for I in range a but with a Y Loop remember we have to initialize our Loop variable if we have one I equals a our Loop condition is while I is less than or equal to B right so we're going to Loop through while I I'm looking at all these values up to an including B and I need to remember to increment my Loop variable within the loop by one each time in this case okay okay and then what do I do within my Loop well I'm going to remember we're solving the similar problem I'm going to keep a running sum so as soon as I see a new I I'm going to add it to my sum I realized here probably my IDE would show me that there's an error I didn't initialize sum of odds so I remembered in initialize some of odds right before the loop and then this is a good place to test the code for a little bit so we'll test it with a really simple example 2 comma 4 okay if we test it with 2 comma four the four Loop gives me a five but the uh the Y Loop gives me a nine so you guys might have noticed what the problem is my for Loop goes through up to but not including the end variable right the B so we can add a print statement in case you didn't figure that out and the print statement would actually tell us right it tells us what we're incrementing first it's two then it's three but I never hit the four so the fix is to just change my end range to be B+ one and then we run it again and we see the answers match okay and this solves the SI the the the bigger problem so now all we need to do is adding the the the Nuance the piece where we just grab the odd numbers and here we say well if I'm just grabbing the odd numbers I only want to add I to my sum of odds when I see an odd number so here I could use my is even function that I already wrote I would say if not is even or I can just do it all over again if i%c 2 equal one then we do this right and now we can run it again and hopefully this now matches with the example I had on paper and it does okay so the idea here is to try to solve a simpler problem first and then as you see more nuances to the problem add in the functionality just a little bit at a time so you don't actually get bogged down by a whole bunch of pro uh uh issues that might come up when you wrote a whole bunch of code the last step is just to test it on the other example just to make sure that it still works right and so if we R print some of odds between two and seven again this matches what I had written down on paper okay if you don't want to use print statements the python tutor is also a great debugging tool okay so testing code often very useful I think I've stressed this in previous lectures as well using prints or the python tutor did debug it's also very useful I don't actually intend to go through this you try it but this along with a bunch of other examples or uh uh things to try at home are in the python file so just functions you can you can write is palindrome this keep consonants this first to last if read the function specification and try to write code that that um that matches the specification and as usual the answers are in the python file but please please try to do them on your own first before looking at the answers um okay uh a quick summary functions are very useful allows us to abstract certain useful tasks right basically abstract away functionality that we might reuse many times in our program functions taken inputs they have something to return we're going to see next time what happens when we don't return anything um creating the function is different than running the function right so you create the function once but you can run it many many times and that's what makes functions useful it makes code easy to write read debug modify uh leads to very nice robust code okay