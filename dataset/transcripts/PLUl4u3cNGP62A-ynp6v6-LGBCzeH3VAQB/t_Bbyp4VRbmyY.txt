all right so let's get started on today's lecture so today we're going to be doing one of two lectures on the topic of recursion and um you may or may not have heard of recursion it's a um programming technique um and a way to algorithmically solve problems um it's not something that is going to come easy because it's going to force our brain to think about problems that we've seen in a completely different way okay so it's you don't have to use recursion if you don't want to but there will be problems where the idea of recursion and applying um uh or writing recursive code is going to come a lot more natural naturally than writing uh code that we have been so far but I'm just warning you it's going to take a little bit of kind of forgetting everything we've learned uh about loops and things like that to train our brain to think recursively for the next two lectures um to help you we will have an interactive portion of today's lecture so think about whether you want to come up on stage or whatever this is the front and be a part of the um uh the interaction you'll be forever immortalized in uh on the open courseware um awesome I love it on the open course Weare videos all right so let's think about iterative algorithms that we've seen so far so iterative algorithm basically means we are writing code that has a loop within it right so either a for Loop or a y Loop writing code with these for Loops or while Loops lead to iterative algorithms so things that re that do some task some for some repetition so the idea of an iterative algorithm is that there are some variables that capture the state of the computation so each time through the loop these variables will change their value essentially capturing what the values are at each step in the loop so when we're writing these iterative algorithms we basically think about what is something that's changing each time through the loop like we keep a running sum like that's the easiest example right what is a a variable that's changing each time through the loop kind of like a counter that keeps track of how many times we've been through a loop when do you stop so for four Loops you stop after you've exhausted a sequence for while Loops you stopped um when you have a condition that becomes false and then at the end of the loop you have some sort of result that you've been storing and accumulating or changing each time through the loop so that's an iterative algorithm and we've been working with these uh a lot so in uh to show you uh we're going to go through the next few slides showing you an iterative algorithm to do multiplication it's going to be very very simple but we're also then after going to uh look at the same uh problem which is doing multiplication but in the context of recursion and hopefully that gives you a sense for how we think about the exact same problem we're trying to solve multiplying two numbers together in a completely different way so this is not the function that I want to write with iteration I don't want to create a function named mol and then return a a a star B right I don't want to use the built-in function I want to assume that I don't know how to do a a star a multiplication and so instead what I'm going to do is I'm going to rely on let's say I know how to do addition I'm going to rely on the idea of addition to actually write my multiplication function so so let's think about how to make uh multiplication iterative we can have a loop right that M that adds a to itself B times right that is the definition of multiplication so let's write a function that does this using a for Loop then we'll write it using a y loop with a for Loop um we're going to write this iterative algorithm it's capturing the state of the computation just like we said we should so the for Loop will uh iterate will have my sort of range of values being from 0 to B so we're going to repeat this Loop B times the variable total is capturing my state of the computation right it's keeping track of what the total is at each step through my loop at the end of the loop I return the total okay so very very simple iterative of uh function here now let's think about another iterative solution instead of uh keeping uh a loop variable B that goes from zero all the way up to b or what was it my Loop variable N I think yeah instead of keeping a loop variable n that goes from zero to B let's work our way backward and this time let's use a y Loop just for fun let's say that I'm going to start at B and count down to zero so again going and repeating some task B times so what I'm going to do is I'm going to have some you know counter that starts at B and decreases down to zero again within my loop I have to keep track of the uh result so my total in the previous code is now being called result in this code and so what I'm going to do is my iteration will start right at zero and then I'm going to keep adding a to itself B times so the code looks like this I've got my y Loop this time instead of a for Loop I'm going to start out with knowing what B is and I'm going to decrease B by one each time through the loop so here I've got b equals B minus one so that's capturing the state of the counter at each iteration the result just like the total in the previous slide is capturing the state of my sum at each time through the iteration okay and at the end I return result so hopefully very simple very review uh code here but now let's look at the code in a recursive sense so here let's not look at the code yet but let's think about is there some thing that we're repeating over and over and over again if we recognize it we can think recursively okay so let's try to figure out this recursive pattern so I I work best with examp like actual numbers so instead of using uh an abstract A and B let's use a as five and B as four as an example so let's say I want to use the star operator that's basically the function I'm trying to implement the star operator between five and four so in the iterative sense we said that's 5 plus 5 plus 5 plus 5 adding five four times the idea of recursion is that we're trying to take our original problem which is using the star operator between two numbers and try to solve a very similar problem if not the same but in a slightly changed way okay so instead of saying I'm going to multiply 5 by four what I will do is recognize that 5 * 4 which is my original problem can be Rewritten by extracting out one of my fives right so I'm going to take a five out and add it to 5 time 3 so this is my recursive pattern okay I'm using the star operator between five and some number but if I extract a five out I can use the star operator between five and a slightly smaller number one less than four okay well what if I do the what what about five time three can I do the same thing again I can right for five time three I can again notice that I can extract the five out again and I have five plus 5 * 2 and then I can do the same thing again to figure out what 5 time 2 is I can again extract a five out and be left with five Time 1 or five star one right and so notice the thing inside the boxes is basically me solving my original problem which is using the star operator between five and some number but that number is changing each time you know on each line at some point I can say this problem is so easy that I know the answer so five star one so a number multiplied with one is just the number itself and so at that point I can say I don't need to continue dividing my problem into smaller and smaller pieces so just to bring the point home let's use parentheses to illustrate sort of which pieces I'm replacing where so I've got my original problem five uh applying the star operator right the multiplication on five and four I extract the five out and I recognize that I can have five plus and then solving five star three I need to have some trust here right I don't know what F star three is but if I decompose that problem in the exact same way I can extract the five out of that right and add it to five star two right so the thing in the boxes are equivalent and then again five star two I'm going to recognize this is the same problem I've been trying to solve let's apply the same solution which is to extract a five out and multiply and add it to the multiplication of five star one less okay so again the two boxes are equivalent so this idea here where we're recognizing the same problem and kind of dividing it dividing it dividing it having uh you know this trust that at some point we're going to divide it so much that we've reached a fundamental fact that we can solve is this divide step okay so we're going to divide it all the way up to all the way down here where I've got five plus five star 1 at this point I can say well five star one is going to be five okay this is a basic fact that I can just solve I don't need to divide this problem any further so once I solve this fact I can start building back up my answer right and I can start passing the answer back up the chain of of of of of multiplic M multiplication calls right so if I'm at this step here and I figured out that this is five star one one this five star one is equal to five I can just replace it with the five and then I can build up the solution to this five star two because now five star two is just five + five okay so this is going to be 10 right it's just simple addition right there's no more multiplication which is the thing that we were trying to avoid so then the F star two gets replaced with 10 and I'm still building back up my solution until I get to the five star 4 so I was trying to figure out what five star three is but before I could do that I had to solve the rest of that uh the two lines beneath it but now I can finally solve it it's just 5 + 10 right that's the similar problem I was trying to solve so I can replace the F star three with 15 and finally my original problem was trying to figure out five star four and now I can finally solve it because I've finally built back up my solution as 5 + okay any questions about these steps should be pretty straightforward I know it's a weird roundabout way of figuring out what the answer is but what I'm trying to get at is trying to recognize the problem that we're trying to solve and then find and then solving a very similar problem just slightly changed in this case we're multiplying five star one less than what we were just trying to figure out so in terms of the recursion for this particular problem multiplying a with B we recognize that a St B is going to be a plus a plus a plus a b * if we extract an a out just like when we extracted the five out and added it to something else we'll recognize that that's just a plus a plus a plus a plus a B minus one times right okay well that a plus a plus a B minus 1 * is just our original problem just multiplying a with B minus one okay so this is my recursive step we recognize that a star B is equal to A+ a star B minus one so I'm using the same operation I'm trying to find here down here in my in my quote unquote solution but this is not the end of recursion because if I just had this as my um as my definition then I would have infinite recursion I don't have a way to stop and so this recursive step in conjunction with a a base case something that is fun that that we know fundamentally about the star operator is going to give us our solution so we knew on the previous slide when we multiply a with one we just get back a so our base case right very simple case of multiplication with between A and B is going to be when B is one then that's going to be a * B is equal to a so these might look like like the mathematical definitions that you might come up with um you know in in in a math class and we have them right here right so if B is not equal to 1 a * B is a + a * B minus 1 and then the base case right is when B is equal to 1 a * B is equal to a so with these two lines we can actually come up with the uh code the programming version of uh of this function so here we're creating a function named mol recur and its parameters are going to be a and b right so I'm multiplying a with b and I have to uh encode these two cases when B is one and otherwise so we usually start with the base case it's the simplest to think about so when B is 1 a * B is equal to a right so when if B is equal to 1 then what is a * B it's just a right so the function can just just immediately immediately return a else so that's our base case else this is going to be our recursive step we're not going to return a but we will return this right A plus a star B minus one well the a is just a plus and this the star operator between A and B minus one is just the function again isn't that really cool we're using the function name in the body of this function that we're defining and it's not a problem because the parameter to the one at bottom in the recursive step is changing right I'm not calling Mt recur with a comma B again that would be very silly of me because that would lead to infinite recursion I'm not making any progress towards a base case but I am calling it with B minus one so this function will just keep calling uh mult recur with a with B B minus one B-2 B- 3 and so on until it gets to B as one and then it'll build back up the solution just like we had in the slides with all the parentheses that we were replacing okay so let's step through the python tutor and I will show you how it actually looks when we make all these function calls and then we'll do another example so here I've got Mt recur with a is uh I think I ran it y with five and four just like the one we've been looking at so this is going to be my main function it makes a function called to mol recur excuse me five comma four so my a is five and my B is four right this is this little blue thing here is one function environment right like when I draw boxes on my slides that are orange they do them in blue okay now in this function called what do we do is B1 no so we go in the else case and we return five plus what happens next does anyone know yeah yes Mt recur will run again with a is five and B is three exactly it is a function call right so as a function call we are going to create a new environment so here's boom another box my previous box is currently hung up right it cannot finish because it's trying to figure out what a what five plus the result of this function call is but this one's not done yet right it's it's still figuring out it's it's its um its result so we've put that one on hold and now we're trying to figure out mult recurve 5 comma 3 well what is won't recurve 5 comma 3 it's going to be B is not one so this one will also go in its else and it will recur it'll return five plus what exactly five the function call when when B becomes two exactly but notice it is another function call right so here I have boom another box now I've got two function calls this original one back here and this and which was waiting on this one that I've highlighted here but now this one that I've highlighted here had to make another function call down here so I've got currently three function calls in the works that are trying to figure out you know what their results are all right finally this mol recurve 5 comma 2 is going to make another function call So it's b is not one so we're going to go into the else and what is it else going to say we're going to return five plus and it's another function call so now I'm four function calls deep and I haven't done any sort of visible work right I've just kept kind of you know kicking the can down the road to try to figure out what the values are and everybody's waiting for somebody else to finally return a value okay so this first one is waiting for the one right underneath it to return a value but this one is waiting for the one underneath it to return a value and this one is waiting for the one underneath it to return a value that's the chain of calls what's this last one going to do is it going to make another function environment no it's going to return a which is five okay there's my return value five so this one will return the five to whoever called it and whoever called it was this one here we recurve five comma 2 right 5 comma 2 was trying to figure out what five plus this bottom function call was okay well now it can figure out that it's going to be 5 + 5 so its return will be 10 this one returns a value up one level to whoever called it and that was Mt recurve 5 comma 3 and now Mt recurve 5 comma 3 three can finish it finish its job it was trying to figure out what 5 plus its function call was which is we figured out as 10 so this one can figure out it's 15 and finally this last value can return back up to the original function call 5 comma 4 and 5 comma four will return five plus the 15 that got returned which is 20 okay um questions about what just happened does everything make sense all right okay so let's look at one more example um I mean we'll look at a few more examples this lecture but let's look at a real world example for now um this one will hopefully illustrate the difference between iterative algorithms and recursive algorithms in a more real life setting so let's assume that um in this real world setting a student asks for regrade for an exam in an iterative setting We have basically one function call right regrade or whatever you want to call it there's my student how is the student going to iteratively get the regrade well the student will be in charge of basically looping through each staff member right so the student goes to the instructor and says can I have a regrade please okay the instructor may have graded one problem maybe they didn't but they will regrade the problem that you know maybe they were in charge of then the student will go to the next person on staff the TA can I ever regrade please let's say the TA maybe regrades the problem they were in charge of maybe they didn't but in any case they'll give the score back or they'll answer you know the students's request the student then goes to the next person on staff the the lab assistant can I have a regrade please the lab assistant might regrade the prly in charge of you know whatever um gives the grade back to the student the student is keeping track of all these regrades uh scores that they're getting to kind of figure out what their new total score is and finally the student might go to the um grader who did probably most of the work um asks for regrade the grader will dutifully agree to do the regrade um and pass back uh the values so here notice the student is in charge of iteratively going to every every single person on staff and getting the result back and the student is keeping track of what their new score is obviously the staff members will too for the purposes of assigning grades but the student is as well right so the student basically adding up all these values but there's only one function call so I've denoted the function call using just this black circle here okay so that's iteration right we know how to do that we've been doing this for a really long time in this class but now let's look at the same problem recursively so in the curs in recursion we've got these two steps right there's the problem of decreasing our original problem into smaller problems right until we reach some sort of base case and then at that point we have the task of building back up our answer so in the recursive setting again I've got my one function called to regrade on behalf of the student but the student will only interact with one person maybe the instructor okay the student will not interact with anybody else in staff the student will just go up to the instructor and say hey I would like your regrade for this exam okay now the student is going to wait right the instructor is also a function call to regrade so maybe the instructor didn't do any of the grading but the instructor will make their own function call to the TA can you please regrade this exam right the TA may be graded one problem they'll keep track of the problem they need to grade but there are other problems that need to be graded so the TA will then ask make their own function call to the lab assistant maybe the lab assistant graded some problems and then the lab assistant will also make uh further the requests or of passing along the function call to the graders so we have the task of doing the regrading as a function being passed along all of the staff members okay when we reach the base case which is the the last um the greater that needs that probably uh knows uh or probably graded the last question we've got the answer being passed back up the chain of function calls right so the grader will say all right I've graded my problem there's nobody else I need to ask so here's my score so this score is being passed back up the chain of function calls to the lab assistant the lab assistant will take that score and add it to their score passes it back up the chain of uh function calls to the teaching assistant the teaching assistant adds that that score to their score maybe they graded a problem maybe they didn't but anyway they're compiling the result little by little back up until it passes it to the instructor and then the instructor says here you go this is your score so you see the difference right the student is the is the iteration right they ask everybody on staff so they interact with everybody on staff but in recursion the student is basically hung up waiting for an answer until we've gone down all these chain of function calls and the answer has been built back up so the student is not keeping track of the answer at all they only get the final answer at the end did that help at all okay I've refined this example a couple of times hopefully this is this is good so the big idea in recursion here is got I've got these quote unquote earlier function calls right the ones I've made way back at the beginning these function calls are just waiting on results to come back right they're not doing any useful work at the beginning they only do useful work when they're assembling the uh the results after getting a return back from later function calls so hopefully that gives you a sense of when of of how we can apply recursion now what exactly is recursion so algorithmically it's a way for us to come up with some solutions to some problems in this divide and conquer approach or decrease and Conquer approach right you have your original problem you divide it so much into the same problem just slightly changed until you reach a base case that base case can kick off the conquer step and start passing back a value that you can start assembling um from your earlier function calls okay now semantically as we saw in the example where we multiplied the functions we've got a a function that calls itself obviously it's not calling itself with the exact same parameters because that would lead to infinite recursion and that's not what we want we're going to call ourselves with a slight change in our parameters in such a way that we will reach our base case okay and once we reach the base case then again we kick off the conquer step and we can start reassembling back and you saw how the function calls do that when they um when they help each other back up okay I'm going to give you a couple of minutes to try this so complete the function that calculates n to the power of P for these variables so if you come up with the mathematical definition it will be u a pretty straight translation to code um I did include two base cases here so maybe a base case is when n is zero and another base case is when n is one figure out what you should return and then how to write this recursive step so I've got uh line um 50 50ish is where I can type in the code all right what's my first base case yeah yep if oops if p is equal to zero then we can return one oops just one time that's another base case p is one we can return n awesome how about my recursive step yep we can return n times like this now let's assume I don't know how to do star star how do you rewrite this in terms of the thing we're trying to write there was a a solution back there yep we can do that too yep exactly so here we're assuming that we don't know the star star operator right otherwise this would be a very fun easy function to write we are trying to define the star star operator ourselves using this function named power recur so we're just going to call it again down here with n and p minus one so if we run it this will give us eight is that yeah yes a great question what is the necessity of this there is no necessity I actually just included it there to just show you um how we can have two base cases so in this particular case we would actually never hit this one if the N is greater than one because we always stop here um if the student if the the user gives us zero we would just return that one but it would work if we completely removed that as well yeah great questions okay let's look at one more um one more example and this one is the one that I'm going to ask for some participation uh I would like four of you to come down with me but before we do that um let's think about factorial so the definition of n factorial is n * n minus one * nus 2 * n minus 3 down to one what is a base case what is the simplest thing that we know the factorial of you guys tell me what is and what is zero factorial one good I chose one but both could work y um if n is equal to zero we can also return one or we can do n is equal to one return one what's our recursive step do you recognize the recursive pattern here n factorial equals n times n minus one factorial right if we extract the first n Out n min-1 * n- 2 * nus 3 and so on is just n minus one factorial and so our recursive step just says it's n times the same function factorial with n minus one is everyone okay with that cool okay so let's look through this example um with some participation so four people one yes and you'll be on ocw forever you guys two yep two more yes thank you thank you awesome okay and I'll have you guys stand right here um I'll ask you guys to come in one at a time um as we are working through this exam so we're just going to demonstrate sort of once again what happens when we make function calls so you want to just stand right here beside behind my computer thank you yep behind my computer cool okay perfect okay so I'll just stand here so I am going to be the main program right I am you you run this code I am going to be the main program I am going to keep track of the um the the variables and everything that's in this Global scope okay so in the global scope just like we have been in the past I've got a definition for my factorial function here okay and this is just some code at this point I've just defined it I don't care what it actually is but I have one function call so my one and only job is to print the result of factorial 4 right I have a prettyy easy job so what happens you guys audience tell me what happens when I've got factorial 4 what is this do I just know right off the bat what factorial 4 is no it is a function call right so as a function call what do I need to do exactly I need to create an environment okay so you will be my first environment hello my name is you can put it on there you go hello my name is and then you can step right over there so you are my first function call your name is fact for factorial awesome so I have just called you um what is your job so you guys tell me what is factorial 4's job is from running the code are they going to do the if or the else the else so this is your job you keep track of that your n is going to be four and your job is to return four times factorial of three do you know what factorial of three is right now no so what do you need to do yes please call somebody else who are you going to call next what is your name going to be factorial your your name is also factorial exactly and you are going to be called with n is equal to 3 so you can stand right beside factorial of four very nice so now notice we've got two function calls both of their names are factorial right but they are completely separate function calls they are completely in different environments they have their own end values they have their own jobs to to do right just because their name is factorial for both of them does not mean that they'll interfere with each other's variables right very very important point to make factorial three do you know what factorial two is no so what do you need to do exactly who are you gon to call here you go what is your name going to Beal yes we are at two exactly so you are factorial your name is also factorial and you are going to be with called with n is equal to two again now I have three factorial calls they're all to the name factorial but they're all independent function calls so your job is to return two times factorial of one do you know what factorial of one is yes as a human you do but as factorial you do not what do you need to do um call her call her exactly here you go your your name is also factorial you can stand beside our lovely other factorials so your job audience I've already given away your last job is [Music] to return one okay excellent so here is your return value now factorial of one are you going to return that value to me which one will you return it to exactly so factorial with n is equal two can now replace their factorial one function with one so what is your return value going to be factorial of two I got it right two exactly so who where do you pass your value along to okay now one thing we forgot as soon as you made the return value you disappear you had a very simple job I'm sorry but it was really important you were our base case without you we would have had infinite recursion okay so you've passed a on your value so as a function that's done its job what do you do disappear exactly thank you all right factorial of where are we three exactly what do you what is your value going to be now six exactly so here's your return value you give it to me or there you go and as give exactly very good we disappear so we've got three function calls that disappeared as soon as they returned a value and finally 4 * 6 24 and who do you give your V value me which I just gave you sorry yeah that was confusing thank you so much you guys that Illustrated a couple of things you guys can um head back thank you so much so we Illustrated a couple things here I'm going to I can do it on the slides as well just to bring uh bring the point home but let's go through it so I've got factorial four every time I make a function call even even though it's the same name all factorial it's a completely separate environment right happens to have the same name but they're just in charge of doing their own job so here I've got factorial of four calling um four * factorial of 3 as soon as I see factorial of three this creates another environment this is going to be returning uh three times factorial of two again another environment this returns uh two times factorial of one and a final environment right our most uh um important environment is that last one with the base case it allows us to Kickstart our conquer step so this base step will return the value one to whoever called it again we're not skipping around we only return the value to the function that called us and I know it gets really confusing because everything is called fact in this particular case but we just have to remember which function called us and so so we return the one back up here this becomes 2 * 1 and they can finish their job right so notice at this point we've got we were one two three four functions just kind of hung up and waiting for values to be passed back to us but now we can finally finish our jobs one by one so this one returns a two this one Returns the six this one Returns the 20 uh uh 24 and the 24 get gets printed out okay so so um big idea here we've got each function call even though it has the same name is completely separate right completely independent environment with their own uh parameters those parameters can change within those environments and that's totally okay they won't interfere with any parameters in any other environments okay all right so let's do the python tutor link and then again we can just do one more time just to show you what this looks like in in terms of the Python tutor so here I've got my factorial with n is equal to 4 calls n is equal to 3 calls factorial with n is equal to 2 calls factorial with n is equal to one at this point right just like with the multiplication I've got all these factorials in the works but we can start returning values back to whoever called us until we get back to the original one uh the original function call okay so this is another recap of the observations that we've seen right each different uh function call has its own environment um the variables Within These environments are specific to those environments they don't interfere with each other um and the flow of control right so when we make a function call all we know is the function that we call next we don't skip around all we know is who we call next and who we need to give the value value back up to right um one last thing I wanted to point out so here I've got the code for factorial the iterative version and the recursive version okay so the one on the left is oh sorry the one on the right is what we already wrote so it's factorial recursive and the one on the left is the iterative version so um I personally think the one on the right is more readable because it's it's very similar to the way that we would write the uh expression mathematically but if you kind of if you had a little bit of time to think about it you can just as easily come up with code that does the exact same job iteratively right so remember in iteration we've got our Loop there's no more function no other function calls we have a loop that you know iterates some number of times there's some sort of loop variable or Loop counter and there's a state variable that keeps track of the answer of interest in this particular case the product from one all the way up to and including it so I want to end today's lecture with just a couple of observations so today we saw some really simple examples of recursion but I think it outlined some really really tricky ideas that people usually have trouble um grasping when you first see recursion and that's because you basically write a function in terms of itself and that can be a little bit confusing so of course we applied recursion to some really really simple things we did multiplication we did um and we did factorial um depending on how you feel the recursive version or the iterative version might be more intuitive for you and certainly for these examples you did not need to write them recursively um there are there's a lot of code out there that you actually don't need to implement recursively the iterative solution is far more intuitive especially since you guys were first introduced to iteration right you introduce for loops and Y Loops back in lecture like three or something like that right so if that's the first thing you saw that's usually the first thing that's going to be your go-to but there are several problems that are more intuitive to write using recursion so a couple of examples where recursion is more intuitive is anytime when you need to repeat a task that um for for which you don't know how sort of deep you need to go in which case the recursive calls will take care of making calls to itself to itself to itself to itself until it reaches the base case you don't need to think about that in your iteration so an example of that is this kind of classic one where we have a file inside a file system someone you know if we're looking for a pet you know pet. text we can have um a student whose pet. text is you know straight under their users pet. text folder but we might have another person whose pet. text is going to to be within their users their documents their schools their MIT their classes their 6100 L their pets their pet one/ pet. text right so that uncertainty for how far deep you need to search the file system in order to get to the file of interest is a perfect place to apply recursion another one is where you have um an expression if you're building your own calculator and code and you have order of Expressions oh sorry order yeah order of operations using parentheses again you don't know how many parentheses you might need to have a loop go through in order to get to that base expression right to figure out the one that you need to do first and so that's another case where um uh using recursion is is is very useful so in the next lecture what we're going to do is a recap of recursion using another example uh Fibonacci Sequence and then we're going to start looking at um recursion applied to lists and specifically if we have lists within lists within lists within lists and we don't know how many nested lists we might have recursion is going to be a perfect example for that okay