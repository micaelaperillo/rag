okay so let's get started today's lecture will be the last one we have on object oriented programming and creating our own data types with python classes so today's lecture we're going to go through uh an example that's sort of more involved we're going to be creating our own Fitness tracker object and specifically we're going to create a class for uh that implements the idea of a workout and the slides for today are going to feel very similar to the slides from Monday's lecture a lot of them are just kind of uh reinforcing the the same ideas we saw last lecture on uh uh creating Getters and setters uh creating class variables and the idea of inheritance but we're just going to do it in the context of this more involved example uh the fitness tracker okay so let me remind you first of all something we've been uh talking about and and hopefully you understand at this point in our uh in our uh lectures on object oriented programming and that's the idea that when we write our own object types we're writing code from two different perspectives right the first perspective is the on the left hand side here where we are making design decisions for how we want to implement this new object this new data type and when we make these design decisions we decide the name of the object we decide the attributes which are either data or procedures uh that we want the object to have and then once we've decided on this and we've implemented our data type then we can start to use uh the data type and to use it we are creating a whole bunch of objects of this this type and we're manipulating these objects in some interesting and useful way so the left hand side we're creating this blueprint this abstract notion of an object and the right hand side we are creating actual instances that we manipulate right so up until this objectoriented uh Le set of lectures we've really just been working with the right hand side right we've been uh working with objects that other people have created but the big idea of these set of lectures is that we now get to create our own object types so we get to write the code here okay so we're going to write code to create uh a tracker for workouts and today's lecture um we're going to there's going to be sort of a sequence of of things that we're going to do we're going to start out with a really simple workout object and then we're going to improve on it so I've actually set out a little road map here on the board that we can follow so every time we finish sort of a little section we'll check it off so it's just easier to understand sort of where we are in today's lecture so we're going to create first a just a very simple workout object sort of In The Same Spirit that we've created we've been creating objects then we're going to improve on it a little bit by adding um nicer methods and things like that and then we're going to go through the idea of inheritance to create very specific types of workouts so if we think about workouts um we have many different kinds of workouts right we've got biking swimming running but really at the core of all these workouts right if we think about sort of the information related to just a very generic workout not a running or swimming specific one or biking one just a just a generic workout there are some common properties that all of these workouts have right so I've listed them here right um the a workout might have an icon associated with it right so this or this or this but whatever it may be there is an icon uh sort of property for a um a workout uh the kind of workout so biking swimming running things like that uh a date so maybe a a start date and an end date start time end time that kind of information the heart rate maybe average heart rate throughout that entire uh activity the distance um and the number of calories burned right all of these properties are common to any kind of workout that we might want to create but now that we have uh specific kinds of workouts that we might want to create uh we can actually think well in addition to these common properties a swimming specific workout might actually have some more information that we'd like to save right and we'd like to allow the user to work with so the swimming Pace maybe the stroke type the 100 yard splits things like that for swimming and for running we might want to show the user the Cadence the running pace the mile splits and maybe the total elevation throughout that throughout that run right but the idea here is that we have some core set of properties that no matter what kind of workout we're creating we would like to save and we would like to allow the user to uh to store and to do operations with now when we Implement our workout class we're not going to implement all of these they're not all necessary we're going to just keep some of the core ones so the ones we're actually going to implement in this class are italicized right so we're going to keep the icon and the kind of workout the uh start time end times and then the number of calories burnt that's something that we're going to just save as a really common um uh the common set of attributes for a workout but of course you can see that if you make the design decision to improve upon this workout class you might include a bunch of these other ones as well okay so um so we're going to have to decide the data attributes so we just mentioned on the previous slide right when we make design decisions we figure out the attributes that we'd like to have uh for our object type so that's the data and the behaviors for the data for a workout we've decided it would be the start time the end time and the number of calories burned so those three things together maybe start time is a string end time in a string and calories is a number right either a float or in whatever um those three things together make up the object uh a workout and then in terms of functional attributes so these are the methods that our object might have well we can have um of course the ability to you know tell us the number of calories burned so something like a getter method to set the number number of calories burned if we accidentally inputed the wrong number right reset it um and then maybe something like uh displaying an information card right so something like this if we ask uh if the user asks us to print a workout object we might display information in this nice manner here okay all right so let's start defining our class so this is a very simple workout class so we're going to do step box number one up there before we improve on it so this is in the same spirit as we have been defining classes in the past three lectures right so we tell python we're creating a new object uh by saying this is a class and the name of this object so the type of this object is workout okay and the parent of this object is the generic python object so far so good right now the first method we have to implement is the inip method right it tells python how to create an object of type workout the Constructor and we've got a bunch of parameters here because it's just a regular function that's a little bit special the first parameter of every method is of course self right because when we call a method we call it on an object right so some object dot this method name the thing before the dot effectively gets mapped to the variable self which is why every one of these methods has self as the first parameter and then we've got a whole bunch of other parameters for how we would like to initialize a workout object so we're going to say when we create a workout uh object we're going to tell it the start time the end time and the number of calories burnt okay so that's the the function uh stub I guess that's how you create the uh the object and then what does this function actually do what does this method actually do well it does some of the usual things that we know uh at this point so it basically Maps every one of these input parameters to data attributes self. start self. end and self. calories okay but in addition to just saving these as data attributes the things that are passed in when you create the object we would like to do two more things we're creating two more data attributes right so in total a workout object is defined by five data attributes these last two data attributes we don't need to pass in right we're just going to by default make them two two strings the icon is going to be the string this um sweating person emoji right and you can have emojis inside strings which is actually pretty cool and the kind is going to be just the kind of workout so we're just going to set it to be the string workout when we create running workouts it'll just be the string running when we create biking workouts it'll be a string biking right whatever you want it to be and we're going to see where these uh where these show up later on okay so that's the definition of my class workout and then for now that's it that's all we have in terms of the class definition now what happens uh when we create an actual workout object well we invoke the name of the class so we say here uh workout right and we're going to save this object to the right hand side of the equal sign as variable mycore workout so far review we pass in the parameters that the workout object expects so here's a string representing the start time a string representing the end time and the calories burned for this particular workout 200 um yes good okay so then we can add a whole bunch more methods to our class right that was just the inip method but last lecture I mentioned that it's important to add um uh getter and Setter methods to allow the user to grab or Set uh various data attributes so here I've got three getter methods to grab for me the calories start time and end time and three Setter methods to set the calories start time and end time okay all right so what I wanted to show you and this is not something we've actually seen before I wanted to show you that every time you create an object of of some type or even an object that already exists you can actually look into um sort of where this object is stored in memory which is kind of cool so if we think about the class definition that we've done so far so not creating an actual instance just defining the class right this class definition is actually kind of like an object stored away in Python memory right so here I have my workout class and associated with my workout class definition python knows about all of these um methods that you're allowed to do with this python class and this is called the class State dictionary so it's a dictionary that basically holds the state of your object so I wanted to show you what that looks like in code so this is my workout class and the way you access the state dictionary is by invoking the name of your class so not an instance the name of the actual class dot this Dunder method double uncore dict double uncore so this holds the dictionary the state dictionary and if we just access the keys we're going to see here every every single method we've defined in our class right so you see here here's my dictionary I could cast to a list if I wanted to but not necessary but you can see every single method that we've defined right so all Getters all our Setters the inip method the double underscore doc actually um grabs for us this dock string that you've put right under the class definition right so that's kind of cool um so that's the dictionary keys and of course you know as we know Keys have values associated with them so the values associated with each one of these Keys is going to be and we can see here so um for example the value associated with the dock string is going to be literally the thing that I printed out right the the little um dock string that I put right underneath my class definition right so now it knows the dock string for this class that I just created and the values associated with my getter methods and my Setter methods and init method and all the methods I created are just the locations in memory where python can find these methods to run right they don't have extra values with them of course associated with them of course because they're just def method definitions but python just knows where to go in which memory location to actually run this function okay so that's kind of cool um cool to know um Okay so that's the state dictionary of my definition right the implementation of my class now what happens when I create an actual instance right so here I've got my workout equals and now I've got this actual instance of this class type workout when python sees this line it says okay what kind of object do you want to create a workout object it looks at the init method of that workout object and then it runs all the lines associated with that workout object so now now it creates a new object in memory puts that at some memory location this object is going to be of type workout class and now this object is going to have its own State dictionary where in in the object State dictionary we're not storing methods or things like that we're storing the actual data attributes associated with this object right so this object all the data attributes are all the things that you access via the self. keyword right self. icon self. kind self. start self. end and self. calories so we can actually go in the code just like we did when we looked at the class State dictionary and look at the state dictionary for one specific object one instance so again we can call the double uncore dict method on this instance so now I have an actual object that has some values associated with it and if I look at just the keys we see these are the data attributes asso associated with an object of type workout right I've got my five data attributes and then the values associated with those keys are going to be the values that are specific to this object right so my start is this date here my end is this date here calories was 200 the icon was the little sweaty person emoji and the kind of workout is workout right so it's kind of neat to be able to look into that sort of detail of where things are stored inside um inside memory okay so we saw how to create an instance of an object and we can create a whole bunch of workouts that we then store right and then we can use do notation to access all of these attributes right so we can either access attributes directly or we can access methods right we already know this so last lecture I said that uh you can use uh do notation to access data attributes so here we're at accessing the calories value right and that's fine but what's preferred is to use the getter methods right so get calories will in this particular case return the exact same value as just accessing the calories data attribute okay but the note that I made uh last lecture was that it was better to use a getter method because the implementation behind the scenes might change right and if the implementation changes then if you access the calories method directly or sorry the calories data attribute directly your code might crash but not only that somebody who's writing a getter method for this uh for this workout function might actually make that method be a lot more complex complex than just returning that data attribute and that's what we're going to see in the next slide right so the idea behind uh using these consistent uh methods instead of accessing using data attributes is that you want to keep information hidden right you don't want to start messing around with looking at how something is implemented because that goes against the principle of abstraction modularity and information hiding right you want to keep things hidden because you want to use the these data these the objects that somebody else has created in a nicely consistent manner the way we use them in a consistent manner is by always using methods that are associated with that object type okay and so using getter methods might have seemed inconsequential when we wrote like the animal class last lecture but it's going to seem it's going to be a lot more important in this particular lecture okay so with that we finished our simple workout class and now we're going to change the imple implementation just a little bit right and what we're going to do is we're going to make a change to the the way that we store the information we're going to use a class variable and I'll remind you what a class variable is in the next slide and we're going to make a change to the get calories method and we're going to allow the user um to say hey I'm going to create this workout object but I don't know about you I don't know how many calories I burn right when I do a workout for you know 40 minutes right I don't know that right off the bat so if the user doesn't Supply the number of calories burned we're have we're going to have our get calories method kind of estimate those calories burned based on the duration of that uh workout right so we're going to allow the user to either Supply the number of calories in which case they probably know what they're doing and then we'll uh when we when they ask us to tell us to get the calories we're going to use those or we're going to allow the user to not supply the number of calories and instead estimate those calories based on the duration that they said this workout lasted okay all right so that's the big change that we're going to do here in um in the workout class right so we're going to do a better get calories Method All right so this is the new implementation of my workout class first thing you'll notice is we're using this uh class variable right we talked about this last lecture when we did the rabbits uh example in the rabbit's example we had um each rabbit change this class class variable value in this example I'm not going to change this class variable value I'm actually just going to use it as a variable that's that every one of these instances will is going to be able to access right and I and I'm just not going to change it which is fine you don't have to change this class variable so this class variable will represent how many calories per hour are are burnt okay so just a number and then the init method and again we're we're make we're going to make a different init method than what we saw in the previous slides the init method is going to be new and improved we're going to take in still the same number of parameters but the calories are going to have a default value right so if the user actually passes in the number of calories the value for calories here self dot calories will be whatever the user passed in but if the user doesn't pass in the number of calories then this uh parameter here self doog calories will be none right nonone rep using uh being used to represent the absence of a value okay so two options here when we create the object other things you might notice is that the self. start so the start time and the end time are no longer just start and end okay I'm going to talk about this on the next slide but essentially what I'm doing here is I'm saying the start and end will be passed in as strings just like we have been in the past right like September 1st 2022 1:35 p.m. that's fine we can still pass in the start time as a string but when I'm storing it inside my object I'm actually going to store it as whatever this thing gives me and this thing is actually going to be uh returning or parsing the string as a new data type something we've not worked with before called a datetime object okay we're going to look at this on the next slide in a little bit more detail but for now all we need to know is that the self. start and self. end will be a new data type a datetime object okay so that's my nit method so few changes now my get calories method will look a little bit different as well right we're not just returning self. calories like we had in that simple workout class right we're going to do a little switch so if the user supplies the number of calories so if the calories here were actually passed in then we don't rever re we don't resort to the calories being none right calories will be 100 or 450 or whatever it is and then this if statement is false so we go in the else and we just return that value so it's exactly the same behavior as in my simple workout class room back there but if the user does not supply the number of calories when they create an object object then the calories will be none here when I create my object the data attribute self. calories will be none here so when I ask the uh when I ask the workout to tell me how many calories I burned we're going to go inside the if statement and we're going to do something the thing we're going to do is subtract the end time minus the start time okay and something like this is allowed on a datetime object but obviously not allowed on strings which is why I'm converting that uh these uh strings representing a date and a time into this datetime object this date time this subtraction here gives me something uh like some something that's called a Time Delta object and it's just a new type of object we haven't really worked with before but it's a object type that we can run a method on and the method is going to be the total seconds so for this time Delta object so 10 minutes or 18 minutes or whatever it may be if we run this method called total seconds it will tell us how many seconds are in that time Delta object divide by 36 to tell us the number of hours and then multiply by the uh the class variable Cal per hour will tell us how many calories were burned in that elaps time okay yeah like workout Dot and then like all of that like oh workout dot is just this thing here workout. Cal per hour that's just this and then we multiply by that uh yeah that number questions about that okay so essentially this is going to do the estimation for us for how many calories re burned in some number of hours or some number of minutes now let's demystify this start and end time stuff okay so the way that we are um converting to this uh this this string to a datetime object is by using this Library up here so a library is a collection of objects a collection of maybe also functions that all deal with the same type of thing so in this particular case they all deal with dates and times and manipulating dates and times and things like that in the last lecture we saw an example of a library that random library that allowed us to do operations with random numbers right so it's just a nice collection of functions and objects that deal with one sort of common thing so in this particular case there is a function inside that uh that Library this parser dop parse function that takes in a string and can parse it to this datetime object okay so if we print the type of start date and the type of end date it'll show us that it's this type date time thing so it's a new object type we haven't worked with it yet but it's an object type like a list is like a dictionary is like our workout is right and so the reason why we're doing the conversion is because we don't want to deal with the messy part of grabbing in a string and then figuring out how long the elapse time is based on just parsing characters throughout this string right I certainly don't want to do that but you know what somebody who was passionate about doing that did it in this nice little library for us so all we're doing is just reusing the work that they've done right to save it as this object and then they basically said let me implement the minus sign to work with objects of type date time and it makes things like this very easy we can just subtract to dates from each other right and it'll tell us the elapsed time we can run a method on that elapsed time to tell us how many seconds that elapsed time is so pretty cool yeah yeah the yes the total seconds gets imported with the the date you tell parser thing yeah exactly um it's an operation that can be run on this uh date time Delta I think type object here so it's like total hours total minutes I think there might be like total minutes and total hours also yeah yeah so is parer class and then like par to second M yeah exactly yeah exactly yeah so yeah the code should be import yeah so we usually import all of our stuff right at the top so I was just going to show the code so here I've got everything that I need to import way at the beginning so it's kind of like python goes and copies and pastes everything in those files and puts them in your file so now everything that's defined in those files is now accessible in your file you just have to sort of do this um the the dot notation on uh on these libraries here so I just wanted to show you um down here so here uh I shouldn't have imported again but it's just part of this exercise so here I've got the the pars are being imported I've got the start time these are just strings right nothing special about them and we can uh parse them so I've got these strings parsed and the types of these objects again are not strings anymore now that I've parsed them right start date and end date are now these dat time objects daytime. dat time and then we can do operations like this so if I just simply subtract one time from the other and print that time Delta object python puts it in this nice little format for me I should just comment these out it's hard to see it puts it in this nice slow format for me so here's number of SEC hours colon number of minutes colon number of seconds right so this is the Str Str method that was implemented for that kind of object it prints it in this nice little form right hours colon minutes colon seconds and then which is and then we can do this useful thing which is what we're doing in our code we can uh run the total seconds function on an object of this time Delta and it tells us that this 10 minutes right is equivalent to seconds so very very cool very useful um and you know we don't don't even need to know how any of that is implemented we just make use of these functions what's cool about the parser though and this will be really really cool um you can actually write the time and the date in any format it doesn't have to be month SL um day slash year space this right so this is kind of how I wrote this one we can actually write it something like sept 30 2021 right like that and it knows how to read that or we can write out September all the way put the comma there put the comma there put the PM lowercase and closer to the to the time and it knows how to read that as well so it knows how to parse all these different ways of writing the dates and save them as these datetime objects for uh for using in this very nice very readable way Isn't that cool okay so very useful if you ever want to um work with date types okay so now um okay so now this is our state dictionary sort of for how we ended up uh with our simple workout class but what are the changes we made to improve it well in my state dictionary I added my class variable calories per hour so now this calorie per hour is available for any instance that I create right we already knew this but this is kind of the representation of that okay and I and we didn't add anything to the instances those haven't changed right okay so little aside on class variables right so um this Cal per hour here is available for all of these instances now a class variable right is just like an instance variable we can access it from within the class definition which is how it should always be done but python being python they allow you to access that class variable from outside the class definition as well um so we can do something like this so we can uh call the uh calper hour class variable on the name of this class right outside of the definition right this is my class definition it ended here right and this is just code that's outside of the definition and python will be happy to tell you what that value is um python will also be happy to tell you what that value is if you access it through an instance so here I've created an actual instance of type workout so I'm not calling the cow per hour on the name of my class I'm just grabbing it through one of my instances and if I print instance. Cal per hour python will also happily tell me what that value is right and python being python they're going to allow you to change the value of that Cal per hour outside of the class definition as well so here out inside the class definition I'm going to say workout. Cal per hour equals 250 so now the Cal per hour is changed permanently to 250 no matter how I access it either by calling the name of my class directly or by calling the class variable through one of the instances okay so no good never ever work with these uh data attri uh with these data Access Data attributes or access class variables outside the class definition if you really want the user to be able to do something like this right then write a method for it and then they can change it or access it in a consistent way right the way that you want them to access it okay so just a little bit of practice for you guys um to create a couple of workout objects just to make sure everyone's on the same page we understand what a workout object is so just create for me two objects and then print the calories for these uh workout objects so the first one I would like you to create name the variable W1 um it started this workout started in January 21330 and it went till 4 p.m. and you want to estimate the calories from this workout you don't know how many calories you burned right and then print the value for that calories and then the second object same same start date same end date but you know that you burn 300 calories right so create these two objects and then print the number of calories burned so this is online 199 and it's okay to scroll back up right to the init method of of workout just to see how it's implemented uh no reason you should have memorized it by now right all right how do we create these two objects what's W1 equal to yep yep yep the start date would be first so I can just as a string perfect yep yep uh I'm not say I don't think I'll say add I don't know if that works um and then the end date right is the next one so this one's 4 p.m. right like that you could do that and then what else do I put or do I put anything else exactly yep in this particular case I I'm going to let it default to none and then how do I grab the number of calories burned for this object for this workout object how do I print that out yep so I just call the get calories method on W1 and let's slap a print statement around that like that okay yep perfect so what is it a 30 minute workout at 200 calories per hour it's 100 calories right burned second one will be pretty similar right so I'm just going to copy and paste what's the difference between this one and the previous one when I create my object what's the one difference yeah yep exactly we will pass in 300 as the last Pam here right and so then if we run that 100 was my first print statement and 300 is my second one right so it relies on the uh the number that was passed in as opposed to calculating it uh by estimating it based on the start and all right everyone okay with this we all sort of understand get calories method perfect so we've finished our improved method here we saw this better get calories method very neat method that allows estimation and we saw a little bit about using these daytime objects okay so the next up the rest of this lecture we be implementing one subass of this date time of this uh workout object um called a run workout class okay and so we're going to use the idea of hierarchies and class inheritance to do this so let's remember a little a little bit about uh hierarchies in terms of python so when we create a class that we know will be sort of this this parent class that's that's a base class right it's a most basic thing that we'd like to work off of we call that the parent class or the super class and this one parent class can have many subclasses associated with it right so in this particular case just as an example we can have two types of uh of workouts right one outdoor workout and one kind is an outdoor workout and the other kind is an indoor workout okay and both of these are workouts right so everything that a workout has and everything that we can do with a workout we will be able to uh we will exist in outdoor workout and indoor workout and we'll be able to do with outdoor workout and indoor workout right so a child class is a parent class a sub class is a super class right but these uh these subclasses can bring about some of their own quote unquote ideas right their own attributes um so for an outdoor workout we might add more information right so add more attributes maybe location something like that for indoor workout you know you might not need a location might not add any extra data attributes um we might add more behaviors right so for outdoor workout I don't know you'd add some different some different Behavior than just a regular workout um same for indoor workout or you might override behaviors so you might change something that workout does to be specific to an outdoor workout and of course we can create as many of these subclasses as we'd like so for outdoor workouts we can now have two different types of outdoor workouts a running or a swimming and for indoor workouts we might have Miller weights types of workouts right and whenever you create these child classes they inherit everything that their parents has so a running class is an outdoor workout and by default it's also going to be a workout right because outdoor workout was a workout okay so what we're going to do in this run workout class is I'm going to show you three sort of methods implemented the first one is going to be just reusing something that our parent can do the second one is going to be overriding a method that our parent already can do to make it better and more specific to the child class and the third one is to add a method that our parent didn't even have okay so we're going to do these three things in the Run workout object okay so let's remember the uh this uh this example here about common properties that all of our workouts have right so this is basically us implementing our workout super class so I know we didn't Implement all of these but in theory we can Implement all of the things that are highlighted in yellow in our parent class and these are common no matter what kinds of workouts we create now in the python file I actually have a swimming subass we're not going to go over the swimming subass in the lecture but please feel free to go through it in this in in the python file for this lecture and I think you'll also be working with it in recitation on Friday as well in lecture we're going to be creating some a subass that's specific to running and this running class will of course inherit all of these properties that our parent workout class has but we're also going to add our own um data and we're going to you know override some data that the workout class has and things like that so specifically the only thing we're actually going to implement that's uh that's different than a regular workout is to add an elevation uh an elevation attribute right so beyond that start time end time calories an icon will also exist and the kind of workout will also exist those are our five data attributes right from workout and we're going to add elevation for running workout to make six okay so this was our parent class right just as a reminder this is what it looked like we had our class attribute here a class variable and this init method here um this class workout is their parent was the generic python object now when we create our run workout our parent will be the workout class right so we don't just want it to be a python object we want it to be a workout object so as soon as we do that inside our code python says all right let me just grab all of the stuff everything that's defined inside your parent class this workout and quote unquote copy and paste it into this class so right off the bat we've got all of the things that workout has but that's not um that doesn't quite work with our run workout because when we create a run workout and again this is a design decision we would like the user to be able to pass in an extra parameter here the elevation value so in addition to the start time end time and the calories burned I'm going to slip in this elevation value right before the Cal burned parameter okay so when I initialize my uh run workout I could theoretically pass in four values string string number number or since elevation is zero elevation has a default parameter and calories has a default parameter I could pass in just string string and those other two will default okay so what is this init method doing it's calling the super function I know we haven't done this before but I just wanted to show you this this is another way um to ask python to tell you who your parent is right so when you run this function super inside a class definition python effectively returns so the replacement of this function right this is just a function it has a return value the return will be the thing in the parenthesis here so effectively that line becomes workout doore init Dore exactly what as we saw in the last lecture when we did animal right rabbits and all those stuff all right so what we're doing here is we're saying well I know workout can do all those initializations for me so let me just take advantage of that not copy and paste it and just let workout you know do the job and initialize all that stuff for me so this line of code here initializes the start end times right by parsing them uh the calories and the icon to the sweaty person emoji and the kind to workout string but since this is a run workout I would like to um replace the icon with a little running person emoji and the kind of workout this is is no longer just a workout let's say it's a running workout right so it becomes a string running so I'm uh overriding those data attributes to be the strings and then the thing that run workout has that workout didn't have at all is this elevation data attribute right so self. elv is now a new data attribute that did not exist in the regular workout okay and then I've got these two this these two function methods down here a getter for the elevation and a Setter for the elevation nothing fancy with them they just return and set yeah yeah so the super init calls the parents init method and the reason I do that is because I know the parent can just initialize all that stuff for me so I'm just taking advantage of the fact that it does all that stuff for me right you can imagine the inip method maybe it also checked the types right to make sure that the person who created this you know to kind of enforce that start is a string end is a string like all that extra code that would happen in the init method of workout we would just let run with this line here so we don't have to copy and paste it yes yes uh uh you mean from this these two yep needs to yes exactly actually yes you're right so the reason this works is because the init method of my workout takes in the start and the end and the calories right if if I said that the init method of run workout doesn't need start an end or something like that I wouldn't be able to run this init method exactly or maybe I would run it with some defaults or something like like if you actually want to run it you you have to pass it you still have to follow the um the the stub of that in it method right yeah that's that's a great Point yeah passing the init of the parent into this one without having to write the super thing yeah so this you're right I wasn't writing the super thing I was just uh naming the the the parent directly so in the animal one I said animal doore init Dore and in this particular case I'm just showing you a different way to to do it maybe you don't know who your parent is question mark um in that case you can just run this function and it tells you who your parent is um but this line would work just as well if I said workout write this thing doore in it Dore and that would be exactly the same as I had done last lecture so let's look at the state dictionary for this one right for this new addition here so this is the state dictionary of just my plain old workout class right we've done we saw this before it's all my Getters all my Setters the init and this cper hour from the new and improved workout class now my subass the Run workout the super method basically says hey this is you are a workout the super method the state dictionary for it will additionally have these two getters uh sorry this getter and the setter these two methods right we're not copying all this stuff all over again down in the Run workout State dictionary because that already exists up here right but in addition the Run workout has this get elevation and set elevation method those are the only things that we've defined in this class right so then when I create a run workout instance so this is an instance of run workout not workout python points to this runw workout class and the data attributes for a run workout instance are going to be of course all the data attributes of a regular workout that was five plus the elevation the new data attribute that I just added okay okay so we're using inheritance in this particular case right in the spirit of modularity in this Spirit of abstraction in the spirit of writing code that's reusable that's readable that's understandable in the future right so we're not if we were writing the Run workout by basically copying and pasting everything in there all over again it would be a really long class where most of it was just a copy and paste off of the workout right so now in this particular if we Define it in this way we can easily see new functionality right and new data attributes that run workout has in addition to just being a workout object okay so all those good things uh for writing very nice clear code okay so now we're going to look at a function or sorry a method that's being reused from our parent and that's this double underscore St method okay so this Str Str method it looks like a beast right it's very very long but I promise you it's not so bad um so this method let's remember what it does it tells python what to do when you print an object of type workout right because it's defined inside the workout class here so I'll show you what it actually looks like in the actual workout class so here's my workout right um there's my class variable my nit my Getters my Setters all that and then here's my strr method it's long right it takes an entire page this this is not a method that I would like to copy and paste in every single one of my sub classes right because that would be a lot of code again against the spirit of abstraction modularity all that good stuff so what we're doing is we're just defining it once in our parent class workout and it's going to do the following so Str strr method has to return a string right it doesn't print the string right this is a very important distinction it returns a string that will eventually be printed when you call the print method so the thing that I'm doing throughout this whole function throughout this whole method is to basically just build up my string to return return R is return string and I'm building it just by concatenating it piece by piece with more and more stuff that I want to eventually print out so the output would look something like this right I'm basically printing out on the console sort of like the little square of a watch right very cute um so what am I composing here the first bit right this thing in the red box prints this line over here just horizontal line that's some width long the next bit here you notice it grabs the icon data attribute puts it here on the line along with the vertical bar in a bunch of spaces and a vertical bar the next bit here prints the kind of workout by accessing the kind data attribute right so either workout or running or swimming whatever that string is print it right underneath the Emoji the next bit here is composing the duration so remember when we did the datetime object just over here right when we were printing the duration where we just simply subtracted an N time minus a start time it looked like this right I'm perfectly happy with that that looks really nice so let's just use that so the duration here the get duration just does the subtraction it's a method inside my workout class and it then we just sort of keep composing that to our return string next we are going to figure out how many calories were burned in this workout object so again we're grabbing the get calories method right the return value from that method however it may be calculated right so for this workout type either we gave the value directly or we let it estimate it from the duration of the workout however it decides to calculated according to how this workout object was made that value gets put right there and then the last bit is this last line down at the bottom okay so then we can create any kind of workout right because all the child classes inherit all of the methods from the parent class so of course all these child classes will inherit the St Str method of workout so no matter what kind of workout I'm creating so here I'm just creating a regular workout here a running workout and here a swim workout no matter how I'm creating it they'll use the same St Str method so all of these will printed in this really nice format right the first bit will be specific to the kind of uh workout we have right the little emojis will be different because I've set those separately right within the sub classes uh the kind as well the the label right workout or running or swimming the calories uh burned and the duration will be will be you will be um you know uh calculated using the get calories method and then the get duration method so again in a nicely consistent way so I'll show you what this looks like in the actual code let me just comment that so here I've got three workouts created and then I'm just printing these three different kinds of workouts and just to show you I'm not lying see the swim workout doesn't have an S strr method defined right and neither does the Run workout right it just has a bunch of other stuff defined but no s strr method so we're we're just using the Str method of our parent and then when we run it it looks like this right so I've got a regular workout with their icon and label running workout with their icon and label and a swimming workout with their icon and label isn't that cute right so we've made our own little digital thing okay so um this begs the question right when can we use uh an instance of a class right of a subass um well you can use an instance of this run workout anywhere where you can use workout right because again the way I think about it is you say well a run workout is a workout so anything I can do with a workout I should be able to do with a run workout or Swim workout or any of the sub classes right but the opposite is not true if I can do something with a run workout well run workout has a bunch of other specific things that it can do of course a regular workout is not going to be able to do those specific things right so let's think about these two helper functions this one calculates the total calories given a list of workouts and this one calculates the total elevation given a list of workouts the code looks very similar for both we're just iterating through the loop grabbing each workout object and then we're calling the get C calories or the get elevation on that workout object right so this will give me a number and then I'm just keeping a running sum for the total elevation and the total calories and at the end I return it right so again the list here is important these are workout objects and workout objects so what if I have a bunch of so here I've got two two workout objects and two running workout objects so these workout objects are 30 minutes long right so using uh 200 calories per hour these ones will each be 100 calories these running workouts are two hours long so they will uh it doesn't actually matter right sorry sorry these running workouts are 2 hours long so they're going to be 400 calories right because these parameters here correspond to the elevation okay and they correspond to the elevation because if we look at the way we defined a running workout right here right this is the order of the parameters start time end time elevation value calories so when I pass in VAR parameters they need to go in that order and I I I can't skip around right if I want one of them to be to be the default variable then that has to to be at the end so in this particular case I've got these two running workouts at 400 calories because by default I didn't actually pass in the number of calories and then the elevation is 100 and 200 yeaha um then you would just put uh if you wanted both to be default then you just put nothing you you can't just leave an empty comma what if you want default uh elevation and yeah so then you then you would have to actually explicitly say like calories equals whatever you want so so at that yeah now that we're working with uh default variables it it becomes a little bit tricky you can't go wrong with just saying like LF equals whatever you want it to be calories equals whatever you want and then you can do whatever you'd like in that case yeah but in this particular case we know our workouts are 400 and elevation is is is those values so when we run total calories on all of the workouts no matter what kind of workout I have it it doesn't actually matter right because python will just grab calories for all of these workout types right so it just sums that up elevation if I run it only on running workouts python will know what to do here's 100 and 200 because those running workouts have an elevation data attribute but if I ask for oops but if I ask for the elevation for a running workout and just a regular workout python will spit out an error because as soon as it sees this workout one it says well what's the workout. getet LV method and it's going to say I don't have a get LF method for a regular workout that's not something I know right because that's something that we implemented in the child class so let's go through these together um and it's it's actually nothing to code just to sort of run um it's just down here so this is just kind of making sure you understand sort of the order of operations and I think one of the ones that was question here where we actually passed in the number of calories is is at the end so when I create a regular workout oops let me just remove that over here what is the value when I ask python to tell me the calories right for this work workout at 200 calories an hour what's the value here just yell it out 30 minutes 100 right what's the elevation when I ask python to tell me the elevation for this object error exactly yep yep because uh the workout object has no attribute right has no method get Lev that's something specific to a runner running workout okay how about this one run workout here so here I'm actually oops I didn't mean to do that what happens if I grab the calories for W2 yep 450 yep pretty it just grabs whatever is passed in right does an estimate how about the elevation yep error again perfect now let's create three kinds of running workouts so here's one what's the calories and elevation for this one I'll just do them all both together right so rw1 this parameter is the only one passed in what does that correspond to calories or elevation yeah elevation remember our parameter list elevation comes before calories so the elevation 250 and the calories will be estimated right based on whatever this is right so calories is first at 100 elevations 250 how about running workout two so here I've got 450 and 700 in that order which one is the elevation yep 450 and calories is 700 so when we printed I printed them backward just to confuse us all um and then lastly how about this run workout three so here this is to S answered the question what if I wanted elevation to be default but I wanted to pass in calories so here I just say the name of my parameter there and I give it an actual value right so clearly here calories will be 300 and elevation defaults to zero so just a little practice reading the specifications um okay so that finishes reusing the Str method from the parent now let's uh override our super class so our improved workout class remember has a get calories method that estimates the calories based on the time that it took you to do this workout whether it was a running workout or a regular workout but I what I'm doing in this method is I'm going to actually Implement my own get calories method inside the class definition for a run workout right so here's my run workout class definition and I've got my own get calories method so when I run get calories on a run workout python will use this one what is this one going to do so we're we're going to do something really cool we're going to estimate the number of calories burned for a run workout based on a set of uh points latitude longitude points so what we can actually do is we're going to pass in a list of tupal like this which represent sort of the root that we take right so from point A so in this particular case I've got sort of four places that I have you know jogged between so these are my four latitude longitude points so each Tuple is latitude comma longitude so I can make this as precise as I'd like but what I want this method to do is to potentially if the user does give me a set of latitude longitude points that they actually went through to calculate the calories burned based on a class variable called calories per kilometer right so given a set of these points what I'd like to do is to calculate the total kilometers traveled between all of these latitude longitude points multiply that distance those that kilometer Distance by the calories per kilometer and use that as the estimate for the uh calories burned in this particular run workout so this is how the code achieves that so I've got another class variable that's only specific to this run workout so workout does not know about this calories per kilometer is 100 and now I've got my own get calories method here it's overridden so if we run this get calories on a run workout it will use this one um and what does it do well if we don't give it any GPS points if we don't give it a list of tupal there python will default to the else what does the else do well it says hey who's your parent run their get calories method so that's just um estimate it based on the total time elapsed in this workout right that's our default parent but if the user got fancy and gave us a bunch of tupal representing latitude and longitude points for all of their workouts then we're going to do the following stuff we're going to iterate through all of these pairs of GPS points right Pair by pair we're going to uh calculate the distance right given this latitude longitude value add on to this running total for the total distance pass uh total distance ran and then return that total distance multiplied by this data attribute sorry class variable calories per kilometer okay so let me um show you what this actually looks like because the only thing that is is sort of still mystifying here is this GPS distance and this GPS distance is actually a function that's in this lecture helpers um file which is included in today's python uh ZIP file and it's just you know from the internet um it's how it's a a way to calculate the kilometers the the kilometer the distance right traveled between two latitude longitude pairs that's all it is so it does some fancy stuff with signs and cosiness and things like that to figure out the the the distance between these two lat laon pairs okay that's all it is so we're just running that function nicely down here to help us calculate that total distance right beyond that everything is is pretty simple it's just looking at consecutive pairs of these um of these tupal right getting that distance plus this distance plus this distance and then multiplying by the calper Coler so in the end what we get is something like this so here let me show you um here are uh here are two points latitude longitude points so I've got Boston and Newton so here I've just got a straight shot right so not counting you know getting very precise with blocks and things like that but if I create a running workout here with the start time end time elevation value and now I pass in the root GPS points right this is another uh piece to my init method I forgot to show you that sorry about that so here's my init method for uh run workout I skipped that little bit um last parameter here is to actually pass in some root GPS points and if I actually pass in those root GPS points when I run the get calories method it tells me that I burned this many right and it calculates it based on that distance between Boston a Newton in the second example here I don't actually pass in the value for the GPS points so we're defaulting to just our regular calories function from workout which is to calculate it based on the start time and the end time so from 135 to 357 right that's why it's a weird not round number of calories so I think that's also really cool you guys um this this function here okay so these overridden methods just to show you sort of for completion sake how this run workout class looks everything is the same as what we ended up with before but now I'm going to reimplement my get calories method right so now run workout knows about a calories method and I've also got this data attribute sorry class variable sorry I always got messed up this class variable Cals per kilometer right and any run workout instance we'll know about of course the Cals per kilometer as well as the Cal per hour from our parent questions about that okay we're building something really nice here right so um I guess the question is and I think you've probably figured this out how do you know which method to call well you just look at the object before the dot right you run a method you object do method name what's the thing before the dot what is its type if the type like for example get calories if the type is running you look to see if that class definition has a get calories method if it does you use that if it doesn't and only if it doesn't you look at your parent and say does your parent have a get calories method if it does you use that and if it doesn't you look at the parents parent does the parents parent get have a get calorie calories method right if it does use that if it doesn't you look at the parents parents parent all the way up you keep going all the way up the chain until you get to the generic python object if the python object type has a function or a method named what you'd like to call you use that otherwise error right no such method was found anywhere within our chain of hierarchies up until the python object all right so that finishes overriding our get calories method and now we're going to do one more thing which is to add something new to run workout that didn't actually exist uh in uh in workout although I guess I am implementing it in workout so it's not actually adding new but we're going to override it anyway so the class workout let's say that we want to compare two workouts together so to do that we're going to uh implement the dunder method double uncore EQ double underscore this will allow us to compare two running workout objects or two workout objects or running and workout objects using the double equal sign right so W1 equal equal run W2 or whatever right so we can use the double equal sign to compare objects of our type so again my decision for comparing these objects types uh for for comparing these two objects workout objects is to say well first let's compare the types so so if I'm comparing a workout versus a running workout right off the bat they're not going to be equal right so first of all the type of this object should be the same so I should be comparing workouts with workouts running workouts with running workouts or swims with swims and I also want every one of the other data attributes to be the same right so the start time end times the kind and the get calories so as long as all of these things are the same I'm going to say that these work works are the same are equivalent so this is the equal method in my workout and then in my class workout I can actually override that method so this should actually be um add override right just like the other one um and in run workout I'm going to override the equal method but I'm going to do it in a very modular pythonic way I'm going to say that a run workout is going to be the same as another workout if everything in my parent is the same so here I'm just calling the super method right saying workout dot Dore equal Dore other so with this little bit here right this line here just the super doare equal other this Compares all of these things so I don't need to rewrite that in the EQ method of run workout and I can clearly see what else in addition to uh regular workout comparison I need to have happen for them to be equal I also want the elevations to be equal right that's the other data attribute right so you can see now how nice modular this code looks right it's very clear what differentiates a run workout to a regular workout right with this with this line questions about this okay yeah exactly yeah so this uh this should all be on one line right but the backslash actually just uh breaks up the line into multiple lines for visibility yeah so in the code here's a bunch of workouts right and I mean we can run some of them but you can see why they're true or false so here W1 and W2 are not the same because the calories are uh burned are different right they're both regular workouts they both have the same start and end times but the calories burned are different so this prints false right just equality on these workouts um um right and then here's a true one right W2 is equivalent to W3 because they start and end times are the same the length is the same right and the calories burned are the same W1 W3 or sorry W2 and W3 these two right this one just used the default value but that default uh calculated uh values were calculated to be 100 because it's a 30 minute workout anyway right so you can go through some of the other ones on your own uh I guess the other interesting one is this W1 with rw1 everything about this is the same calories burned um right everything is the same except for the fact that they are different kinds of workouts right one is a run one is a regular so we around that that's F other questions or any questions okay so last slide um this is the last lecture on object oriented programming um hopefully it gave you an idea for how to create your own objects and this last example specifically showed how we can just improve it a little bit at a time to make it be you know this really cool thing right we added uh way to estimate calories we added a way to estimate calories using GPS points and we just did it incrementally right so you don't want to do that right off the bat just write a little bit at a time and in the end you can write a really cool object type um now that you know how to create your own object types you can create objects using other objects right so some of the data attributes for something more complex could be a workout object right something like that but it's it's possible to overdo it right especially now that we're not writing super complex classes it's possible to over engineer right and when you over engineer it becomes kind of annoying to just keep scrolling back and forth right to this in it to that in it to figure out you know what methods were in this uh with this class what methods were in the other class and so if you know if you can achieve it using just one one object type or maybe just a function no need to create your own you know all these complicated object types that build upon object types but I just wanted to show you that it is possible you know especially as you might be building more complex things in future classes things like that um it is possible to write really complex classes that don't look so bad right because you're building upon code that you've already written right so now we've got these ideas of abstraction modularity information hiding that all work together to help you achieve this really cool um cool object or cool class or cool program okay so the next lecture next next set of lectures we're going to uh leave programming for a little bit we're going to look at um figuring out how to write efficient programs and how to figure out whether our programs are efficient or not and and things like that so we're going to go into a more theoretical side of of computer science but