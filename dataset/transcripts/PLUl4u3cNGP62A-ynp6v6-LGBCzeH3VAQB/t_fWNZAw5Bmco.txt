okay so let's get started today we will be continuing talking a little bit about loops and seeing some other uh couple nuances of loops and then we'll get started on our first algorithm the guest and check algorithm and then towards the end we're going to start talking about binary numbers in advance of seeing our next algorithm so let's do a quick recap of what we learned last time and then we'll do a little coding example and then we'll move on so we saw last lecture some looping mechanisms right we saw while loops and for Loops they are both a way for us to control what happens in the code and specifically there a way for us to repeat certain lines in the code sort of automatically so to speak so with while Loops the lines of code were repeated as long as some condition held and with four Loops the lines of of code were repeated for some sequence of values okay and the sequence of values was something that we decided it was numerical that uh that that's what we saw last lecture today we're going to see that the sequence of values can actually be uh non-numerical as well so both of those Loop types I guess um had uh uh ended at C at certain times right so the Y Loop ended when the condition became false and the for Loop ended when we've exhausted our sequence of values but often times we want to write programs where we break out of the loop prematurely we don't want the Y Loop uh condition to become false and we don't want to exhaust our entire set of values in a for Loop so in order to exit a loop before the uh Natural end comes we can use this thing called a break statement and the break statement allows us to exit the loop um and the loop it exits is going to be the one that immediately surrounds the break statement so here's a a little example of a nested two nested while loop so one while loop and then one nested one inside it the outer one is going to uh run whenever condition one holds and the inner one runs whenever condition two holds okay now expression a will evaluate when both condition one and condition two hold right so we enter the first y Loop and we enter the second while both of those conditions have to be true but python as soon as it sees this break statement python will immediately exit the loop that it surr that surrounds that brake statement so the loop that surrounds the brake statement is the one that has condition two right the condition one Loop will keep going so as soon as python sees this break statement it's going to immediately stop running the Y loop it's not even going to go back up and check the condition two which means that expression B will actually never get evaluated so this is terrible code we don't want to write code like this because expression B will never be run right but this is just to show you the impact that a break statement would have and expression c will then be evaluated whenever condition one is true now condition two may or may not have been true along the way but expression c will evaluate only when condition one is true right condition two would have stopped being true and then we're going at the same indentation level as this inner wild L like it only evaluates the one time like it only gives a once and then because the break is there exactly yeah that's a great point so it only evaluates this expression a one time because right after it evaluates it it sees the break and then we immediately exit the Y Loop and we're done that is a great observation yeah and that's what this um this code will will basically show so here it is us doing the break statement sort of in the same structures on the previous co uh the previous slide and what we're going to do is actually just run the python tutor for this code just to give you some more practice running the python tutor so this is the same code AS on the previous slide I've got a four Loop that goes through some sequence of values can anyone tell me what are the sequence of values this for Loop will Loop over five seven nine and we stop right because 11 is n but we go up to but not including n minus one so 5 79 are the only three values we would potentially Loop over so hit next we initialize my sum to zero so in our minds we kind of think about the fact that we're going to Loop through uh make this Loop variable be 579 so the first time through the loop I will be five we're going to uh add I which is currently five to my sum so 5 plus 0 makes my Su five and then we immediately see the break right because if my sum equals 5 is true so we go inside and we immediately see the break statement this line will never get executed so we're never going to increment my sum by one so the break immediately breaks out of our Loop now the if the if statement is not a loop right it's a conditional so the loop we break out of is the for Loop and then there's no other loop surrounding it so then the program is basically done and we print five okay again bad code we would never write code like this but this is just to show you exactly what happens with uh with the break statement right so there's the code block for the for Loop and this is the code block for the if statement and the break breaks out of our Loop right which is the lighter purple um not not the not the if statement okay so let's have you write a little bit of code and this is sort of maybe a little practice with just Loops in general that uh that we saw last lecture there's no break really in this particular program here um just a little bit of practice so what I want you to do is to write code that basically has a for Loop running through this range so for I in pick one of these I want you to write code within that for Loop that counts how many ne how many even numbers are in that range right so including the zero so for Range Five you you your counter should basically pick up on the fact that zero is even two is even and four is even and then that's it so it should print three so here is that you try it inside the python file for today and I've already started you off with this 4 I in range five as the first one and I'll give you a couple minutes to just write the code in here okay would anyone like to start us off with some code or give me yeah yep so this line of code is going to take our ey right so in fact what we could do to remind ourselves what i is and this is very helpful for quizzes as well we can write a little comment here that says I is 0 one 2 3 4 just so we don't have to remember this fact we can just always look here and know what i is going to be um and then this line of code absolutely correct is going to take I and grab the remainder when I is divided by two okay and if the remainder is zero that means that the number is even and then what do we do inside here when this is true when it's even how do we keep track of whether or how many times this condition occurs yeah yes exactly should we create a variable yes we can so let's call it even nums and um we'll probably want to increment it by one right because here's another number that's even so even nums plus equals 1 and then let's remember to um initialize it right before our Loop right so initially before we even start our Loop we have zero even numbers and then each time through our Loop we see one that's uh perfectly divisible by two we're going to increment this little counter by one okay and same oh yeah not the same variable thank you even num nums yeah and the mental model you should have sort of at this point or beginning is just the fact that these three lines solve our problem it does the automatic counting for us right because I will take on zero then one then two then three and then four automatically as the loop goes through this sequence of values and so at the end of the loop so sort of at the same indentation level as the for Loop all we need to do is print how many um how many of these numbers we have so if we run it it'll print three and if we change this to 10 it'll print probably six right because it counts the zero right questions about uh yeah please I should look in so if you're under counting you may be initialize did you ini ize even nums to something else or maybe this is not incrementing right or maybe the range is different I'll try yeah it worked awesome okay so iterating through uh using for Loops to iterate through sequence of values is pretty useful let's take another look here at uh this particular program so this program is uh these this set of code this code and this code actually end up doing the same thing but let's look at the top one for now so this is a program that takes in a string S as sort of an input so to speak it iterates through the numbers zero to the length of s right so for I for index in range Len s is basically going to say for I index in range 13 or however many letters this string has right d e m o space l like all those letters there's probably 13 of them or something like that um so this line of uh code here is going to have our index take on the values 0 through 13 representing the index in s right so the lowercase D will be at index zero the lowercase e will be at index one and so on so with this index in hand the next bit of code if s square bracket index equal equal I will check for me if this particular character is an i or that particular character is a u and every time that happens I'm going to have this print out H uh uh print out to the screen there's an i or U so inside my code here this is the first one and I run it it's going to print out that sentence twice because there's only two eyes are Us's in here and if it repeats it'll print out twice so there's one U and one I okay but this code can actually be written a lot simpler okay notice it took me a little bit of a while to explain it and probably at first glance it would take you a little bit of time to figure out what it's doing and that's because we're actually relying on the index as kind of a middleman right we're looking uh we're iterating our for Loop through the index and then we're indexing into that index variable to grab the particular letter it turns out that with four Loops right I told you you can iterate over any sequence of values not just numbers and remember that strings are actually just a sequence of characters right case sensitive characters so in Python we can actually write code like this so the middle uh box right here it has our for Loop iterating through each character in the string directly so no longer are we looking at the index 0 through 12 but we're looking at the letter directly so our Loop variable which I called Char but you can call whatever you'd like is now going to take on values that are the letters themselves one at a time so the first time through the loop Char will be lowercase D the next time through the loop Char will be lowercase e the next time Char will be lowercase M and so on and so now we've got the sequence of values that's the letters directly so when we check if the letter is an i or a u all I need to do is check if that character right Char my variable is equivalent to I or equivalent to youu and it's going to be the same and it's exactly the same code so this is the one we had before and this is the one I just went through and again it prints out that sentence twice right because it's the same starting string so the sequence of values now is our characters direct right it's the letters directly it's not the the index itself and it turns out there's actually a much more pythonic way to write the code this middle box down here so in the bottom box the only part that I've changed is the if statement and I'm using this in keyword to test whether the character that I have in hand lowercase D lowercase e lowercase M and so on is in this sequence of characters I or you and for this case it's not so important right because in the middle box we could do if Char is equal to I or Char is equal to U which is fine but if we were if we wanted to test if the character is one of the digits 0 through nine this if or or or would be become a really long line right and so all we can do is you know if Char is in some particular sequence of characters python will automatically turn that into that longer if it's this or if it's this or if it's this or if it's this and so on okay okay so the big idea here with for Loops is that yes we're iterating through a sequence of values but we're not limited to just numbers and that's the cool thing about for Loops you can iterate through characters directly and we're going to see later on we can iterate through lists of numbers lists of strings and a whole bunch of other things so let's write a slightly more complex program this was version uh 0.01 of the cheerleader robots you see up in the corner there that I wrote um the robots or not mine but the code is uh so here's a little bit of code that kind of puts together iterating through strings directly and iterating through numbers directly so let me show you what this program is actually doing and then we'll go over the code somebody give me some noun you're really excited about what is that what never mind give me something else that I know what is it pineapples okay pineapples okay so there it's going to cheer for us about pineapples and let's say we're enthusiastic level eight about pineapples all right so this is my cheerleader program so I typed in a word and I typed in an enthusiasm level for pineapples and then all it does is and notice the repetition which computers are really awesome for give me a p p give me an I I give me an NN and so on right what does that spell and then it does pineapples with three exclamation marks eight times because that's how enthusiastic I'm about pineapples all right so let's look at the code that actually does this notice there's two parts to it right there's the part that does the um spelling and then there's the part that does repeating the word some number of times so these are two separate Loops the spelling is up here this for Loop here and then repeating some number of times is down here okay so the part where we do the spelling has a for Loop that iterates through the letters in the word directly right I'm not doing anything special with these letters so I can just iterate through uh the letters directly so for w in word where word is the input that I grabbed from the user W is a loop variable that's going to first be P Then I then n then e then a and so on right and then I have an if else here and if you look carefully the only difference between the if uh what we do inside the if and what we do inside the else is whether we type in un and then a letter or a and then the letter right because some letters make sense to say give me an a as opposed to give me a a it just doesn't sound right in English the letters where it makes sense to do un are defined up here so notice they're just defined as a really long string and so the if statement uses that in keyword we saw on the slide right it says if W so if that particular character is one of these is in this sequence of characters then print give me un and that particular character and otherwise it's you know it's not one of these letters where it makes sense to say un so then you just print give me a and then that letter uh here I just rewrote these two print statements using f strings which we talked about back in lecture two just to show you how you could um how you could rewrite it with f strings um but it can be done both ways okay so at the end of this we've done the spelling and then we have a print statement that says what is that spell and then the last part is to repeat that word some n number of times whatever the user told us so I save that number of times in a variable called times and then all I do here is I have a nice little for Loop that goes goes through however many how much how much that number is right so range times means it's going to be zero all the way up through an including times minus one that's a total of eight eight times in this particular case that it Loops through and then all we do is print the word with three exclamation marks notice that this print statement that's inside the bottom for Loop is not actually doing anything with our Loop variable right our Loop variable here is I but we're not doing anything with it and that's totally fine right because all we're using in the times and the loop vary in this particular Cas is to do this action some number of times right we don't always have to do something with that Loop variable any questions about this code uh yeah you also have used if statement for could you use if statements for the prints which one which prints these ones yeah how so to evaluate like the the W instead of having to um I mean f not if F oh F strings yeah we could have done it like this yeah so this is this is how it is f and then we do the characters themselves inside the curly bracket yeah oh no that's okay it's okay yeah there's a question yeah that last not yeah so the last for Loop is um is still going to iterate through uh times times right and the loop variable each time through the loop will be zero then one then two then three it we're not doing anything with the I right the stuff that's indented is going to get done but we're just not using the fact that I is zero or one or two at all incr yeah it increments itself automatically we're just not using it yeah exactly okay uh and that's what I said Okay so let's have you write a little bit of code so let's assume you're going to be given a string of lowercase letters right so we're not going to bother uppercase lowercase just assume you're given lowercase letters it's stored in a variable s so as an example s is equal to ABC a I would like you to write some code that counts how many unique letters are in this string right so notice a occurs twice but the count that your code should do for this particular uh in this particular string should just be three right we don't want to double count the a so there are three unique letters in ABCA they are a b and c so I do have a little hint it involves the use of an extra variable um as these programs usually go uh try to think about uh having this extra variable be a string that contains everything you've seen so far so as soon as you see a letter that you haven't seen before add it to this to this string variable that you've marking that you've now seen this this this letter and then use this scene variable to um to to write the rest of it so if you as you go through your your letters make sure that you're going to check whether you've seen it already before uh before recounting it so as usual it's in here around line 76 this is the code to um to do it so I'll give you a couple minutes and then we can write it together okay so let me just work through it and this is something that I think is pretty useful in a quiz situation it's just writing things on the on paper first just because it's a you know programming computer science class doesn't mean we have to start coding right away so it's really helpful to just kind of put some ideas down on paper so the way I would go about this problem is clearly I have to touch each character right in the string s so already for me that's I need to have a loop so as I'm looking at each character I'm going to keep track of it so if it's not something I haven't se so if it's something I haven't seen before what I want to do is say okay I have now seen this a so I'm going to add it to a seen variable and then I'm going to increment a counter right I've seen it once so count maybe equals 1 now the next time I look at the next letter I'm going to say it's a b have I seen it before no let me add it to my scene variable and increment my count next time I'm going to look at the letter c I have have I seen it before no I'm going to add it to my scene and then I'm going to increment my count and then the last time I'm going to look at this letter A I'm going to say is it already in my scene yep so so I'm not going to do anything with this one right so when I see a letter that's already seen that I've already added to my seen variable I basically do nothing in my code right so the most of the work happens when I encounter something I have never seen before so does anyone have some starter code or something we can write we don't have to write it perfectly top to bottom we can write pieces here and there yeah um you like you find there yep I wrot um car and I don't but I said like if car and in uh in walls but like I want to say if it's not in scene yeah so that that's a great start so if you want to say if it's not in scene we can just say if Char or car however you pronounce it is not in scene so that takes the inverse of you know true or false whatever this is right because inen will either be true or false and not that will be false or true right so that's perfect uh yeah can you you quickly when do we use the word not and when do we use like the exclamation Oh yeah so we can use not when we're dealing with booleans right so something that an expression that evaluates to true or false that's when we use not and the not equal so the exclamation mark equal is used when with other Expressions when we're testing for equality right like three not equal two or like a not equal b or something like that right so things that are that could be numerical not necessarily just true and false yeah okay so if Char is not in scene so if I haven't seen it before what do I want to do yeah [Music] yep yep so we can append the character that we just looked at to our scene list right just as we had done incrementally here so that takes care of adding the character one by one if we haven't seen it to our scene good anything else we want to do or we can even test it out like this right so we can print scene each time through our Loop right so first it's a then it's a then it's ABC and then the last time it should still be ABC and it is okay and the last step is to just do what the problem asks us to do which is to print how many characters are how many unique characters are in this list or in this string y yeah we can have a counter that is initially zero before the loop and every time we add a new thing to our uh scene string we can increment our counter and then that takes care of the bulk of the work right this does all the counting all the adding to the unique scene and so at the end of the loop we have this number in hand and then we can just print it so with this particular case it's three if we add more A's in random spots it's still going to be three right yeah so now that we have some code that that basically basically that works really well we can make improvements to it so one Improvement that suggested is instead of keeping a counter variable we can actually just recognize the fact that the length of our scene is just all the unique characters we've seen already right because when we double up on something we don't read it so all we can do to uh to print out uh the number of unique characters is to just say I'm going to print out the length of scene okay and now there's no need to increment any sort of counter and so that still gives us three questions about this code does it make sense okay um notice there's no else right we just have a nice little if there's no else because there's nothing to do when we've already seen the character so we could have else Pass and Pass is just some is just a keyword in Python you see it's turned blue because it's a keyword in Python it just means do nothing right so we wouldn't write this obviously but that's that that you know if we had an else case that that's what we do we just do nothing okay other questions about the code is that right uh Sor say again why are we printing the length of scene here um so we're printing the length of scene because um because we see that uh whenever we add a unique character to this scene variable it it's it's one that we haven't actually seen before right and so the only things I'm adding to my scene are things that are new and so uh even as I was going through manually here I said I've seen the a I've seen the B I've seen the C I added them one by one and then when I saw the duplicate a I didn't add it to my uh here right and so basically the scene already contains all the unique characters in my list uh in my um in my in my string original string yeah okay so quick summary of what we've seen so far before we start looking at our first algorithm so we've seen objects right that's how we write python Pro uh python programs we manipulate objects by saving them to variables so the values are more easily accessible we have Expressions that evaluate to different things integers floats booleans things like that we added branching as a way to control as a control flow mechanism to our program right it says Hey python either evaluate this set of statements or this other set of statements depending on whether this condition is true and then we added the last uh uh mechanism for control flow the looping mechanism that said you know either Loop or repeat this code while some condition is true or Loop this code for this sequence of values okay so really with that in hand we basically have a really nice toolbox of things that we can use to write interesting programs that's kind of all we need but this is not the end of the class we're going to look at other things that will make our code neater more readable um we can write more of it more efficiently and things like that but really if you want to just start writing little algorithms this is all we need in terms of python syntax so the first thing we're going to apply this knowledge to is our very first algorithm called the guess and check algorithm so another word for the guess and check algorithm is exhaust cost of enumeration okay so the idea here is that we're given a problem we can guess a value for a solution okay we'll just do a guess and then we'll test whether this guess is correct does it solve our problem if it does we're done we found a solution to our problem if it doesn't solve our problem we're just going to keep making guesses until we've exhausted our set of possible guesses right so either we find a solution or we say we weren't able to find a solution to this problem doesn't mean that one that one doesn't exist it just means that with guess and check and exhaustively enumerating all these possible values we were not able to find a solution so in terms of a flowchart the way this looks is we have an initial guess we ask is this guess correct if it is we're done and if it's not we're going to choose a next guess so let's look at uh finding the root of a perfect square and that's our problem and we're going to say either we found the root of this perfect square or we say this is not a perfect square so with guess and check we can say well what if we want to find what if we want to find whether seven is a perfect square if it is what is its root and if it's not say that it's not a perfect square well we can make an initial guess six that's not the right solution we can make another guess nine that's not the right solution we can make another guess two that's not the right solution we can make a guess zero that's obviously not the right solution we can keep guessing randomly like this but it's not going to be very efficient right what we want to do is use the power of computers and computers work with these sort of patterns in hand right remember range starting from zero following a pattern going up to some number so the idea is to be systematic and then we can really harness the power of of programming and computers being able to do things really really quickly for us so for that same problem finding out whether a a a number X is a perfect square let's be systematic and start with a guess of zero two pro two cases the number we're trying to find the square root of is a perfect square let's say four we're going to start with a guess of zero is 0 squared solve our problem no increment does one squared solve our problem no increment does two squared solve our problem yes we are done what if X is not a perfect square okay let's say 10 let's use the same systematic approach of guess and check we're going to need to add a little bit of algebra though because if we don't we're at risk of potentially doing something that will lead to an infinite Loop so the algebra we need to add to solve our problem is to say if the if we uh we're looking at a number that's not a perfect square we need to have to find we have to find a way to stop right we don't want to guess something that's infinite this is guess and check so we need an exhaustive set of potential Solutions so we're going to use algebra and we're going to say we're going to stop as soon as our guess squared becomes bigger than x okay so we're going to start guessing zero then one then two then three than four and at some point that number that guess squared will be bigger than x and we know we can stop because numbers bigger than that will definitely be bigger than x so our first guess would be 0 squared obviously less than 10 1 squar less than 10 2 squar less than 10 3 squar less than 10 right that's nine 4 squared becomes 16 and we say this is where we stop and we have not found uh a square root for 10 right so 10 is not a perfect square does that make sense is that right okay so our exhaustive set of potential Solutions is zero through four because that brought us close closest to 10 and at four we've gone over 10 and we don't need to check five six seven because there's it's definitely not going to be those values squared will definitely be bigger than 10 so this is the code that solves that problem we get input from the user so what number do you want to find whether it's a perfect square or not and what is what is it if it is a perfect square um we have a while loop that checks one condition right that's our stopping condition here we're going to iterate through the loop when guess squared is less than x right so on that number line we're going to keep incrementing by one as long as our square is less than x so that's this y Loop here and what we're doing inside the loop is incrementing our guess right guess equals guess plus one and then at some point if we haven't found a perfect square or if we have found a perfect square this condition becomes false right because this is false when the when we have the opposite of this less than sign so gu squ becomes greater than or equal to X now that's two very different things right gu squ greater than x means we haven't found found this perfect square but gu squ is equal to X means we have found a perfect square right and both of those cases trigger us to leave the while loop so then right after the while loop we need to have an if else the if else checks for one of those two cases so the if gu squared is equivalent to X means that we exited the Y Loop because we found that it was a perfect square so like four for example right if X was four when we hit two that y Loop becomes false and we exited because four was a perfect square but the 10 for example would fall within the else uh Clause here right because we have exited the loop because guess squared 4 or squar 16 was greater than 10 okay and so that's um then then we would print X is not a perfect square okay so this works for many different values as big as you'd like but it doesn't work for uh it doesn't work for negative values and the reason it doesn't work for negative values is because the loop never actually enters in the first place um so for example uh if we look at this uh whether -2 is a is a perfect square we're going to start with guess is zero just because that's how we imple uh we implemented the algorithm right on the previous slide it says guess is equal to zero right at the top and so guess is 0 we say is 0^ 2ar less than x no zero is not less than -2 and that y Loop never even enters at all which is fine right because -2 does not or ne4 you know negative numbers are not perfect squares unless we're talking about imaginary numbers but we're not in this particular case however we might want to handle the case when the user giv us a negative number maybe they accidentally typed in the negative sign or something like that so we can actually take care of that case by adding a little bit of extra code around what we already wrote so the stuff that's boxed in red is the extra code we write everything else is exactly the same as two slides ago okay so the only thing we want to do when we encounter a negative number is flag it using a new variable that's either true or false and then at the end we can handle that flag so if it's uh true we do something and if it's false we do something else so in this particular case we've got a negative flag initially false which means that we're going to initially assume the user gives us a positive value right so negative flag equals false the user we get input from the user and then we check if the user gave us a negative number so if the x is less than zero then we're going to change the uh value of this flag neg flag equals to True right so we're going to change the value from false to true and then the rest of it is the same right this is all the same as what we had two slides ago except that at the end we're going to check to see if the user gave us actually gave us a negative number we can check with them did you actually mean the positive version of that number or something like that and so in code the way this looks is is as follows so if we run it and we give it you know four obviously it tells us it's a perfect square and what its square root is nine Works 10 it says it's not a perfect square and then when we give it a negative number square or not it just uh tells us ne4 is not a perfect square and then it says just checking did you mean four so it does this extra print statement when the number was negative Yeah question yeah so I can explain that again so the negative flag equals false is just a variable right I just called it neg flag it's a variable I initialize to false just to say hey the number I'm going to assume is not negative and then we only flag it to uh we only change its value to true if the number was negative so in fact we could have just had a little if else here right so we get the X we don't have this line up here we have X is equal to int and then we say if x is less than zero NE flag equals true else neg flag equals false we could have done that as well yeah okay so the big idea with guess and check is we can't test an infinite number of values we have to stop at some point right so now we've been working with the code that that looks like something on the left side right we've been using while Loops but we've seen that we can actually write very efficient code using for Loops as well and in fact the guess and check method maybe intuitively lends itself better to a for Loop than a while loop right because we're trying to iterate through an exhaustive set of values right the number zero through some number right and so maybe a for Loop is a better way to write such a guess and check algorithm and we're going to see how to rewrite that in a little bit but in terms of a flowchart the way the for Loop would go is we sequentially go through all the possible values when we've exhausted all the values we say we didn't find a solution and otherwise the for Loop just automatically grabs for us the next value in the sequence so let's have you work on this for a little bit I want you to hardc code for me a number as a secret number this is kind of what we did last lecture so secret equals you know 7 five whatever you'd like it to be and then I want you to write some code that goes through all of these numbers from 1 to 10 inclusive let's say and prints uh that it found the secret number so if the secret number is within the range 0o through 10 print that you found the number and otherwise don't print anything so if you don't find the number print nothing and as you're working on that and if you finish that code think about how you would change that code to do one thing differently if it's not not found print that you didn't find it so in the first version if you don't find it do nothing but in the second version if you don't find it tell me that you didn't find it okay so these codes are in this python file and the easier version is about line 129 and then if you work on you know after you finish that if you're done you can just copy that code to lines 144 and try to modify it um to the new specification so if you don't find it print that you didn't find it okay so tell me some code for the first one so if we find the number print we found it and otherwise do nothing what's better while loop or for Loop for Loop yeah for let's say I in range how do I get numbers one to 1 to 10 inclusive one comma 11 exactly good so this and again I can write a little message for myself I is one 2 3 4 dot dot dot 11 what do I do to make the check whether this number I is my secret yep if I equ equals secret we let's say print found okay run it obviously four is within that range obviously a 100 not in that range right so when we had four it printed found and when we had had 100 it did nothing okay I'm going to copy this code and paste it down here so let's try the version now where we just make one small change to our specification right now we request the code to say if you don't find the number within this range print that you did not find it what are some things we can try else okay print not found okay so four obviously was found but we also printed all these not founds why yes because it's iterating through the whole range so you could try breaking out of the yeah we printed it because it's iterating through the whole range every time I check an I I'm either printing found or not found yeah so we could break I guess um when we found it right break run it okay then we print not found until we find it and then we break so we're getting there right it's it's looking a little bit better what else can we try yes another break we can try another break after not found but then the four is not found [Music] yeah yeah I like the idea yeah we can do you can try to do a Boolean flag was that your suggestion as well yeah okay let's try to do the Boolean flag way um let's delete the breaks let's go back to what we had before so basically our idea is I think what we're trying to get at is we only want a print not found when we've gone through all the numbers in the range right so kind of something like this right I want to print the knot found only once at the end of my Loop okay but this code doesn't work either because I'm always printing not found no matter if I do this extra print inside here right because this not found at the end here is at the same indentation level as the for Loop so the suggestion from a couple of you is to actually set a flag right so we can set a found flag to be originally let's say false right so before I even start my Loop let me just assume it's false and I'm GNA use this flag to to uh to trigger or I'm gonna I guess I'm going to change this flag whenever I found the the the number right so found is originally false and the place in my code where I know I found the number is here right when I is equivalent to my secret and then I can set my found flag to be true I only call it a flag because it it flags that an event happened or not so it's kind of a a Boolean event but it's really just a variable right nothing special about the word flag it's just a variable right okay so now I think the suggestion was now that we've set our flag to to true or false depending on what happened in the code we can say if found or I guess in this particular case if not found right the inverse of my Boolean print not found right there there's no else because the else was already taken care of when when we had the secret when we found the secret within the code so now we print found when it's four and if the number is obviously outside the range like 100 we print not found we can make a small change to it I guess so we don't have to print found down in there for maybe uh consistency or making things even we can just say else print found or something like that and I think that should work as well so 100 is not found and four is found right so now we're doing things kind of consistent stantly we're printing out whether we found it or not down here and inside the for Loop we'll just we're just dealing with the logic of the finding or not finding it any questions about this code does it seem all right does it make sense so I'm showcasing these Boolean Flags just because they're very useful for signaling that things happened in your code right so when you find yourself asking how do I how do I know that this thing happened something like Boolean flag is the answer right just set it to true or false zero or One A or B whatever you want and then check the value of that variable um later on in the code to to see if the event happened or not so these are the two codes that we had just written kind of side by side just to show you exactly what the difference is so here is the code where if we don't find the number we don't print anything right so it's just a for loop with an if and we say we found it and the one on the right is the code where we did find it uh where if we didn't find it we printed that we didn't find it so the only things that are added in addition to the code on the left is the stuff that's bolded right so I just have this flag that I initially set to false I set it to True when this event happened that is I found the the number and then I do the check at the end to print or not print found yeah can you explain why you don't use else I don't use else in the if or down here in the if uh so we don't use the else inside the if I equ equal secret because that if or else will be done every time through the loop right and I only print that we didn't find it one time at the end right the if if I have an an else inside the for loop it's basically asking if I is the secret number so zero is not the secret number we would hit the else one is not the secret number we' hit the else two is not the secret number we hit the else and only when I get to Seven in this case it is the secret number so I hit the if and so on so it's not something I want to do every time through the loop it's I put it at the end because I only need to do it once do that that make sense okay so Boolean variables are a variable that is in one of two states right I used here true or false but as I mentioned you can use zero or One A orb as long as you as the programmer remember what values you're expecting this this variable to take on Boolean variables can be used as signals that something happened in the code right so this could be useful in a quiz situation we call these boo Flags but again it's just a name uh it's it's just a variable that changes state depending on if some event happened in the code okay so I'm coming back to the idea of while and for loops and we've already seen that there are many situations where for Loops are a lot more a lot easier to use than while Loops okay um so when we have four Loops that irrate through a sequence of values so the guess and check algorithm actually lends itself a little bit better to for Loops than y Loops so here's an example of us trying to find the cube root in this particular case not the square root of a number and again we're only asking if this uh number X is a or in this case cube is a perfect Cube okay so the way the code works with a for Loop is we're going to iterate through all the possible values so we have four our guests in range some number so we're going to check all the values zero all the way up through Cube + one the reason reason why we did the plus one is because if the user gives us the number one we want to check one itself right if we didn't have Cube plus one if we just had Cube we would mistakenly stop at zero even though one is a perfect Cube okay and then inside the four Loop we just have if guess cubed is equal to cube then we have found our perfect Cube okay if we have negative numbers with cubes it's just adding a little bit of extra code but it's not as weird as with the square root right because the cube root of a negative number is just the cube root of that positive version of that number with a negative sign in front of it so all we're doing with a negative number uh as the input is saying I'm going to iterate through all these values in through zero all the way up to the positive version of whatever the user gave me so this is taking the absolute value of the number that user gave me and adding one to it so just kind of like the code on the previous slide except we're doing the absolute value of it we're checking if the guest cubed is equivalent to uh the absolute value of cubed exactly the same as on the previous slide except taking the absolute value of the cube and then we have this extra little bit that checks if the user actually gave us a negative number so do we need to put a negative number in front of our guess so if the user actually did give us a negative number let's just take do minus whatever value we just found for the cube and then we can print the cube root of this perfect Cube okay so again same code as before the only difference is absolute value of Cube and adding this check to deal with negative numbers okay so we can actually make this code a little bit faster because for example when we're taking the you know checking the cube root of 27 the numbers we're checking are 0 1 2 3 4 5 6 in our for Loop all the way up to 27 right but we can recognize the fact that when we reach uh or okay 27 fine let's say 26 we can recognize the fact that when we hit three the guess cubed is actually 27 right and so in our for Loop it doesn't make sense to keep checking Four five six seven to see if those numbers are then going to match or or be our our cube root for potentially perfect Cube and so that's what this code is doing it's going to have a little if statement in here so again this is the same as before but we're going to have a little if statement that says if the guess cubed is greater than or equal to not just equal to but greater than or equal to let's break out of the loop okay and so so when this condition is false or sorry when this condition is true guess cubed is greater than or equal to we have exited the loop but now just like with the square root code with the Y Loop we have to see why we exited the loop why did we break out of this Loop prematurely okay one is we exited because the guess cubed was equal to the cube or the guess Cub was greater than the cube and so then we have a little if else uh conditional here that says if we exited because it's not equal greater than then it's not a perfect Cube and otherwise we exited because it was equal to which is the same code we had on the previous slide check whether the user gave us a positive or negative value put the negative sign in front of our guest and then print the perfect uh cube root okay so all variations of the same sort of starter code we're just adding little bits of function functionality and making the code slightly more efficient here and there so I have another example and this example is probably the point in this class where you're like aha this is what computational thinking means so remember these word problems from childhood right you see a math problem you have basically a system of equations algebraically you could probably solve it within a minute or so we can actually apply computation to solve problems just like these so we don't need to do it algebraically we can just tell the computer here's a bunch of values I want you to try try them to see if they match these systems of equations and then print out the answer right so here's an example I've got Alyssa Ben and Cindy selling tickets to a fundraiser Ben sells two fewer than Alyssa Cindy sells twice as many 10 total tickets were sold how many did Alyssa sell here's some code that could solve this problem for us I'm basically figuring out all the Poss possible combinations for tickets that Alyssa and Ben and Cindy could sell right so I've got three Loops uh each nested right so Alyssa could have a could sell zero or one ticket or two tickets and so on but for every value of Alysa so Alysa can have um can sell zero one or two tickets for every one of those Ben can sell zero one or two tickets right so Alyssa can sell zero Ben can sell zero Cindy can sell zero Alyssa can sell zero Ben can sell one Cindy can sell zero and on so we're basically having these three for Loops that make all the possible combinations of tickets so here I have Alissa Ben and Cindy trying to sell tickets to a fundraiser and then I have my system of equations here so in total they sell 10 tickets so here total two lesson twice are all Boolean variables so a plus b plus C is equivalent to 10 is the first condition I need to hold B is equal to a minus 2 is the second condition I need to hold and C is equal to is equivalent to 2 * a is the last condition need hold those were the conditions from the previous slides right and so these three booleans whenever they hold total is true and two less is true and twice is true when all these things three things hold I have found the solution to my problem so inside my code this is Alyssa Ben and Cindy trying to sell tickets and the code automatically tells me they sold this many each and what's cool about this code is we can then change something about it and then we can run it again and immediately it tells us what the new solution is we don't have to do it algebraically and solve it all over again the problem with this code and the way I wrote it specifically is it's really slow for big numbers if I change it to a thousand tickets being sold by three people right and then a couple other changes here just the sheer fact that I've got Alyssa iterating through 0 to a thousand and Ben iterating through 0,000 and Cindy iterating through 0 to th000 takes really long time and so that particular code I'm not even going to run it will take a really long time if I change the values to be 1,20 and twice but instead we can use kind of a mix of algebra and computation to solve the problem we recognize we actually only need a loop through one Loop right I only care about maybe checking Alyssa's number of tickets being zero through potentially a thousand tickets sold and then I can use my other two um equations right Ben and Cindy how many did they sell with respect to Alyssa and then I've got my two other equations here which will tell me how many Ben and Cindy sold with respect to Alyssa's Loop right and then my last equation here is that Ben and Cindy and Alyssa all together had to sell a thousand and so with this particular code I'm able to find the answer to the question which is how many tickets they sold and again this is really awesome because now I can make small changes to the numbers and solve the problem basically immediately like that right I don't need to go back and solve it algebraically as I would um if I were to do math okay so we can apply computation to many different problems I hope that this is a really good showcase this this word problem of what we mean by computational thinking and the kinds of things we want you to come away from uh Come Away with in this class the last thing I wanted to talk about and I'll just do a quick intuition is binary numbers and this is actually a precursor to the next algorithm we're going to see in the next lecture an approximation algorithm it's going to be an improvement on the guess and check algorithm so so far we've seen numbers in Python they can be integers which are whole numbers and floats which are real numbers but in programming some interesting T things happen when we deal with floats okay and this is going to be our motivation for talking about binary numbers numbers and then fractions and then floats in this lecture and then in the next one so here's an example of some code so I've got is exactly what's in the slides I've got an integer X and all I'm doing in this code is I have a loop through range 10 so that means it's going to Loop through 10 times and I'm adding 0.1 10 times so 0.1 plus 0.1 plus 0.1 10 times and I'm going to print whether X this sum .1 plus .1 plus .1 is equal to one and just to show you I'm not pulling your leg I'm going to run it and print whether X so 0.1 plus1 plus1 10 times is equivalent to one and this code prints false not intuitive right if I'm adding 0.1 10 times I should be getting one but I'm not in programming and just to show you the actual answer we get let's print what the value of x is and then ask whether that's the same as just multiplying 0.1 by 10 so doing the loop where we add this number 10 times gives me actually 9999999 whereas just multiplying 0.1 by 10 gives me one as I expect okay and this is the motivation for uh or I guess the precursor to our next algorithm the approximation algorithm okay so we have this thing called a floating Point error and why does it happen and since it happens we can't do equivalent right we can't use the equ equal sign between floats because we get things like this that are going to completely mess up our program when we expect you know something as simple as adding 0.1 to itself 10 times to be one and it it's not right and so the big idea here is we have operations on floats and the way because of the way floats are actually stored in computer memory these operations introduce a very small error super super small every time you do an operation with with a float but the more you do this operation that has this tiny air the more this air gets magnified right and so then we see surprising results like that and so that comes about with the way that floats are actually stored in the computer so what we have in the computer is we work with binary zeros and ones but humans actually work in base 10 right we think from 0 to 9 but the computer works in base two either zero or one and the reason it works through Z and one is because of the way that the computer hardware is built right it's easy for the computer hardware to say that a magnetic spin is up or down right zero or one it's easy for the hardware to say that it has a voltage that's low or high right if it would be a lot harder for the the computer hardware to say hey I have a voltage that's zero low high let's say one or it's one/ tenth of the high or two10 of the high there would be too many errors introduced and so it's a lot easier for the computer hard R it just be in one of these two states zero one right so that's where binary comes in and so when we're dealing with integers this is not a problem because we can easily convert numbers uh that are in base 10 to base two that are whole numbers integers the problem will come when we do floats so you don't need to know how to do the conversion but I it will give you an intuition for what's going to happen so the number 157 in base 10 so that's what we have up here is 1,00 + 500 + 0 * 10 + 7 right in base two we have a similar pattern we have some some whole number multiplied by some power of two here we had the whole number be be either numbers 0 through 9 multiplied by some power of 10 but in base two we're going to have either zero or one multiplied by some Power of Two And if we're trying to convert the number 157 from base 10 to to base 2 I guess humanly speaking the way we' think about it is what is the biggest power of two that we can have that takes us close to but not over 1 157 and that's 10 2 to the 10,24 because 2 to the 11 is 2,000 something and that's already too big and then you ask yourself what's the next biggest power of two I can add to this number 1,24 that brings me close to but not over 1 157 that's going to be 256 notice we 2 to the 9 because adding 2 to the 9 takes us over 1,57 it's adding 512 to 1024 and so we repeat this process where we're basically trying to figure out what are the biggest powers of two we can add in order that makes up 1 157 and it turns out it's going to be 2 to the 10 plus 2 to the 8 plus 2 7 plus 2 the 6 plus 2 5 2 to the 4 three and two are all going to be zeros and two to the one and two to the zero and the bit right 1 * 2 10 1 * 2 8 is basically what gets represented here right these whole number portions that we multiply the powers of 10 by and that's how we convert from a from a decimal number to binary number but again this is kind of a human way of converting we can actually do it in a more systematic way a more not uh a more imperative way right a recipe way some way that a computer can actually use to take a number number and convert it to Binary and you would never have to come up with this way but given this way of converting to Binary you should be able to code it up so the idea here is we're going to take a number and we're going to look at uh the remainder when we divide it by two right if it's an odd number obviously the remainder is one if it's an even number the remainder zero and that remainder actually gives us the last bit the farthest right bit and then we we can take that number and divide it by two fully and then that gives us the remaining four digits so you see everything else just gets shifted over and the way the code looks is just doing successive divisions and figuring out the remainders so I'm just going to look at the python tutor real quick and then we can um we can stop so if we're trying to convert the number 157 following this particular recipe all we do is we look at the remainder when we divide the number by two so this is an odd number obviously the remainder is going to be one so we add a one to our binary representation and then we're going to keep adding what happens when we divide the uh the remaining numbers by two we're going to keep adding the remainder to the front of this string here so if we divide the number 157 by two that gives us 753 and now we ask is 753 odd or even it's odd so we add another one to the front of this string the result string divide 753 by 2 it's 376 this is even so now we add a zero to the front of my string right so notice what happens to this string as we go step by step 376 divided by 2 is 188 what is this even number so we add a zero to the front of this string 188 divided 2 is 94 again it's an even number so we add a zero to the front of this string 94 divide by 2 is 47 it's odd so we add a one 47 divide 2 is 23 it's odd so we add a one 23 divide by 2 is 11 so we add an odd so so we add a one 11 divide by two is five so it's odd so we add a one and then 5 by two is even we add a zero and then one is our last number so we add a one and notice this is the exact same number we had when we did it in this human thoughtful way uh where we were trying to figure out the highest powers of two we can take to go up to but not over the number 157 okay but we did this using just this this very iterative very nice um loopy code and if we wanted to do a negative number we would just add these two boxes here it just basically means we add a negative sign in front of it okay yeah