so let's uh let's get started with uh lists and mutability so last lecture we talked a lot about um what it means to have these mutable data structures lists today we're not off the hook we will continue talking about the idea of mutability but we're going to do in the context of uh removing items from lists and some of the pitfalls that come with that and then we'll go into uh along the way ideas about cloning or making copies of lists and aliasing uh making another name for the same object in memory so first let's uh do uh let's quickly talk about making a copy of a list because so far when we uh we're dealing with these mutable objects we notice that it's a sometimes inconvenient uh to have the uh to to mutate the list right and it it's hard to keep track of the fact that we're mutating a list and there are some problems for when it does make sense to make a copy of our list so that we can mutate the copy or mutate the original while still having that sort of original uh those original items in uh saved somewhere else okay so you can ask python to make a copy of a list and basically behind the scenes it creates a new list object for us in memory and copies over every single element from the list you'd like to copy like to copy into the new list okay so the Syntax for doing a copy of a list is as follows so we've got uh a list that's already made called L and we want to make a copy of it so the syntax is L square brackets with a colon inside it and behind the scenes python makes this list inside memory and then we save that new list that has the exact same elements as l into a a list named L copy okay and so in memory the way this looks so if I have this code here where I named my list L original again I'm choosing a different name than L just to show you that whatever list object I have that's the name I need to reference so if I have L original is 456 in memory if I want to make a copy of my list I just say l original square brackets with a colon inside it that means copy every single element from beginning to end of the list and bind it to the name L new okay so notice in memory now I have two list objects they're referenced by different names and so if I change one of them the other one will not change right there's there's um they're now completely separate objects okay so we're starting this lecture off with a quick little exercise just to kind of get you to remember what we did last time and to practice writing a little bit of code with mutable fun with mutable objects so I would like you to uh write this function called remove all this is going to feel very similar to something we did last lecture so last lecture I asked you to write a similar function which took in a list l and an element e and that function from last lecture created a new list and then basically populated that new list with all the elements from it had all the same elements as L except for omitting the ones that were equal to e okay this version that I would like you to write for me is not going to create a new list and return this new list it will mutate my input L such that you're going to only keep the elements from L that do not match e okay so I'm going to give you a hint for how to do this so the process for this is going to make uh is going to make use of this thing that we just saw which is I want you to first save the list as is into a copy and then at the end of last lecture we saw a way for us to mutate a list to empty it out of all the elements so we still have that object in memory but we're just essentially clearing it out we remove all the elements from it so first make a copy and save the elements then clear the list we want to mutate L and then iterate through the copy and add all of the elements that do not equal e back into L right so that should be the process and in the end when we call this remove all function the thing that we're passing in will have been mutated we don't have anything to return okay we're just mutating the thing that's being passed it so I'll give you a couple H uh minutes to work on that and you can start writing it on around line okay uh does anyone have uh some code to start with yes yep initialize a new list yep what do you want to call it l new good name L new equals how do we make a copy and what do we copy so so what we'd like to do is mutate L right but L already contains a bunch of items in it right so that's why we first want to make a copy of it right so just like in the syntax from the slides this will essentially save for us everything that we already have in L in a new list called L new okay so now that we have that does anyone yeah so L do clear does not take a parameter in right it's just a function that empties out L fully so it'll basically draw drop every single element in L okay um but we will see some fun some a function that will remove elements okay so if we do L do clear then L becomes uh the empty list right L just becomes this so now that I've mutated my object to contain none of my elements in it how do I add back in the elements that satisfy the condition yeah so for n in L new right so I'm iterating over the list that actually contains stuff the thing I've copied um and then and then you can see like if not yeah exactly l. append so notice I am yeah I am appending to L but I'm iterating over L new right L new new has all of these elements in it I want to touch each element to see what value it has if it's not equal to the one uh the one from the parameter e then I add it to my list L the one that's currently empty okay and then do I need to return anything we don't need to return it won't hurt to return L but L will already be mutated by virtue of this function so we don't need to return any any L right L is parameter that I've passed in so there's nothing to return it's just being mutated um in the function so when I make my function call here right I'm passing an L in I'm just making a call to remove all with this Lin object which is this one here and notice there's no I'm not saving the return from this function to anything right because this function will just mutate whatever I passed in and then if I just print the value of L in after this function call it'll print the the mutated value uh yes sorry we should append uh n not e thank you yep and that looked weird perfect and so if I run the other two examples here I'm removing one so it should just show me a list with all twos and here I'm removing zero and zero doesn't even exist so it doesn't mutate that input list at all okay so now we can start talking about uh other operations on lists which deal with removing lists making the lists smaller so we're actually going to take elements away from the list and this is similar to kind of what the suggestion was instead of uh kind of uh to clear out an element a specific element right but the clear function removes all the elements however these functions will remove certain elements from our lists so there's three different ways that are on this slide and I'm going to show you an example with this list L kind of showcasing what each one of these functions do but first I'll just explain them so one option for removing an item from a list is if you know the index of the item you want to remove like you want to remove the very first one in the list or the last one in the list or the halfway point or something like that you can tell python to remove the item from list L at a particular index with this Dell parenthesis so this function Dell and you pass in L at whatever index you want to remove now sometimes you uh you want to remove the item all the way at the end of the list so the farthest most right in that case there's a operation called pop and you call pop on list l so if you just say l. popop with nothing in the parentheses pyth Pyon will automatically grab that last value from the list and drop it from the list okay now pop is a little bit interesting because it has a return value we're using this dot notation which we used with append and clear and a bunch of other uh things from last lecture but here um this pop not only does it have the side effect of mutating my list by dropping the last element from it but it also returns something so this function call here will return for me the value of the element that got dropped just in case you want to do something with it um and lastly we C if you know the element you'd like to remove specifically so if you have a list of a bunch of names and you want to remove Anna from that list and you know the string a Anda is what you'd like to remove you do that using the uh function l. remove so whatever list your names are part of you say that list. remove and then you'd pass it in you know the string Anna or the number five or whatever actual element you'd like to remove okay now if there are many elements that uh that match that value right if there's many anas in my list of names it will only remove the first one it finds so from index zero all the other ones will remain you'll have to call that function again so let's look at this example here I've got this list of seven yes seven elements within it let's do a few of these operations all in a row so each one of these operations will mutate my lists so the op operation right after it will work on the mutated list okay so let's start with this L if we say l. remove two python will look for the element whose value is two well there it is it's at the front of my list that's fine and python will remove that element so this list will now be one element less shorter right and that two is going to be gone so the list L will now be mutated to be 1363 70 all right well what if we remove three now right so we've done the operation to remove two We've Ended up with this mutated list now what if we remove three from this mutated list there's two of them in there right the element that's going to be removed is the first one it finds so just this one here okay and again this is an operation that mutates my list so this list here that I've started with would be one uh ele one element shorter and that three will have been removed right so now I've got 1 six 3 70 all right what if we want to delete a par an element at a particular index so now again we're working with the mutated list 1 16370 this Dell function takes an an index in a specific list and removes the element that is there so in this case I want to remove the element at index one so in this list here the element at index one is the six right this is zero this is one so the six will be removed and my list will be mutated to just contain these four elements 1 3 7even and zero and lastly if we pop that function will just remove the element at the end of the list the end liit at the end of the list is this zero so the list through this side effect of the pop right is going to be mutated to contain just the three elements except for the last one so it'll contain one three and seven and additionally if I'd like to save the value of the element that got removed from the end of the list the zero you can because this function call here l. pop you can save the uh return value into a variable none of the other ones Dell or remove have any return right so if you saved a variable from that function the the the function called to a variable that variable will be none pop is special because it actually grabs that variable value and and returns it okay so all of these operations mutate the list right so that means as we did Operation after operation we were working with the mutated list okay yes there was a question yeah I'm sorry say again like the third one you said like L1 L at index one yeah so the L at index one here works on the list we had just mutated so this one the element at index one is the six oh yeah Y no worries okay so let's look at the code we just wrote in the UT tried exercise and try to rewrite it using this remove operation well the way we can think of it is we'd like to remove the element that is e right so we know the value of the element we'd like to remove it's you know three or five or one or two or whatever so that's e and we know of an operation that can remove the element from the list it's called remove unsurprisingly so what we can do is we can say l. remove e right and that would remove the first instance of the element in the list but I might have many of these elements in my list so we can just write a little while loop around this operation and we say while we still have this value in our list remove it right so that's what this while loop is doing e in L is going to be either true or false whether you know the number you know five or whatever is in my list and as long as I still have a five in my list call l. remove on five or whatever it is okay so a nice little TW liner here to solve uh uh the same problem now what if we rewrote that code in a slightly different way again using remove but let's say maybe we didn't realize we could use a y Loop and instead we used a for Loop to iterate over each element in L and if that element is equal to e remove it right seems reasonable so what would happen and I can run it for you guys so if we run it with this code here this is this the one from the slides just to show you that I'm not making it up so if this is the code that we wrote I tried to remove the two from the list and when I printed the result it actually printed one comma two so I have two elements left in my list it looks like it didn't correctly remove a two okay and at first it's surprising why this is right because see the code seems to it looks right it seems to work just fine but let's step through sort of this memory diagram and see exactly what happens step by step so with each iteration of our for Loop so originally I've got L containing one two two two right so far so good that's just us doing this line here and then I make a function called to remove all so I want to remove the number two from my list um I've got a four Loop where my Loop variable is called LM and it will iterate through each element in my sequence right where my sequence is the list is all the elements in L so first it'll be one right then it'll be the next value in the sequence two and then two and then two right so here I've just got LM initialized to the first value in the sequence if LM equ equal e well the one does not equal the two so then we do not remove anything next the for Loop goes on to the next value in my sequence the two so now LM is two and if LM equal equal two it does equal two what am I going to do well I need to do l. remove e so this is where bad things happen I'm going to remove an element from my list right so I still have those three twos in there but as soon as I drop one of the twos all the elements beyond that two shift over but python doesn't know that it should also shift over the pointer right it's still pointing to that element that it's currently at it's not going to shift itself backward just because you removed an element and so python just finished removing the element and now it says I finished this Loop through so I need to go back up here and make element be the next value in my sequence the next two so I've essentially skipped over one thing that I needed to remove because when I removed the item everything else shifted over as well but my pointer didn't decrement okay so this is a big problem I mean we can finish off here but we've already seen you know we've already seen the problem um the last time through the loop python sees well is this two equal to the thing I want to remove it is so it removes it and this is the end it has no more values left to go through in the sequence because it's already its pointer is already out of the bounds okay is everyone okay with that issue okay so the problem here with remove is that we're iterating over a list as we're mutating it right and so removing these items can cause unpredictable Behavior something like this could still happen if we were adding items it's except that we're usually adding items to the end of the list right with a pend if we were adding items somewhere in the middle or somewhere around where our pointer is supposed to be I think we could theoretically run into the same issue when we're adding items where we might skip uh elements or we might see an element twice okay it's just more apparent when we're removing items okay so this is the big thing that we're going to talk about in this lecture so I'm going to go through another example this is tricky example number four where we're going to do a very similar thing but we're going to have a loop iterating over um L's elements directly just like we we did um but doing a different task just so we're not doing that same remove all task so let's look at a slightly different problem uh this will be in the context of of a function called remove duplicates this function will take in two lists so as an example here I've got a list with 10 20 30 and 40 in it and I've got another list with 10 20 50 and 60 in it the purpose of this function is to mutate L1 okay and the way I want to mutate L1 is such that if a if a v if an element in L1 is also in L2 I want to remove it right so the 10 and the 20 notice are common to L1 and L2 so I would like to remove the 10 and the 20 from L1 the 30 and the 40 stay because there's no 30 or 40 in L2 okay so that's our task and this is the code that supposedly does this so I've got a loop that goes through each element in a one so 10 then 20 then 30 then 40 and I ask if that element is in two so you know here they are there's two of them here then remove it from L1 very similar thing to what we just did this code doesn't work because if we actually run it the uh in the end python will mutate L1 to contain the 20 and the 30 and the 40 right whereas we only wanted to keep the 30 and the 40 right because the 20 also appeared in L2 so why in the world did we keep it well we kept it because of the same issue we just saw we're mutating a list as we're um iterating over it and we're doing a removal so we're again skipping over an element so let's just step through this one just to show you again what can happen so here I've got 10 20 30 40 for L1 and 10 20 50 60 for L2 in my Loop uh my variable is e so first it'll be 10 and we ask if 10 is in L2 that's true remove it from L1 so you can see what's going to happen my 10 is removed everything else shifts over by one but my Loop index is stays stays fixed okay next python says I'm going to increment my uh variable e to go to the next next item in my sequence so e becomes the 30 and already I've skipped over one element that I was interested in removing so here when we're pointing to the 30 python says well the 30 is not an L2 so we don't do anything and then it points to the 40 the 40 is not an L2 so we don't do anything and then the code is done and we've erroneously finished with uh mutating L1 to just be the 20 30 and the 40 okay so let's try to rewrite the code uh to actually work by using copies so we certainly could use the same trick we did previous uh we at the the first UT tried exercise where we could make a copy clear L1 and then add the elements back we could do that but we can also do a slightly different version of that where again we make a copy so here I've got L1 copy equals L1 square bracket colon and then the key thing here is we're iterating over the copy right so if we iterate over the copy we're not going to mutate the copy but we will mutate L1 so for the for Loop l uh variable goes over the copy but the removal is done from L1 so to visualize that this is what happens so I've got L1 and L2 as before so when I make my function call here I have L1 copy equals L1 Square back and colon so this makes for me a new variable inside memory which is an exact duplicate copy or a clone of L1 okay so every one of my elements is now saved so I can do whatever I'd like to L1 and know that I can still have a way to iterate and look at each variable from the original L1 so now my Loop variable e goes over elements in L1 copy so first we look at the 10 and I say if the 10 is in L2 it is remove it from L1 so notice I have just mutated L1 not the copy to be one element less then the loop variable e goes to the next value in my sequence so I'm not skipping anything here because I didn't mutate L1 copy so now we look at the 20 correctly this time right so now we ask is the 20 in L2 it is so we remove it from L1 and then the 30 and the 40 We Do Nothing questions about this is this okay is this too fast is this too slow oh good okay okay so that's using copies or AKA clones to help you keep track of uh values in an original list without overwriting them or without removing them accidentally now I want to talk about um aliases because this is a very important topic when we have these mutable data structures so let's do a quick um overview of what an alias is so if we think about a city for example Boston an alias for Boston is basically Any Other Name that refers to the same city right the same object so Boston uh also known as The Hub or beant toown or Athens of America all of these names refer to the same inherent City right so if I say Boston is small in Tech saavy then those two attributes or properties refer to this object itself right the city so the Hub is small and techsavvy or Beantown is small and techsavvy right it doesn't matter what I refer um what name I refer to this object as it's the same set of properties still apply to it and so if I add an attribute or if I take away an attribute through one of these aliases through one of these names well if it's suddenly snowing in Boston then yes it's snowing in the hub or it's snowing in Beantown right because these are just names for the same object and so that idea is also something that comes up when we deal with these mutable objects if you don't explicitly tell python you'd like to make a copy of a list and you just use the equal sign between a a mutable object and another name for this mutable object then python only creates an alias for that object okay so notice we had to say explicitly I want to make a copy with the square brackets colon if we write code that looks like this so here the only difference I've done uh so the code on the right is the one that worked the code on the left is me not making a copy of my L1 I'm only using the equal sign directly and in Python using this assignment operator the equal sign tells uh it means that you are Ma you are making an alias for that same object in memory so it's just another name to refer to that same object if you mutate that object through L1 L1 copy will also have been mutated because it's this it's pointing to the same object and vice versa so really this particular code on the left here is not any better than saying 4 e in L1 because L1 copy is pointing to the exact same object in memory okay so let me show you exactly what this means in the little Cloud diagram that we uh that we've been doing so this is the this is the code that creates an alias not a copy so I've got L1 equals 10 20 30 40 L2 is 10 20 50 60 just like before the code up here so L1 copy equal L1 I just named it copy but it's not actually making a copy right because I nowhere did I say explicitly to make a copy using the square brackets colon so the alias in memory means that it's just another name pointing to that exact same object okay so then the for Loop for en L1 copy is iterating through this object here which is being pointed to by L1 copy and L1 okay so if I'm iterating through and removing elements as I'm doing so this is just the original buggy code that we had that iterated through L1 right so I'm removing the 10 incrementing the element uh the E variable to the next element and then not doing anything with the 30 and not doing anything with the 40 does that make sense aliases is that all right okay so the big idea that will kind of tie a couple things together um is related to functions formal parameters and actual parameters so when we make a function definition right the things inside the uh the parameters inside the function definition are called formal parameters right we're just writing the function assuming that these will eventually get some actual values associated with them when we make a function call that's when we pass actual values and when we have mutable objects being passed into a function the formal parameter actually becomes an alias for the ACT for the actual parameter in the function call so here's our function once again the difference between what we've been seeing so far this is the code that we had just seen the difference that I've done in this particular code is not named this L1 and L2 like it was named up here right because it doesn't have to be named L1 and L2 I named it L A and lb and this will sort of bring the point home so when I make my function call to remove duplicates with L A and lb python takes this object and this object and passes them in as parameters so in my memory diagram I've got La is 1020 30 40 and lb 1020 5060 right that's what I have down here as soon as I make my function call remember python Maps out right formal parameters to actual parameters but when we're dealing with these mutable objects L1 and L2 are aliases for the things being passed in so L1 will point to you tell me yes exactly so here I've got the same name for the same object and L2 will point to lb right two different names pointing to the same object and that's why when I'm iterating through and doing whatever I am doing to these par these formal parameters here python actually mutates the object that were passed in yes uh LA and L1 will have the same IDs yeah yeah exactly yeah using that ID function we we did last time exactly I invite you to try it too but I think I think they should because they're modifying the same object everyone okay so far two two names aliases for that same object and so that's why when we're mutating L1 here this L and lb that we passed in will be mutated right so here's my L1 copy as well so I've got three names for this particular object and then we do the thing where we mutate the thing right and then at the end of the function when it's done this entire thing has no return it returns none but when we print La the thing we're printing is this object here it's like what it's whatever La points to and it's this thing that was mutated through L1 yes no thumbs up thumbs down is it good this is very cool you guys okay this was a nice loose end to tie up okay so the last 10 minutes I want to talk about what happens when we have lists that contain lists themselves right so you so far the examples we've been working with uh are lists that just contain you know strings or integers or things that are immutable but what exactly happens behind the scenes when we have elements that are mutable themselves so we're going to do uh an example we're going to go through in a lot of in all of these slides working through an example where we start out with this old list that looks something like this so we have a list that contains three elements right the first one is another list the second is another list and the third is another list right I don't care what elements those lists have for now all I know is at the top level old list contains three things okay so let's do um aliasing and then we'll do a shallow copy of this list and then we'll do a deep copy of this list and show you what happens so in this example what we're going to do is just a straight up Alias of old list so we're going to make old list and new list be aliases for the exact same object this thing here so I do that with just the uh plain old assignment operator so inside memory the way we're going to represent this old list is here is my list with three elements in it and because each element is itself a list so a mutable object I'm not going to plop it in here but in instead python generally tends to make a pointer to that mutable object somewhere else in memory you'll see why in a in a couple slides but for now I mean it will it would look cluttered if I did so but for now it helps to visualize the structure so old list contains three elements and each one of those elements are kind of pointed to over here so if I say new list equals old list python will make another name for the same thing in memory when I do this line here where I index new list at index two so that's 0 one two and then I follow it to index one over here right so this guy here the six I have changed Fu the string food to B6 and now new list and old list both are pointing to the same object so it will have been mutated to contain that six in that sub list okay so that's aliasing now what we can do is we can create copies of uh mutable objects and we can create create either something called a shallow copy or a deep copy the shallow copy is equivalent to what we've been doing with the square brackets colon and that's perfectly okay if we're dealing with uh lists that just contain immutable things but as soon as we create a shallow copy of a list that can contain other lists or other mutable things interesting things happen only the top level gets copied but anything that's mutable at a deeper level than that top level does not get copied okay because if it did and you had many many levels deep of all these mutable things that would be a lot of things for python to copy okay so what we're doing with this particular code is we're going to create this old list here so it's one two as first element 3 four as a second element and 5 six as the last element we're going to create something called a shallow copy and we could have also said old list square brackets colon it would be equivalent and in this shallow copy python only creates a copy of the top level so notice new list is pointing to a list with three elements in it but anything that's at a deeper level than that top level does not get copied okay so all these mutable things that are my elements this list and this list and this list these are three mutable uh elements they do not get their own copies because we've we've only made a shallow copy so what this means is at the top level sorry so this is just what it prints out so at the top level we can add elements to Old list and it won't interfere with the top level of new list so as an example here we're going to add this 78 list to Old list so we follow old list and we add another element to the end of it okay so there it is but that element didn't get added to new list right because we only added it to the top level of old list so now question is what happens if we go in and mutate one of these three shared items okay so old list and new list is as we would expect so let's do one more operation so instead of appending or in addition to appending the seven and the eight like we do over here let's also mutate one of those shared items so here it is this is what we just did on the previous slide there's my seven and eight and now let's go into Old list at index one so 01 that's this middle one here and add index one in that so that's 0 one the four over here let's change the four to the 9 okay well when we print new list we're going to be printing a list with three things in it the first one is the list one two the second one is 39 we just mutated that and the last one is 56 and when we print old list this one will also have that nine over there because those middle elements are shared but we will also have an extra element at the top level the 7 comma 8 that we just added only to Old list okay thoughts on this example what is confusing yeah yeah why does the nine get added or get changed through to the new list yeah so the operation called copy from this Library which is also named copy only creates a shallow copy of the list so a shallow copy means that if you have a list with some elements within it right so here in this case you know we have uh those three elements in it all you're doing is copying the top structure right so this structure here but if you have any elements that are themselves mutable they don't get get their own copies so really inside the memory if this one is pointing to some object like it does to that list one comma one comma 2 the copy is also going to point to that same sub object substructure and so if you're mutating this substructure through one name if you're accessing it through the other name that other name is still accessing the thing that was mutated does that make sense is that okay yeah and so this shallow copy is just copying the top structure here so you can see at the top level we have these two different lists so that means to this one I can add another item to the end of it right and that item will not be duplicated up here because this is one thing this is another thing but the middle ones or any levels that are beyond that top level are shared they're not copies Yeah question so if you edit it through the new list would it is it Mutual like it yes yes exactly great question so if you edit it if we edited uh this number one here through the new list then yeah the old list will still see the edits because they're both pointing to this uh to these these shared things but if I edit the seven and eight it will only be edited through old list because that 78 is only seen by old list okay that's basically what I've said here and so if you really really really want to copy every single mutable object or every single object at all the different levels we would have to create something called a deep copy so we do this using copy. deep copy okay and so this is exact same example except that we've just changed copy. copy to copy. deep copy and so here we've got our old list exactly as we had before and if we deep copy old list python will make copies of every single object at every single level in uh you know from from old list so everything becomes its own object so now if I mutate old list to pen seven and eight that only gets added to Old list and if I mutate old list to have this element be a nine that only gets mutated through old list so old list contains uh the changed values but new list remains untouched because I've made copies at every level yes so cop kind of like with yes but then it goes further down at every single level so the the regular copy. copy does the square bracket colon and the Deep copy goes further to all the other levels okay so lots of uh ideas uh in the this lecture and last I would highly suggest going through the python tutor and all these examples just so you see them in a kind of different way to see exactly how you know it'll be the same sort of memory diagram that but we've done except that you know through the python tutor so um it will be very helpful for you I think I I would give that a try as you're setting for the quiz I think what's important to realize is that we have objects uh in memory and we have names that point to these objects and so if you kind of get that and keep that straight in your um in your mind it will be very very helpful to understanding what's an alias what's a clone when you're iterating over certain objects um and things like that and the big idea here is just side effects okay every one of these opt operations has some sort of side effect and it's important to make sure that you're not changing something you don't want to be changing okay um I guess I just had one last thing to say about listed tuples I guess we've seen both of them when do you want to use tups and not lists when you want something that shouldn't be changed so if you have something that might accidentally get changed do not save it as a as a list if you okay and then on the other side it why would you use a a list but not a tupal you would use a list because um you don't want to be creating copies all the time so when you have again these large databases every time you want to make a change to it you don't want to make a copy of everything with that small change in it and so mutating an object is is Good from that respect okay so that wraps up lists and mutability next lecture we'll just tie up a bunch more loose ends and then we'll get into a new a new topic