all right so welcome to the first lecture of 6100 L that's our new number um my name is Anna Bell that's two separate names first name Hanah last name Belle super confusing but I've been a lecture here in the ECS department for probably almost 10 years now and I've been doing the intro course for a while I'm really happy to be teaching this full semester version of 6100a so um today what we're going to do is go over a little bit of course administrative information and then we'll Dive Right into just some thoughts about computers high level how they work and then we'll start going into some python Basics so we're going to get coding right away so I hi highly encourage you since you're in this class to download the lecture slides beforehand to take notes and uh run code when I do um some of the lectures are interactive so and and we'll have breaks so there'll be a a place where you uh can take a break to actually do some coding and that's important uh I call them utri breaks that's important to make sure that you're actually practicing what we are learning right at this time um the main idea for lectures is yes I will do some teaching but there will also be opportunities for questions and for uh you guys to try some programming right on the spot even if you don't finish writing a program that we start talking about I will finish it and we can all kind of talk about it together and I'll kind of show you some uh pitfalls and things like that um there will be lots of opportunities to practice in this class through at various degrees of granularity um and then there's also lots of opportunities um that I have in the handouts to do extra practice at home and through a bunch of different resources as well um the reason why I stress participation and practice is because part of the reason you're here is you want to learn how to program right you you don't know how to program yet and programming is actually a skill right it's like math or reading it's something that you have to practice you can't just watch me type in a bunch of lines of code and then when it comes time for to do the quiz you'll automatically know how to do it you need to do it often more and more so that it becomes sort of second nature right so the three big things you'll get out of this class are knowledge of Concepts obviously we're going to learn some computer science ideas programming skill and problem solving um problem solving skills lectures and exams basically uh help you with your knowledge of or test your knowledge of Concepts and help you get knowledge of Concepts finger exercises get uh uh give you the programming skills and the problem sets help you with problem solving basically if you're given an English version you know of a problem in English how do you go from that to thinking about what computer science Concepts can I apply and then after that how do I take those computer science Concepts and actually do the programming so what are some topics we'll be covering we will be at the core of it learning computational thinking so in the future when you encounter a problem you can uh your first thought be how do I kind of mathematically solve this or how do I brot force right manually solve this problem how can I apply computation to help me solve this problem and throughout these lectures you're going to see some examples of us applying computation to a problem you might have already seen and maybe solved uh mathematically um which is pretty cool um obviously to get to that we're going to learn the Python programming language once we get the basics we're going to see how we can start to uh structure our code to look a little bit better so we don't just have a bunch of code dumped on a on um in a file we're going to start to organize our code and see how we can um make it neat readable and modular and then towards the uh uh uh not in this lecture but in a couple lectures and as a theme throughout this uh this class we're going to look at some algorithms they're not super complicated but they're kind of the base algorithms for a bunch of algorithms you might see um in the future if you decide to take more CS classes um lastly towards the end of the class we're going to see algorithmic complexity which basically means we're going to start asking or trying to answer the question um how do we know the programs we write are efficient right we can write programs but how do we know that they're fast and how do we know that they don't you know take up all the memory in the computer so things like that um comparing different algorithms that do the same thing um against each other so if there's no questions again as I said a bunch of this information is already in the handout plus more we can begin okay so let's start by talking about knowledge um declarative knowledge is a statement of fact and a lot of us probably in math and in the past have worked with declarative knowledge but this is not how computer science this is not how this class Works um in computer science what we do is we we work with imperative knowledge which is basically a recipe how to do something and when we're programming all we're doing is writing a recipe for the computer to do something that's it so here's a numerical example um the first statement is a declarative uh statement right uh the square root of a number X is y such that y * Y is equal to X there are many possible values for X and Y that this statement can be true right but if we gave that statement to a computer it wouldn't know what to do with it what we need to do is tell the computer how to find the square root of a number and then tell us what the square root of that number is and so the computer then needs a recipe um so the recipe a really simple one for finding the square root of a number is steps 1 two 3 so what we do is let's say we want to find the square root of 16 it we obviously know it's four but the computer doesn't and so we give it an initial guess let's say the guess is three how do we go from there so the steps we follow step one if um 3 * 3 9 is close enough to 16 we can stop it's not really close enough for me so let's keep going step two otherwise so we're going to make a new guess by averaging G which is our original guess three and X over G which is 16 over 3 right 16 was the square root we wanted to find so our next guess is 4.17 okay using the new new guess repeat the process until we are close enough so we go back to step one that's the first part of the process we find guess squared 4.17 squar is 17.36% and 16 divid 4.17 right that gives us our new guess 4.35 okay next step right using the new guess we repeat the process so 4.35 squar is 0277 is that close enough to X yeah I could be happy with this I could stop there because we're within sort of plusus one so I'm I'm okay with that but if we wanted to be within plus or minus one time 10 the negative like six or seven or something like that then we would continue the process so really what we had there is an algorithm right it's a sequence of steps step one step two step three there's some sort of flow of control right we had uh a place where we said if this is you know if if the guest is close enough then you know we can stop otherwise we do something else we had another uh flow of control where we said repeat this thing right so we're kind of not going linearly but we're changing the flow and then lastly is a way to stop right we don't want the algorithm to go on forever we would like to stop at some point and the stopping point I was kind of vague about it but it could be you know when we were within plus or minus one of the actual uh answer and so right recipes are basically algorithms right my grandmother was basically teaching algorithms when she would teach me to like to to to bake a cake right she didn't call it that but she was really um and so even um recipes have that same structure there's a sequence of steps there's a flow of control like if you don't have egg use egg substitute or repeat this um you know repeat sticking a toothpick to see if it comes out clean every minute or something like that and then there's a mean a way to stop right when the toothpick comes out clean you take it out of the oven and you eat it and so computers are machines that execute these algorithms they're actually dumb right computers are not very smart they don't make decisions on their own they just follow these sequences of steps that we told to do computers are good at storing lots and lots of data right we can't really do that but computers can store um gigabytes of storage terabytes even and computers can do operations really really quickly which is something we can't do right they're good at those two things but they're not very smart they can't make decisions unless they're told to make the decisions um so really the computer only does what you tell it to do and that's one of the big ideas that I want you to come away uh from this from this lecture with computer only does what you tell it to do right the sequences of steps that you tell it to do that's the only thing it follows so a little brief history just to kind of make you appreciate uh programming Python programming language before we actually get started with it is um so before the 1940s we had these things called fixed program computers okay like a pocket calculator is an example of that every button was an operation you could you know in the little screen you could use parentheses to put a bunch of different operations together but there was no way to sort of store all these operations together to um to you know later put in different inputs for that same sequence of operations you had to input it every single input those sequences of operations every single time um after the 1940s stored programs computer uh computers came into play and they were able to store instructions to do things as data okay and there was a special program called an interpreter that executed these instructions it knew how to follow simple sequences of steps when the program told it to go to a different location it did so it was it was basically executing these instructions and um the instructions that it it did were um arithmetic and logical so addition subtraction things like that simple tests like checking for equality between two values and moving data so taking this value and putting it at a different memory location so I just wanted to give you a really brief overview and this is not super accurate but it gives you a sense of how exactly things happen um lowlevel um in uh in the computer so the computer basically has memory where things are stored it has an arithmetic logic unit that does operations it knows how to add things subtract things multiply things compare things and then it has the control unit where this program counter is um is set and this is where you put a program in so see how this works um this is a program and up here is our memory so we have a bunch of memory locations 3 4 5 6 3 4 5 7 and at each of these memory locations we have some values stored pre you know pre-filled so when we first run this program what ends up happening is the um The Interpreter sees the first instruction add the values at 3456 and 3457 together so it goes to these memory locations here grabs the three and the four and sends them to the arithmetic logic unit the ALU knows how to do the addition so it adds 3 + 4 seven and sends the result back here now we never told it to store that result anywhere but the next instruction says store the value you just got back from the ALU at this memory location 34 58 so the next step basically takes that 34 uh that seven and stores it at memory location 3458 super tedious all we did was add 3 + 4 we do that again uh we add 7 the values at 7889 and 7890 so it goes in the memory it grabs the five and the two sends it to the ALU the ALU calculates it as seven brings it back and then we store that in location 7891 okay and then after that all we've done is two additions um and then the next instruction says compare the values at memory locations 3458 and 78 91 so we're going to compare the seven with the seven the ALU again does this comparison and says all right well seven and seven are equivalent so this is you know true or whatever it wants to give give back to the um to The Interpreter and then the last instruction here we have is print the result of that comparison so we print true because they were equal right again super high level but it kind of gives you an appreciation for um programming languages these days right this is very tedious to write if we had to write programs in in this manner um Alan Turing a long time ago showed that you can compute anything with actually a very an even more basic set of Primitives not addition subtraction but instead with a tape you would actually have six Primitives move the tape left move the tape right read the value at the tape put a value on the tape um erase the value from the tape and no operation and so since he showed this what the result of it actually was um is down here anything computable in one language is computable in any other programming language so if we had some you know some program written in Java that basically boils down to right something super long but something that is made up of these six Primitives that means that if we've boiled down this program to these six Primitives we can build back up the same program in a completely different language and that's really powerful that's a really cool statement now we're not going to be working with those Primitives um we're going to be using the python Primitives which uh are more convenient and they allow us to do a lot more things in much less time I'm going to do a little comparison as we talked talk about The Primitives of python with English so in English some of the Primitives might be um words or even we can do letters or characters but you know we can we can say it's words um you know with characters we can build up words with words we can build up sentences with sentences we can build up stories with stories we can build up books and things like that in programming um in programming languages The Primitives are numbers um sequences of characters uh operat like addition multiplication division um uh checking for equality checking that something is greater than things like that so once we have these Primitives in a language we can start to build up the syntax of the language so in English having something like noun and noun noun doesn't make any sense right cat dog boy doesn't make much sense it's not syntactically valid but noun verb noun is tactically valid right similarly in programming languages we can have two objects kind of side by side so here this is a sequence of characters H and I and this is the number five right beside that sequence of characters but that doesn't make any sense right what does it mean to have this sequence of characters and that number right beside it it has no meaning in Python instead what we have to do is we have to add an operator in between these two objects so here we add a little star operator in between the sequence of characters High and the number five and in Python the meaning to this is I want to repeat the sequence of characters High hi five times so this would basically give me high high high high high so once we have um sentences in English right and and and uh Expressions that are syntactically valid we can now talk about the static semantics of the language so in English saying something like I are hungry is is syntactic Ally correct but it's not synta uh static it's not sorry it's not it doesn't have uh good static semantics right there's no meaning uh there's no meaning to that because the r is for you know you or plural similarly in programming languages and this will differ depending on what programming language you use um here you know in the previous slide we saw that you can use the star operator between the uh the the sequence of characters and the number and that meant repeat that um that sequence many times but if we use a plus operator in between the sequence of characters and a number that doesn't have uh any meaning in Python so it has a static semantic error even though it's syntactically valid right we have operator uh sorry uh object operator object so so far we've been able to find really nice parallels with English right uh the English language and the programming language but this is kind of where things break down when we talk about the semantics of a language so in English you can have many different meanings right the chicken is ready to eat means let's eat this chicken um or the chicken is ready to eat means the chicken wants to eat something right programming languages there is no multiple meanings to a program that you write because the pro because the computer the machine the language follows the set of instructions to a te there's 's no ambiguity about what it needs to do right it just follows the instructions and does what it needs to do to the end till it reaches um you know the it terminates the program and so programs only have one meaning but the problem is it might not be the meaning that you intended it to have and that's when things start to go wrong we can have syntactic errors in our program spelling errors and indentation errors things like that and those are easy to catch static semantic eror are 90% probably easy to catch but the problem comes in with the semantics right the meaning that you intended this program to have might not be what it's actually doing and that's where most of my errors happen and that's where I get super frustrated when I program and that's probably where you guys will get super frustrated too because you write a program that you think is doing one thing but instead either it crashes right away or runs forever and doesn't really stop or it terminates but it gives you an incorrect answer it's not what you expecting and we're we'll talk about this um in a in in a few uh a few lectures so when we write programs we're basically writing sequences of definitions and commands and we're going to write these either in a file editor or in a shell the first today at least we're writing in the shell directly and half of Tomorrow will write in the Shell um because we're not really writing any uh we're not really uh really writing many lines of code um we're just going to be I'm just going to be showing you some really quick um uh quick things that we can do with the Python programming language so hopefully you all have installed the programming environment um this is the code editor so tomorrow we'll start working in here but for today we're really just going to work on in the shell and even in the future um you can still type commands in the Shell I find the shell very useful if there's just something really quick that I want to check that I don't want to write a you know write a program for and then run it's just like a simple command that I want to check to make sure it's doing what I think it's doing before I insert it in my code editor um so here we [Music] have this right so mine is uh I guess I'm using the White theme just because I find it easier for you guys to see um this is the file editor um and this is just a bunch of Expressions uh yeah a bunch of code that we're going to type in today and we're going to type it in the Shell today so the thing on the right hand side okay so what exactly do we do when we write a program at the base of it we are going to create objects inside our programs and we're going to manipulate them that's it that's what programming is mostly about um as it's at its core now when we create objects it's important this is kind of something we're going to come back to again and again in a kind of more High Lev setting but right now what I want you to understand is that when we create an object an object has a type okay and the type that an object has tells python the things you're allowed to do with that object so here are two examples the number 30 it's a number um the type we we'll talk about it in a bit the type is an integer it's a whole number but basically what are the things we can do with this integer with this number we can add it to another number we can subtract it to another number we can take it to another power we can take some other number to this power of 30 right a bunch of sort of mathematical operations as you would expect so that's pretty straightforward what about this one here this quotation um capital a lower case a lowercase n lowercase a quotation so this is something we'll talk about next lecture it's called a string and it's a sequence of characters the quotations tell python it's a sequence of characters and the characters part of it are capital a lowercase n lower case a the kinds of things I can do with this string are not the same kinds of things I'm allowed to do with a number right if I tried to take um Anna and divide it by the sequence of characters Bob uh python would complain very much right because you can't divide a string by another string a sequence of characters doesn't make sense to divide it by another sequence of characters similarly I can't take Anna to some power right I can't multiply uh or I can't multiply by itself things like that but the kinds of things that I am allowed to do on a sequence of characters is different than the kinds of things I'm allowed to do on a number so the things I can do with a sequence of characters is I can say well what's the character at the first position what's the middle character how long is the sequence of characters right how many characters do I have and so now you can see that the the type of the object is actually really important python uses it to to know the kinds of operations you're allowed to do with it and so there's actually um scalar objects and these are Python's Primitives um numbers and truth values and there are non-scalar objects we're not talking about these yet we'll talk about these in a few lectures but um these have some sort of structure so for example a list of numbers has a structure because there's a number at the uh beginning of the list there's a number at the end of the list things like that but a number itself doesn't have a structure it's just the number so what are the types of the scalar objects what are the types of The Primitives in Python integers so number five Z negative 100 a million float is another type it represents all the real numbers so three you know 3.27 2.0 is a float because it has a decimal number even though to us that just means two but to python if you put in 2.0 it says that's a type float negative 3.14159 things like that bull is a Boolean it represents truth values and there's only two possible values that a Boolean type has um true and false and it has to be capital T true and capital T oh sorry capital F false and the last one is this uh nun type uh uh type it's literally called nun type and it has only one special value none we're not going to talk about it for a bit but we will sometime in the future so to figure out the type of an object when you create that object you um you use the type command so we can say something like type parentheses and this is a command and inside the parentheses you say what do you want to find the type of so if we do type of seven it tells me it's an INT um and if you want to do the same command again I hit the up arrow and it automatically puts in what I wrote previously and then if I want to do type of 0.0 it's a float because there's a decimal point right um so this is basically what I said so we type this in the Shell um and uh the shell tells us what uh the output is so just to reiterate int float bu and nontype are types of objects and there can be many different objects you can create of that type right so if you think about it ins and floats we basically have an infinite number of objects we can create of those types right because we can have zero 1 two three 100 200 300 a million right there's and all the negatives there's almost you know infinite number of values uh objects that we can create of type intern float but bu there's only two the truth values true or false and the non type there's only one this none right so that's the type and these are the possible values possible objects we can create you try it so you can just yell out the answers uh there's nothing to type unless you want to check yourself so what is the type of 1,234 int type of 8.99 float type of 9.0 type of true bu and type of false bu perfect if you ever wonder what the type of something is you type it in here just you guys are doing well type is Bull type of lowercase T true is an error just wanted to point that out just to reiterate the fact that capitalization matters in Python this is our first error by the way guys very exciting um the error is a name error and this is the um messages associated with it um you also know that uh it's something special in Python when you have colorcoded stuff so you see capital T true capital F false are uh this dark blue here right whereas anything that's not um spe special in Python is just black right so type is a special Command right this is a float so you see that they're colorcoded okay so once um we create objects one thing we can do with these objects is to cast them to a different type now this is a little bit um maybe confusing because we're not actually changing the object once we've created it so once we create the integer three it's there in memory if we cast that integer to a float version of it we're creating a new object in memory we're not changing the three the three already exists we're just getting the float version of it and storing it as a new object in memory so when we do float three this is a command that gets for me the float version of the integer three okay so that will give me 3.0 so for example um right this is what I had float three right the output is 3.0 if I do int of 5.2 it truncates it and it gives me the integer portion of this float if I do int of 5.9 it still truncates it and gives me the integer version of this float it doesn't round right I'm just asking for the integer version of this of this of this float some operations like round is an operation we can do um has an implicit cast in it so if I round 5.9 it's actually going to round it to 6.0 and then cast it to an integer so notice it doesn't give me as an output put 6.0 it then rounds it to just six okay um so that's basically what I said um in the example so let's have you try this um what are the types of the following I don't need the values but the types so if I get type of float of 123 what is the type of that float yeah exactly yep I'm yep what it what if I round 7.9 what's the type of the result int yep what if I create a float of the round of 7.2 yes good uh float would be 7.0 and the int of 7.2 int yes exactly I want the type not the value and the int of 7.9 is an INT exactly awesome good Okay so we've created a bunch of objects right we we know that we can create a bunch of objects in our programs what do we do with them well we can combine them into Expressions so let's say we have 3 + 2 I've got object operator object cool syntactically valid in Python and has no static semantic error so if I do that in Python it's going to be okay 3 + 2 5 and the type of 3 + 2 is an integer right so basically what I've done here I've put an expression within this type um command and that's okay right that's in fact encouraged in Python you don't just want to calculate and then stick in um that would be very very tedious so you can insert expressions in many many different places right so here we have 3 + 2 5 divid 3 again we've got you know 5 divided 3 has this decimal value and the result has a float has of type is of type float so the important thing to remember when we're doing Expressions is python reads the expression but it does not store the expression in memory okay what it does is it reads the expression evaluates it to one single value and then it stores the result value in memory so it never stores the expression it evaluates the expression and then stores the value okay and so this is the Syntax for an expression object operator object as we just um just saw and that's really and the idea I said before right where python stores uh values of Expressions not the Expressions them themselves is really really important right so this is my first big idea slide um I decided to insert these because I think they kind of stress the importance of several Concepts so I hope this is one um so you know we're taking Express Expressions they can be as complex as you'd like we can use parentheses you know a bunch of it can doesn't just have to be operator uh object operator object it can be more complex than that but basically however complex that expression is we evaluate it and we replace it with one value and the expression can be something like this it doesn't just have to be something that's mathematical right this was a mathematical expression but this is also an expression and it evaluates so this entire thing evaluates to this uh word you know this word which represents the type integer so here's some more examples um 3 plus 2 again um we got uh we've got these uh examples with the parentheses 4 plus 2 * 6 - 1 obviously gives us the number 35 and then we can insert Expressions wherever we'd like so here I'm inserting that specific expression in the type command and this is also an expression like I just said and its result is int okay and similarly we can also insert that expression here and then we can wrap that around cast and it gives us a flow yes when you're inserting Expressions the operator when you're inserting sorry when you're inserting what well since you said their expressions and you said that you need like uh object operator object expression typ in this Cas oh I see um how are they def yeah that's a good that's a good question um so in this particular case the type and the float are not uh there is no operator I guess in this particular case it's more like a command that gives us an output but there is still some there is there is still an output that that it gives us so we can then take the result of this and save it somewhere else sorry yeah I guess the the example I gave on the previous slide was just an example of an expression where we could do object operator object yeah um okay yeah so when we have these uh I guess it works for mathematical Expressions uh mathematical Expressions work left to right just like in math parentheses can override uh certain uh uh precedence um if we have commands that have computations then we have this command with the parentheses and we evaluate what's inside the parenthesis first so we work our way in to out in that particular case um so here's some examples let's have you try these so we can type these in our console uh what are the values of the following Expressions so 13 - 4 / 12 * 12 so we can try that um I don't know off the top of my head so we'll have to type it in 0625 okay so the value of that expression is a float right 0625 what's the value of the expression type four time 3 int yep what about the type of the uh expression 4.0 * 3 yes exactly that's very good so the type of 4 * 3 is int but 4.0 * 3 is a float good and then what about int of a half or of one over two yeah exactly it's zero yep because it's 0.5 and we truncate to zero the reason I had this here is because it leads nicely into this slide you don't have to memorize these rules you can always check it out in the console but there are some rules for the resulting types when we do operations so um when we uh do operations with numbers addition subtraction and multiplication um always yield an integer if both of the operators are integers if one is a float or both are floats then it gives me a float division is different no matter what uh types you divide you'll always get a float okay now what about this slash slash and this percent these are actually useful operations they kind of go hand inand with division so when I do five divided three it's this 1. 667 slash slash is basically a floor or you know getting the integer portion of the division so five sl3 gives me one right it truncates the um the the the fraction the percent gives me the remainder so 5% 3 gives me the remainder when I divide 5 by three so it's going to give me give it to me in a whole number right so that's going to be two because there's two left over when I divide five by three so these are pretty useful operations um the the slash slash and the percent when when we do sort of mathematical programs the last thing is the star star is how we denote um Power exponentiation kind of different than uh than you might be used to in math so 2 to the^ of 3 8 right 2 to the^ 3.0 8.0 and the rules for um integer uh integer division percent and exponentiation are just like addition subtraction multiplication if one is a float then the result will be a float as well okay um yeah okay and we talked about the type of output uh so I think I briefly mentioned this uh the operator precedence is exponentiation and then multiplication division percent remainder uh at the next level and then addition subtraction at the bottom but you can always override these using parenthesis okay question so far before we move on yes so why division why does it always result like like 9 by and that's why yeah so the question is why does it always uh result in a float if it didn't I think it would uh the operation itself would have to do extra work to figure out whether it's a whole number or not so I think it's just easier that it gives us always a float um I guess uh previous versions of python the slash was actually I think integer division which is super counterintuitive because you would use that in your program and then you would basically integer divide and things would go wrong but again I just a design Choice uh on behalf of the programmers yeah other questions so far okay so we have a lot of objects right objects have different types again floats integers booleans what can we do with them right so far they're kind of just sitting in there and we can get properties about them but what we'd like to do is write programs basically trying to automate some things about these objects manipulate them to help us uh achieve you know a more complicated and interesting program so what we can do to uh to get to that to that end is to start assigning names to some of these objects okay if I create an object for uh for PI right in my program to 20 decimal places somehow and I have that number in my program that float in my program if I want to use that number in many different places in my program I'd have to copy and paste it a whole bunch of times right so far which is very tedious lots of Errors will happen right I don't want to do that so instead what I can do is I can give a name to this ridiculously long value of pi called PI right and then I can just use this name anywhere I want to grab that ridiculously long value for pi in my program it's a lot easier to read right it's a lot easier for me to write this program and you know it it it leads to a really nice um uh and neat program so what we can do is we can start saying that you know the float 001 will be uh referenced by the name small or uh you know the the 100.4 will be referenced by the name temp so what we want to do is create these things called variables and a variable is different in computer science uh uh from a mathematical variable or variables that you've known so far in math so math variables come back to the idea of declarative knowledge right a declarative statement you can have something like a plus b is equal to B minus one in math right or X is equal to or x x x is equal to Y and that's perfectly okay right in math we basically say that variable X represents all the square roots of y That's not going to fly in computer science computer science we don't have right we don't do declarative knowledge we do imperative knowledge and so what we're working with in computer science is a bunch of assignment statements so what we can do in computer science is we're going to basically bind a value to a variable so we're going to say this variable name is bound to this value every time I want to grab this value I'm going to invoke this variable name so here are some examples examples I've got a is equal to B + 1 the thing on the right hand side will evaluate to some value as long as I have something that b uh you know B has a value for I've got here m is equal to 10 right so m is a variable its value is 10 I've got f is equal to M * 9.98 so again I have an expression on the right hand side and that's okay I'm going to use the value of 10 so F's value will be 99 9.8 yeah can you put it so that like like for is it like this one value of M or can you have it like it's going to be whatever M sign recently or like yeah the question is can you have m whatever it recently is so in this particular case I just have these two lines and M will be whatever 10 is but we'll see in a couple lectures that we can write like a loop where you change M and then every time you change M you read immediately calculate F and then it'll calculate F based on the new value of M but if we just have these two lines that's that's all there is um it just uses 10 was there another question okay so in computer science variable you have only one variable to the left of this equal sign called the assignment operator and you have a value to the right hand side of the equal sign the assignment operator okay so one variable basically maps to or binds to one value so the equal sign is an assignment statement it's not equality it's not a solve for x type of situation it's just an assignment it binds this name to this value so the way that we figure out uh the name uh with the value is well if we have this assignment statement here we first look at the right hand side so we always start with the right hand side and we evaluate it remember we have an expression on the right we have to evaluate it to one value so this will be 3.14 whatever it is 1.1 59 and then we take that value and bind it to the name Pi so anytime I type in Pi Pi in my program from now on python will automatically grab 3.14159 from memory right so it's bound to that value now okay there are some rules did I have them on the previous one yes there are uh some rules to um variable names um but we'll talk about that in a bit for now I want you to tell me if any of the following are allowed if I do X is equal to 6 is that allowed in Python yes it is good because I have one variable name B to one value six what about 6 equals x it's just backward okay good 6al X is bad syntax error how about x * y = 3 + 4 four nope exactly because the thing on the left has an operator in it and operators are special right so it can't have you can't have a variable with that star as a name how about XY equal 3 + 4 allowed yes exactly I was hoping to get you guys with that but I didn't XY = 3 + 4 is okay there was no error and then I can invoke the name of the uh variable I just created simply by typing it in so if I type in XY it gives me seven right and then I can do operations with it XY + 1 is eight right yeah before you were putting the Str with a so those are strings right sequences of characters here these are variables so these are names that I uh I'm giving to uh as a variable yeah that's a great question so this is going to be a string and you notice it it changed color right it has some meaning in Python um but but XY is a variable that I I create yeah okay so why do we want to give uh names to variables because as I showed you with a pi example it's a lot easier to uh write code write readable code if you have variable names within uh within your programs so when you uh grab uh when you write programs it's important to choose variable names wisely you don't want to use just single letters you don't want to name it something that doesn't have something to do with the program you're writing um because you're going to want to reread um these programs sometime in the future or others might want to read your programs sometime in the future so here's an example of a nice program it's just basically four assignment statements that do some calculations the first line of the program is not really a line it's called a comment um you can have as many of these as you like they start with a hat hash it's a line that starts with a hash and it's uh basically uh text that you write that helps you or others figure out what the code is supposed to do and usually we comment sort of large chunks of code at a time not line by line um then we have these four equal uh four assignment statements so here I'm defining variable named Pi bound to the value here so not the division but 3.14159 variable named radius bound to this float 2.2 and then I have a variable named area which is bound to the result of this expression okay so when python sees my pi and my radius it grabs them from memory replaces them with the values evaluates the expression grabs that one value that that we evaluated to 15 point something whatever this is and binds the 15 something to the name area same with circumference code style is something that we're actually going to look at in your problem sets so I just wanted to quickly talk about that here is a program that has really bad style actually that shouldn't be me it should be you know terrible or something like that but it's in case you haven't noticed it's the same program as on the previous slide but if I gave you this program straight off the bat you probably wouldn't know what it's doing it's reusing 355 over 1 13 twice here it's using Just A and C as variable names it's description is do calculations so pretty bad this is a little bit better I've recognized that 355 over 113 is being used twice so I'm saving it as a variable but my uh variables are still single characters and my comments are pretty bad I'm basically saying what the code is doing please don't do that um we can see that a equals P * R * R right I see that I'm multiplying p with r 2qu i don't need to read that in English right what I would like to see is a comment like this here I'm commenting you know a chunk of code and someone who doesn't want to read this chunk of code just reads the comment and I already know that I'm calculating the area in circumference using an approximation for pi that's a pretty nice uh comment there and good descriptive names and all that so we can actually once we create an object a variable sorry once we create an object and bind it to a variable we can change the bindings so we can take that variable name and bind it to a completely different value this might not be sort of useful right now but it will be useful when we uh introduce control flow in our programs so to rebind a variable what that means is we're going to take the name we're going to lose the binding to the previous value and we're going to rebind it to a new value so I'm going to show you how this looks like in memory um I'm going to use this sort of cloud picture to represent uh what happens behind the scenes whenever we write programs and it's uh like a little animation to help you understand line by line what's going on so here we have pi equal 3.14 so the green 3 14 is my value in memory cloud is memory that's my value in memory and it's bound to this name Pi so this is my variable name the next line radius equals 2.2 same thing I've got 2.2 as my value in memory my object and radius is the name for that object area equals Pi * radius squ so what happens uh behind the scenes is it calculates this value right it doesn't store the expression it stores the value resulting from the calculation and then it saves it uh or binds it to the name area okay everything okay so far we've seen this code before cool so now what happens when we do this radius equals radius plus one in math that would say 0 equals 1 but we're not in math here right we're in computer science and this is perfectly valid we're following the rule right when we have an assignment that says look at the right hand side first and evaluate it and then bind it to the left hand side so if we look at the right hand side first right we see radius well what's the value 2.2 we see add one to it 3.2 save that in memory and then we see the assignment now save it with the name radius okay so we can only have one variable assigned to one value at a time right this is not math this is computer science so you can only have radius point to one thing at a time with this line of code radius equals radius + one we've lost the binding to 2.2 this object in memory and we've rebound it to the value 3.2 okay and that's perfectly fine 2.2 is now just sitting in memory we can't get back to it unless we say maybe radius equals 2.2 it just sits in memory and then you might be collected later on by or reclaimed by garbage collection or something like that but for now we can't get back to it now what's the value for area at the end of these lines well according to this it's 15.1 1976 so it's using the old 2.2 value for radius and that's okay because the program never told uh never had a line that said recal calculate area after we change the radius right it's just following dumb line by line right it doesn't know that hey if I change the radius the user might want the area changed right it doesn't make those connections it's just following instructions and that's okay if we wanted to change the area we would have to copy this line and paste it after we've changed the radius and then the area would change as well okay does that make sense that's kind of an important part of this lecture Okay cool so big idea here is our lines are evaluated one after the other we're not skipping we're not repeating things that's something we're going to learn about later um but for now line by line so here's a little UT Tri it um these three lines are executed in order what are the values for U meters and feet variables at each line so how about at the first line what's the value for meters after after we execute the first line 100 what about feet so feet at at the end of the first line there is no value for feet yet how about after the second line 3 28.8 right how about the value for meters 100 still and what about after the third line I'm changing meters to 200 exactly yeah meters is 200 but feet is still 328 point 08 and this is something I want to show you guys today and we're going to use this python tutor a lot more in the future python tutor is a nice website that allows you to step in your code step through your code step by step so at each line that you execute you get to see the values of all the variables in the code a very useful debugging tool I hope you'll try it out today and uh on Monday maybe for the finger exercises if you're if you're having trouble and you know you can use it for quizzes uh to help you debug but we can I can just show you it's pretty simple uh here because it's just a step by step so we step through so the red says the line I'm going to execute green is the line I just executed so I just executed meters 100 so here I have my meters variable with the value 100 step through next so I just executed feed equals this so I now have a variable named feat with an a value 3 28.8 meters still 100 and then meters 200 feet remained okay so obviously this is a pretty simple program to run the python tutor on but you can imagine using it um in uh um in more complex settings how about one more and this is my last example I want you to try to write a program that swaps the values of X and Y so originally and I'll draw this the memory diagram real quick so we have this is our memory we have X is bound to one y is bound to two and what I want to do without saying xal 2 yal 1 what I want to do is swap the values I want X to be associated with two and Y to be associated with one but only using commands like this right and so the code here is buggy that means it's wrong it has an error in it because well let's step through let's step through a little bit at a time yals x what do I do when uh Y equals X here yeah exactly Y is going to move from two to one now what happens when I do x equals y yes X stays the same my first line yal X lost The Binding to two right and now it's all messed up because I can't get it back so instead so if you didn't understand this you can click python tutor and just kind of Step through step by step on your own but how can we fix this create a third variable yeah that's a great idea yeah we can create a third variable so X is one y is one uh Y is two so we can create a third variable what do you want to make the variable equal to X or Y y yeah either one um I made it y so let's do y um so here I've got a temporary variable called temp and I made it equal to two and now what can I do which one can I reassign now x equals y or Y equals X exactly y equals if I do xals y I lose my binding to one and I'm I it messed up again so yals X is okay to do so I'm going to lose the binding from y from Two and bind it up to one and now what do I do yeah now I can safely reassign X to Temp right so I can say x is equal to Temp because temp points to two and I want to make X point to two as well so in terms of code so that's sort of the diagram but um you know we can write the code so don't uh let's see um we don't write it in here but you know on on your own or uh you can write it in here if You' like or we can do it together so X is equal oops x = 1 Y = 2 right um and then we can have we had temp we wanted to assign it to whatever y was right so we say temp is equal to Y and if you want to check the values of the variables you can just invoke the names right so X is 1 Y is 2 and temp should be whatever Y is 2 okay good so far so now I'm at the step here I think right I've just created this and then the last thing I need to do is lose the binding from X to whatever temp is right so I want to do this operation here which means I want to assign X to be equal to Temp right so now X is 2 Y is one what did I do yeah let's so this happens sometimes we can just start all over right so y equals temp or sorry sorry temp equals y y equals x y is One X is one and then x equals temp Y is 1 X is 2 okay so it's okay if things go wrong um they will go wrong we can just start all over in this particular case by redefining our variables and just trying it out all over again so that's kind of what the shell is for that's what I use it for that's what we're going to use it for in the future um just to do quick things like this um you know and also things like checking the types and uh and other commands we've done uh earlier okay so any questions before we do the summary was this all right pace or was it too fast or it's okay okay cool thumbs up is good so let's do a quick summary um we saw that we can create uh programs by manipulating objects we created objects in Python and we saw that objects have a particular type the type that the object has tells python the things that you can do with that object object right um we can combine objects in expressions and these Expressions evaluate or boil down to one particular value objects or values can be stored in variables and these variables allow us to access these values with nicer names later on in our program and to and then we're able to write neater more uh legible uh programs as well right so the equal sign I showed you a couple of differences between uh math and computer science the equal sign was one notable difference right the equal sign in in math is declarative and the equal sign in computer science is an assignment you're basically saying this is associated with this right and we're not doing any sort of equality in computer science um and yes computers do what you tell them to do that's kind of the big the big thing here right line by line it executes starting from the top goes line by line so far we haven't seen any places where we uh where the computer makes a decision but next lecture we will see how we can insert decision points in our programs um for for the computer to you know either execute one set of code or another set of code all right so that's the end of today's lecture thank you all for joining I will see you on Monday