okay so let's get started um today's lecture we're going to do a little bit of a recap of the last lecture uh we had begun talking about binary numbers and then we're going to dive into our second algorithm of the class then approx the approximation method algorithm so let's remember the motivation we had for even talking about binary numbers and how numbers are represented in the computer in the first place and the motivation was this piece of code so it's very simple we have an initial X is zero and then we have a loop that just adds 0.1 to itself 10 times and then we printed whether that sum equals one and what we saw was that it was false false printing X equivalent to one was false so then we printed what the actual value of x was after adding point1 to itself many uh 10 times and we saw that that summation was actually 9999999 and of course to python 9999 is not equal to one so that's why we had printed uh false for X equivalent to one right that that expression and so this is our motivation why in the world does this happen in uh in programming and Python and something like this could really screw us up right if we're not even able to compare floating Point numbers so last lecture we ended with this piece of code um it was a way for us to uh to uh get the binary representation of a number in base 10 right so given some number we followed a really simple recipe a really simple algorithm to convert that number into base two the stuff that's in Bo in boxes let's not wor about it for now but let's look at just this part right here so the stuff that's in between the two boxes and this is the part that does most of the work for us or all of the work even for us it basically creates a string uh initially empty and the idea was that we were going to prepend um either zero or one to that string depending on whether the number we had was odd or even so for a number like 19 if we wanted to convert 19 base 10 into base 2 what the algorithm was doing is over here in the loop it says while the num this num whatever it is initially 19 is still greater than zero let's get the remainder when we divide the number by two so that's what this num percent two is doing it's either getting a zero or one so 19 the remainder when we divide 19 by two is one and we're going to pre pend so we're casting this one integer to a string and prepending it to this result which is initially empty so that's what this line is doing result equals this thing here and then we're going to take our number and integer divide it by two so we're going to take the number 19 and divide it by two right so that's going to be 9.5 but we're only interested in the integer portion of it so nine and then the loop does the check again is 9 still greater than Z Z it is so then we're going to say what's the remainder when we divide 9 by two it's another one so we're going to prepend it that remainder to the string that we're building up okay and again we're going to divide this number by two so now we have 4.5 when we only grab the integer portion of it four and again we ask what is the remainder when we divide 4 by two it's a zero so we prepend the zero to our uh sort of this binary string we're building up again we divide it by two it's a two the remainder when we divide two by two is zero it's an even number again we divide two by two it's a one and the remainder we get when we divide one by uh uh or sorry and yeah when we divide one by two is a one and so this is the string that we had eventually sort of systematically right iteratively built up with this Loop here and num after we divide this is going to be zero and then we break out of the loop right so the binary representation of 19 was 1 0011 base two we just kept it in a as a string the parts that are in red boxes is US dealing with uh in case with a negative number so if the user wanted to convert negative 19 to a binary representation this if else up here says is the number number less than zero if yes let's set a negative flag to true and let's just assume the user gave us a positive number so we convert that negative 19 to the absolute value of itself positive 19 this code goes through as if the user had given us a positive number and then at the end we would get get the same number as before except that we're going to prepend a negative sign so the negative uh so the binary representation of negative 19 is just the same thing okay so that's that was where we ended up we talked about these integers um but now what about fractions right integers seems really easy there's a really easy simple procedure algorithm right recipe for us to follow to get the binary representation but what about these fractions oh yeah sorry so how does the negative right everything's going to be Zer or one so how does it read negative um here here here oh we just um it doesn't read it we just pretend like we were given a positive number and then we just do the same process over and over again okay so the computer I mean it for the purposes of the algorithm it doesn't need to know because the number will come out the same we just flag it as being a negative number and then at the end we say Hey you we were actually given a negative number so let's just pop this negative sign right in front of it okay and then talk about like the the powers that like two is put to like are we like going left to right like descending powers or ascending um we are actually doing ascending when we're building up the string because we're going right to left so yeah yeah exactly so this is two to the zero and this is two to the four yeah so in terms of fractions if we're thinking about what it means to talk about a fraction action in in human readable base 10 right so numbers 0 through 9 when we have 0. ABC we're basically saying that's a divided 10 plus b divided 100 plus C divided by a th000 and so on and in base two we're going to have the same sort of thing going on if we're talking about a base two representation of a number 0. a BC where now a A or C is just zero or one instead of 0 through n it's going to be the same thing so we would have a ided 2 plus b / 4 plus C ID 8 and so on so now we're dealing with powers of two instead of powers of 10 right because our base our base is now two instead of 10 so that means the binary representation of a decimal fraction basically means can we find some sort of combination of these values 0.5 time a z or 1 plus 0.25 * a 01 plus .125 * 01 and so on and so on so these are all the powers of two to so I'll give you the recipe for how we can actually find the uh the uh the representation of a fraction and this is not something that we expect you to come up just like the recipe for this is not something we expect you to come up with but given the recipe you should be able to sort of intuitively figure out what is the code that actually you know performs this this uh this action right that does this recipe so the idea to convert a decimal number to to a uh a decimal fraction in base 10 to a fraction uh sorry to a binary fraction right in base two is as follows so let's look at the decimal number 3 divided 8 just as an example so that's 0.375 right but we know it's 3 over8 in base 10 so using numbers uh know uh numbers 0 through 9 we end up saying it's 3 over 10 plus 7 over 100 plus 5 th000 right that's just base 10 but we need to come up with a way to convert this into base 2 and so the trick here is to basically say what is the biggest multiple of two that I can multiply my number my decimal number with such that I end up getting a whole number an integer that's sort of the trick to this whole thing can I multiply my 375 or what whatever fraction I'm interested in calculate in in changing to base two by some power of two big enough such that I'm going to get a whole number out of this out of the multiplication and it has to be a power of two because we're converting it to Binary right zeros and ones so in this simple example 375 is 3 divided 8 so that means that the biggest power of or the the the smallest power of two I can multiply uh 3 over8 by to give me a whole number is eight right that's 2 to the^ of three so if I multiply 375 by 8 3 over 8 * 8 gives me three in base 10 and now this whole number I know how to convert to Binary I have a recipe right we've done it on the board here we have the code on the previous slide so all we have to do now is convert the number three to Binary which is just one one base two but this one one is a representation of the number three so in order to get back to 375 I need to divide my three by 2 to the^ of 3 so I need to divide my 1 one by 2 to the^ of 3 and in binary dividing by some power of two just means Shifting the decimal point over just like in base 10 dividing by 10 means Shifting the decimal point over so if number three is 1 one and and I multiplied by 2 to the 3 to get this value to divide by 2 to the 3 I just need to move the decimal point from just after the 1 one over one two and then it add another zero so the representation of the 375 becomes 011 right I just shifted this decimal point over by three because now we're dealing in base two okay so that's this that's the system like that's the recipe for getting this uh decimal uh this binary representation out of a decimal number but there's a problem right this is all relying on the fact that I can find this magical power of two right that if it's big enough right I can find such a power of two that when I multiply with my decimal number I get a whole number out of it and that's not always the case sometimes that power of two is going to be really really big or it might not even exist okay and so if it's really big or if it doesn't exist that's where we run into problems as we're going to see in a little bit okay so this is all relying on the fact that I can find this power of two so here's the code to actually do this recipe that I had on the previous slide finding the power of two doing the conversion and then Shifting the decimal point over so I'm going to do a quick sort of overview of the pieces and then we can run the python tutor just to show you exactly step by step what's going on so let's say I want to do 625 and convert that to a^ of two so I've got my X initialized up there this bit here so this big box here is the part that finds this magical power of two for me okay it's just a loop that keeps incrementing the P the power such that 2 to the power of P multiplied X this percent one just gives me the decimals bit out of that multiplication is zero so I'm going to keep multiplying two to some power of P by X as long as I still have a decimal piece to my number as soon as this percentage be percent one becomes zero that means that the number I'm I end up with is some number do zero right there is no more decimal part to it at that point I break out of the loop and I found my power of P or my power P this is going to be the integer so I'm multiplying X by that special Power by two to the power of uh that's by two to the power of that special power and now I have this number so on the previous slide right it's the number three in base 10 and then this box here is exactly the same as two slides ago it's this procedure here it's taking my number whatever it may be and getting the binary representation of it and after that we need to figure out how many spaces to move the decimal point backward so so what is the power of P we multiplied that number by and now we need to work our way backward and say well that dot is here let me move the dot back P steps and that's what this is doing so it's iterating through P minus however long this thing is to pad the front with zeros okay because if because sometimes this is going to be a really small number so I need to add some leading zeros before I put my decimal point and then I put my decimal point and that's all this line is doing and then I and then I print my result so python tutor all right so step through so this is 625 just like in the slides p is initially zero so now this Loop is just incrementing P1 by one to find uh the the point where I have a remainder of zero so here I'm actually also printing the remainder so here we still have a nonzero remainder right so it's 625 as a remainder 0.25 as a remainder 0.5 as a remainder and then at some point I had multiplied it by 2 to the^ of three because p is three and I had a zero remainder so now I've broken out of that Loop and I know num is equal to five I multiplied by 2 ^ 3 time 6 to 5 to give me five so now I need to convert num which is five using this process we did here into binary that's what this code is doing and this is exactly this process we had here so I'm creating this result string and then prepending a zero or one whether the number is uh divisible by two or not so the number five in binary is one1 okay so that means I have one Z One Dot as my binary representation of five and now the code is going to go through this Loop which means it's going to move the decimal point to the left three slots right because I mult because I have to multiply by two to the^ of three to get the five so you can see it's going to go Loop through uh three slots right so here it is it made the0 one1 and then sorry this bit which I skipped over applies the dot right so it puts the dot in front of it and then the last step is to just print the representation so the binary representation of 6 to5 is 0. 101 so here's the code and we can run it so 0.5 the representation is 0.1 0.625 which is what we had just done the representation is 0. 101 right and we can play around with a bunch of these values but then when we do something like 0.1 what is the representation of 0.1 going to be right because now we can use this code to get the representation of whatever decimal we'd like point one was this Troublesome decimal so let's see exactly what happened well it had to do a whole lot of Divisions right um it had to test a whole bunch of powers of two before actually got to a a whole number right in fact about 50 of them and we know that because there's about 50 of these zeros and ones here right so it was approximately two to the^ 50 that it had to multiply 0.1 by before it got to a whole number so what that means for us is a number that's kind of a a a a linear combination of powers of two is really easy and fast to compute right something like you know this one here 1 * 23 is 01 but something like 0.1 which isn't as as easy to see what the linear combination of all these powers of two are is not so easy to compute right and in fact we had to use our program to figure out exactly what it is and it for us it was about 50 these digits long which was pretty long right and some of these numbers could be even longer potentially infinite so the point here is that everything in computer memory is represented in terms of bits right zeros and ones the reason we went through this whole computation is because there are some numbers that are just going to be way too big to fit inside these inside the computer hardware inside these representations okay so for integers it's straightforward to deal with we had a really fast way to compute the uh the the base the base to representation but for fractions it's a lot harder and those numbers can be really really big so now how are these numbers actually represented inside computer memory so they're actually being represented in two pieces one is uh one piece is the significant digit and the other piece is the power of two Okay so if we had the representation one comma one inside computer memory basically the significant digit is one and the Power of Two is one so that means we're going to take this one dot and give it the power of two so we're going to add a zero after it so this is the binary 2 representation we basically just move the Dot from here to here and then the number one zero and base two is 2.0 right that's what we have on the first line one comma negative 1 that repres representation means I'm going to take the significant digit one and the Power of Two is negative - 1 so I'm going to take this decimal point and move it to the left one so this is going to be uh 0.1 right that's the this number 0.1 which is 0.5 this is base two this is base 10 and just to bring the point home 125 okay is going to be 125 as significant digit and 2 to the -2 how is this going to work well we're going to take the 125 and convert it to a power of two so it's what is this I'm not going to remember what it is one one one one one zero one this is what 125 is in base two but the signif but the uh the exponent here tells me it's -2 so instead of putting the dot here I'm going to move it one two over so this is the actual number I'm representing in memory and now I can just convert the two pieces separately so this is going to be 31 dot uh what is this 25 right yeah okay so this is how computers actually represent numbers inside memory okay and we call this uh the object type which is you know decimal or real number uh a float because this decimal point kind of floats around okay or 31.25 for number uh base 10 base 10 is 31.25 and 125 is how it's represented inside memory so it's a base 10 sort of thing and then what is the power of two yeah so there's a couple conversions being done here we're representing the the the Bas 125 is base 10 and and how much we need to move the decimal point but first we need to make the conversion of 125 to Binary which is this long thing here not counting this decimal point the Nega -2 dos us we need to move the decimal point over and then we have the actual number we're trying to store right and the reason we're doing this is because we're mostly just storing numbers as whole numbers inside the memory we're not storing fractions right yeah I'm just a little confused because you went to all that trouble to convert the oh know but that was for fraction that was for fractions exactly yeah yeah okay so in the end we did all that because we're trying to figure out the error right why do we get this error inside our programs well in the end it's because computers have a finite number of bits to store data most modern computers maybe have 32 maybe 64 bits to represent significant ific digits right so if we have 32 slots in order to put these significant digits if our number base two representation was 50 digits long then we're going to truncate at 32 we can't store those extra bits right and so a number like 0.1 ends up actually being an approximation in base two inside computer memory we're not able to store that number exactly perfectly so it becomes an approximation right and the approximation actually ends up being at the 30C bit right that either will be zero or one you know depending on how we decide to truncate and so the error is actually two to the 2 to the - 32 right which is on the order of 2 * 10 the -10 which seems pretty small right it's it's a very small error but we just saw that that error accumulates really really quickly right so while 0.1 has an error at the 2 to the3 2 slot if we take that error and we just kind of accumulate it over 10 increments as we had this Loop that went through 10 times we see that that error ends up becoming a big problem right we see that it actually at the negative 16th slot or something like that it you know it starts to uh to round to the wrong to the wrong thing and so we see things like this right we expect it to be one but it's not one okay so the moral of the story is we don't want to use equivalents right the the equivalent operator the equ equal operator when we're comparing uh comparing floats because of Errors like this the errors can accumulate and then we start getting the wrong answer and then your programs end up not doing what you expect them to do okay so we always want to test whether some float is within some Epsilon of another float and so that brings us to approximation method last lecture we saw the guess and check method as a really simple algorithm for solving problems we have a set number of solutions that we can check and then we check each one by one and then at some point we either find the solution or we've checked all that we can check and we haven't found the solution right it's usually an integer what we're kind of the things that we're checking but as long as you have some finite set of values you can check for a solution through guess and check is totally applicable okay but the problem is it's a little bit limiting right it doesn't give us an actual approximation to the square root if you remember the code we wrote last time it didn't actually say I'm approximating the square root uh of you know five to be 1.4 something or whatever it is or 2 point something right it was just able to tell me the square root of a perfect square or that the number you gave me is not a perfect square and so it's a really limiting algorithm but the approximation method the one we're going to see today actually is going to be able to give us an approximation to the square root of any number okay so it's better than guess and check because we don't just want the correct answer or nothing it's not an All or Nothing kind of situation it's that we can approximate the answer to some degree so we're going to use guess and check when the exact answer that we want might not be accessible right we need some way to find an answer that's just good enough and approximation methods will not always and not usually actually most of the time will not give us the right answer they'll usually give us an approximation that's good enough okay and approximation methods these they came about because of the exhaustive enumeration limitation right we're not able to test all the possible values to find the exact square root of a number right because those values are all infinite so floating points come into play here the whole thing we've been talking about at the beginning of this lecture and last of last and last last time floating points come into play here because they're very important to this method now that we're comparing floats we're have to we're going to have to be careful about how we actually do the comparison so how can we approximate the square root well instead of looking at just whole numbers and saying whether we found the root or not what we're going to do is have smaller increments so no longer are we doing just integer guess and check we're can do 0.1 2 3 point 4 and so on until we get to a guess that's close enough to X right so we say that 2.1 or whatever is good enough to the square root of five what does it mean to be good enough right suppose we wanted to find this approximation to the square root right the guess and check was not able to do this for us but the approximation method can so what we're asking for can we find a root such that that root times that root times itself is equal to X right and we're going to do this such that we have a good enough approximation so that means that root that we're going to find minus X is going to be less than some Epsilon or the absolute value of that subtraction is going to be less than Epsilon right so in where we did incremental step by step we're going to go through as long as we are within or until we are within some Epsilon of X okay so the algorithm will be as follows we're going to start with a guess that we know is too small so for the square root of a number we let's start with zero and then we're going to increment it by a really small value with guess and check we incremented it by integers with this uh particular method we can increment it by 05s or 0. ones or 0.001 whatever we'd like okay that new increment gives us a new guess we're going to check whether this new guess is now close enough to X if it is we're good and if it's not we're just going to keep incrementing the guess until we get close enough to the actual answer okay so we are we have two parameters we actually need to set in the approximation algorithm the first is an Epsilon so this is down here how close do we want to be to the final answer what's the leeway we're going to allow and second is the increment so how uh much do we want to change our guess by the way the algorithm performs depends on the values we choose for these obviously if our guess is smaller right if we decrease the increment we're going to get a much more accurate uh approximation right if we increase the Epsilon how you know how close we want to be to X our program is going to be a faster because we're going to enter that plus minus Epsilon boundary faster but it's going to be less accurate because at some point we're going to enter the boundary and we're going to say good enough I'm not going to get any closer to X because there's no need to I'm already with an Epsilon so here the guess you know good enough guess was to the square Ro of five was 1 point something but on the previous slide right when we had a smaller Epsilon the good enough guess was 2 point something so the approximation algorithm is like guess and check except that we have some small increment we change by a small amount and we stop when we're close enough so we're going to check that the absolute value of this solution minus the solution minus the actual answer is within Epsilon so here's some code where we can Implement what ex uh uh uh finding the square root of a number with approximation method we have some uh stuff here that we're initializing so this is the FI thing you want to find the square root of this is how close we want to be to the final answer and this is our increment numb guesses is just to keep track of how many actual guesses we're doing and we're going to start with a guess that we know is too small zero this is the loop that does all of the work for us so the way we would say it in English it says basically while our guess is not with an Epsilon keep making new guesses so while what does it mean for the guest to not be within Plus or - Epsilon well the absolute value of Our Guest squar - x is greater or equal to Epsilon so while we're still too far away let's make a new guess so we increment our guess by the increment value so originally we were zero then we're 0.1 01 then we're going to be 02 and so on this num guesses again is just for us to keep track of how many times we've actually gone through this Loop and at the end we can print how many guesses we've done okay so here's the code and 36 so we can run it what do we see here's our approximation to the square root of 36 now we know it's six and of course if we kept going we could have found probably exactly six but notice this approximation algorithm stops as soon as you enter that plus minus Epsilon boundary yes um do for Loops always increase in integer amounts do for Loops always increase in integer amounts yes the step has to be an integer positive or negative yeah so exactly a for Loop would not have worked here right yeah right so here we stopped this algorithm as soon as we entered that plus minus uh boundary of Epsilon right and so five 9991 is close enough to squ root of 6 and that's what we're reporting the number of guesses here was about 5999 2,000 and that's makes sense because our increment is 0.001 and we went all the way up to 5.99 right so with each time through the loop we incremented pi1 so that's just this times 10,000 okay that makes sense so let's try it with a couple other values so here it is with 24 right 4.89 again we're seeing these U floating Point errors pop into play right whenever we see this weird like 0 Z and then some small amount at the end that's these floating Point errors just given the numbers we're working with adding up um here's the square root of two right 1.41 again floating Point Air but this time on the other side 0.9 and9 uh 1 2 3 4 five run it it took a second right there was a little pause and then it gave us the answer just because it has to Loop through about what is this 100 1 two three 1 million times right so did that Loop one million times to get us get us the answer and then we can try one more 54 3 2 1 this should take about five times as long right because [Music] 1,2003 12,345 took about 1 second this one should take about 5 seconds but it's not I'm pretty sure I was talking for more than 5 seconds and this program is not ending so something's gone wrong I'm going to stop it remember you can stop it by clicking the shell hitting contrl C or the little square here in the corner so what went wrong oh yes my question is will this Loop always terminate and 54321 was an example of the loop not terminating so what happened right we did all this let's try to debug what exactly happened because clearly what we have in code right now is not really giving us much information so let's add some print statements the print statements I'm adding is just in here so everything else that's not boxed is the same as on the previous Slide the only thing I'm adding new is this if statement here so every every 1,000 uh sorry every 100,000 guesses so every time I've gone through this Loop a 100,000 times I'm going to print what the current guess is and what the guess squ minus X is so how far away I am from X the Epsilon or yeah not the Epsilon but how far away I am from X so let's run that code it's down here I added a little bit of extra thing which is just it's not printing the whole time it's just going to pause for me just to talk about what's going on so here I have the code run has run so my first 100,000 times through the loop I have my guess being about 10 and how far I am from X is about 54,000 so I want to be 01 away from the from X right because that's what my Epsilon is and so here I'm 54,000 away from X so clearly that's too much okay um let's continue so then we make more guesses and then here when my guess is a 100 I am about 44,000 away from X from 54 so looking good let's continue so with 120 I'm 39,000 away from X with 200 I'm 14,000 away from X so it's looking much better right I'm getting closer and closer to uh to getting that difference uh you you know being Zer or 01 continue with 210 I'm 10,000 away from X and then I'm almost 6,000 away from X and then I'm 1,000 away from X and then from 230 as my guess which brought me 1,400 away from X the next time I have 240 right the next print out I have brings me to 3,000 away from X so I was 1,000 but now I'm 3,000 and then from there on things break down really quickly because I just get now farther and farther away from X right so here I am continuing the program for a little bit and then I just keep making guesses right because I was never within that Epsilon so here's 500 and now I'm almost 200,000 away from X and so now you see what's happening this program is just going to keep getting further and further away from where I need to be so let's visualize what what exactly happened this is our X 5,400 uh 54321 and this is our Epsilon let's say it's you know 01 obviously not to scale blue is going to be representing one guess so here's a guess and then we have the guess squared a green so let's just for visualization purposes let's say this is our guess and this is our guess squared okay we're far away from from X we're definitely outside the Epsilon boundary we make another guess by incrementing it a little bit this is the guess squared we make another guess by incrementing it a little bit because we're still far away from that plus minus Epsilon this is our guess squared we make another guess this is our guess squared we're pretty darn close to that plusus Epsilon boundary right we want to be within that plusus Epsilon so one more guess should make it right this is our next guess but now the guess Square squ is on the other side okay this is the big reveal you guys so what happened what happens now the program says keep guessing because we're not with an Epsilon so it's going to make another guess guess squared and it's just going to keep guessing and then our guess squared is just going to keep getting bigger and bigger so we basically overshot the Epsilon right we've overshot our little plus minus boundary we were interested in being within right we didn't account for that when we wrote The Loop right all we wanted to do was be within Epsilon and our program would end so let's fix that one addition will fix that and it's something that we had been doing in guess and check anyway right in guess and check we would say something like if we've passed the reasonable guess right when we we know that guess squared from here on out is definitely too big just stop stop guessing right just just stop and so we can add that same thing here as just another ending condition so everything in this code is the same as before except for this red box we're adding another stopping condition that basically says keep guessing while we're we we're while we're still guessing something reasonable right but when we've guessed something that's not reasonable right which is when the guess squared is greater than x right we've we're way past it stop guessing as well so whichever one of these conditions either this one or this one being with an Epsilon is true we break out of the loop and then we have an if else kind of the same sort of thing we've been doing so far in the guess and check why did we break the loop did we break it because we were with an Epsilon that is the else Clause here right if we did then we say this is close to square root of x but if we broke it because we've passed reasonable number of guesses then we know we failed to find the square root right because of We overshot The Mark or whatever so here is the code with 54321 but now we have that extra condition here guess squared less than uh less than x so we see that we've done some number of guesses right 2,300,000 and the message we get is we F fail to find the square root makes sense right because we knew we would fail and we're also reporting what the last guess was and the last guess squared just in case the user wants to use that information for anything what are some solutions to fix this right if we don't want to fail what what can we do well I gave you a hint right here we can decrement our increment or we can decrease our increment If instead of uh adding uh 0.00001 every time through the loop let's add 0.0000001 so let's make it uh make a guess 10 times as many guesses we're going to have to wait a little bit maybe about 10 seconds but the program will end it's taking this long obviously because it's making all of these extra guesses right for every one guess we had with the program that failed we're now making 10 guesses right because we decreased our increment by 10 okay so it ended and we see exactly that idea and the number of guesses so here we had 2.3 million guesses when our increment was 0.1 but when our increment was 0.1 right four zeros we had 23 million guesses so obviously we had 10 times as many guesses which made our program be 10 times as slow but now we didn't fail because we were able to go within that Epsilon right so we found that 233.356 Epsilon and how else can we you know stop the program without it running into an infinite Loop right that would be bad so I think I already went over this right what are some observations about running it uh yes it reported failure so we reset the increment down to uh 10 times smaller than what it was before the program was small was slower because we had more values to check through okay so the big idea here is we want to be careful When comparing floats if we we were using something like equal equal sign right that would have been a complete disaster that we would might have never been with an Epsilon or something like that okay um yeah so what are some lessons we learned in approximation right so we can't use double equal sign to check for exit conditions we always have to check whether we are within plus or minus some Epsilon of the actual answer we have to be careful that we have that the um the exit condition being plus or minus within some Epsilon doesn't jump over our exit test as we just saw right in that case we add some extra condition and then we saw that we actually have a trade-off right we can have a program that does terminate and reports a correct answer right it doesn't say we failed but it does report a correct answer but that could be a a program that's a lot slower right it's a lot slower because we had to decrease the uh our increment alternatively we could have increased our Epsilon boundary right our plus minus Epsilon that we allowed to be within could have been bigger but then we would give up on some accuracy as well so there's always this trade-off of speed versus accuracy to get um the program to do to actually give you an answer or to do what you'd like right and depending on the application you might want accuracy versus speed or vice versa okay so this approximation algorithm is is really slow right to to get an answer for the Square < t of 54321 we had to decrease our increment to something like 0.0000001 and we ran it and that program took maybe 10 seconds to run right on my computer because we started from zero and we were just painfully incrementing that increment one at a time even though we knew sort of from what the number actually was 54,000 that that the square root of it could not really be that low but that's just the algorithm we had right we had to start from something zero just in case the user gave it other numbers which you know didn't make sense to start higher than that and so the approximation algorithm as you saw can be really slow the question I have is is there a faster way that still gets good answers and the answer of course is yes and we're going to see this uh this uh particular this algorithm in the next lecture okay so in quick summary we saw floating points uh we did a lot of calculations with binary numbers you don't need to know how to do those calculations but again given a recipe or an algorithm can you take that and put it into code right floating Point numbers introduced a little bit of challenge for us in comparing them because of the way they're stored in memory we can't represent some of these numbers exactly in memory so that's a problem because they're not represented exactly in memory we might magnify some errors right as we saw with that Loop and the approximation methods use floats unfortunately or fortunately right they need to use floats because we need to have a small increment and we have to be mindful of these issues uh when using them okay