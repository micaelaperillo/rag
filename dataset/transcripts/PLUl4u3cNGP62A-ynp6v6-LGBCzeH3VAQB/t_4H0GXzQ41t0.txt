so welcome to the last class please don't come on Wednesday I will not be here uh today we will just be uh tying up some loose ends regarding some topics that we've seen throughout the course and then I'm going to do just a wrap up of things we've learned and potential uh uh courses that you might want to take after this okay so today uh as I mentioned we're going to tie up some loose ends regarding lists dictionaries so those two topics are kind of going to be combined into uh one sort of kind of uh one part of this lecture um it's going to also include a little bit about complexity so just some things that we've learned kind of demystifying some details that I kind of ski throughout uh the past few lectures and then we're going to talk about simulations so simulations are very very useful is a very useful idea that you can already do with what you've learned in this class and I'll show you some uh useful places where you can apply computation and simulation to do some interesting uh some interesting things and then we'll do the wrap up so let's first uh start talking about lists so lists were the first data structure that we encountered that was really useful right like we did see strings and we did see tupal and things like that but once we saw lists it opened up a whole new world of possibilities for how we can manipulate data right so lists are sequences of objects I kind of skipped past how they're actually implemented in memory so I do want to talk about that a little bit but what we did talk about was the uh complexity the the ASM totic complexity of list operations okay so some of these are were pretty obvious so the ones that are Theta of n down here were obvious because well to check for equality between two lists you of course have to look at each element in the list right so that's sta of the length of the list to check whether an item is in a list or to iterate over a list obviously it's Theta of n because you have to look at each element in the list but we didn't really talk about the uh complexities up here so accessing an item in the list specifically is Theta of one so that means if you have a list with a whole bunch of elements in it to grab the element at a specific memory location it's Conant time complexity right so it's basically doesn't depend on the length of the list it's instant so we're going to see why that is let's first for Simplicity St sake assume that we're storing a list in memory of just integers right so I know lists can store other lists and dictionaries and things like that but just for the this first slide let's assume all we're doing is storing integers so the way python does this is uh when you create a list let's say you're initially populated with length L python initially allocates a contiguous memory block with uh with length L memory locations okay so if you have a list with 100 elements in it initially populated with 100 elements in it python will initially create for you a sequence of memory locations that are reserved for this list then it says well if this is going to contain just integers I'm going to say each one of these memory locations will hold four bytes for that integer that's kind of how we represent an integer right and it could be you know eight bytes something else for different machines but in this particular example let's just say each one of those memory locations will store an integer and that's four bytes long well if this list is contiguous right a bunch of blocks of memory in all in order then to access the I element all you need to do is a little bit of math right so here I've got an integer in one uh position in my contiguous block then I have maybe another integer at the next position and so on and so on until I have another integer at the I position so since these are consecutive to access the location of the of the element in this I spot all I need to do is look up that many memory locations from the start of my list okay so that's just pure math so one bite is eight bits so if I have have 4 * uh 4 * 8 Bits multiplied I plus the first location that will tell me exactly the location of the I integer okay so this is all made possible because these memory uh these memory locations are allocated in order if they were allocated not in in order then maybe this would not be uh as as easy yeah is it 32 um 32 because uh so if I say an integer is stored as four bytes um in bits that's 4 * 8 because eight bits is in one bite so eight Time 4 is 32 bits for one bite yeah all right but this is assuming that I'm storing integers and obviously lists can contain other lists they can contain tupal they can contain dictionaries and some of those objects might not fit within this set number of bytes right within four bytes because some of those objects might be very very large themselves so in that particular case let's say the list is heterogeneous that doesn't phase us because we can say well instead of storing the object itself at each memory location that worked for integers but not might not work when we have to store a list of you know a thousand elements at a particular memory location let's instead instead of storing the element itself let's store a pointer and a pointer is just a number that tells you which memory location that list might be stored at or that dictionary might be stored at right so if we store a pointer at a particular memory location then that means that this is my again contiguous memory allocated for a list of length l or something like that then here I'm storing still an integer and that integer tells python which memory location to jump to to grab the integer that's stored there or something like that okay and here I might have another list that I'm storing but I'm not storing it exactly in that memory location it's pointed to by uh by this pointer that tells python again to jump to a different memory location where that list might be continuously stored itself right so here in this in this example I'm still storing um numbers it's just that these numbers correspond to a memory location that tells python where to go to get my element in that list right so in terms of the computation to get the I element in the list it's going to be the same I'm still allocating in my original list four bytes to store my pointer again just a number and so to get the I location all I need to do is tell python to go the start of this list plus 32 * I locations down to get to that element okay so this formula here right adding the start of this memory location of the list plus 32 * I is just math there's nothing here that depends on the length of the list right so to grab the element at the I location right somewhere within here all we're doing is some math right an addition and a multiplication and since that is just you know that none none of that depends on the length of the list the complexity to access the I element in the list is constant right just math and we're using this idea that we are we know exactly how many uh memory locations we need to jump to get to the I location does that make sense okay so that leads us to uh the question well okay we're storing a list of elements and we're using the idea that a list has indices right to tell us the value there's an element at index zero a an element at index one an element at index two and so on so there's an order to the lists right and because of that order we're able to index an element at the I location in constant time but let's say we wanted to store a DI dictionary a dictionary does not have an order to it right and what does a dictionary store it stores a key value pair in a list you could think of the quote unquote key as the index 0 1 2 3 four and so on and the value was the element at that index but in a dictionary the key is not ordered right the key can be anything so here I've got a dictionary that Maps maybe a name to a Boolean Maybe you know this student is in this class true or false so a naive implementation of a dictionary could be to say well let's Implement elements of the dictionary so a key value pair as a list so just two elements the first element in that list is my key and the second element in my list is my value right so here really naive implementation uses the list and I've got four entries in my dictionary the element at index zero are all stri strings the element at index one in each location is my value associated with that key well if I were to index into this list right to grab the value associated with Eric for example can I do that in constant time no right because there's no numerical index here there's no order to this set of values right um it's not even an alphabetical order right so a then J then e then s and there's no order guaranteed for dictionaries anyway so in order to look up an item in this naive implementation of a dictionary where you're just putting all the elements in order in a list it's Theta of n where n is the length of our list right and so this implementation of a dictionary doesn't work and yet when I showed you this slide a few a few uh a few lect lectures ago we saw something interesting so this is what we just uh what we just kind of proved quote unquote um the access time in a list is constant but the access time in a dictionary is uh is constant as well in the average case in the worst case it is Theta of n right accessing an item in a dictionary is Theta of V because in the worst case we might store the dictionary like this right it's just a list of all of our dictionary entries all in order so to look up one index we'd have to go through the entire list and check if the element at index zero is the one we're looking for and then grab the element at index one as its value but in the average case and this is what we're going to see next in the average case the access the time it takes to do a lookup for a key uh in a dictionary is constant it's actually Theta of one which makes dictionary really powerful data structures to use in a lot of situations so why is this well it has to do with the idea of hashing okay so the way that dictionaries are actually stored in memory is not as a list of a bunch of entries right we just showed that that is not feasible that leads to a Theta of n lookup time so instead they use something called a hash table we briefly spoke about this a hash table is just like a long list uh and the indices of the hash table are actually things that you look up using a hash function okay so how does this work well any key that you'd like to add to a dictionary can actually actually has a hash function run on it and this hash function takes in maybe an integer maybe a float maybe a string maybe a tupal any sort of any any hashable object hashes it which means it takes that object if it's a string it'll give us an integer if it's a tuple it'll give us an integer so if it hashes it that means it takes it in as an input and gives us back a number an integer and that integer is what is used as the index to look it up in the hash table to look up the value associated with it in a hash table so in that sense the lookup itself is constant time because we just showed looking up an item in a AR using the index is constant time and if that hash function is also constant time then the time it takes to uh look up an item in a dictionary is also constant time so here are some examples of the Python hash function actually being run on different objects so up here if I run it's it's literally a function in Python hash of some parameter so in this case 123 it just gives me the value back so the hash of some number is the number itself itself um we can hash a string uh that'll give us you know this particular number so again an integer the hash of a tuple also gives us some number back so these are all this these are all just some function running behind the scenes that takes in this hashable object and gives us back a number that's it now we can't run a hash function on a list because a list is mutable and therefore unhashable right if the object changes then the hash function run on this object will give us a different value okay okay so if you actually run this on your own computer you might get different answers or if you run it at different times you might get different answers because python adds a little bit of Randomness to the uh the hash values just in case you want to encrypt data and things like that but generally you will always get some integer back if you run the hash function on a mut uh on a immutable object okay so then that begs the question how big should a hash table be right so if a hash table is basically just a long list and if I run a function on some object to give me the value of an index within that list how big should this table be how many indices should I have a thousand a million 10 million right what's a good number well let's take a example of a string okay so for a string what we can do is and we can use my name as an example if we want to Hash uh my name such that every single name hashes to something unique what we can do is the following so we can take each character in somebody's name and behind the scenes each one of these uh uh characters actually has uh an integer uh sorry an asky code associated with it which is something numeric and what we can do is just conver convert that number to Binary so the letter capital A happens to be uh this binary value right 0 1 0 0 z001 the lowercase n is this value the lowercase a is this value and so on right so I've got seven different sort of groups of eight bits here for corresponding to each letter in my name now if I take those bits and now just smush them together concatenate them to give me one really really big number right so this is all going to be one really big number the corresponding number in base 10 is this really long thing okay and so if I do this as long as someone's name is unique they will end up with a unique number associated with their name right and therefore that unique number can be used as a unique index into a really big hash table so let's think about how hashing the names of mit's 4,000 undergrads right let's assume that the longest name is 20 characters long right so there's going to be 20 of these different uh letters that we need to Hash so we use the same process here each one of those 20 characters gets its own eight bit representation so in total the number of bits that I'm going to use to represent that 20 long character is going to be 8 * 20 so 160 different bits okay that's a lot of Bits And if I concatenate all those together the number that that corresponds to is 2 to the 160 which is this thing here okay so if I want every single combination of letters in the alphabet to be a unique value in this long list then I will need to have a list that is this long I'm not even going to try to figure out or to say how big this number is but it's really really big and having a list AKA hashtable that has this many entries will guarantee for me that names that are 20 characters long will each hash to something unique but I only have 4,000 names that I'd like to put in my table so I have 4 th000 names that I'd like to put in a table that has this many spots right so that's a lot of wasted space yeah is it 160 because he put it to Binary yeah so exactly so uh each one of the characters has eight bits associated with it right so there's going to be 160 of these zeros or ones in a row so to tell the number that that is that's associated with we basically say uh uh we basically calculate at 1 20 with 20 zeros at the end and that gives me 2 to the 160 right that's going to be how big my number is that is uh going to be uh that's going to be for one for one not that's going to be how many slots I'll need in order to have unique combinations of letters be mapped to one slot right so 0 one will map to one thing 00 1 0 will map to another thing 0011 will map to another thing so like all these combinations of letters will each map to something unique and I in order to guarantee that I need this many slots but since again since I only have 4,000 undergrads well that's a lot of wasted space right I'm only using 4,000 of these slots to hold students names and that's because a lot of those combinations of letters aren't really valid right so what's the solution there's a lot of wasted space there so the solution would be to say well you know what I would be fine with having a smaller hash table I don't need that giant number of entries in my hash table I would be fine with maybe having you know 10,000 spots and then having some names that happen to Hash to the same thing or saying I'm fine with having a hash table that has a million spots and you know out of those 4,000 some will be used some will be unused and some might Collide to the same hash value and that's totally okay okay so if we allow collisions what is this going to look like so here's a visualization of our hash table so think of the hash table like a list the reason why we think of it as a list is because indexing into a list is constant time right we're taking advantage of the idea that if we index into a list that's going to be constant so let's say we're adding some names and grades into our hash table right so this is our representation of a dictionary the values here uh says that I have a hash table that has 16 different entries right 0 to 15 and 0 to 15 corresponds to like the list index okay so if I have a name and a grade that I'd like to add to my hash table I need to run a hash function on the key so the key is the name and the grade is the uh uh the value associated with the name so to add Anna with the grade of C to my hash table I need to take my Anna which is the key and run a hash function on it such that when I run the hash function on this name a Anda it'll give me a number an integer between zero and 15 okay and if I can do that then I know I've added my uh my entry here into into one of these buckets so a reasonable hash function to run on the name and we saw this in the dictionary lecture is to say well let's have a ma to one B ma to two c ma to three and so on so in for my name I've got 1 + 14 + 1al 16 but since I want to ensure that this hash function gives me a number between 0o and 15 let's mod that with 16 right so I can sum all the letters in my name just fine and then let's finalize it by saying mod 16 to give me the remainder either 0 one two or 15 and if I do that I'm ensured that this key value pair will be added to one of these buckets from 0 to 50 okay so in this particular case Anna with a grade of c maps to zero right that's what the hash function on my name uh told me to add uh the the location that the hash function on my name told me to add to so there I am putting my name in there let's add a couple more people so here's Eric um his name hashes to 35 mod 16 so that's three so I'm going to add Eric and his grade to bucket number three then we can add John with a grade of B his name hashes to 47 mod 16 so that's 15 so we can add John down in bucket 15 okay and then let's add Eve with a grade of B so she uh hashes to 32 mod 16 which is also zero and you know what Anna was already in the bucket zero but that's fine because you know what I have four number four names here so four entries that I want to add to my hash table dictionary and two of them collided that's fine I still have many other buckets that are empty here so if I have you know uh you know 10 students in my class probably they won't all hash to zero they'll probably hash you know somewhere within here so that it's nicely balanced and so maybe out of 10 students in my class only two collided and that's way better than having all of the students in the class be you know enumerated in one long list right so when I look up Anna the way that this works is you hash the name Anna against right so when you want to look up the grade of Anna you that's the key you hash the value again you say hey Anna hash to zero so then I'm going to look in bucket zero and say all right let me enumerate everybody who's in bucket zero and see if I can find Anna with her grade happens to be the first one but you know if it was later on then I'd still be able to grab it much faster than if I had everybody in one long list does that make sense like the idea of yeah go ahead so you can still like access them just that like you might get two answers instead of exactly yeah you can still access them you just might have to look through a list of two right so here at bucket zero I'm effectively storing a list of these everything that hashed to a zero right which is it's fine yes that's that's two that I have to look through it's not four it's not 10 it's not you know 100 it's not everybody all in a row right yeah is the complexity that so the complexity of this is actually going to be smaller than Theta of n right and it it'll depend on on the hash function that we use right this hash function needs to be nicely balanced it shouldn't put everyone in bucket zero right then that's a useless hash function um and it depends on the size of the hash table right if I have maybe you know a thousand people that I'm storing in 15 buckets I'm going to have a lot of collisions right but if I'm only storing these four or maybe you know eight or 10 or something smaller than the size of my table then there will be far fewer collisions it'll be more nicely balanced yeah I bet likea n like things in zero oh Theta of n for the things in zero yes and that's fine because usually what we care about is Theta of the length of the input right so in this case it's Theta of if I have four students in my class right I've got only two that uh that mapped to zero so here it's you know length over two but if I had more students then it would be far fewer right it would be two out of 10 or maybe two out of 15 that to the same thing yeah so yeah so as as the question said what makes a good hash table and hash function uh pair right because this only works if you have a really good hash function and a nice hash table to go along with it so this is actually a problem in computer science you know a research problem all by itself so people actually study this for their um for their lives coming up with good hash functions and and hash tables so some some base rules uh you want to have uh the domain of Interest so in this particular case you know a tupal or a string or whatever it is um map to integers between zero and the size of the hash table so in the previous example we don't want to have a hash function that mods two because then everything will either hash to zero or one right if our hash table has 15 things well we better make sure that our hash function is going to give us a number between 0 and 15 second you want the hash uh the hash value to be fully determined by the value being hashed so in this case we don't want any sort of Randomness to go on for the reason that well if I want to look up Eve's grade later on in you know in in the code or whatever then I need to run the exact same hash function on her name to determine the grade so if there's Randomness involved in this hash function then you might not get back the same value that it hashed to originally right so you'll be looking in the wrong bucket and you'll uh you know incorrectly say she doesn't have a value or she's not there um third you want to use the whole input to Hash the uh uh the function should use the whole input to to run the hash function so again in this example we don't just want to use the first letters of people's names because then that will lead to a lot more collisions than if we use the entire you know the sum of all the letters in the alphabet or all the letters in their name right um okay so those are really big ideas and then uh what we want out of our hash function is all the values right if you run this hash function on a bunch of different inputs for you're storing names or you're storing I don't know tupal or whatever you're storing you you want this function to give you a nice uniform distribution of values right so in our hash table previously here if I add more names to my hash table I want to ensure that they're going to land in buckets you know 2 5 6 7 8 9 10 11 12 133 14 I don't want everything to Hash to number zero right that would be very bad so as a side reminder back in the lecture on dictionaries I actually said something like um uh for now think of the objects that can be Keys uh to a dictionary as immutable objects right and I said technically hashable but we don't need to know what that is well hashable means just this you can run a hash function on the object and you'll get the same value back no matter how many times you run the hash function on that object right so we looked at this example what happens if we add a student whose name is not immutable not hashable so lists are mutable objects so as such they are not hashable that means if we run a hash function on a list today and then we potentially mutate the list tomorrow that list will not hash to the same thing right so we saw this example let's say Kate with a K uh is added to our hash table so her name currently hashes to 37 mod 16 which is a five right so we added her there now let's say you know tomorrow we want to look up her grade to you know do whatever to integrate it into a bigger spreadsheet she had changed her name between yesterday and today now she's Kate with a c if we run the same hash function again on her name that leads us to look in a different bucket right she's still there she's Kate with a K as we had originally added her but now her name is Kate with a c we run the same hash function tells us to look bucket 13 and she's not there right so that's why we only want uh hashable objects to be added to be uh keys to the dictionary because we want the same value to come back to us when we run the hash function on them right okay so now we can see in the worst case scenario everything maps to the same bucket in my hash table my list right every single thing I add is has a really bad hash function on it let's say the hash function always returns three right if my hash function always returns three no matter what I'm adding to my uh diction no matter what I'm hashing then every single item essentially gets put in a really long list at bucket number three so when I look up a value well surprise it hashes to three and now I need to look through every single thing in that bucket number three to find the one I'm looking for right so it's just very very bad and in the worst case scenario this is is the complexity it's Theta of n where n is the length of whatever items we have that we're adding to our buckets to our hash table but in the average case and this is only when we have a hash table that's pretty big relative to the things that we're adding to it and when we have a hash function that's good enough right that has a nice uniform distribution of values only in that case in the average uh in the average case the time it takes for us to grab a value from uh a dictionary is Theta of one constant right and so that's why dictionaries are really really useful data structures to store things and to retrieve things from um back in uh back when I was doing a little project I didn't know about python dictionaries I had just learned about the language and I was actually using lists to read in um genomic data files and I was storing everything in lists like jom names and things like that and um it was really slow like you know my advisor would be like you know uh is your code done yet I'm like no it's been a couple days still waiting and then you know someone told me hey just use a dictionary to store the values and then the lookup is going to be a lot faster it was done you know within a couple seconds so very very useful the time complex because it's genomic data it's huge amounts of data right so the the the Theta of n versus Theta of one is really it makes a really big difference when you deal with large data sets right it's not just on paper it's it actually makes a big difference okay questions about this I hope this ties in uh yeah so Pyon uses a specific cash function yeah if python updates or anything can they change that function and nothing would change or is it so you don't yeah so python right now uses a specific hash function in a future version they might use a different hash function we don't really use the numbers associated with the hash functions I mean you could for your programs but it would be I guess relative to whatever value you get right so you wouldn't kind of hardcode the value for you know the the tle one two three as something right you just get what you get and and and that's what it is right but it it could give you a different hash function if you ran out of your computer actually you might get a different hash value than mine yeah um so this topic kind of ties in data structures we've seen lists and dictionaries um some of the behind the scenes look at how things are stored puts a little complexity in there talking about algorithms and and runtime so it ties in a bunch of the topics that we've seen in this class really really nicely so one other thing that I'd like to now talk about is the idea of a simulation okay and this hopefully is going to be a little bit more useful to you if you decide to take another uh computer science course or computation course in a different field you know whatever you'd like computation uh simulations are very useful tools in computer science so it allows you to computationally describe the world so if you see an event in the world you can actually simulate it computationally what you've learned so with what you've learned so far you can totally simulate a whole bunch of things um and we're using Randomness to simulate the these events that you might see in the real world so for example you might have seen sort of um the the hurricane paths right when you see on the on on in the news or whatever the the most likely path right that a hurricane might take but then they also have the little models that show you know other likely paths they simulated right using a bunch of uh uh data that they have the most likely path for that hurricane right um another place where simulation where where simulation is useful is if if you see a real world event that's actually kind of complex you can take a a simpler set of rules and simulate those and then add in more rules you know to make it closer and closer to the thing that you actually observe in the real world okay so the idea of a simulation is that you have some event in the real world and you want to calculate something about it we're going to use uh computation to design an experiment right and we're going to do R use Randomness for that once we've done that we're going to repeat the experiment a whole bunch of times computationally and that just means we're going to put a for loop around whatever experiment we've designed computationally and if you're interested in some outcome some particular outcome like uh as we're going to see we're going to roll a die when we're interested in how many times you know a four comes up then we're going to keep track of that outcome okay and you keep track of it however many times that outcome happened in in your whole bunch of repetitions and then after the end of the repetitions you can report some value of Interest maybe the probability that a four comes up on a DI roll so here's the example it's going to be very simple because it's something we can calculate already right off the bat but it'll give you a sense of how you can write code around uh such a real world event so here we're interested in just rolling a dice and seeing the probability to get a dot dot dot dot right to get a four on on the dice uh on on on one of the dice rolls or the probability to get a DOT whichever so here the event is that we're rolling a dice and then we're interested in getting the probability of some uh face so we're going to design an experiment for that dice roll and this is just one way to design the experiment there are a whole other many many other ways to design it this is just one that I chose that felt Illustrated uh most how we can uh uh take a real world example and put it into code so a d has six faces so what I have done here is I've created a list of each one of those faces right you could have used numbers as the elements in the list in this case I just use strings to be a little bit cuter or cuter but you know whatever however you'd like to represent each one of those die faces here's a list of six things in it and then I'm using using this Choice function from this random Library again the random Library super duper useful Library random. choice will effectively select one of the elements in this list for me so if I type in random. choice in the console now it might give me the dot dot if I type it in right after it might give me the dot dot dot dot whatever it's going to be random each time I run this function but this line of code effectively simulates me taking a dice and rolling it and then we can repeat this experiment a whole lot of times right if I'm taking a dice and rolling it that's like what one or two seconds per roll I don't think I have time to repeat that experiment 10,000 times but with simulation with computation right with programming we can simulate it 10,000 times or a million times and then just wait a couple seconds right so very very useful um application of programming so so how do you simulate this dial 10,000 times just slap a for loop around that line of code right so for some number in range 10,000 that means I'm going to get this run this line of code 10,000 times all of a sudden I've just rolled a dice 10,000 times as I'm doing so I'm interested in the outcome of some event so let's say how many times did a dot dot dot dot come up right a four well each time in my for loop I can keep track of the value of roll if it was a four increment a counter if it was not a four I don't care do nothing so each time I have a counter that tells me how many times a four came up and then after the for Loop is done I've repeated my experiment 10,000 times and I can report the probability to get a four right so the counter divided by 10,000 so this is the code code that's it it's super simple uh I wrote a function and it actually takes in a parameter so if we're interested in the probability for a you know a dot dot dot dot to come up then we pass in the value of that particular uh of that side if I'm interested in the probability that a DOT comes up then I pass in the dot as a string okay so what does it do well just like in the previous slide I've got this for Loop here that tells tells uh python how many times to repeat the experiment I have the experiment number here as a variable so I can easily just change it to be something else and then I've got my roll here so this is me actually doing the experiment so just here's me rolling the dice here's roll value and then I check what the value of the Roll was and increment the counter if it was the side of Interest right the thing I've passed in as a parameter and then at the end I just do a print but you could imagine doing a return or something something like that so if I run it uh we're going to get the probability that the side dot came up was 0.167 and the probability that dot dot dot dot came up was 1602 intuition says they should be the same but you know what that's that's that's our intuition right we already know the problem if we didn't know how to calculate the probability of you know one of these uh sides coming up this would be pretty good right the the beauty of computation is we can just add two more zeros on there run it right and maybe uncomment it so we actually see the values run it we wait a couple seconds but now the probability is getting closer and closer to the true probability right so the more experiments I do the better my answer becomes and I just had to wait a couple seconds if I increase it by 10 more I would have to wait 10 more times right 10 times as long so maybe 20 seconds I'm not going to do it so it's still a guesstimate but it's a pretty close guesstimate now the other beauty of writing code is that we can now ask well this is a fair die right every single one of these sides comes up with an equal probability what do you guys think the change I should make to uh to make an unfair die let's say it's weighted unfairly towards uh the the the the the do dot right the one yeah add the dot yeah exactly let me just add another dot here here uh I've got another Dot and now the die is weighted unfairly right it comes up more times on the one than on anything else so if I run the code again wait a couple seconds probability to get a one twice as high as probability to get a four right so a really easy change it helped me answer another question a small variation of my original problem and I didn't have to you know roll it dice 10,000 times in in the real world okay so that was really easy simulation right the probability of getting one d uh of calculating uh uh sides of dies coming up is is pretty simple so why did we bother with the code right because we could just do it mathematically the side question that I asked was also kind of simple to figure out because we can actually ask harder questions and harder variations of our original problem we could certainly come up with mathematical solutions to these harder problems as well but I wouldn't be as certain about though my answers to those um as I would be just writing code for me it would be a little bit easier to debug code than it would be to answer to uh to mathematically write probabilities to much harder questions and you can see once you've written the code right once you've kind of framed your experiment in this way it's really easy e to just go ahead and change it a little bit right so the code is easy to change once it's written so let's look at a new question this one says um one experiment is no longer to just roll a die once one experiment is now that we're rolling a die seven times and I'm interested to know the probability to get the dot dot dot dot at least three times out of those seven rolles much harder question right than before it would require a little bit of thinking some paper right to figure out but in terms of code it's going to be really simple so now one experiment is no longer just one choice from my list of of dice faces but it's going to be seven choices from my list of dieces right representing the seven roles that I have for one experiment right and out of those seven roles what I'm interested to do is keeping track of right incrementing a counter whenever I see a four dot dot dot dot and then just like before slap a four loop around it repeat that experiment 10,000 a million times however many times you'd like and then keep track of how many times that four came up uh three or more times out of the seven rules okay so this is our event count how many times out of of the 10,000 in that case but it could be a million whatever it is the um we incremented our counter to be uh more than three more than or equal to three okay and then our value of interest is the probability of that happening so take that counter and divide by 10,000 because that's how many times we repeated our experiment okay so this is the code slightly longer and I've actually divided it into two parts this one up here and then this one down here so so the code up here is going to uh do the simulation 10,000 times so I've got one for Loop here that goes through 10,000 or a million however many times you want to repeat the the experiment within here sorry uh and I sorry I forgot to mention that here I have a function where I've kind of generalized a bunch of stuff so we could run it with different values so instead of SE three times out of seven Rolls we could have 15 times out of 3,000 rolls right so we can generalize this um so here um inside this for Loop I've got the simulation of rolling seven times right so here I've got range of n rolls in the previous slide I said it's seven but it could be anything you'd like and then I've got choosing one of the faces seven times and keeping track of how many times out of those seven I got a dot dot dot dot okay so at the end of this for Loop here I've counted how many times I got a dot dot dot dot and then I'm going to keep track of that number in this list how many matched so how many matched will be a list of 10,000 elements right 10,000 elements one element for each one of my experiments so the first time may be three dot dot dot dot dots came up out of seven then the next time one then the next time five then the next time four however many right so now I've got a list of how many times the dot dot dot dot came up out of seven rows so the code down here that's why I split it up because it's a little bit easier for me to think about it the code down here is now going to iterate through this list of 10,000 experiments and say which one of these is greater or equal to three this one this one this one so I'm incrementing a counter anytime that is true and at the end of this Loop down there I'm going to know how many times out of those 10,000 trials I had uh three or more times out of seven come up uh on the dot dot dot dot okay so I can run the code and here I've got the exact problem on the previous slide so if I'm interested in the probability of the four coming up at least three or more times out of seven rols that's and then I also down here wrote it like this and this probability is16 what is this problem down here does it look familiar so the probability of a dot dot dot dot coming up at least once out of one roll that's just the previous problem right on the previous slide I just have one roll and I count the probability to get the four okay so this matches what I got with my the previous function that I wrote but hey now I wrote a better function that can actually that's more General and I can also run it to get the probability that I from the previous code right so this is actually a much better code to run okay questions about this interesting I mean it's dice rolls how interesting can it be but yeah so let's look at a more uh interesting problem something that you might apply uh to you know to the real world so you might see this in a calculus course might not um but it is more of a calculus problem so I've got water that runs through a faucet at random somewhere between one gallons per minute and three gallons per minute this is the setup what is the time it takes to fill the 600g pool does anyone have an intuition for how we could solve this if not I can just click next yeah definitely between the lowest rate and the highest rate right so between 200 gallons per minute sorry between 200 minutes and 600 minutes right 200 at best if the water flows at three Gall per minute and uh 600 minutes at worst if the water flows super slowly one gallon per minute so we could say well let's take the average of the flow one the average between one and three gallons is two right so if we take 600 gallons divided by two gallons per minute that would give us 300 minutes it's a reasonable guess but that's not actually the right answer another way we could say is well let's uh take the slowest and the fastest it could run right so it could take so here I've got 600 minutes and 200 minutes and average those numbers out right divide by two so that's 400 minutes but that's actually not right either yeah you could yeah I don't want to do integrals though yeah but that's exactly the right answer yeah you have to do an integral and yeah I I I yeah we yeah we're teaching computer science here so we're not going to do integrals in this class instead we're going to do code and the code is going to be like five lines okay to do the to find the answer to this so all we're going to do is grab a whole bunch of numbers between one and three a million of them if you want these will represent a bunch of random values you could have the water flow right be and then we're going to say for each one of these numbers chosen at random how long would it take to fill the pool so you do 600 divided by that rate right just just just how long it takes and then we're going to average all of these rates right so we have a million of these numbers potential times that it could take to fill the pool sum them all average them this is the code it looks like a lot but down here the bottom half of this is just us reporting the results this is you know here's two print statements and here I'm actually also plotting what the what the uh what the dots look like right all the flow rates the actual code to do the simulation is these Okay I lied seven lines of code not five so I've got a function Phill pool it can take in a size parameter we could even do a lower range and an upper range if we wanted to for the flow rate for now we'll just hardcode it to be between one and three I've got two lists that I'm going to populate with a bunch of different random numbers so the flow rate R will be chosen between one and three so here I've got um random. random is another useful random function from the random library that uh gives me a number between zero and one so to get a number between one and three at random I'll just multiply by two and add one right so bottom case it'll be one top case will be 2 * 1 + 1 three right so R all we need to know will be a random number between one and three a float right so could be anything um append that random number to our list of of flow rates and then using that flow rate that we just randomly chose figure out how long it takes to fill the pool SI the pool of size size so size divided by the rate right just very simple math and then we now have a list uh that's populated with all of these times that it takes to fill the pool okay and that's the stuff inside the loop the for Loop here is one experiment right so I grabbed one random number I figured out how long it takes for me to fill my pool and then I repeated that 10,000 times right okay so down here I'm going to report the average flow rate which should be two right because if we're choosing a random number between one and three the average of those numbers better be two and then I'm reporting the thing that we're actually interested in which is the average fill time right which was not either of those two things we had the intuition for but it is the integral and down here I'm doing some plots so these are the things that I've plotted so on the left side I've got on the x- axis apologies I forgot to label my axes and put a title on this so I'm just going to uh talk about it so the x axis is numbers zero through 10,000 representing each basically like you know 0 1 two 3 four represents one of my experiments right choosing a random number and the y- axis is the random number that was chosen right so this is uh looks like a a nice smattering of Randomness here which is what we wanted and then for each one of these values I'm going to have a corresponding fill rate right so for example here if at Point z uh the fill rate happened to be uh one right then that means the time it took for me to fill the pool should be up there at about 600 right it could be that little point right there maybe okay so this is a graph of random numbers between one and three 10,000 of them Chosen and this is the graph of the corresponding times it took for me to fill the pool with each one of these dots that we randomly chose we notice that the plot on the right is not uniformly scattered right in fact it's more kind of densely populated down towards the bottom right so our two guesses were that the fill rate was either 300 or 400 on average right and neither of those were right um let's view these graphs in a slightly different way I'm actually going to sort the values so right now right it was just a random uh number gotten between uh one and three but I can sort them it doesn't matter the order that I got these random numbers I can sort them and if I sort them I get something that looks like this so again I've got randomly chosen numbers 10,000 of them and with equal probability right that's why we see this nice line I chose a number between one and three does that make sense okay and so then the corresponding time it took for me to fill my pool for each one of these numbers right is a number between uh 200 and 600 as we had guessed now the average of the time it takes uh of the fill rate is two which is true right that is not a surprise for us because it's a random number between one and three but the actual average time it takes to fill my pool is down here if I were to average every single one of these values it's down down here at around 330 so it's not 300 it's not 400 it's definitely between you know between those two but it's not really close to one or the other that's because I've got more points kind of dense more densely populated down towards the bottom than the top okay so the actual values that I got for 10,000 different randomly chosen numbers is 331 I think the actual value if we do the integral is like 329 something or rather so we're pretty close but then again we only did 10,000 we could do a million and we would get pretty close to the actual value right so it's not 300 or 400 and that's because as was mentioned from uh from one of your uh uh from fellow students there is an inverse relationship between the fill time right and the uh and the pool rate right so it's the size of the pool divided by the rate so what we actually need to do if we wanted to figure out the the value is to solve the integral between one and three of you know D DX overx whatever that would be right so I don't want to bother with that but I will bother with seven lines of code and then just wait you know wait five seconds for that code to repeat you know five million times or a million times or 10 million times right is that cool and this is totally within your reach right it's it's not hard code to do it's just for Loops it's using a a random library right to just randomly grab a whole bunch of numbers and then just knowing the problem at hand filling a pool you know at a certain rate um simple math and then you get a nice a nice answer a nice approximation but still an answer to the question so hopefully this shows you how powerful computation can be this is just another example of how you can just apply computation programming to a problem that you see in real life um if if you choose to do like a you know a europ or uh take future courses in in you know a different field maybe not in CS uh you will probably apply computation to uh uh Concepts and ideas and problems in those fields and it'll be something similar to this You observe something you try to think of it computationally model it with a bunch of uh you know Randomness and then uh calculate an idea uh something of Interest okay so that's the end uh of 6100 L I've got a little wrap up to uh remind ourselves where we've been and where we will go um so what did we learn oh also this is also these slides will be kind of like a meme dump of every remaining meme that I have okay so this is going to be very meme heavy uh okay so what did we learn we've got of course we learned Python Programming right we learned a lot of python syntax some lectures were heavier on python syntax than others but hopefully you've got a a handle on that we learned of course flow of control right with branches if statements L Lis L sorry L ifs L statements right allow us to either do one thing or another in the code make a decision Point um Loops four loops and while Loops as well as exceptions as a way for us to deal with unexpected things coming up in the course the ideas here flow of control um are actually transferable to any other programming language so you know if you know the ideas if you have the intuition for what kind of flow of control you'd like to use all you'd have to do is change the syntax and then suddenly you can write some code in another language of course we learned about data structures so we did lists right really useful data structures dictionaries super useful data structures tupal things like that so uh you can learn about more advanced data structures in a future course if you'd like but those are really the the top you know two or three most useful data structures um we talked a lot actually it was a common we didn't talk a lot specifically but it was a common theme in this class organization of code right so these ideas of decomposition and abstraction they came up a lot when we talked about functions that's our first introduction uh so functions helped us take uh some functional piece of code like some code that does something abstract it away into a nice little module right decompose it into one little module you have to write it one maybe write it a few times but debug it a few times um and then use it a whole bunch of times uh you know without worrying that it's going to change so it's just a very nice way for us to decompose functional pieces of code and then we saw it come up again when we did classes object-oriented programming right we were able to bundle behaviors and data together into one nice little object right that we could then create many of in many different parts of the code and then manipulate individually another common theme throughout this class was algorithms so we talked about B section search algorithm way at the beginning of the lectures right we talked about it in pet one and it came up again towards the end when we talked about complexity and searching and sorting algorithms things like that so that was kind of your own a big algorithm that you saw in this class but it shows you just how you can Implement you know some code in a completely different way to behave in completely different way right to be a lot faster you know with some conditions like being sorted things like that and then lastly the last part of the class was a little bit more Theory heavy we talked about computational complexity and that big Theta notation um so that gave you a sense of how to maybe design algorithms right so if you have a first crack of pseudo code on piece of paper you can see well H if I need to run this code on a really large data set it's not going to work because it's too slow right you've got three nested Loops or something like that so it might force you to rethink the design of the algorithm sooner than you know having already implemented it um but you know if you're dealing with small data sets maybe you wouldn't care that you've got three nested four Loops or you know a really inefficient recursion algorithm so that's those are the big uh the big things that we learned in this class your experience I kind of categorize in three different uh three different ways so you might have been a natural if you kind of joined this class and immediately got logic immediately learned you know knew how to do the problem sets that's totally fine I still hope you got something out of this class and you learned some some something you might have joined the class late right if you uh found 61008 to be too fast or uh too challenging you might have joined it uh joined it late kicked it to the curb and said let me join 100 L I welcomed you um we did a little bit of research and found that even if you join late it does not actually hinder your performance in the class so hopefully that was your experience um did you work hard so maybe you didn't get all the concepts right away maybe you struggled a little bit with the problem sets maybe you struggled a little bit on the pet uh or on the quizzes but I still think that you learned a lot and the test is always to go back and look at the first problem set so if you do that when you go home tonight you look back at the first problem set in this class you look back at the code that you wrote it will seem so easy I I promise you this and that's because I think you all did such a good job you tried your your hardest in this class I know it's not easy um I know it's slower paced but it's still not you know not not an easy easy class and I think you've learned a lot looking back at the first problem set we'll just we'll show you that for sure so what's next uh there have been some questions about what are some future classes that you might want to take or what can you do once you've you know once You' finished here here we go so we've got 600b is kind of the most natural Next Step it's a half semester class in the second half of the semester so there finishing up right now basically um it's an overview of really interesting topics in computer science and with a focus on data science though so what we talk and I actually run that class as well so what we talk about there is optimization algorithms so for example let's say you want to um create a schedule for your classes next semester and you will have some constraints right like you don't want to have classes at 8:00 a.m. or 9:00 a.m. or 10: a.m. or 11:00 a.m. and you want it to all be within you know some time limit or things like that optimization algorithm could be something that you write and you could just apply it to something that you have simulations uh exactly what we saw today of the you know the physics filling the pool thing uh you'll see more uh examples of that and ask different questions about it as well so you'll see things like um um you'll calculate you know things like standard deviations how many times do we need to repeat this experiment in order to be within some confidence interval right so how confident are you about your answers so we'll be doing more things like that and then there's of course the uh machine learning aspect of it so if you have uh a bunch of experiments that you do that you get a whole bunch of data from how can you fit a curve to those experiments and then you know for a future experiment what's the expected value right so that's a little bit of machine learning uh on experimental data and then some more machine learning in sort of a more classical sense is uh dealing with clustering algorithms and classification of of data and things like that okay so 6100b I know a lot about because right it's I also teach it it's a really good next class if if you want to kind of be employable for an internship if you take this I think you'll be good to go um 6101 is also a really nice class to take next if you really enjoyed the programming in this class 61 one will be your next step it's called fundamentals of programming and it is in Python that one has um it's it's pretty fastpaced so there will be problem sets every week and they're going to be pretty uh hardcore um there's going to be a lot of debugging involved in those problem sets and uh I actually was a recitation instructor for that class and to get a first um for the problem sets at least to get something working doesn't take that long but to make it work according to the specifications that they have will take a little bit of debugging and reworking that's because they deal with a lot of real world data so writing code that's really efficient is very important right so again writing you know nested for Loops of course we can totally do that but making it efficient using data structures like sets uh to make the code efficient using you know proper uh algorithms that are efficient is is very important part of this class but you'll learn a lot if you take this class you'll be very employable for an internship in some uh you know some some computer science or some computer science company um 6102 is also a nice next class if you're interested in software construction um it is actually in a different language it's in typescript these days used to be in Java um you can take what you've learned here and if you're interested in you know learning a different language this is a nice one to try it's their their their motto is you're writing code that is safe from bugs easy to understand and ready for change so they have also lots of problem sets but you're also working in a team so you get to learn how to work in a team um well with with other students how to code together um how to write code that has you know nice documentation is you know lots of debugging things like that so more of that those ideas of decomposition abstraction that we learned in this class will definitely be uh prominent in this class in 6102 and then of course we've got other classes I'm happy to chat about uh so machine learning is a a nice one if again if you have a handle on programming really well and want to try uh some just applying programming to machine learning an algorithms class is also a fine next step if you're more interested in the complexity part of this class that we saw um also very very reasonable things to try to to do next after this class okay um yes last slide if you're not going to code for a while but think you might code in a couple semesters or something like that uh like you know you want to take a more computational class in some desired field I would say that you should try to practice coding at least once a week so in our website we've got a little help um menu where you can go to we we've listed some other websites there's a little bit of coding practice you can do it doesn't need to be a lot 30 minutes you know once a week something like that just so you don't forget to code um can go a really long way because I know you know over the summer sometimes I don't code for a month or so um because I do other stuff besides coding in my life and um you know coming back into it takes a little bit of time and it's just without practice like with anything else it's just easy to forget and it's hard to get back into it so even if you just do a little bit of coding write a really simple program you know once a week it's it's going to go a long way right so that's that's it I want to thank you all for being in this class and thank you for coming to this last lecture I know you didn't have to but I I do appreciate it um happy coding and you know good luck with exams and have a good break everyone thank you