all right let's let's get started so today um we're going to be starting a completely new set of topics and we'll be talking about these topics for the next four lectures and it's a big topic um the big idea we're trying to accomplish in these next four lectures is for us to start defining our own object types okay and we'll be um we'll be uh defining these object types through these things called python classes all right so today's lecture we'll just give you a a really we'll just Define a really simple object type and then we'll build up from there on so let's take a step back and think about uh particular objects like really specific objects that we've been working with so for example we've been working with probably the number 1,234 we've been working with the float Pi 3.14159 we've been working with sequences of characters like H with um lists of numbers right so here's a list with those specific uh elements within it and we've been working with dictionaries and here's a a specific dictionary with these entries now every one of these things up here is an object right we have it in our program we can manipulate it we can add it to other things we can index we can do all these things but every one of these objects is basically has a c a certain type right we talked about this back in lecture one when I introduced types of objects um so what does that mean well in that lecture I said that the type of an object basically tells us the kinds of things that we can do with it right so the things you can do with a number are going to be different than than the kinds of things you can do with strings and we've been seeing this uh you know since that lecture up until today today we're going to see how we can create our own object types so to do that we have to understand uh the following thing and this is something I'll keep repeating today so once you uh decide to create an object type or every one of these objects for example has been created using some blueprint right and when you're creating these objects you need to think about two things the first is what data will represent this object and the second is what behaviors will this object have now the objects up here are pretty simple right the kinds of data that represents you know this integer is well there's no data really it's just the number itself but you know it has some operations some things that you can do with this integer now the the data that represents a list is going to be different than the data that represents an integer because a list is kind of made up of a sequence of num numbers or you know objects and then the data that makes up a dictionary is completely different than the data that makes up the list because a dictionary has entries where each entry has a key and a value pair and then you have a bunch of these entries right so the data representing each one of these objects is different and we're going to decide what data represents the new objects that we want to create and of course this is something we've known from the uh first lecture the kinds of ways that we can interact with these objects is also different amongst all these different object types right so in terms of a terminology when we create an actual object that we want to manipulate we call it an instance of a type so this specific number 1,234 is an instance of an integer and this specific uh sequence of characters lowercase h l o is an instance of a string okay all right so the idea of object oriented programming is basically that everything in Python is an is an object and this we've talked about when we were introducing functions we treated functions like like objects and what that means is uh it's that we can create new objects that have some type so we actually create these very specific objects that we can manipulate and we can also destroy the objects right so you can create them manipulate them and Destroy them as you will but each one of these objects has a specific type so let's talk a little bit more about uh the data abstraction so once you have an object that you'd like to create so think of you know anything in in in the world right some some some thing um the two things that you need to think about are what is going to be the way that you represent the object in terms of data right and the other thing is what are the behaviors of this object how can other programmers or other objects interact with this thing that you're creating so when we're creating our own object type we have to think about these data abstractions okay so let's take a more sort of real life example so let's say I have these two very specific specific cars that actually you know exist in the real world so we can actually you know Drive these cars around we can manipulate them right they have already been created they are actual objects right well behind the scenes these objects were created using some blueprint right this this blueprint is not an actual tangible thing it's basically some abstract notion of how to create those specific objects those specific cars so as we're thinking about creating our own object types we have to think about design decisions right if I want to create a blueprint for a car that somebody can then use to create an actual car in real life how do I abstract the car and as we're creating these objects ourselves we get to make these design decisions which is pretty cool so if I were creating this car right the blueprint for a car I would say well I'm going to use maybe the length of the car the width of the car and the height of the car and the color of the car and those four data attributes will represent a car object but of course that's my design decision right if you are more familiar with cars or if you wanted to get into a more detailed description or um representation you would also uh you know have uh a number for how many horsepowers it has how many doors it has maybe how many people it could fit you know other things like that but a very simple uh data abstraction for a car is length with height and color all right so that's data abstraction so what data represents this object you're trying to create now how about the interface well in terms of the interface we decide what are some ways that programmers can interact with the object or other objects can interact with this object so we could say that we could um let the users change the color of the car right we could say um that we can uh let the car you know make a noise so honk the horn could be maybe one you know thing one function that this car could do and if we say honk the horn then maybe you would print something to the screen right something like that and then we can have the car drive from point A to point B or we could have the car you know you know go in a a circle you could have the car crash another car and all of these behaviors will are are part of this uh of this uh the interface uh for this particular car but we're going to Define them such that any car that we create from here on any actual object that we create will have all of these behaviors and all of these data attributes Okay so so an example a little closer to home is the list right we've been working with lists so far so behind the scenes somebody created the data type list right so there's some code in Python that basically defines the data that makes up the list the data attributes how is a list described and the behaviors the procedures the functions that a list can do right so in terms of data attributes well there's many design decisions that you know whoever decided to create this list class could have done how could they have represented the list well they could have said I'm going to allocate sort of a contigous block of memory and where uh and your elements will go in that order right from the smallest memory uh value to the biggest memory value that's one design decision another one could be that instead of allocating sort of a contiguous block of memory you could say oh I can allocate memories here and there that's okay but then each element in my me in my list will then be represented by two things the first being the value at that location and the second could be maybe another integer or something that tells python which memory location to go to to get the next element in the list so both valid design decisions I think python did the second one um right so those are that's how you represent a the uh the data that represents the list and in terms of behaviors well we've already been working with lists so we know a bunch of the behaviors that lists have right you can index into it you can sort a list you can append an item to the end of the list you can get the maximum element within the list all of these different uh procedures functions are things that you can do with lists right and we've been working with them and we've been working with lists without actually knowing the representation how somebody uh decided to represent this class okay which is pretty cool so a couple more uh real life examples right if we were to think about representing you know one of the each of these so if we think about the object in elevator right again it's up to us to make the design decision it's basically a box that can change floors right so we could represent it using the length the width the height maybe we could also repres which are all you know Floats or something like that we can also represent it uh using the Max Capacity and the current floor it's at so all five of these variables you know together values together represent my elevator right and again it's my designed decision to do this yours might be different and in terms terms of um things that the elevator can do well we can change its current floor which is basically saying you know change the value of the variable current floor to be something else um add people to it maybe checking if you're at Max Capacity or not then you know maybe printing out a warning if you're above that removing people things like that an employee is also a pretty common example uh of something that's typically implemented in a bunch of programming languages so an employee basically a person that has a salary right maybe works for company X so you could represent this employee using uh their name right maybe a string for the first name a string for the last name and then their birth date maybe um and then their salary which is you know a float or an inch something like that and in terms of behaviors what Can employees do well you can change their name you can change their salary you can maybe activate or deactivate them as current employees things like that a Queue at a store also a really nice example and it's kind of goes hand inand with a stack of pancakes um how would you represent a que at a store well the representation isn't going to be a set of things the representation could be something really simple like just a list right which is fine so maybe the list will have you know some strings with the names of the people who are currently in the queue at a store but what's going to make a queue kind of special is that is the way that um we'll be using it right so the representation isn't super unique it's just a list but the way that we um the way that a que operates will be special because if you think about the que the first person who comes into the queue will be the the first person out of the queue right a first in first out kind of situation so that means if you make the design decision to add new people at the end of the queue right so if I have a new person that gets added here they're the newest person in that means if I'm removing a person from the queue I better remove the oldest one which is going to going to be over on the at the first at the beginning of my list right so the way that you use the queue will be consistent with this idea and then you know people and then you can basically simulate the queue and the stack of pancakes is very similar if you think about pancakes the um the first one you made is the last one you eat right so it's a first in last out of kind of situation so that means that we can still represent a stack of pancakes using a um a uh a list right so the representation the data representation for a stack of pancakes will be the same as uh as a q except that the behavior will be different right because if I just made a new pancake and it goes at the end here right the newest one that I made is the first one that I'm going to eat so if I add I if I add a pancake to the end of my list I'm going to remove the pancake that I want to eat from the end of my list as well okay so the idea of objectoriented programming and the reason we're doing this is because now we're bundling basically data and behaviors into one thing and so we can create all of these different objects that have the same type that all are going to function in the same way we know they're going to be consistent right they're going be they're going to be consistent in the data that represents them and consistent in the way that we use them right so Q right we we know for sure that the Q is going to be a first in a first out kind of situation right um and the way we're going to implement this is using these things called python classes and the reason we create these python classes is to make code that's very nicely reusable we can create really simple python classes that we'll see today and then we can build upon these python classes to create more complex classes which we'll see on Wednesday but the big idea here and this is something that I was a little bit confused about when I first started and you know learning about objectoriented programming is you get to be in charge of the design design decision right so you get to decide what data represents the class and you decide what behaviors represent the class so if you wanted to say that you know you represent a queue using a list right first in first out if you add items to the end you remove items from the beginning that's one design decision another design decision could be well you still represent it as a list but new items get added to the front but to be consistent with the idea of a cue that means you remove items from the back and then the behavior is the same right we're implementing the a queue no matter which one of those design decisions we've made okay so as we're going through today's lecture I want to make a note of a couple things so I've got these little tabs up at the top here um we're going to be basically switching our brains a little bit today we're going to be dis defining a python object right so we're going to be writing code that tells python hey I am telling you I would like to create this object type okay and these are the you know data these are the this is the data that represents them it represents it and these are the behaviors that represents it so that's uh us implementing the class so telling python that we are now creating and telling you what one what an object of this type is and does and the other thing is once we have a definition for this object type we're going to actually use the type right we're going to create new object of this type so when we're creating the class when we're telling python that an object like this exists we're deciding the name of our class we're deciding what data AB abstracts it we're deciding what behaviors can we can do with it right so if we think about the list we haven't actually seen the code to do this but someone wrote code to Define this list class now we using the class means that we're assuming that this code already exists right and you're just creating a whole bunch of objects of this type so we've been doing this definitely right if we think about the list class again here you know for example we created an actual object that we can manipulate right L is equal to 1 comma 2 we've also created L is equal to three comma four comma five and all these things right we're basically creating these instances that we can manipulate and and and use in our program to achieve something useful and today we're going to see how we can do both of those things I want to draw a little parallel with functions because it's going to feel very similar right and with functions when we uh when we were defining a function we were telling python that I would like to uh you know abstract some code that does something useful using this class using this function definition right so we were writing the definition for the function in this uh abstract way we didn't actually run the function at that point right we just defined it and so when we define a class that's basically what we're doing we're telling python that we're creating this object that bundles data and behaviors together okay um when we create an uh instances of of this data type that we're uh that we're going to Def Define that's kind of like we uh called the actual function that we defined right so when we called the function we were now doing something useful in our program right we said here are some actual parameters I want you to run this function with now tell me what the output is okay and that's exactly what we're going to do when we create instances of the of the data type we're def defining we're now creating actual objects that we can manipulate and and use in our class okay so the object we're going to uh create in today's lecture is a coordinate in a 2d plane okay pretty simple pretty mathematical so before we actually uh write the code let's kind of think about what it actually means to put a coordinate in a 2d plane so we're going to think about if we had a bunch of instances right if we had a bunch of coordinates in a 2d plane what do they look like what kind of data are we interested in you know grabbing from these instances what are some things we can do with it so here I have a point in my 2D plane so if we think about how we uh look at this uh at this coordinate well we know how far away the coordinate is on the x-axis and we know how far away the coordinate is on the y- AIS right so that's one instance of a coordinate object now let's say we had another one right here's another dot in my 2D plane again this dot will also know how far away it is on the x- axis and how far away it is on the y- AIS okay so one reasonable uh data abstraction for a coordinate in a 2d plane could be to say uh I want two numbers one representing how far away is is on the x axis and one for how far away it is on on the y- axis right that seems pretty reasonable I don't care about color right even though I colored these things but you can imagine making a a AC cuter version of this coordinate object that also has a color associated with it okay so the data that will represent my point in a coordinate plane in a 2d coordinate plane is just two numbers right one for the X one for the Y now what are some things that we can do with these coordinate objects certainly something really simple we can do is to to say Well Point uh you know one of these points you know the orange one for example tell me how far away you are on the x-axis or tell me how far away you're on the y- axis right so those two commands could return you know something like three for that's how far away that point is on the x- Axis or four for how far away it is on the y- axis um those are pretty simple things to do one more interesting thing to do is to say well hey you point Orange Point right over there can you tell me how far away you are between the Green Point right so that would be the ukian distance between these two points and we're going to write a code that uh figures out how far away one coordinate object is from another coordinate object okay all right so let's start defining this class coordinate we're going to you can see here this is the code that implements the class so this will tell python that we are now uh creating this object type coordinate okay so we're not using it yet we're not creating any object object s any object instances we're just telling python that we'd like to create this object type so we start with the keyword class right uh in parallel we started with a keyword DF to define a function then we say the name of our object type so this will be literally the type of the object so coordinate just like we had list int float you know all those things this will be of type coordinate and then in parenthesis here we say the parent of this class so usually usually we say object until two lectures from now when we're going to see what happens when we put something else in there but when we put object in the parentheses there we're telling python that anything a generic python object can do our object can do as well so something really uh uh really basic is saying that I'm going to create this object in memory and assign a variable to it so that I get a handle for that object using this variable right something super basic any python object has this ability and ours will too because I've put this object in the parenthesis here okay all right so now we've told python we're creating a data type called coordinate what are we going to fill in the body of this class so the things we need to fill in are going to be our attributes okay now again what makes up an object two things the data that you want to represent this object with and the procedures AKA functions AKA behaviors that you'd like this object to have okay so the data will be uh two things right we decided that we're going to represent a coordinate using two numbers okay now what about behaviors behaviors will essentially be functions that work with objects of this particular type so we're going to Define them as functions but we're going to Define them in a really special way that tells python you can only run this function on an object of type coordinate which makes sense I would not like to find the distance between you know two integers that's just subtraction or I would not like to find the distance between two dictionaries what does that even mean right so distance method that we uh mentioned is one thing we'd like to implement will only work with objects of type coordinate okay so uh these special functions are actually called Methods okay and I'm going to use this term a little bit today hopefully you get used to it and then from now on from there from next lecture on I'll just use the the word methods to refer to functions that only work with objects of this type okay so we so far in the previous slide had class coordinate object now what is the next thing you have to do so the the next thing you always have to do when you tell python you're creating a new data type is to tell python how you want to construct this data type okay kind of a Constructor uh a Constructor function and the way way we do this is by defining so you can see we're defining it like a function DF but we're going to define a function that's has a special name and the name is double underscore init double underscore okay so that's the name of this function and you can see it's a function DF name and then parentheses and there's a bunch of stuff in the parentheses the first thing will be this thing called self so already it's going to be a little bit different than regular functions now I'm going to uh uh this is not the only time I'll explain self I'll explain it um you know throughout this lecture but the basic idea of self is that it's always going to be the first parameter of a method right a function that only works with an object of this class of this type and the reason why we have it here is because all we're doing here is telling python that we'd like to create this object type we don't have an actual object to manipulate right I haven't created an actual object yet I'm just telling python I'd like to create this object so if I don't have an actual object created yet I need some way to refer to an instance without actually having one yet and that's what the self is doing right it's basically a variable that tells python that this is an object of uh that this is a a function that only works with an object of this type and I'm going to use this variable self to refer to this object myself my data attributes and my methods and things like that so will become clear there will be many examples but for now it's basically a way for us to refer to an object of this type uh an instance of this type without actually having created one anything after Self is basically uh parameters you'd like to create this object with so for us it doesn't make sense to say uh create this coordinate object without actually initializing its X and Y values right when we put a coordinate object in a 2d plane I would like to put it in that 2D plane so it needs an initial X and initial y value okay so these parameters here will tell python you need to pass in a value for x and y when you create your object and then the body of this in it will have whatever you'd like whatever code you'd like to initialize your object yes question is like the way you the underscores is that of write the underscores is part of how you write it so you have to have underscore underscore in it underscore underscore yeah it's a special function we'll talk about them next lecture it's called a Dunder function double underscore function Dunder okay okay so the body of this function can contain a bunch of initialization codes so anything you'd like to initialize when you create an object of this type that's what you stick in here okay usually most of the time 99% of the time you want to initialize the data that makes up your object right so the data we decided makes up our object is how far you are in the x- axis and how far away you are in the y- axis so here this data that I want every single one of my objects to have a value for x and a value for y is initialized using self dot right so self dot a variable named X and self dot a variable named y and the self dot before these variables distinguishes these variables X and Y here from regular variables right if I were to just say x equals x Val and Y equals y Val X and Y will just be regular variables as soon as my init function terminates those variables are gone but because I've got self.x and self.y this means that these values X and Y will persist throughout the lifetime of my object when I create my actual object object and every single object I create will have their own X and Y values question yep good question does this uh self do thing have to be different uh it does not have to be so you can have self. XV Val equals XV Val and self. yval equals y Val the reason I did it here is to Showcase that they actually do not have to be the same yeah they are completely different right so self.x is different than x value we're just happen to be assigning this value to be whatever is passed in okay so a little bit of a a kind of again just kind of explaining what the self is in the context of a blueprint so if we think about a blueprint in real life right so here I have a blueprint for a a room that I might want to create I don't actually have this room created yet right it's just an idea but what I know is that I'm going to use this blueprint right uh uh to have uh uh to have a room that contains two chairs a coffee table and a sofa right so in this blueprint I don't have actual rooms that I've implemented you know this this thing in I don't have actual rooms where I've put two chair chairs at coffee table and a sofa in it's just an idea but self is uh is kind of the way that a blueprint accesses its attributes right so I've got if I say self. coffee table that means if in the future I have an actual room self. coffee table means I'm referring to that room's coffee table okay so the the self is a variable that we used to refer uh to data or to attributes for uh for a blueprint when I don't have actual rooms created but once I create instances of rooms right so for example here I I have something called living room created right so I've taken my blueprint and now somebody asked me to create a room with this blueprint right now I no longer use self because I have an actual room in hand so now I would refer to coffee table in this living room as living room. coffee table or living rooms coffee table right no longer self's coffee table so self is only used in the context of my blueprint okay and to sort of find bring the the last Point home the idea that with the blueprint you can create many different instances well here's a living room that I've applied my uh blueprint to and here's another living room completely different room that somebody asked me to use my blueprint for to create it different chairs different coffee tables different colored you know things these are all different instances that I Ed my one template my one blueprint for the room on okay so when we're defining the class we don't have actual objects right again that's just kind of a really big idea here we're just telling python I'd like to create this object and this is what it looks like I'm bundling this data with these behaviors together but I don't have actual objects of this type created yet so let's actually create some objects um the code that does this is as follows so I've put the definition for my class uh the Constructor the init method for my class up here just to remind us what it looks like and with that code we can now start to create actual objects that we can manipulate so when we created something like you know L is equal to one you know square bracket lists one comma 2 now I'm creating these actual coordinates in my code using my blueprint so the way we do that is we invoke the name of our class so you say coordinate that's what we named it right that's our data type and here I'm passing in every single parameter except for self so i initialized a a a cordinate object using xval and yval so I need to put in two parameters here for xval and yval and self actually becomes this thing that I just created this object right so coordinate 3 comma 4 is now an object that's being referenced by variable named C and which is why I'm not passing in itself so it's kind of weird to think about but now I have one object in memory it's referenced by name c and on the next line I have another object in memory right again I've invoked the name of my class coordinate the this particular object x value will be zero and Y value will be zero so different than the than the the one I just did on the previous line but it'll have the same structure right so they will both have some X and Y value they'll just be different from each other right but they'll both have X and they'll both have y the one I've named down here is going to be origin okay so I've got two objects of type coordinate one is referenced by C by name c and the other one is referenced by name origin okay so now now that I have these objects in hand I can access any of their attributes and python will grab for me the attribute of that particular object so here I've got um this thing called dot notation which we've seen before and I'll I'll explain it again in a couple slides but the dot notation tells python to access the X data attribute of object C so this will grab for me the x value of c three right and the next line will grab for me the x value of origin zero and this is all made possible because X and we could also access Y X and Y were defined in the class definition using self dot if I didn't use self dot those would just be variables and as soon as I created my object they would have gone away because that function had terminated but in order to have these variables X and Y persist throughout the lifetime of my object I've defined them using self.x and self.y right so any object I've created that's of type coordinate will have some value for x and some value for y right so we can access that value through this notation does that make sense so far is that all right okay so we're going to visualize this in a a slightly different way so the exact same code AS on a previous slide we're now going to do it in this in our little um memory sort of type so here I have C is equal to coordinate 34 exactly what I had on the previous slide so in memory the way you think about it is you know as we've they've been thinking about other objects so it's not much different we have C is our name right and it's bound to an object of type coordinate it just so happens we Define this object but it's the same idea I've got a name bound to some object and this object has its own XV value and its own y value okay so when you evaluate c.x python goes into memory it says hey what type is C and it says oh it's a coordinate object does coordinate object have a data attribute named X yes it does because it looks at the init and then it says well what's its value it's three and so it just returns that and so uh the the the next three lines here are slightly different from two slides uh two slides ago but very similar a is equal to Zer creates for me a variable named a bound to the value zero right just to Showcase that it's exactly the same as having a variable named C bound to this object that we created and then when I say orig equals coordinate a comma a python says all right well here's a name orig for origin what is it bound what is it bound to well it's also bound to an object of type coordinate and it's an object we defined so we defined an object of type coordinate having an X and Y value so here they are and they're originally zero they're set to zero when I created this object so when I say orig dox python will look up orig it's going to say hey what type are you oh you're a coordinate do you have an x value you do that's what we Define in the init let me grab that value from you okay so we're just manipulating objects in memory right now that we've written the code to uh to work with objects that we created we're just creating a whole bunch of these objects in memory and then you know grabbing their X values and then we're going to get the distance between two objects in a bit one more way to kind of show you that exact same code is to visualize it so here is the code all the the entire code as you would have it in a file right so you would have all this all together the gray box is the definition for my object type and the blue box is me using this object that I just created okay I've just separated that out just for clarity so when I have my gray box there's nothing to display right it just sits in memory uh and python knows of this type of class cordinate that has two data attributes the things that I've defined using self dot right X and Y when I create C is equal to coordinate 34 right visualizing what we're trying to do here here I've got this object whose name is C and it's at three comma four and then I've got this object named origin and its uh X and Y values are Z comma 0er so because I've created these objects using the same blueprint right the coordinate blueprint that I've defined up in the gray that means every object that I've created C and origin has a self.x and self.y value right it just so happens that the actual values for X and Y are different between these two objects right okay so when I grab or originx I'm looking up origin and I'm grabbing its x value zero right just another way to visualize it okay is everyone okay with these data attributes all right so now let's add a method right so a method remember is just a function that works with an object of this type okay so the way that we tell python we'd like to create a method is by passing in self as the first parameter so let's create this uh function named distance if you look in the actual python code for today I've got uh two more functions one to get the x value of this current object and one to get the yv value but those are not as interesting this distance one is interesting though so I would like to create this function uh that only works with an object of type coordinate so what we done so far is this these lines up here so now we've got DF again it's just the function so we've got def name of it distance and then the parameters so again since this is a function that only works with an object of type coordinate I need to put self as the first parameter and this self will help us refer to the object when I call the method on it right so so if self is the first parameter that means that this distance method will be called on self so when I call when I have an actual object in hand that I'm calling distance on the self parameter will take on the value that is that object we're going to see this in the next slide okay so self is the thing that I'm calling this function on and then what other parameters do I want to uh take uh give to this function well I want to find the distance between myself so this object that I'm going to call distance on and another coordinate object now other than maybe a dock string here that says hey warning other should be a object of type coordinate there isn't really anything that that enforces the type of other when you make a function call when you make a method call right so you can call this distance method with other being an integer right which is not an object of type coordinate the code will run but will immediately crash because of what's going on inside so the only way this code will work is if you're calling it on an object of type coordinate for the other okay so the reason for that is because well when we think about grabbing the distance between two objects that are coordinates in a 2d plane we uh take the difference between the X values Square uh square that take the difference between the Y values square that right Pythagoras add those two together take the square root so if I'm calling this distance method on an object of type coordinate I.E self how do I grab my's x value well I just say self.x right my x value what is it and then I would like to subtract that from the other coordinate object's x value what's my other coordinate object it's the thing that I'm passing in as a parameter so grab their x value so if I take self.x minus other dox python will grab my x value subtracted from other's x value square that we do the exact same thing with Y right grab my X Y value subtract it from others y value square that and then the rest is just Pythagoras add those two and take the square root I take it to the power of a half okay and this function is just a regular function other than this self being the first parameter and us working with you know data attributes of myself and potentially other um parameters but you know you can see it returns a value it has the DF a name and things like that so the way we're going to use this method that we just wrote is using the dot Operator just like we accessed a data attribute of a object that I created I can access a procedural attribute I.E a method of an object I just created so we use the dot operator for this the thing before the dot is the object I would like to call the method on dot the name of the method I'd like to call and in parentheses it's just a function so I need to give it any parameters this method expects now this should look very familiar we introduced dot notation when we worked with lists right remember that and I said when we work with a list right you for now have to remember why we use this special way of writing this this function but it was the same idea the thing before the dot was the list I wanted to apply the function to right so my list is the name of a list variable I wanted to apply the function append and it happened to take an integer as a parameter okay and same with you know sort here is also another one but this one didn't take any parameters but it's the same idea the dot notation so in terms of our class here I've got two coordinate objects right and I've got a DOT notation being used here to find the distance between one object and another one so the thing before the dot is an object I would like to use the distance method on pick one of them C dot distance the name of the method I'd like to call and in parentheses I've got another coordinate object or rig so here I am using the class right and I've got actual values right actual objects that I'm manipulating right C and orig okay so this might look a little bit weird but when we actually call the function remember we omitted self when we uh when we omitted uh sorry we omitted self when we made this function call but that's because self implicitly becomes the thing before the dot the thing you're calling this method on okay so let's visualize that in our memory so here I've got my class definition for a coordinate it has some data attributes and some procedural attributes I've got uh the these two objects being created C is this object of type coordinate or rig is this object of type coordinate they've got different X and Y values but they both have X and Y some X and Y values when I make a function call to C uh to uh sorry a method call on C python says all right let me look at this thing before the dot what is it it's an object of type coordinate okay then it looks the method you're trying to call distance it says hey does coordinate have a distance method defined why yes it does we just wrote it and then it says all right well let me call this distance method it's going to set self as C the thing before the dot and any other parameters will be set in order to whatever is being passed in here so or rig will become the other parameter for my class from my definition for that function okay so this is just the conventional way of calling methods and it's the way we've been working with lists and dictionaries and things like that so again we've got some object the thing before the dot some method to run and when we call it this way the thing before the dot becomes self in our class definition right in our method definition and then all the other parameters become assigned one by one right everything except for self now to sort of demystify this I would like to show you what this is actually equivalent to so we can run the function the method that we defined using by by actually passing in a value for self right if this is more if this is clearer to you so in that case the thing before the dot cannot be an object right because if it is an object of the type coordinate then python will say well this is the object I'm running the distance method on so to demystify this you can actually invoke the name of the class right the object that you're trying to create the name the data type right coordinate and then python says oh I see you're calling the name of the class it's not an object so then what do you want from me okay the thing after the dot says I would like to run this method on you but now it needs all the parameters in the parameter list including self so here I would set you know I would have to give it explicitly C comma 0 instead of just zero because the thing before the dot is the name of my class not an actual object like it is on the side so this is actually the conventional way to do this right this is the shorthand the pythonic way to do this but this hopefully demystifies the self deal and the way um we actually you know set that first parameter to the thing before the DOT all right yes question yeah exactly if there's more parameter just pop in those extra ones with commas just like a regular function right so this dot operator basically accesses either our data c.x or our methods right c. distance whatever or whatever method name we have right so that's it uh for today's lecture next lecture we're going to build on this coordinate object by creating circles and then we'll create some fraction objects and um we'll look at some other way some other objects that we can uh bundle together okay