all right let's begin today's lecture so last class we began our adventure with creating our own data types today we're going to start off with a little bit of a recap just to remind you um some of the details about creating our own data types and then going to build upon that uh coordinate class we started in last class we'll build uh we'll build a circle class and then we'll build some fraction data types all right so the first thing I'd like to mention is to uh remind you guys about sort of um writing code from these two different perspectives right so just like when we wrote uh uh functions we were kind of writing the definition of the function telling python we have this function that we're defining abstractly and this is what it does and then we were calling the function later on in the program many many times well the same thing exists uh the same idea exists now that we're creating creating our own data types we have to write code from the point of view of somebody who's implementing the class so deciding all of these details that goes into creating the class itself versus somebody who's just using a class that's already been written where we create instances a bunch of different objects that just happen to be this data type so when we implement the class um what were some of the things we did well um we're telling python that this object now exists we're telling python the name of the data type that we're creating something we choose we're deciding um we're making these design decisions where we decide what attributes make up our class so the attributes are either data like the properties what are the variables that make up your object and the behaviors through methods right um so that's implementing the class and then when we're using the class we're now saying all right let's assume that this class definition exists there's this object that has these behaviors and these data attributes let's now create a whole bunch of objects that are of this type and this is when we're creating these instances and then manipulating all of these instances by running methods on them things like that so when we're implementing the class right this thing on the left hand side we're basically um uh telling python in abstract terms Ms what are the common properties and behaviors of our data type and then when we're using the class the thing on the right hand side here we're creating actual objects with very specific values for their data attributes that we can manipulate in different ways so let's remember this coordinate class that we wrote last lecture okay um this is not new so but I will just go over it real quick so first line here tells python we're creating a new data type its name is coordinate and this keyword class tells python we're creating the data type the parenthesis here is object which stands for the python object data type so it's something really generic um and this in the parenthesis here is the parent of our class right so anything that a regular python object can do the very basic things our class can do as well last lecture I mentioned an um an example of such a basic thing is to take a variable name and assign it to an object typee that we create the very first method that we should write for a new data type that we create is the init method and this I uh called a Dunder method because it starts with double underscores before the init and double UND and ends with double underscores after the init and that's the actual name of this method double underscore init double underscore okay um so this method is like a Constructor for the class it tells python how do you create an actual object of this type so it's it's a function uh it's just a function that works only with objects of type coordinate so as a function it takes parameters um you can see it takes three parameters here the self the X and the Y now when we're actually creating objects of type coordinate we only pass in parameters for everything other than self because self is a variable name that we use to describe cribe having an instance of the class without actually creating one yet right because remember what we're doing here in this definition we're telling python that this object type now exists we're writing it as we speak but we don't have an actual instance to manipulate yet right this is just the definition and so the self tells python that when we're writing this code we're going to use the self variable name as sort of a formal name to be able to run this method on okay so we're going to see in the next slide exactly how what what maps to self when we run it but that's what the self means inside the parameter list here and here and then beyond that we use uh self within the inip method to tell python which one of these variables are actually data attributes versus which of these variables are just plain old variables as we've been working with so any variable that's defined using self dot so here I got self.x and self.y are data attributes so that means any object I create that's of type coordinate I know will have a variable X and Y associated with it right because I've defined these X and y's using self.x and self.y now in the last lecture I actually had these parameter lists list the parameters in this list here be different than X and Y I think I had X Val y Val um and then I had self.x equals x valal where this x here to the right of the equal sign is the X from the parameter list right but you know so in that sense it doesn't matter what these variables are in the parameter list they're just going to be the same over here on the right hand side of the equal sign okay but the actual parameters the sorry the actual data attributes are self.x and self.y of my object right okay so then we had one method that we wrote last lecture it was called distance and it took two parameters so the first one of course is self and this self represents the thing this object that you're going to call the method on I don't have that object yet so I'm just calling itself for now um because this is the class definition and then this other parameter is no some other coordinate object that I'm going to run this method on so the body of distance says all right well how do I find the distance between two uh points in the 2D plane it's just Pythagoras right so that means grab the x value of one of my points subtract the x value of the other point Square them same with the Y's Square them add them take the square root so what's the x value of one point well one of the points is going to be the thing that I'm calling the distance method on self so I grab the x value of self using this do notation self.x and then what's the x value of this other coordinate point well it's called other in my parameter list so I'm going to grab the x value of other again using do notation okay and then we just do the math [Music] yes yeah so you can make methods you can make methods for a particular class right but like you can only call those functions that you define call exactly yeah yeah yeah is there a way we could define a class as something other than an object a class is something other than an object right we put coordinate and object something else in the parenthesis yes we can put other things in the parentheses so that's actually what Monday's lecture will be about in that case the thing in the parentheses becomes the parent of the class that you're currently writing so I won't go into too much detail but to to have this other object as a parent means that everything that that object can do automatically your object can do as well and then on top of that you can decide a bunch of additional stuff your new object does but in a sense your coordinate object is a whatever this thing in the parenthesis is and then it can do a bunch of other stuff as well yeah simar how we yeah how do that oh to make a copy of the object or a copy of the class oh so here we're not you can't make a copy of the class here specifically because we're just defining the class but when you're creating coordinate objects then you could Define a method that copies your object into another object so in essence it would return a new object of type coordinate with whatever parameters you'd want to do yeah so all yeah all these things are are possible yeah so let's add one more method to this class let's call it 2core origin okay so this distance method just to remind ourselves returned a number right so it just took the difference between these two points and it returned a number just how far away they are but this two Origin method is going to do something slightly different essentially what I'm going to have this method do is to take my point from wherever it is in my 2D plane that it has been initialized to and say I'm going to reset it back to the origin right so to do that all that means is I'm going to make its uh x value and its yvalue be zero so I can manipulate the X and Y data attributes of this particular object to be whatever I want them to be so I can reset them both to zero so if I ever call this method on an object whose X and Y values are something other than zero they'll be reset to zero okay so let's actually uh run the code that that we just wrote so here I've got two coordinate objects being created so the beauty of writing this class for us is that now we can create as many coordinate objects as we'd like they all will have an x value and a yvalue associated with them it's just that the specific values for X and Y will be different right so here I've got a coordinate object with X3 and y4 being created and it's going to be bound by the variable named C and here a coordinate object with X and Y values both zero bound to a variable named origin okay so then I can use this dot notation that we talked about last lecture to access either data or to run methods on the on on the object so in this print uh print F uh statement here I'm using dot notation on C and origin to grab the X values of c over here and origin over here okay and then I'm running the distance method on C so remember dot notation says the thing before the dot is going to be an object the thing after the dot is going to be the method name that can run on this object of type whatever this is coordinate and then in the parentheses it's just a function we just pass in all the variables that that option that that method expects right so C do distance will print whatever you know however far away it is I no five because those are nice numbers okay so then if we run this function that we just wrote to origin this function just to remind you doesn't actually return anything right it just resets the variables X and Y for that particular object back to zero so in here when I call um this method here right again dot notation the thing before the dot is an object it's C its X and Y values are currently three and four but after I run this function it returns none by the way its X and Y values will be changed to zero and zero so if I look at my code here right so here's this print F statement right so C's x value is three and C's and origin's X is zero fine um and then I've got these two calls here so c.2 origin right I'm making this function call before the function call C's X is three C's Y is four and after the function call you can see C's X is zero and C's Y is zero so I'm literally changing the X and Y values of this object C okay all right so questions so far so far so good hopefully a recap okay so again sort of similar to the first slide we started with right so we've got this class coordinate object right the class name is our type so this object I'm creating is of type coordinate um we're defining the class in a generic way in an abstract way right so we have to use the self um uh variable either in the parameter list to tell python what's the thing before the dot going to map to well it's going to map to self in my parameter list or we use the self to tell python what the data attributes of this object are right so anything defined with self dot some variable uh name will be a data attribute that's common across all the instances I create so from of this type when we create actual instances that's when our uh our blueprint our abstract definition now you know gets put into use and now I'm creating actual uh objects that I can uh grab X values from change X values from you know get distances between other objects and so on and so on okay so what I'd like to do next is to um take this coordinate class and build uh a circle class with it so this comes uh sort of hand inand with the idea of when you're deciding how to create a class you get to make the design decision right so when the finger exercise for Monday's lecture today's Wednesday yes Monday's lecture um you guys had to create a a center uh sorry a circle class right but the way we defined the circle class in that finger exercise was basically by that circle's radius that's the only sort of way we abstracted that Circle right but now in in this lecture we're going to make a different design decision and say that let's say and say that a circle will now be defined using two things the first is the radius right so I'm going to say that that's an integer and the second is going to be the center of the circle right so as in the picture there I'm going to say that a circle is you know based on this Center and this radius and the center is not going to be a float it's not going to be a tuple it's not going to be an INT it's going to be a a coordinate object right the data type that we were just writing okay all right good it's not a secret but that didn't lower my voice on purpose just just wanted to let that sink in right so the one of our data attributes for the circle class is a coordinate object so we're using an object that we just wrote to create a more complex object a circle okay so here's my class definition uh the data type is called Circle again it inherits all uh the parent of circle is just a generic python object first method we have to write is the init method uh first parameter is self so this thing that I'm creating right now and I say that to create a circle I have to give it a center and I have to give it a radius the data attributes of the circle class right so the the two attributes that make up my circle are this self. Center so the center variable here and self. radius right so these two things together make up our Circle object and initially in the init method right and when we conru Constructor object we're just going to set these two things to be whatever is passed in as parameters in that uh in the Constructor okay all right so what I'd like to say is that this um Center thing uh Center parameter will be a coordinate object and radius will be an INT now notice in this code I'm not actually enforcing this right I could create a set a circle object by just passing in two strings right at this point this code doesn't care right nowhere am I enforcing the fact that Center is a coordinate and radius will be in it but you know that's just something that we we know so then when we create the actual um object down here right my underscore circle is going to be a variable that's bound to my circle object so here I'm invoking the name of my class Circle and then what are the two parameters I'm passing in well the first one I said right up here that it should be a center a a coordinate object so Center is a variable name and what is it well I had to create this coordinate object right so I'm just invoking the name of coordinate this class that creates for me a coordinate object and I happen to put the center of the circle at two comma 2 uh yeah okay so this Center thing is a coordinate object right it's not a tuple or float or whatever it's a coordinate object and then the radius of this uh circle is two an INT everyone okay with that okay so what I'd like you to do next is to modify this init method just slightly just to show you that the init method doesn't just always set the data attributes and it's done it can do a lot of initialization code one of the more important things it can do is to try to enforce the types on the uh on the parameters here right so what I'd like you to do is add to this code to uh to to check that the type of Center is a coordinate and the type of radius is an integer and only if those two things are true then do you set uh the the two data attributes and otherwise raise for me a value error okay so that should be around uh line 48 okay does anyone have some code for me yeah not equal coordinate yep so that's raise value a yep cool so that takes care of one yep yep so if the type of radius because that's the parameter passed in not equal to int raise value there so if if we drop into each of any of these ifs then we immediately raise the value error right the code doesn't complete and then only if we didn't drop into this one or this one do we then go on to create my object so then here we are these two lines here will uh succeed right so there's no error raised or anything like that but then this line here raised our value error because we tried to create a circle where the center is an integer right obviously not a coordinate object and then here again we raised our value error because we tried to pass in a string as the radius any questions about this code oh yeah sorry yeah so it's it's important to place them before you actually create the object right because you don't want to create it unless unless uh yeah unless everything's appropriate okay so now let's add one more useful method to our class Circle now that we've defined a a circle using a center point and a radius we can add this little function that checks if another coordinate object is inside our Circle okay so again I'm not going to be able to enforce um that this point is a coordinate object but you know you could do it in the dock string or you could do a check or something like that but you know again we're just going to assume the user using this method is going to follow the rules so how is this method going to work the idea here is that we're going to use the center which is a coordinate object and some other point you know P wherever it may be what we're going to do is we're going to say what's the distance between this point and the center of the circle if it's greater than the radius we know the point is outside the circle if it's smaller than the radius we know the point is in the circle right so this code is just enforcing that so we have uh just a simple return statement that's going to run the distance method right this is a method that we wrote back in the coordinate class right that's fine because you know what point is an object of type coordinate and self. Center so the center of this circle object I'm trying to manipulate right to tell if another point is inside me or not is also a coordinate object object so why not we already wrote the code that calculates the distance between these two points so let's call it so here I've got the thing before the dot a coordinate object dot notation the method I want to run on this coordinate object and then in parentheses this is another coordinate object so this will just tell me some number for how far away these two points are and all we do is return whether that number is less than the radius okay does that make sense and again this only works if point the thing that's passed in here is a coordinate object right otherwise this code will fail because it's going to try to pass in uh it's going to try to run the distance method on a string for example and of course the string doesn't have a distance method right so down here uh these two lines are exactly as we had before we create a circle object whose Center is at 2 comma 2 and radius is two and then I've got another coordinate object down down here uh it's uh at 1 comma 1 right so clearly within the circle so that print statement will then print true right so that's just basically what I wrote this is a coordinate object this is the method this is another coordinate object right so let's run it so this is exactly the code from the slide so if I run this method on a coordinate object that's one comma one somewhere in here so true and otherwise if I run it on coordinate object right here P 10 comma 10 clearly outside the circle it prints false questions okay um uh yes that's exactly what I said already okay good so now I want you to answer this question nothing to code here but I've got these two is inside method so the first one here is inside one is exactly the one that we just saw right it runs dist distance method with point and self. Center is inside two looks slightly different the differences I've highlighted in this box what I'd like you to tell me we can do a show of hands is are these two function these two methods functionally equivalent that is will they return the same thing given the same input right so think about it and then I will do a show of hands so who thinks yes they are functionally equivalent like given the same input they will both return true right in part false okay who thinks no they are not functionally equivalent some half and half okay well let's think about what the distance method is doing it's being run on an object of type what coordinate exactly so in here is point an object of type coordinate yes okay and then here what is the a parameter to the distance method is it object of type coordinate self. Center is it an object of type coordinate yes so now let's look that is inside two what is the type of self. Center coordinate and we're running the distance method on this object of type coordinate and what is the object in the parameter list here what's its type coordinate so when we wrote the distance method does it matter which object we call the method on to get the distance between these two points no right because the distance between say saying I want the distance between this point and this point is the same as saying I want the distance between this point and this point right it's just the order is different right so just the way that this distance method works right it doesn't actually matter which object I call the method on right as long as they're both coordinate objects which they are does that make sense is that all right any questions about this for those in the not yeah self do Center self. Center is an object of type coordinate not Circle because so self is a circle right because self is is talking about me the class that I'm currently defining and the class I'm currently defining is a circle but self. center right we even wrote code we would like to enforce that it is a cord an object right so we could have put parentheses around this self. Center if we wanted to and then called the distance on that does that make sense okay all right so that's all I had regarding the circle class now we're going to switch gears and we're going to look at fractions right so numerator slash denominator situation here so we're gonna create a new data type to represent a number as a fraction so first thing we need to do is make the design decision what data will represent our fraction so think about it you guys tell me what do you think what's a reasonable set of data that could represent our number as a fraction when you think of a yeah yeah a set of two two things maybe integers right one representing the numerator the thing above the the line and one the denominator the thing below the line good that's exactly what I had in mind what are some behaviors of fractions you guys tell me what should what things should fractions do yeah yeah yes adding them multiplying fraction together dividing them uh inverting a fraction also something we could do right so one over what it currently is things like that all right so we're going to write it together um the full code is actually in the python file so mostly I'm going to go through the slides just because it's incremental so it's easier for me to talk about it um but you know the exact full code is is already in the in the python file if you're running it later so the first thing we're going to do is is create this uh fraction class and I'm actually going to name it simple fraction instead of fraction because we're going to improve upon this simple fraction object uh in a little bit so this one I'm just going to call Simple fraction uh like before it's parent it is is the generic python object right so again very very simple it it um you know it doesn't do anything special yet the first method we need to write is the init method so how do we initialize a fraction object obviously we don't want the numerator or the denominator to be empty right so when we create a simple fraction object we want the user to tell us the values for the numerator and the denominator so those are the two parameters that I would love the user to uh to uh initiate this fraction with and then what are going to uh what will be the two uh data attributes that we had decided on well numerator so self. num and self. denom will be the two data attributes right so self. Nom and self. denom are our data attributes and they're going to be set initially to whatever is passed in uh that Constructor uh call okay so far so good let's write a method that helps us multiply two fraction objects together so we'll call it times so this times method will be called on an object the thing before the dot that object that thing before the dot will get mapped to self and then the thing in the parentheses the one other parameter will be mapped to OT okay so how do we multiply two fraction objects together take the numerators multiply them take the denominators multiply them you got your new numerator and you got your new denominator right so how do we grab the numerators of both of these objects so the numerator of the thing before the dot right that maps to self is self. n and the the numerator of the other object that's going to be in the par parameter list is the name of my parameter otth do their numerator no everyone okay so far yes okay I saw some head knots that's good the denominator will be the same so my new denominator is just multiplying my denominator the thing before the dot with the thing in the parameter denominator okay so I've got my new numerator my new denominator and all I'm going to do is do the division and return this value what's the type of the return here what's this method going to return what type a float exactly yeah good yep because all I'm doing is dividing one number by another number okay perfect so that's uh what I've already said now we can Define another method plus to add two uh two fraction objects together very similar thing except the top is going to be slightly different right you take the numerator of one times the denominator of the other plus the numerator of other times the denominator of the first one the Cris cross thing the denominator is the same right just multiply the denoms together and again we return the division Top divid by bottom again the uh the return of this method will be a float so even though I'm multiplying or adding these two fraction objects together my return will be a float fine so let's run the code I'm creating two simple fraction objects first one is going to be accessed using variable named F1 so this one represents the number 3 over4 second one is accessed by variable named F2 and this one represents the fraction one over4 okay so now if I access the numer numerator of F1 python says well what's the object before the dot it's F1 so what is your numerator well I set it to three so this one tells me it's three right pretty simple same thing with the denominator of F1 again it looks at the thing before the dot it's a fraction object it says do you have a dnom a data attribute you do and its value is four so that's four now what's the result of fub1 do plus F2 super weird way to write WR it but um it's what we've got so far right so the thing before the dot is an object it's a simple fraction object and the thing before the dot remember maps to self in my parameter list right because this it's just a function so like usual functions you know a a bunch of lectures ago we basically map the actual parameters when we run the function to the formal parameters the things for my function definition so the actual parameter here for self is the thing before the dot F1 and the and the uh and the parameter F2 gets mapped to OT that's how we read that so this is just doing the the addition right so this will give me 1.0 because it's a float same with the times the thing before the dot maps to self and every other parameter in the parameter list maps to all everything else except for self so this one will do 3 over 16 to give me 875 okay everyone okay so far the trick here is to remember that the thing before the dot maps to self in the fun in the method definition and then everything else maps to everything other than self okay I'm glad everything's okay so far because I'm going to get you to write this uh this code here it looks like a lot but um the first half of it it is just re uh defining the init method for simple fraction I want you to write these two methods and they're going to be on liners basically so get inverse will return something and it returns a float representing one over myself right so if the input as is in this example here if I have a simple fraction object representing 3 over 4 if I call get inverse on it right here f1. get inverse self becomes F1 and I would like it to return and therefore print 4 over3 so 1.3 3 3 3 3 3 3 okay that's get inverse and then invert is a method that doesn't return anything so it returns none and instead it just internally switches the numerator and the denominator of self right so self's numerator becomes whatever its denominator is and the other way around right so when you call it this one doesn't print anything but instead if we access f1's numerator and denominator they will have been switched okay so this is down on line 133 give you a couple moments and then we can write it together should not be a lot of code okay how do we write the get inverse so remember you have to return something how do we return yeah one over one over self so remember self is an object of type simple fraction right so we need to manipulate its numerator and the denominator if we want to do the return because if we just do this um is it this one yeah this one here then python says oh sorry it's trying to divide one an integer by an object of types simple fraction right and that's the error that we get here and it doesn't know how to do a division between an integer and a simple fraction so how can we do that by working with actual numbers that are part of my simple fraction anyone yeah self. denom divided by self. num yep we can do that yep or one over self. num divid by self. D num that's also fine yeah but this is a little bit cleaner so now dnom is an integer right because when we create it we pass in int int so Dam and num are integers which means that python knows how to do a division between a number and another number yeah so if we run that now it prints 1.33333 exactly okay how do we do the invert function method sorry sorry go ahead yep yep like that yeah yep that's one way to do it yep so you can see now accessing the new numerator and denominator gives me four over three any other ways that you've done it yeah I yep the tupo trick I like it self done yep perfect yes oh okay yeah that also works yeah perfect all all very valid ways of of doing it nice yep so notice this there's no return for this one right I didn't want to return anything python will automatically return none and these internal uh numerator and denominators will have been flipped perfect questions about this code okay so let's try it out a little bit more so here I've got these two uh additions right so um this is exactly what we had previously the exact same code code what's weird though and you might have been um uh weirded out by this too when we first ran it is I am doing operations with two fraction objects and yet the plus and the m and the times methods give me floats which is a little weird right ideally if we're working with fraction objects I would like the return to also be a fraction object so I can then work with more fraction objects later on that's one weird thing another weird thing is if if we then print one of our objects that we've created F1 in this case we use print statements often right to debug and things like that if I use the print statement on an object of type that I've created in this case a simple fraction python spits this out it says hey your object is an object of type simple fraction at this memory location no thank you that's not very useful to me right what I'd like to know is maybe a nice represent of my fraction object like 34 right I don't care about what memory location it's at and one more thing we'd like to try to do this is a class that that represents something numerical so something that people might instinctually want to do is to use operators like the star or the Plus or the slash right to divide add multiply these fraction things but if we run the star operator between object of type simple fraction right times another object times of type simple fraction python gives us an error um and I'll even show you the error [Music] so here right so here I am printing my object right so it spits this out which is fine but not what I want this one you know obviously we've seen this it already prints this out and then if I try to multiply my two simple fraction object objects together it says I don't know how to do that right so it's unsupported operan types so the operant simple fraction and simple fraction are not supported with the star operator well no surprise there how is python supposed to know how to multiply two simple fraction objects together right right before I even ran this program I didn't even know what a simple fraction object was right so we need to tell it all of these details and we will do just that so all of these um uh operators print Len that we've been using Star ad right less than greater than even the square brackets to index into something these are actually shorthand notations right they're really common operations that you want to do and python lets you use these common operations in instead of writing these really verbose function names but really behind the scenes all of these shorthand operations actually run a method okay again not a secret I'm not lowering my voice because it's a secret but it's just it's really cool so all of these operations like the multiplication or the print statement just gets replaced with a method okay and the method names look like this they are Dunder methods just like the init method was a special method that python ran when something special happened like you're creating an object well when something special happens like you're using the plus operator between an object of your type and something else python will also run this special Dunder method behind the scenes right and same here if I want to multiply my object with something else python will run this special Dunder method behind the scenes if I want to print an object of my type python will run this special Dunder method behind the scenes right um even something like casting if I want to cast my object to to a float or to a string or something python will run this special Dunder method behind the scenes um and then you know there's a whole bunch of other ones even indexing into a list or sorry not a list indexing into an object of your type so if you make an object like a q or a stack where you know you have a bunch of sequences of objects you can tell python how to index into an object of your type into an object that's a q right so all of these things uh um all of these methods need to be implemented somewhere now most of them are not implemented in the basic uh python object except for the Str Str so the Str Str method actually just prints the memory location of this object that's exactly what we had seen right by the default Behavior but none of these other ones are really implemented and so if you want the object that you're currently writing to work with the star or the Plus or the double equal sign to test for test for equality between this object and and something else you have to write the method in your class definition okay so you have to implement it to tell python that this is what you want to do when somebody uses this special shorthand notation so let's start with the print because it's the most basic thing you will probably want to implement when you create a new data type right for debugging purposes you'll find yourself Instinct saying hey print you know F1 to print this fraction object to see what it looks like and so the Str Str method is one of the really basic things you should Implement right after the inip method okay so let's look at it in the context of the coordinate object so here I've got my coordinate object 3 comma 4 and even when I print this coordinate object python tells me this uh still un informative message that this object is of type coordinate at this memory location okay I don't care well instead what I would really like to do is say hey I want to represent a coordinate object by something like this angle bracket the value of the x coordinate comma the value of the y-coordinate close angle bracket right so that would be a far more informative print statement than what memory location this thing is at right so let's do that well here we are uh our our our um our coordinate object the distance the init like we had before and here I'm defining my Str Str method right so double Str strore no other parameters except for self so me calling this method on an object and what is this uh going to do it will return not print return a string and the string is going to represent the thing you want to be printed out right so it returns a string doesn't print it however you want to make up the string is up to you so here I've just used concatenation of a bunch of stuff so I'm concatenating the angle bracket with uh the x value of my current object cast to a string concatenated with the comma concatenated with the Y value of my current object cast to a string concatenated with the closed angle bracket right that's the design decision we made to um for how a coordinate object should be printed everyone okay so far okay so if you want to use an F string to make up this thing to return totally fine if you want to make a variable right in between the return and the definition here that you just keep concatenating with so you can concatenate it with new lines and things like that also totally fine at the end you just have to return that string that represents the thing you want to pre print it out so now let's see what happens when we actually run the the code right so here I'm creating a coordinate object and then I'm printing that coordinate object well python says hey you just called a special shorthand notation on an object of type coordinate let me see if you implemented the St Str method it looks in the class definition it sees the Str Str method implemented here and then it runs the code inside and says Ah you want to grab C's x value and C's yv value and concatenated with these things here sure I can do that for you and then it goes and prints this out to the screen okay very cool right now we can decide how to print objects that we create all right so let's try to wrap our minds around types here okay so if we print this c c is an instance of a coordinate object right it's it's it's it's a it's it's an actual object that we're manipulating it's not the class definition it's not anything abstract like that it's an actual object like the integer three right is an actual object so if we print that C python uses the Str strr method well what if we print the type of C somebody tell me what's the type of C coordinate yeah it's the class name that we defined so when we print the type of C python says this is a class coordinate which makes sense because if we just replace type of C here with what it is coordinate we'll get the same print statement if we just print coordinate python says this is a class of type coordinate right so those two lines are equivalent and then let me blow your minds a little bit more what if we print the type of coordinate well what is coordinate it's a type right we're defining a new type in Python called a coordinate so coordinate is a new data type in Python so it's type is type okay so every everything in Python is an object even types okay one more thing so we've used um the type of something equals something else right when we check that the type of uh the the circle's Center was a coordinate that's one way to check for types another way is to use this is instance function just as an aside so you can um check that uh C is an instance of type coordinate uh by using this is instance method and you know this will tell you true and you know just to draw a parallel you can say you know is instance three comma int that would also say true right because three is an object of type integer it's just another way to check for types okay so the remainder of this class I would like to go back to our fraction class and make it better now that we know uh Dunder methods right let's Implement a whole bunch of Dunder methods methods to help us um to help us and and people who want to use our class use it in a more efficient way right so we're going to implement the star operator the plus operator we're going to implement the print and then we're going to implement uh Implement uh converting to a float all right so the first thing that we should probably add is the strr method right because then it will help us in debugging when we print an object of type fraction so let's define double uncore store right again no parameters except for self because that's the the uh the method we're the object we're calling this method on and again however you want to uh form this string is up to you you can use f strings or a variable that you keep uh adding on to um I just did it straight in here with concatenation so I've got the numerator slash the denominator as a very reasonable way to represent a string right so three slash four as 3 over4 okay so one thing I guess to keep keep keep track of is if you're concatenating you just have to remember to cast the strings right if it's a number that or something that's not a string so let's try it out I've got three fraction objects here okay so the first two we've already seen so I've got a fraction representing 3 over4 a fraction representing 1 over4 and F3 is now going to be a fraction representing 5 over one okay if we print F1 again python asks hey did you implement an Str Str method in your class definition yes you did good job let me use it so then it uses this right so it grabs the numerator of F1 slash the numerator of sorry the denominator of F1 so this will print three the numerator of F1 slash the denominator of fub1 okay same with F2 except that now it's going to grab f 2's numerator and denominator one4 so notice now it's not doing the divisions like it did before or sorry never mind we're not there yet there's nothing to divide it's just grabbing the numerators and denominators and just printing them out right it's not doing any divisions now when we print five uh the the the uh the fraction object representing five over one it prints fiveash one I don't like that because it looks weird right do you like that no so then I'm gonna have you fix it um change the Str Str method just a little bit such that if the denominator is one just have it print the numerator right and otherwise the representation should be as before numerator SL denominator okay so this should be down line 14 where is it very far down 265 okay anyone have some code for me yes yep yep we can do an else that else is not needed I don't think because if we dropped into the if we just immediately return otherwise we would just do the the remaining thing but perfectly fine yep and let's run it right so the a is a fraction representing one over four so it nicely printed one over four and B the fraction 3 over one is just printing three good questions about this code okay for the remaining lecture though we're not going to use this modified this nicer better Str Str method so let's just forget what we just did and just remember that it looks like this okay just yeah okay so now let's implement the dunder methods for addition multiplication division things like that so I'm going to do the multiplication just because it's not as long for the numerator so just convenience factor here the left hand side I've got our old simple fraction code and the right hand side has my new fraction code okay so the old simple fraction code remember had this times method that uh took in an OT it calculated a new numerator and a new denominator and returned this okay now my new fraction code will no longer need to call times right so we're not even going to implement a method called times instead we're going to uh implement the method behind the scenes for the shorthand notation star to multiply two fraction fraction objects so we need to implement DF dcore M dou underscore parameter list is the same because we still have a thing before the star and a thing after the star as the two fraction object we'd like to multiply within the code itself the new calculations of the new numerator and the new denominator are the same as well right we're still grabbing the numerators of self and other the denominators of self and other multiplying those together right what's different is in the returns right what was the return type for the uh the times method a decimal yeah a float exactly what's the return type of my new method the mole a fraction exactly so yes I'm operating with fraction objects so I'm expecting that the return type of this method the star double mole is also a fraction object so then I can just keep working with fraction objects throughout my code not having to worry about whether this thing is now a float or not right so how are we creating this fraction object well just like we would create a regular fraction object up in you know the previous slides right so here right here's an example of us creating a new fraction object right numerator one denominator uh four well same here this method me will return a new fraction object whose numerator is the thing that I just calculated the top and the denominator is the thing that I just calculated bottom does that make sense okay so this one returns a float this one returns a fraction okay let's run it so a is fraction one over4 B is a fraction representing 3 over four good those are the numbers we've been working with if we print a the print statement says this is the fraction object 1 sl4 right whose representation is one sl4 now if I use the star operator between A and B the thing before the star is kind of like the thing before the dot it's the self it gets mapped to self in my double uncore Mo and the thing after the star right the second parameter so to speak is the uh is the is is the one parameter that my method takes right other so this will create will run the mole method behind the scenes right so python when it sees that star asks do you have a mole method implemented in your class fraction because the thing before the star is a fraction object yes we do what does it return well it does the multiplication and in the end the return of this method is this thing here right so I literally just you know made this uh I guess copied this from the return using the numbers of A and B so it creates a new fraction object whose numerator is three and denominator is 16 so C equals fraction parentheses 3 comma 16 basically just another fraction object so now when I print C it's going to use the Str Str method for a fraction object right because C is a fraction object right there right that's exactly what C was so this will also print the way we asked to print fraction objects numerator SL denominator 3/16 everyone okay so far okay so the following lines are all equivalent okay um using the shorthand notation very nice very pythonic way to multiply two fractions together but behind the scenes this is just running a method so of course if you really want to you can just use the same old way of calling a method right thing before the dot dot method name parentheses parameter list so here thing before the dot is a DOT the name of my method Dore Moore parentheses all of the parameter list except for the thing I'm calling it on right so those two are equivalent and of course last time I mentioned uh s sort of a way to hopefully demystify um running these methods where you know the self becomes this thing before the dot you could call the method on the name of your data type right the the type that you're currently creating fraction so fraction is not an instance right a was an instance it was an actual object that we created but fraction is just the name of my class so if you call the method on the name of your class then python expects the full parameter list right so something for self something for others something for whatever parameters you have and so there we would explicitly pass in both A and B as part of my parameter list because the thing before the dot is not an object so there's no there it doesn't map it to self okay but I would never ever ever uh run a line of code like this this last one here right this is just for your information it's non pythonic it's just very verbose right and so this uh these uh these Dunder methods help us abstract away a bunch of these details right so how annoying would it be to always use dot notation when we want to multiply an integer with another integer can you imagine constantly writing three do square m Square 4 that would be very bad code it would take forever to read right and so we're abstracting away all the details for calling these methods into these nice low shorthand notations and as I said the shorthand notations exist for a lot of different operations we saw print you can do length comparisons like equality even you know indexing into things you can always you can abstract all of those away um with into shorthand notations and behind the scenes these methods will be run okay so big idea right exactly what I said all these Special Operations that we've been using already behind the scenes these methods get run and these methods were written inside the class definition for the types that we've been using right so when we index into a list L square brackets three or whatever there's a method being called behind the scenes in the list class to grab the element at index three I don't remember the dunder method name for that but probably like double uncore index double uncore I don't know but there is some method behind the scenes all right let's do a couple more things sorry forget the D name for something is way to ask python uh you can't ask python but you can look at the documentation I think it's uh like in python.org there's a website that lists basically everything that you can that's a Dunder method yeah under categories like in all the indexing type stuff all the numerical type stuff yeah um okay so let's do one more thing let's uh uh say that well we're working with fraction objects and so uh the dunder methods that we're writing are now returning other fraction objects so let's allow the user the opportunity to cast one of these fraction objects to a float just in case they would like to grab the you know the the the float value of 316 right that's a very reasonable thing they might want to do so let's you know get ahead of them and add that as part of our class definition so to uh cast things to a FL in this particular case the dunder method for that iscore float double underscore and all it's going to do is grab the numerator of self and divide it by the denominator of self right so this will just do a division self. num is a number self. denom is another number it does the division and this returns a float right so here when we multiply C is equal to a * B remember that c became a fraction object with numerator 3 and denom minator 16 right you remember that so then when we cast it to a float down here python says hey did you implement the dunder method double uncore float double underscore oh yeah you did let me just go ahead and do the thing that you want me to do inside it so it takes the three divides it by the 16 and it prints right okay let's try it out a little bit more so here I've got two action objects um one representing 1 over 4 the other one representing 2 over 3 I multiply those two together again this gives me a fraction object right because it's running the the mold Dunder method and the mold Dunder method gives me uh a fraction object with a new numerator and denominator so when I print the return of that when I print C this prints the new numerator which is 2 * 1 divided by the new denominator which is 4 * 3 so it prints 2 over 12 does that look okay to you I mean it looks okay but suppose you're doing you know calculations with a whole bunch of numbers and at some point you get to really big numerators and really big denominators but then you stared it long enough and realize that that big numerator divided by that big denominator is actually something like one over4 right so this is not reduced right which is fine our code is not doing the reduction but it would be nice to write a method that allows the user to reduce a fraction right that would be really nice so can we fix this yes we can otherwise we wouldn't be here so let's write this method to reduce a fraction object it looks like a lot but it's not trust me okay it's just a bunch of if eles so the first part part of it is a little helper function not a method right notice there's no self going on in this gcd function right this is just a regular function that I will use to help me get the greatest common divisor for the two parameters n and D okay because when I have two numbers right if I want to reduce them I find the greatest common divisors and I'm going to divide the top and the Bottom by that divisor right and that will help me reduce it so this gcd function helps me find this greatest common divisor all right so here I'm just defining the function I'm not actually using it and then I've got uh two uh an if and an L if so if the denominator is zero something's super weird so I'm just going to return none right because having a fraction where the denominator zero maybe something went wrong else if the denominator is one we don't need to do any red reduction right right no reducing is needed so we just return the numerator and else I do have two actual numbers that I could maybe could potentially reduce so let's just uh reduce them the first line here runs this function this helper function that I wrote on the numerator and denominator to grab the greatest common divisor so you know if it's 2 over 12 it'll find two then the next line here take the numer the numerator and divides by that greatest common divisor and casts it to an INT right because I want my numerator to be an INT and my denominator to be an INT right so it'll take the numerator and divide by for example two same with denominator I'm going to take my denominator and divide by that same gcd I found casting to an in so my new top and my new bottom will now be used to create a new fraction object that is in reduced form so one6 for the example 212 right so here it is this is my previous example where I multiplied that thing that gave me 212 and then if I do c. reduce python will call the reduce method on C so the object that's uh whose numerator is two and denominator is 12 and then this will reduce it to 1 over six and we will print call the Str Str method on an OB of type um fraction to give me one over six everyone okay yes um you could put it outside the reduce but since it's being used specifically in the reduce we'd like to just keep it within right so it's not if it doesn't need to be used by other things we'll just keep it only to the sort of scope where it needs to exist but it it can be outside yeah okay so one thing is weird here though right this L if here um what is the type uh that is gets returned from the elves you guys tell me what's this type here that gets returned down in the else fraction what is the type being returned in the L if yes an INT so if the denominator happens to be a one this function uh this method reduce returns an integer if it's not it returns a fraction so if at some point in the future you're mixing you know you you happen to reduce something that has a denominator of one you're now working with integers and then potentially you'd be doing further operations by mixing that with fraction object so as an example here I've got a fraction object a 4 over one B 3 over9 reducing a gives me a four fine it's the integer four and reducing B gives me one over three it's fraction one over three right so the type just to show you exactly you know that I'm not lying uh the type of the A reduced is an INT right that's what the code is doing and the type of b reduced is a fraction so then when we do the star operator between AR and BR Python's going to say you're trying to multiply an in with a fraction did you ever tell me how to do that no right we told it how to multiply a fraction in another fraction but not an INT with a fraction and so python will fail here right so one thing that you can do to fix it is to change uh this L if here so let's have everything consistent so I want you to do this change instead of returning self. num return for me a fraction object representing the numerator right all right does anyone know just a small change to instead of returning self. num what should I return how do I make a fraction object just invoke the name of fraction right what's the numerator of this fraction object supposed to be it's already there self. num what's the denominator of this fraction object yeah exactly so it just returns a fraction object whose numerator is selfon num and denominator is one exactly right so now all the different cases except for this randomly weird denominator being zero right in case that happens some something's gone wrong maybe all the other cases are returning a fraction object which is good because now it's consistent right oh yeah exactly so we did say we didn't want it to be five over one but this is actually using the old Str Str method where we didn't do that check so it will print five over one but if we you know if we do the check if self. D Nom equal one then return stir self. n like if we add that then it won't do that yeah but this is just using the old uh strr method that doesn't do that nice formatting for us questions right we've been working a lot with returning new objects of the same type that we're writing right that's sort of a new thing today okay um so what's the purpose of these two lectures right so hopefully it shows that um it's very useful to uh to bundle data and behaviors together right so the ultimate goal when we're writing programs is to write code that's modular organized right because in the future you might want to build upon this code in the future you might want to read this code to use it for something else in the future other people might want to read this code or use this code this class that you wrote to build more complex classes right like we use the coordinate class to build a circle class right other people might use your circle class to build I don't know a sphere class or something like that something more complicated and so it's really nice to create these little data types that are't organized right modular and so we're basically bundling together these data right so what makes up your object and behaviors together so we can use these objects in a nicely consistent way so remember back when we were learning about functions right the ideas of decomposition and abstraction were very important functions basically took a chunk of code and decompose them into one module that we could reuse many many different places right and we abstracted away the details of the function through doc string so people didn't have to slog through a whole bunch of code to figure out what the function did all they did was read the doc string and they knew exactly what we wanted now object oriented programming and python classes have that same big composition and abstraction energy right they've got a bunch of modules that we're creating here where we're bundling together data and behaviors right so we can create a whole bunch of objects that behave in the exact same way nicely consistent so that we know that if I create a coordinate object here it's going to have an X and A yvalue and if I create another coordinate object it's also going to have an X and A yvalue it's not suddenly going to have an X Y and Z value right so creating these objects that work in a consistent way is is very very is a very um you know decomposition uh and abstraction uh uh you are working with the ideas of decomposition abstraction just like functions did okay so next lecture we will be starting on we'll do a little bit more of these classes and then we'll start on inheritance so having parents the objects that we created all right