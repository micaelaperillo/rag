all right so hello everyone let's get started um this is lecture 10 so last lecture we introduced two new data types we talked about a data type called a tuple and a data type called a list so today we're not going to talk about tupes anymore more because they were pretty straightforward a lot of operations you could do with strings you could do with tupal they were immutable objects that means once you created them in memory you couldn't do anything to change them and so they were I guess pretty boring except that you could populate tupal with uh objects that were of any type so you could populate a tupal with integers and floats and booleans and other tupal all at the same time okay um we introduced lists last time as well as something that was really similar to pups and strings in terms of um manipulations lists were also nice because you could populate them again with any kind of data objects just like you could tups okay today what we're going to focus on though is the idea of mutability when talking about lists okay which is something new we have never talked about this idea before and so this lecture is going to be pretty heavy on kind of that idea and a little bit heavy on syntax and things like that to kind of remind you of how to do um how to to manipulate these uh compound data types so please if there's any questions feel free to stop me and then I can uh go over what I just talked about if there was anything confusing so this slide is basically a copy of the slide we had on lists last lecture it shows a bunch of diff oops a bunch of different operations that you can do with lists they're very similar to operations that you can do with strings right so here I'm just creating an empty list I'm uh creating a list with a bunch of elements in it so here we we can see that this list contains four elements and they are all of different types right this is an integer this is a string this is an integer and this is another list and that's totally okay to do with um with these data types doing all of these operations getting the length indexing slicing concatenation getting the max all that is uh should be review as well as iterating a for Loop over the elements in a list directly so just like we iterated a for Loop over uh characters in a string this Loop basically makes e our Loop variable take on the value of every single uh element in our list L what's new the bolded thing here is something we haven't been able to do before and this basically goes into memory and changes the element at index 3 and L so that's kind of how we read that and it changes that element to have the value on the right hand side so this is kind of I mean we read it in the same way as we do other assignment statements we look at the right hand side and we evaluate that in this case it's only a 10 but the left hand side looks different right it's not a variable name as we have seen before but in fact it's this uh it's referencing the item in list named L at index 3 so that would be index 0 1 2 3 this line of code down there L sare braet 3 = 10 basically replaces this entire element here with the number 10 okay so on the next few slides we're going to talk about what exactly this means inside memory because it it's it's it's different than what we've been able to uh what we've been doing before so what exactly happens when we go into a mutable object like a list and we change an element using this exact syn Tex all right well let's draw our memory diagrams the way we have been in the past here's a little Cloud representing the memory L equals 243 creates this list for me in memory this list object and L is the name that I'm referencing to this list object right so I'm basically binding the name L to that object in memory L square brackets 1al 5 tell tells python to follow the uh name L to the object in memory and then look up the index in the square brackets in this case index one so that's 0 one this four and take the element at this location and override it to be whatever the right hand side says so the right hand side says five so basically we're going into memory and changing that middle element okay so this is different than strings and tupal we were not allowed to do anything like this with strings and tupal so let's look at an example Le on the next slide about what this means but the idea here I'm trying to get at is this object that we have changed one of the elements um inside uh one for which we've changed one of the elements we've changed the object itself we didn't make a new copy we didn't kind of make a version of that object we have changed the object itself so let's see maybe similar code that might have kind of that you might think does the same thing except with tupal all right so the first two lines of code are going to be the same we've got l in memory being the object 243 L being the name bound to the object 2 43 L square brackets one so L at index one equals 5 changes that middle element to be A5 okay same as the previous slide now what if we had these two lines of code T is going to be a a a variable name that's bound to the Tuple 243 3 so notice this is now the tle denoted in in parentheses if I say t is equal to 253 what happens basically with this line I am creating a new object in memory okay so there's my new object and I'm taking the name t and I'm binding it to this new object right the old object to 43 as a tuple Still Remains in memory I have not modified that object at all it's still there I've just lost the binding to it so the name t is separate from the actual object in memory right in terms of tupal what that means for us is we can never change the uh the Tuple object in memory once we've created it but with lists using this specific operation uh this one right here L square brackets 1al 5 this does allow us to go into memory and literally change that object right that is associated with with the name L does everyone okay with this slide does this make sense this showcases the difference right so we need to think about what is the name of the object versus the object itself in memory okay so that shows you how to create a list and then go ahead and change elements to different values within that list but now that we have a list object right that we can mutate other operations we can do with it is to to let's say add more items to the end of the list so we can make the list bigger right we can mutate the object by doing that using this append function now I'm going to talk about the syntax syntax of the append function in a little bit but basically if I want to mutate L to add an item to the end of it I have to use the syntax there isn't a different form a different function to do this so this specific syntax has to be used um aend is basically the function name okay element is going to be the parameter the thing that I want to add on to the end of my list and L the thing before the dot is going to be the uh the object I want to add the element to the end of the list right so l in this case I'm using it generically but you can imagine creating a list of uh employees in your company right then you might name that list employees in that case we would say employees do append you know Anna or whatever right so that L is just kind of generic for now but it gets replaced with whatever variable name your list is so this operation basically mutates the list okay so it mutates it to be one extra element longer and the element you're adding to the end of the list to the right hand side of the list is going to be whatever is in the parentheses to append so let's look at an example so we're going to create L is equal to 213 in memory and then let's say we do l. append five all right well this line of code says look up L it's this object in memory here 213 and add the uh object five to the end of it so I'm going to add the five to the end of the list now it's no longer three elements long it's four elements long and again I didn't make a copy I didn't preserve the original list with just 23 in it I have literally change this list in memory that's referenced by L now this function a pen is being used basically for its side effect and the side effect here is mutating the list after the uh after the function adds the five in this particular case to the end of the list the function doesn't need to return anything back it's basically done its job to do the mutation and so functions like append and we're going to see other functions later don't have any return value okay so one really common mistake as we're kind of learning about mutable uh mutable objects and using these functions that mutate is to say well I'm going to do l. aend five and save this the result of this function it back into the variable named L and this would be incorrect so let's see if we do this line of code what exactly will happen Okay so it's an assignment so the first thing we do is we look at the right hand side and we evaluate that well the right hand side basically says l. append five which is exactly the same as the previous line so we're going to put another five to the end of our currently mutated list right just kind of going with these operations in order and then I said this F this function this aen function has done its job to mutate the list by adding a five to the end of it so it returns nothing there's nothing of value that it could return because it already did its job of mutation so it actually returns none so the the the assignment the equal sign then basically says take the name L and bind it to the return of this function L do pen 5 well the return of the function is none so basically now we're losing The Binding from 21355 which was our mutated list and re binding it to the return none so that is an incorrect way to do the mutation of adding an item to the end of the list okay everyone okay with that so far yes okay excellent so what should we have done instead uh sorry yes be careful uh about the append uh operation right you're doing a mutation and you return none as a result right so you do not you do not want to resave this to any variable so instead we what we would do is we would just do the operation right there's nothing to save nothing to save in any return variable so we if you wanted to add two fives to the end of that list you would just say l. append five again and L would then have been mutated to be 21355 okay and so in your code if you just print l in between these append the uh if you printed l in between after the first append five it would print this 2135 and then if we print L after the second of pen five it would print 21355 right because it's kind of a it's an ongoing operation it's mutating this list and now you're doing operations on the newly mutated list everyone yeah the element can we only use one integer or we do five for the element can you do do you have to do one integer or can you use five comma five so you can the append only works with one one thing so if you wanted to append a a tuple you could append one tupal object that has many things in it but it would just append that one Tuple um we're going to see at towards the end of this lecture an operation that allows us to extend the list by a bunch of items yeah but there is away just not with a pend yeah so the other thing uh so this this operation always returns none right l. aend five or whatever the pend always returns none but here it's just sitting on a line by itself we're not saving it back to anything right in the previous one we took the return and saved it back into L and that's why we lost the binding to our the actual list so what we usually say is that we use a pend and a bunch of these other mutable functions for their side effects and the side effect in this case is to mutate the the object that I'm calling the app pendon right in this case the list named L okay so let's uh have you think about this problem and while you do it uh and and then we can write it on the board together so as we go through this these um lines of code one at a time what will the values of the lists be become okay so L1 is the string ray L2 is me L3 is doe um what is L4 going to be right with that line L4 equals l1+ L2 anyone know what's the type it's concatenation right so concatenation with lists is like concatenation with strings yes yep what are the elements in it yep yeah exactly I'm not going to do the strings but but you know what I mean all right so L4 with that line is just these two elements uh in in a new list now what happens to with the next line l3. append L4 which one gets mutated L3 or L4 L3 gets mutated exactly and what does it get mutated to so L3 originally has do in it what am I adding to the of L3 exactly yes I'm adding one item right and that it's linked to the question that was here what am I appending I'm appending one item it's whatever L4 is and L4 is this list so I'm going to be adding Ray and me within my list here right and I got to close this list here right so this is one item one object one element and this is another element right here it just happens to be a list okay um what about the next line L equals L1 aen 3 what is the right hand side going to give me am I mutating L1 or l31 yes and what am I mutating L1 to be L1 is originally Ray and what am I adding to the end of it yeah exactly this L3 which is this big thing here right so it's a list with two uh with two elements the first one being a string and the second one being another list like that okay so that's the right hand side and then what is the left hand side going to be what is L going to be no exactly yeah exactly okay so now that we've introduced mutable objects we have to be careful about what functions we're using some of them mutate the list right and don't return anything append is one of them and we're going to see a few more in today's lecture so these um these functions are just being used for their side effect right they mutate the thing you're you're calling the function on and that's it they don't need to return they don't return anything they don't need to return anything they have done their job purely by the mutation aspect of it so I wanted uh just quickly make a an aside on this dot notation that we've been that we've introduced with this append function okay this is something we haven't actually seen before um but it's something that we will learn about in the future when we create our own object types right so right now we're using object types that somebody else wrote like a list or a tupal or something like that but in in a future class we're going to learn how to create our own object types and when we do we're going to use this dot notation a lot but for now you basically just kind of have to remember which functions use dotn notation and which which don't but I'll give you a little bit of intuition for um what this do notation actually means so when we have so everything in Python is an object and when we have objects in Python the idea here is that the objects that you have have data asso iated with them so what kind of what makes up the object and they have certain behaviors right so we touched upon this on uh maybe the first lecture where we said things you can do with integers are different than the things you can do with strings right that's that's that's pretty clear and that's different than the things you can do with lists right and so the kinds of things that you could do with each one of these object types differs depending on the type and at its core really everything can be written in terms of this dot notation but some of the more common operations like getting the length of something or adding two numbers together are actually uh we we do them in this shorthand notation like using the plus operator or using the Len right but at their core really we can take all of those operations and convert them to a DOT notation we're not doing this today but that's that's what we can do and so when we see this dot notation the way we usually read it is we say well what's to the left of the dot it's going to be be our object the thing that we want to do an operation on right in this particular case it's a list named L right but it could be a list name employees or words or whatever you know book or whatever uh the list contain whatever the list name is the dot then comes for the dot notation and then the thing on the right hand side is going to be the operation that you want to perform on the object to the left of the dot right so the operation if you basically cover up l dot the operation looks just like a function right it's aend parentheses some parameters and so the operation is basically just a function that you want to run on an object of type list this specific object named L okay and you can see it has a name a pend and it has parameters or arguments in this case it's the thing you want to add to the end of the list so again unfortunately at this point in the class you just have to kind of remember which functions are do notation and which ones are not but it will become clear uh what this do notation actually means towards the end of the class okay so let's have you work on this uh on this little code here it's going to use a pend obviously and it's going to have you create a list um so the name of the function you should uh make here is called make ordered list and it takes in one parameter an integer n it's positive and I want you to create for me a list that uh uh that has all of the integers from zero all the way up to an including n inside that list in order okay so as an example down in here around 34 right if we call make ordered list with six it's going to create for us this list inside the function and return this list right all right so a couple minutes to work on that and then we can write it together all right what's the first thing we should do here or how would you approach this problem yes you want to create an empty list what do you want to name it you named it list um list is an okay name but notice list is also the name of the the type of the object so I would refrain from naming anything things that change color so we can use l or my list or whatever something else my list is an empty list all right so it's originally empty and now we need to populate it with some stuff you want to go on make a for Loop that goes over what yep Zer to n plus one exactly because we need our boundary to go up to an including n perfect so now that I've got I changing to be zero then one then two then three what do I need to do to my list yeah exactly append I so my list right is the name of the list I've created do append I okay the last thing return the list right so return my list so run it perfect if we change this to two still works okay so just testing it out with a couple different inputs just to make sure it works questions about this code it pretty yeah is the zero necessary in the range Zer the zero is not necessary in the range yeah it defaults the zero exactly okay we're not done yet you have more writing to do so let's write a slightly different function now called remove LM it takes in two parameters the first one is a list right and the second one is going to be just some variable it could be an integer it could be a string it could be whatever and what the function should do is create a new list populate it with the same elements of L in the same order but exclude the ones that are equal to e okay so you don't want to include the ones that are equal to e otherwise keep everything in this in the original list l in the same order okay so as an example here we've got if our input list is 1 2222 and I call the function with L and two the list that this function returns should just contain one element in it just the one right so that try your code for the next couple minutes around line 50 and then we can write it together all right how can we start yes uh I created a new list yep what did you name it list cool what did you U make it be empty empty list okay yep so for I in L okay and at this point I would make a note for myself because you used I which in my brain means index but I would make a note for myself that I is is maybe one then two then two then two just according to this first example so if I'm reading the code I would just I will remember that it's not the index but go on so for I and L directly like this okay yeah okay and then good return new list okay let's try it yeah so e is not a list e is going to be a um an element right so I I I that's my bad I should have put this in here e is uh you know uh like you know an object or something it's it's you know it could be a list but then I would be looking for that exact sub list that exact list as a subelement so maybe we think of e as an object like five or something like that equ yeah not equal to e right so if I'm just looking for that element directly I want I to be not equal to e in which case I keep the element in my new list so if we run that that gives me one according to this looks like it's correct and then we can run it with these other two cases so here I'm removing the element one right so I'm going to keep 222 as a as my returned list and here I'm removing zero which doesn't exist in my list at all so it should just keep and it does my original list unchanged um any questions about this example anyone try it a different way okay all right so other useful list operations um we can convert strings to lists and then lists back to Strings okay and this is very useful um when you know you're reading in uh text or something like that to a function it's going to be useful for problem set three so on and so on so let's first see how we can take a string a s and convert it to a list so if we just cast s to a list right the way we used to cast uh you know the number five to a float we would just say float parentheses 5 well we can take a list and cast it to a list by saying list parentheses s and if we cast it like this python takes every single character in s and makes it be a separate element in a list so you can see here I've got the string iart Cs and U it makes for me a list where every single character including the space right and all the special characters becomes a separate entry in my list that's not that useful I mean it can be but it's not that useful what is more useful is to take an input string and split it on a particular character so one very common character that we would split on is the space and if we do something like that it basically extracts from us from our string all of the individual words right which is pretty useful so here I've got S.S split and in parentheses I've got the character I want to split on this particular case a space so if I take s and I split on the space python will go from the beginning of the list to the first space make that be one element in a list um it'll go from the first paste in the next space in my string and make that be the next element in the list and so on and so on until it gets to the end of the list and makes that last bit the last element in my list so here when I've split on the space I've got three um three uh three uh three base words quote unquote words um I heart is going to be one and there it is as my first entry CS is in between these two spaces and that's my next entry and and you question mark is my last entry here okay so this is a very useful function we can of course split on any character we'd like so here I am splitting on the less than character so if I there's only one so if I split on the less than character one element in my resulting list is just the capital I and the remaining element in my resulting list is the three space Cs and U and there it is right there um all right so once we have a list we can also go backward we can take this list and convert it back to Strings so we use this um this join function here and the thing before the dot is going to be what character you want to join the list elements with and this is the list you want to join back into a string so let's look at an example so let's say I have list L that has three entries in it a b and c if I join on the empty string so here this is just quote quote right beside each other there's no space or anything in there that's going to take from me all the elements in the list L and join them together as one nothing in between the a or b a b and c right and that bring this operation here will basically make for me a b uh the string ABC if I join on an underscore right you might have guessed it'll uh join a b and c with an underscore in between each character so there it is aore bore C right you can join on any character you'd like I don't know if you can join on multiple characters but I don't see why not you could try this out on your own um join only works with uh with lists that contain only string elements so if we try to join a list that has just integers or Floats or booleans anything that doesn't contain a string in it then you'll get an error right because it's basically trying to put all these back into a big string if you wanted to join uh non-string elements you would have to B basically Loop through and cast every one of these to a string first and then join them together so if you want to join one two three you would have cast them to Strings and then you could join them to make the string one two three okay so let's have you work on this example so here we're going to uh uh try to split uh the input so so here's a function called count Words it takes in one input sen for sentence and I I wanted to use something that's not s just to make it clear that the thing before the dot doesn't isn't always s it's whatever object you want to split or join or whatever so this function is going to return how many words are in s right quote unquote words in this case because it's just I'm just interested in the the elements or the characters between spaces and between between the start and the end of a word right so if it's a number I still count that as a word if it's a special character do exclamation point I would still count that as a word as well so this should be just a couple lines of code uh down around 99 okay so I'll give you about a minute to work on it and then we can write it together okay so thoughts on how we can do this L1 equals s. split yep uh yep sorry parentheses space yep and then return L1 yep and then we can return the length of L1 perfect let's run it on these two examples and should print three and 12 and it does so notice how easy this was with lists right because lists are a data structure that's just kind of naturally iterative and so running Len on this split list or split string which gave us a list is really is is really easy right it's a two-line piece of code without lists you could imagine creating variables that keep track of where you see the first space right and then iterating through one character at a time and if it's a space keep track of the fact that you saw a space and then look for the next space right and then resetting things every time you see a space and that would be really really tedious it would be a really good quiz one question but not once we've introduced lists because it becomes really really easy to do it with um with lists okay all right so now that we have lists we can H uh we can do other really interesting and useful operations to mutate the list so we saw the do notation on uh a list to do a pend so basically to add an item to the end of our list that was useful other things we can do in terms of mutating the list is to sort a list and reverse a list and these are also very useful uh operations on lists so the first two here sort and reverse is how is a notation for how we sort a list and how we reverse a list okay and these will mutate the list that you call the functions on so if I have list uh 427 here and I call l. sort and I print L as the next line after this L will have changed in memory to be 2 4 and 7 right in that order it didn't make a copy for me it didn't preserve the original order it changed that list to be now in sorted order reverse similarly so if we do l. reverse on 427 it will reverse all the elements so the one at the end becomes at the beginning the one second last is the second second one third last is the third element in the list and so on okay and again this mutates my list so I would have lost my original order with this command l. reverse and with l. sort of course now there are many situations where you want to preserve the original order like um I don't know maybe like the order that people joined a company or the order that people joined a grocery queue I don't know things like that right you might want to preserve that original order but you might also get maybe the sorted names of people for a function that does something with those sorted names in that case you don't want to call sort on your original list because you would lose the original order you could of course make a copy or you could call this sorted function and the sorted function is going to keep my original list L intact in the same order that I had created it in but it would return for me so this function will actually make a copy and return for me the sorted version of L okay and L remains unchanged so this function does not do any mutation we have to take the return and save it into a new variable this case I called it l new okay so might be a little bit sort of hard to keep straight in your mind sort of whether to use sort or sorted you could of course always try it in the console right to see which one does what the way I sort of remember and think about it is the sort to me feels like a command it's like sort this list right mutate this list and sort it whereas sorted is more of a request like can you please get me the sorted version of of L right and so that's kind of how I keep things in in in in my mind as to whether I'm calling sort to do the mutation or asking to get the sorted version of the list yes it is sorting it by whatever the builtin sort is for those particular um object types so in uh in the case of integers it's just increasing order in the case of uh strings it'll be alphabetical um you can choose different sorting functions but we we don't get into that yeah um that's a good question I think they do um in in order for it to work so we can try like l equals um one and then we can give it a tuple or something and then we can ask sort L yeah so in this case it doesn't know how to resolve right it's trying to do uh behind the scenes less than to figure out which one's bigger than which and in this case it doesn't know how to resolve how do you choose whether the TS bigger than an integer yeah but you could imagine again like as I mentioned this is not something we do but you could write your own sorting function where depending on the type you would you know decide which one is bigger so yes question yeah so you would just do l. sort without parentheses but L has to be a a list that contains things that can be sorted right so all integers all uh strings or something like that so let's look at the memory diagram for how this would look just to kind of bring the point home about objects that are being mutated so our original L is 9603 so in memory I've got uh the name L bound to 9603 again let's do an append just for fun l. append five uh is going to add a five to the end of that list and append sort and reverse will all be used for a side effect right that means they're going to be mutating the object whereas sorted will not do a mutation so let's do an append to the end that's going to put a five at the end of the list something we already know uh how it works now let's do a equals sorted l so again it's an equality right so the thing on the right hand side is going to be the function that returns for me the sorted version of L so it's going to create a new object however it does the sort it's going to create for me a new list that contains that sorted order the original L notice in memory remains unchanged so if I want to reference l in my program from here on out it will use this unchanged L um so now the return of sorted is this list and I bind it to a okay so name a now points to the sorted list version all right now what if I do this line here b equals L do sort again let's look at the right hand side l. sort is going to mutate l so this function itself will go and change L to be uh to L's object the object that L points to to be the sorted list but it's not done this function is being used for a side effect so what is the return from it none right it's like the append so this example here will make B point to the return of that function which is just none right now please don't ever do this all you would have to do to sort L is to just on a on a line by itself say l. sort I just did this to kind of show you again that if you do L equals l. sort bad things will happen you're going to reassign L to be none in this case I saved it under a different variable but um it's an easy mistake to make okay and then what about the last one here l. reverse again I'm going to go and grab the object pointed to by L and I'm going to reverse all the elements so here doing l. sort and then l. reverse right afterward makes my function uh makes my list be in Reverse sorted order so biggest number to smallest number so with that command there I've got 9653 0 instead of 035 69 and again sort and reverse changed my list L directly so I've lost that initial order of 9603 that I had up here okay um one last point I want to make uh I know we've usually seen functions that Tak in parameters right sort and reverse are still functions and they just happen to not need any parameters right you call them on the object L using this dot notation so in effect it does have sort of a quote unquote parameter the thing before the DOT but it doesn't take anything else in in their own respective parentheses right but they do still need the parentheses there because they are functions right they are operations that will do something for us okay questions about this is it okay okay very good because now you get a chance to try it out so let's have you do something similar to what we did last time take in a parameter send which is a string representing a sentence I want you you to figure out all the words quote unquote the same in the same manner that we did before uh in the previous example but now return for me a list with these words in sorted order okay so if the input was look at this Photograph as my sentence then I would return a list where which has at look photograph and this as my three ele or my four elements in that order so here I uh start writing it down on line 134 okay what is the solution what do you have so far yes L equal. split and we split on a space got it okay L got it return L perfect okay let's see if that worked with our two examples yep there's my first one there's my second one anybody do it a different way did anyone use sorted yeah um return sorted parentheses l yeah is that how you yep we could do it all in one perfect yeah this could be a oneliner for sure um yeah so this uh works because this thing here creates for me a new object I could have saved it in a different variable and then return that variable but this does it all in one so just for completion s if we comment out the other solution this way still works question so far okay all right so what we've seen so far is a bunch of these functions built-in functions right that have these side effects they mutate the input uh the input list so we can actually write our own functions that have a side effect where if we pass in a parameter that's a list we can have our functions mutate that list however we'd like so let's go through this example let's say we were given the task of writing a function that takes an input list L and and mutates the list L such that each element in L is changed to be the elements square right so two four 2 three and four as an input list becomes 4916 right and I'm mutating that list I'm not creating a new list and returning the new list I want to actually mutate the input list l so if we were faced with this task the way that we would kind of go about it maybe based on what we've learned so far is to say well I'm going to iterate through each element in L because that's the very pythonic way to do this right so I'm grabbing the element in the list L but then I would be stuck because the Syntax for changing an element at a particular location right is L at I equals you know whatever the changed thing is but my Loop variable is iterating through the element directly so what's my index in this particular case I don't have it in hand right I have the element but I don't have the index so what are some Solutions well a first solution could be right before the loop to create a new variable that keeps track of the index right so you make I equals Zer right before the for Loop and inside the for Loop you increment I each time now you're keeping track of the index yourself option two is to change what we iterate over so instead of iterating through each element in L directly let's iterate over the index so iterate over range length l in that case the the the range length L basically becomes range you know five or 20 or whatever the length of my list is and the last option is to try to use this um this thing called enumerate which is a python uh keyword I guess function python function and the Syntax for that would be for Tuple I comma e in enumerate l so I'm basically wrapping enumerate wrapping L inside this enumerate function and python uh each time through the loop makes this little Tuple I comma e be the index and the element at each location each time through the loop and so it gives you a two for one kind of deal here using this enumerate function I'm not going to go over option one or option three I do encourage you to try to look these up or or try to implement them yourself but I will go over option two uh in in these slides so if I were to iterate over the the index directly the way I do it is I'd have to change the loop variable right for I in and then the thing I want to Loop over is all of the indexes indices right so I want to get the numbers 0 1 2 3 4 all the way up to the uh but not including the length of L right so once I have this index in hand I can do something like this very easily right because this I here is going to be my index right and the thing on the right hand side is just going to be a matter of grabbing the element at that index and squaring it okay so here L square brackets I on the right hand side grabs for me the element at index I so what's the value of that element at that particular location 203 whatever Square it so star star two squares it and then the thing on the left hand side is the sytax for changing the element at a particular location right we saw this way back on slide two so with this line of code python goes through each element in the list and squares it and saves it back into that same list no new list is created it's mutating the original list right no return nothing to return this function will return none because it does its job of doing the mutation so if we uh go through an example suppose that uh L is 2 3 4 what is this Loop going to do so I the first time through the loop will be zero and then that first time through the loop it will mutate I so it says L sare braet 0 equals whatever the element at zero is the two squared so L square bracket 0 will be changed to four right so we've mutated the first uh the element at index zero to be a four and everything else is the same next time through the loop I'm mutating the list that I had just mutated right so the first element is still the mutated value four but now I'm going to change my uh element at index one to be 3^2 9 last time through the loop every all the elements up to index uh two are going to be the mutated elements so four and nine and then the last time through the loop I mutating the six uh the four to be 16 right the square version of that okay so to check to that we did the mutation correctly what we would do is we would create an input list I called it Lin and you know I've set it to 234 my example if I print before the function call the value of L in it's 2 comma 3 comma 4 as expected it shouldn't be anything different than that then I make a function call to the function that we just wrote note I'm not returning uh any here so I'm not saving the function call to any uh any variable right if I print l in after the function call it will print the mutated list so this l in here and here and here is the same object nothing was returned this uh this function here has nothing to assign its return to if we assigned it to something that variable would be none just like the append just like the sort just like the reverse yeah all right so when you're writing oh yeah question we created a function don't have a return and we created a function it doesn't have a return it doesn't say none because we didn't save the function called to any variable right if we said like like a equals this function call if we print a it would show none yeah okay so when we're writing functions that mutate input lists the two likely things you're going to have to do and it depends on what your function is actually doing but most likely you're going to have to iterate over the length of the list so for I and range length L to grab the index as well as the element to be able to grab the index as well as the element and these functions I mean they could do other stuff but if you're using them for for mutation and things like that they're going to return none so when you make function calls to them they'll those function calls will likely just be on a line without saving the return to any variable right okay so we've talked about mutable objects they're very very useful um places where they're useful or the reason that they're useful is because they allow you to have basically large databases of objects like employee employees in a you know in a company list of all the students at MIT things like that and if you want to make a change to something about that list like a student changes their name or their address or something like that with t plls you'd have to make a new copy of that entire list so it could be very space in efficient because every time a student changes their address or their name or something about themselves or their grades or something like that you're making a new copy of this potentially thousands long uh data structure lists don't have that issue with lists you're just mutating the object in place and you're done no extra copies are being made so it's a very efficient data structure but with lists come some unexpected challenges and we're going to go through three tricky examples today and next lecture we're going to see tricky example number four and these three tricky examples involve looping over the list in one way or another over the range of the length of the list or through the list directly so let's look at the first example um in this uh code down here we're going to Loop over the range the of the length of the L okay and then what we're going to do is append the loop variable I to the end of my list now what does range length L do so remember the the thing that our for Loop iterates over is a sequence of values now range some number creates for us a Tuple like object not a tupal specifically but you can think of it like a tupal so Range four the length of this particular list would create for us in memory something like a tuple the sequence 012 3 right and this is the sequence that the loop variable I will go over first it'll be zero then it'll be one then it'll be two then it'll be three so when we iterate through the sequence python says okay the first time I see this I encountered this for Loop I'm going to save this sequence I need to iterate over as a as an object in memory and then I'm going to have my Loop variable iterate over each one of these elements the thing I'm doing is appending i to the end of a list so the first time through the list I'm going to append a zero to the end so the zero being this Loop V uh loop variable here next time through the list I'm appending the one to the list I just mutated next time I'm pending the two to the list I just mutated and last time through the list I'm appending the three to the list I just mutated and we finish we've gone through four times we've appended four items to the end of the list 0o one two and three right this uh this thing this the the elements of my uh sequence that I'm iterating over let's look at the memory diagram so originally L is 1 2 3 4 what exactly happens when we first first encounter range length L that gets put as a variable uh this Tuple like thing I made it be a tupo but it's not exactly a tupo in memory and this I will iterate through each one of these values in my sequence right this is the sequence of values that uh that I'm going to iterate over so the first time through the loop python is has I pointing to zero here and so what's it doing inside the loop it's going to pend the zero to the end of L right next time through the uh then it's going to print L sorry and then next time through the loop the loop variable increments by one right so we've already looked at the zero now we're going to do the one so the loop variable I is now one so we're going to append the loop variable one to the end of L print L Loop variable becomes two append the loop variable to the end of L so now it has a two print L and then the last time we pend the loop variable three to the end of the list L and print L pretty straightforward the code terminates because we've created this original Tuple like object here which tells python what values you need to iterate over this is your sequence of values to go through okay so that's basically what I said so let's look at a slightly different example so in this case instead of iterating over the range length L let's iterate over the elements in L directly so for e in L now to keep things sort of in parallel to what we had done before let's create a loop variable I equals z before the for Loop and let's increment it by one each time through the loop so we're going to still append zero then one then two then three to the end of our list so in this particular case um we start out with the memory diagram like this so we have L pointing to 1 2 3 4 Loop variable I is going to be zero originally and E will first point to the first element in the list right that's what the for Loop over the elements in the list does so going into the list we say l. append I so at the end of L I'm going to mutate it to contain a zero good I increment I by One good I print L okay good and then the next time through the loop python says all right what's the next element in my sequence well I looked at the one first now let me look at the two all right now I'm looking at the two as my next element in sequence I'm going to append I to the end of the list right so I'm going to pend one to the end of L increment I by One to be two print L okay next value in my sequence e increments to the next element in the sequence the three uh we append I to the end of the list so we append two to the end of L increment I by One print L what do you notice is this code going to ter terminate no because our Loop variable will always be four elements away from the list the end of the list right as I'm adding an item to the end of my list Loop variable iterates to the next item but then I'm adding another item to the end of my list and my Loop variable iterates and so we're always going to be four behind the end of the list so this code will actually never stop all right so the difference here is what I'm iterating over in the previous example as soon as python saw range length whatever it made this predefined sequence of values it needed to iterate over but here it doesn't do that because it's iterating over my object L there's no predefined sequence to create it's supposed to iterate over L directly okay so that's the difference between these two all right so now I'm going to show you uh before I do the last tricky example involving concatenation I wanted to mention one thing which is uh there was a question earlier how do we actually add more than one item to the end of our list and we do that using this extend operation and this extend operation will is kind of like a pend but we are going to add all of the elements of some list as the parameter to the end of our list l so in effect we're mutating L to be extended by all the elements in some underscore list so here's an example first let's do concatenation just to remind ourselves what it does so L1 is 213 in memory L2 is 456 in memory L3 is going to be L1 concatenated with L2 pretty straightforward it's concatenation so python creat creates for me a new object which is all the objects in L1 and L2 put together as this completely new object bound to the name L3 so L1 and L2 remain unchanged no problems there but the extend is going to take is going to mutate notice the a DOT notation format of extend it's going to mutate L1 to be extended by all the elements in this list so it's going to add a zero and a six to the of L1 so here it is I've got L1 mutated to be 213 and then zero and then six so just to bring the point home the thing we're extending by is all of the elements of this list in the parameter right so in this particular case l2. extend will be extended by how many elements two or four yeah I see two exactly it'll be extended by two elements at the top level right this list has two elements in it a list and then another list so this command here will extend L2 by these two elements specifically one comma two as a list and three comma four as a list right but these are individual objects there single objects that are lists they happen to have a bunch of elements as part of the list but they are two objects yeah um when we extend it by 0 comma 6 there's no brackets because we're extending it by the elements of this top level list so it's two integers right and here we're extending it by the elements of this top level list so in sense the the outermost parentheses which are act they are lists right so in this yeah okay so that introduces extend we're not actually going to use extend for this particular example but I did want to mention it in this example we're going to use the plus the concatenation operator to create for us this um this new this new object and bind it to L again so let's see what this is going to do um first I'm going to actually tell you the answer and then we'll do the the memory diagram again to bring the point home so this Loop will again Loop through all the elements in L originally it's 1 2 3 4 in a list all right so what is the actual Loop going to do it's going to take whatever is in L double it right so originally L is 1 2 3 4 the first time through the loop is going to create a new object which is just l 1 2 3 4 doubled right I've concatenated L with itself and then I'm going to save it in my new uh as this new object with the name L again that's the first time through the loop second time through the loop I'm going to take whatever L was mutated or whatever L was before sorry not mutated but whatever L was before so it's 1 2 3 4 1 2 3 4 double that and save it under the name L second time through the loop now third time through the loop I'm going to take whatever L is right now so these two rows of 1 2 3 4 1 2 3 4 double that and save it under the name L and then the last time through the loop I'm going to take whatever L was before so these four rows of 1 2 3 4 1 2 3 4 Double those and say save that as the new L and that's it this code does not go uh to Infinity now let's see why exactly that is so this will help originally I've got L is 1 2 3 4 right so that's straightforward my Loop variable e goes uh through each element in this object right so first it's going to point to the one so far the same L equal L plus L let's look at the right hand side first okay this creates for me a new object right remember concatenation creates for me a new object it doesn't mutate anything so in memory I'm going to get 1 2 3 4 One 2 3 4 right I've doubled l l with itself what is l equals going to do do you remember we did a slide like this very similar to this it's like when we reassign the tupal the L equals will actually take the binding from my original object and put it on the new object that I had just created right exactly that that that memory diagram with the tupal right I had happen to have the same name but it's pointing to a new object same here I happen to have the same name L but it's now pointing this new object the old object this thing that I'm iterating over I've lost The Binding to it and really the only way I can even reference that old object is through this e because that e is still going to go through this old object elements so that's the first time yes question why do why CH yes you defined e to to be the object in memory not the name l so it's so e is bound to the object in memory that's this thing here that's why I it was so important to kind of separate ourselves from the object in memory versus the name we give an object because that name can change to anything just a bunch of other stuff but the object itself remains in memory right so then this becomes pretty um straight forward if you understand that piece right the first time through the loop I've got L assigned to this new object here I've lost The Binding to my original uh list that I'm iterating over so when I print L I print this next time e increases to the next element in my uh sequence right uh L will double what it currently is so it's currently this thing here it's going to double to that and I'm going to lose the binding from the original or not the original but this thing that I had just bound it to to bind it to the next object that I had just created and then that's the second time through the loop it looks like this third time through the loop uh e increments by one right to the next value in my sequence I'm going to take L plus l so double that previous uh data object take the binding from that previous object to the new one increment uh e by one more right and this will be the last time e is going to uh change because after this e will have gone through all the elements in its sequence it's gone through the end of the that list right so the last time through the loop I've doubled that L and I've lost The Binding from the previous one made it to the new one and then that's it it's done um questions is it straightforward does the picture help all that okay okay one more thing I want to mention and this is kind of a preview of what we're going to do next time um one very useful operation um that you might want to do is to take a list and remove all of its elements but not yeah go ahead sorry it like stops before the last one oh here it's um that's in range so here it's just iterating through all the elements in the sequence right going to yeah every one of them so one useful operation we might want to do is to remove all the elements in a list but not uh sorry but by mutating the list so we want to keep our original uh list object we just want to basically clear it out of all of its elements and so the command for that uh has a pretty nice name it's called clear so if you want to take a list L and clear it so to remove all the elements inside it you say l do CLE okay and that mutates my original list L to be empty so one thing that might help sort of with this mutation lecture and figuring out which object is which and whether you've created a new object or not is to figure out is to ask how do I know that this object is the object that I'm mutating and to do that we're actually going to use this function called ID and ID lets us kind of get the memory location or memory object or the idea of the object itself in memory so the code on the left is code that takes in a list l we get its ID to see what is this uh what what is this object in memory what's its number append an eight to it we're going to see that the ID of this is going to be the same as the ID of this because we're mutating L we're not adding we're not changing it we're not creating a new object and then lastly we're going to clear it and check the ID again and you're going to see that the ID is exactly the same in all of these different cases okay so I'm doing this in the just in the console just to show you real quick so here I have 456 as my L right here's l456 the idea of it is this number here we could just look at the last four uh three letter three digits or whatever 808 let's append an item to the end of our list right L mutated to contain that item the ID of L Remains the Same right ends an 808 it's the exact same object in memory we've mutated it L do CLE L empty list right I've removed all the elements of L and the ID of L will show me that it's the exact same object right I'm just mutating this same object in memory let's do that again except in the new version instead of using L do clear I will say l is equal to the empty list and this is also a really common uh common mistake to make so here I have L is 456 again this is my L let's get the ID of L it's going to be a new one because I've reassigned L to this new list right so this one ends in 312 again let's do an aend just for fun right the ID or L ID of L is going to be again 312 but now if I say l is equal to the empty list this is exactly same as the situations we've seen before with the Tuple and with the that that tricky example number three when I say l is equal to the empty list python takes my name L and assigns it to this object that is the empty list my original object 4568 is still in memory I've just lost the binding to it right so here's L it's an empty list but the idea of L is now going to be different right originally I was working with this list at ID 312 but after I said L is equal to the empty list I've lost The Binding from that Old list and rebound my list my name L to this new empty list right and you can see this using the this ID is pretty cool okay quick summary so we saw lists and tupal um as a way for us to create these compound data structures that can contain any kind of object as their elements tupal are immutable so for things like uh things things that don't change they're very useful like uh country latitude longitude those things won't change or you know the word that appears on a page number and a line number something like that um lists are mutable objects so you use them in situations where you need that Dynamic aspect right so if you want to maintain a list of employees you want to maintain a list of students a list of grocery items or things in your fridge right those are really good situations where you'd want to list because things are constantly changing you don't want to make copies of everything all the time because it becomes very inefficient to do so okay so next lecture we will continue with tricky examples um and we'll also have a quiz right remember quizzes are now on Monday