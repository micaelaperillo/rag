all right everyone so let's get started last lecture we introduced functions um and we saw some syntax around how to create functions but mostly we were interested in kind of motivating functions as a way for us to start writing really clean code code that's easy to debug and code that's easy to read in the future today we will uh continue our fun adventure with functions and uh we'll see how what it means to treat functions as objects so let's recall the example we talked about last lecture we created this function is even so the Syntax for creating a function uh is basically uh the keyword DF tells python we're defining a function we decide what name to give our function parentheses tells python in here we're going to name all the arguments all the inputs to the function the colon starts the body of the function the first part it's not required but should always kind of be in there uh as a way for us to implement abstraction is the called the dock string so this uh in green is the dock string triple quotes starts our dock string and triple quotes ends the dock string and you think of the dock string um also known as a specification as just a really long comment okay and in it it's uh and and the dock string is kind of I called it a contract between the person who writes the function and a person who uses the function and in the contract the person who writes the function basically says this function is going to take these inputs and I guarantee this function to work correctly when you give me these inputs of these types and these restrictions on them things like that and then you also State what the function is going to do and then you also State what the function will return okay in this particular function we have uh only one line This is the body of the function but you've hopefully seen functions that are a little bit longer as you did the practice from last lecture um and the body of the function itself so the lines of code are basically lines of code that we've seen before okay there's nothing sort of special about that except step for lines that start with a return so lines that start with a return basically uh tell python that as soon as I see this line with a return hit uh in when I'm executing my function I need to stop executing this function take the value associated with this return and pass it back to whoever called me okay a function always returns something okay in this particular case the function will return either true or false a Boolean but you can write functions I return integers floats uh strings things like that uh in this case yeah this is what is returned it is possible and we actually saw this in one of the UT triats as we were writing our code it is possible to write a function that doesn't actually return anything explicitly so here is the iseven function and inside the body the only change I've made is I've eliminated the little return keyword but otherwise the work that is done is the same so here I'm just calculating whether the remainder is zero or not so this line of code when the uh when the function is executed just uh is replaced with either true or false okay notice this function doesn't have a return keyword but all functions return something so while a function is being executed because of a function call if the function reaches the end of all of these indented lines here right any everything that's indented if it reaches the end and no return statement has been hit then python automatically returns none okay so this is the line without a return statement you can think of this uh code AS basically behind the scenes python putting this little line at the bottom that says return none okay now this is not something that we would ever write you just do the operations maybe you print some stuff out and then you just omit the return keyw if you want to return none from the function okay and none is this uh nun type uh is is a a value that is of Type n type we talked about it back in maybe lecture one or two and we haven't really used it that much since but basically you think of it as just having the type none type and there's just one value associated with it none and usually we use this value to represent the absence of a value in our code so let me just run some code first just to show you exactly some of the kind of uh things you might observe when when you write code that doesn't have a return statement so here uh I promise this is the last time we're going to see is even um so here I have two versions of the is even function so I have one that I named is even with return and I have one that is named is even without return okay they do very similar things the difference is that this one has a return statement where I return whether the remainder is equal to zero and this one has no return statement but it just prints whether the return uh the remainder is equal to zero okay so let's look at uh running the code with uh is even with return and as we're doing so this first uh function will be a recap of last lecture kind of tracing through what happens when we make a function call so I've uncommented this line and now I'm running line 13 so when python sees this file it basically sees this function definition and this is not code that runs yet right it's just telling python that I've created this function inside memory when I have this line being run that's when the function is actually being called and actually being run so I is replaced with a parameter three and at this point the body of the function is executed so the first thing that we tell the function to do is print the string with return so if I run it you'll see it prints with return then it calculates this variable remainder which is going to be one right because 3% 2 equals 1 and then I'm going to return whether one equal equal zero so that's going to be false so as soon as we see this return statement python returns out of this function call and replaces the function call entirely with the return value so this entire line after the py uh the function call is executed is replaced with false so I've just noted that here we're not doing anything with this return right all we're doing is making the function call and it just kind of sits on line 13 in order to see the result of the function call we saw last lecture that we actually um wrap the function call around a print statement right and function calls in that sense are kind of just Expressions right they do some work python evalu them to some value and then replaces that function call with the value so if we wrap is even with return three this function call around with a print statement python does the whole thing again I is three it returns false and this line effectively becomes print parenthesis false and we know what that does right it just prints false to the screen and there it goes right notice we still did this print statement because as part of the function body we tell it to do this print everyone okay so far okay so now let's see what happens when we run this function is even without return so very similar I've just created an extra uh parameter here or variable here just to show you that you can um so this function uh is even without return three is being run on line 27 so I is three this function will print without return and then it calculates remainder to be one and then has REM will be false right so the variable has REM will have a value of false and then as part of the function body we're going to print the value of has R which is false so this line here will actually print for me without return and then this thing false okay and then the function has no return statement explicitly in there so you think about it like python kind of implicitly adds this return none at the end of it the function call we don't add this I just wrote it there just to show you that python would add a line such as this when it reaches the end of the function but you would never add it so that means that the entire function call is replaced with none okay yes what happens when you in the return what happens when you put print in the definition versus around the function call versus like when you put in the versus when you put return in the definition so that's the next line so in the next one if we were to do what we did before which is let's print the result of the function call well python will do everything we just did right so it'll print without return it'll print false but then it'll additionally print the return from the function call so if the return is none this line effectively becomes print none so what we end up seeing or what the user would end up seeing if they actually run this program is they'll see without return they see false and then they see this extraneous none in the console right so you'll see probably this in problem set two you'll probably encounter an error such as this and maybe problem set three but don't be scared whenever you see a none out in the console it just means you have to be careful about the function that was called right you probably forgot to return something and instead we're we're just you know printing the correct value within the function but just never returned it right so that's just uh something to be wary of yeah so that's that's a good question should you always use return it depends on what you want the function to do most functions are useful because they go off on their own they do a task and they get a value at the end and they pass the value back to whoever called it and then you can use that function with many different inputs to give you many different outputs so usually you'd want to make functions that return something that you can then do something else with further in in another part of the program the the the prints within the within the functions should usually be maybe for debugging or for or you know like maybe the status of the function you know what part is it's executing or something like that okay and then when you run the function then it will give you the return but you run print and the function that's what it does exactly yeah if the function is not returning anything then it'll do it'll print none right yeah but if the function is returning something it will print right this if you wrap it with a print it'll print whatever got returned okay so let's have you uh work on this actually there's nothing to to write but think about it so I've got four lines of code here add one comma 2 print wrap that around the print statement Mt three comma four and then add add that around a print statement so try to trace through and tell me what outputs um each each function call will give me right so add one comma two what happens what do you think the output of this function is what gets printed to the screen what is it am I telling it to print anything that's the question yeah so nothing is actually printed to the screen right because in the function called add comma 2 right we basically map the parameters one at a time x is one y is two that was good we return three and so this entire function call is replaced with three but we never told the the that line of code to print that result right so there's nothing printed in this case well what if we wrap uh this in a print statement is anything printed in this case yes what is printed yeah exactly right the ad itself gives me five and so I'm telling it to print five what about the next one Mt what is that four 3 four is anything printed as a result of running this line I heard some yes some no yeah the print is in the function exactly so just because it's a function call doesn't mean we don't print anything right we need to check out what the function is actually doing so in Mt um X gets mapped to three y gets mapped to four and the function body itself says to print the result so this will print as a part of the body right um prints the 12 anything else at Prince no and lastly what if we put a print statement around the Mt 4 five what will that print yeah exactly 20 than none so the Mt itself is going to print same as there it prints the 20 so the function call returns none so this entire function called basically is repl repl with none and the line then becomes print none so this will print uh the none to the screen so there's actually four uh four printouts generated from these four lines right the first one generates nothing but the last one generates two lines of print outs any questions about this example yes you go over white this one here yeah so the Mt um check out what it's doing it's it's doing a print statement so that 20 gets printed out to the console but what's the return value of maltt there is no return right so if there's no return python adds the none right that's just something that's implicitly done so the return from malt because it doesn't actually have an explicit return is none so we're asking it to print the return which is n okay so a couple words on return versus print so the return only has a meaning inside a function so as an example if I just have this uh file open and I have return five just randomly that's not within a function definition already I'm in trouble you see that red X and if I run that code python gives me a syntax eror this one's pretty easy to debug there's a return outside of a function yep there it is okay so return only has a meaning inside a function it basically says this function has done some work for me and it's returning back this value print statements can be put wherever you'd like inside functions outside functions wherever you'd like and they all get executed you can have many return statements inside a function like if you have a function that returns zero if some condition applies or one if some other condition applies then you can have those two return statements but as soon as python during execution hits one return statement it immediately ends the function takes that return value and Pops it back to whoever called it okay so it's not going to run more than one return uh statement print on the other hand you can run as many uh print statements as you'd like inside the the program right and they can all be hit um and they can all generate some sort of output to the console um so the return statement has a value associated with it right so return five return you know we had remainder equal equal zero whatever there's the associated value with that return statement that value is what gets passed back to whoever called the function the print statement also you can think of it as having a value associated with it that's the thing that gets put out to the console but that value associated with the print statement is is just something that's outputed to the console it's not being passed around through the program at all it's just kind of static it gets put to the console and then that's it nobody else can really use that value you know unless it's a variable and then you're just using a a regular variable the last thing I want to show you this is kind of cool so if we have a print statement right just in here and we run it obviously that prints that to the console but what is this print it's a function right it has all the tale signs of a function the name is print the parentheses are there and I'm giving it one parameter five right so if I print the return of the print function so if I wrap my print function in another print function what do you think this is going to Output I'll run it it outputs none so the first five is due to this this shows up on the console but print being a function it doesn't actually return anything right it does something useful like take whatever you want and show it on the console but it doesn't return anything back to whoever called it and so if I wrap my print function around another print function I'm basically printing the return of the print function which is none so that's where the second none comes in right so thought of another way you can make a variable a equals print 5 and if I print a basically we're saying the return of that print first print function is just none yeah okay so I'm I'm going to have you work on this code for a little bit uh nothing to write but there is something to fix so here's a function called is triangular it takes in one parameter and it's a number an integer greater than zero I want this function to return true if n is triangular and false otherwise so triangular just means it's a whole number uh such that it's equal to 1 plus 2 plus 3 plus some you know some some summation like that right so one is triangular three is triangular uh six is triangular and so on and so on so take a look at this code um it's on line around 49 is so start by running it seeing what you get and I'll give you about a minute or so to see if you can try to fix it okay so make sure it runs with all these test cases here okay what's the first thing you should do when you're asked to fix some code that's buggy yes we can do that but first let's run it with something right um so let's run it with the first one print is triangular 4 so we know the answer should be false I mean I I told you so that it's good um yes it does give me false which is good but it also prints out a none what does that mean for us yes yeah exactly perfect so there's no actual return statement right like I mentioned in with this even example if you're seeing some nuns show up in places check your returns so is this function actually returning something no it's just printing this the result so it's printing the right thing in this case right so let's start by changing the prints to returns right yeah says and then FSE for this one yeah oh mind I think I just okay all right let's run it perfect yeah so that seems to fixed it um what should we do next yes check the rest of the print statements it doesn't work one yes exactly let's check the rest of the print statements so the second one six is triangular so that prints true and last one as you mentioned is going to fail on us it prints false but one is triangular right because one is just the sum of one so do you know what a fixed could be the range n plus one yeah exactly so you've you've spotted it the range should be n+ one if you didn't spot that right away um as I think somebody mentioned there the first thing we should do is just start putting some print statements and inside the loop is a great place to put a print statement we can see what thing we're iterating over right and so if this was still n and we didn't manage to fix it and we run it we see that we've iterated when I is zero right right here and we never actually hit hit one right so the fix for that is make sure we go up to n including n and now if we run it and remove this print statement because it might be a little confusing that now gives me the correct answer last step should probably be to run the other two cases again just in case my fix broke something else and it didn't the other two cases are still the same questions about this code does it make sense okay so now last lecture I mentioned that once we write functions it's really easy to include these functions in larger pieces of code and it makes those larger pieces of code very nicely readable so let's try to do the same with a slightly more complex example let's try to do uh to create take our bsection root code right and make it into a function and then there's going to be an exercise in a couple slides where you get to use this uh this function so the inside of this uh function here is basically what we had like three lectures ago okay it's just the bisection square root code the only thing I've done is I've wrapped it around a function definition so DF I gave it a name B section root is a pretty nice name and figured out what input this function should take so the input should be the X I would like to approximate the square root of right um one thing I didn't do is put a dock string on this so that's my bad uh but you know the doc string would say x is a positive integer greater than one and Returns the approximation to the square root of x or something like that um okay so here we're hard coding Epsilon to be1 uh we've got our low and high end points right just remembering what the bisection route does and we're starting out with a guess that's right in between the low and high the while loop here is going to do the work for us so the while loop condition is while the difference the absolute Val value right the difference between our guest squared and the actual X we're trying to find the square root of is bigger than Epsilon so while we're still farther away than Epsilon we have more guesses to make the way we make the guesses is by updating the lowend point or the high end point right depending on whether our guess was too low or too high this should be review hopefully and then after we've decided on which end point to update we update our new guess to be whatever High plus low is divid by two again so the midpoint of those where either high or low would have just changed right because of this if else and this Loop will just keep going over and over and over again making better and better approximations until we come within plus or minus Epsilon of uh the square Ro of X of X the difference between this code and what we wrote a few a few lectures ago is this uh part down here so a few lectures ago we all all we could do really was uh write a print statement where we took our guess that we ended up with right and we printed it along with you know that guess is close to the root of our original X but instead since we're writing a function I would like to take the result right my approximation to X and return it so somebody can call this function many many many times with different values of X and figure out a bunch of different approximations for all of these different X's okay so here I have the function calls right so I've got bsection root with four and bisection root with 123 and then I can just print the results of these right so here is the bisection root function I've got my print out uh commented out because I don't actually need it uh the rest of the code will do something useful with the approximations right so in this case bis section root of four was uh gave me a 2.0 so that's the approximation and the bisection root of 123 uh was approximated to 11.09 okay so what I would like you to do and this is going to be a little bit involved code it'll require some thinking is to write a function called count the numbers with the square root close to N plus or minus Epsilon okay and I'll I'll I'll help you out by drawing something on the board but I would like you to do uh the code for it so the idea here is that you have some n that's given as an input and you have an Epsilon that's also given as an input what you'd like to find out is how many whole numbers have their square root within plus or minus Epsilon of n so this is is kind of hard to wrap your mind around without actually drawing a picture so this is also something you should try to do in quiz situations pets things like that don't code right away try to draw a picture kind of depicting what we're asking for here so here we'll start with a line right this is our number line because we're doing the square root we want to know how many integers have a square root with an Epsilon of n so let's start with an N right and we have something plus or minus Epsilon right so this is Epsilon and this is also Epsilon right in the end we want to know how many integers have a square root square root of I so actually I'll do it like this square root of I is equal to somewhere in this range does that make sense so far that's what we're trying to figure out the square root of I is somewhere in this range so that means I is going to be some giant number out here right so this line can go further out so in the example here I've got n is equal to 10 so I know for sure that an i of 100 just kind of us as humans would work right because the square root of 100 is probably going to be approximated to pretty darn close to to 10 so I know that that value will be within plus or minus Epsilon of 10 but there's probably a couple numbers around 100 that also match this criteria right if I take the square root of 99 according to this example that approximation puts me within plus or minus Epsilon of 10 right so it's going to be uh you know Square of 99 is going to be like 9 whatever is here 95 right so that's within plus or minus Epsilon and similarly right square root of 101 and 102 also work because if I take the square root of these guys that will also put me within plus or minus Epsilon of 10 so the goal here is basically to figure out these numbers 99 100 1001 and 1002 you should use the power of computation and computerss being able to do a a task really really quickly to basically say I'm just going to brute force my way through this problem and say I'm going to test each number one at a time all the way up to some pretty large number right so you want to make sure you hit 99 100 101 102 maybe going up to maybe n cubed right if you go and take the square root of some I cubed you know you're going to hit all these values within plus or minus Epsilon so you're just going to Brute Force look at all the integers between 0o and N cubed and figure out if this appro if their square root the approximation to this square root is plus or minus Epsilon of n if it is keep a counter and increment it and if it's not ignore it and that's the idea to this um to this question Loop and a check that's it and you can definitely feel free to make use of the bisection root function that we wrote uh in in our code right you should definitely use it because it's very helpful so around line 96 is where you can write your code all right does anyone have a start for this uh for writing this code or how would you think about it or yes for I in range uh n cubed yeah we can do that all right so this will give me numbers zero through n cubed perfect so I've generated basically this sequence now what do I want to do once I have I and you know you can always write a little comment for yourself what you want to do once you have I right so in English what would you want to do once you have a number like this take the square root yeah take the square root of I okay how do you want to take the square root of I we can shall we use our bisection route we can too yep we can do both so let's use the function we just wrote so B section root of I this gives me square root so now sqrt is going to be some value here right it could be 10 it could be 99.5 it could be 99.7 what do I do with this number now yes yes exactly let's use an if statement so if and there's many ways we can uh if use the F statement we could do absolute value right that's what we've been doing already so if we take um n minus the square root right so n minus this value we just calculated is less than Epsilon all right so here we know that um square root is within Epsilon and what do we want to do once we know that the square root is with an Epsilon well if we don't know we can look at the doc string so we need to return how many integers have that square root with an Epsilon of n yeah exactly keep count of it right so count plus equals 1 yes and I do have to initialize count count equals zero right before my okay anything else yeah we do need to return so at the end of the loop we can return our count okay run it uh what is this from oh this is from the other two lines here so four I think that works because from the example there were four numbers that worked to double check we can or if you know something went wrong and the number you got wasn't what you were expecting again print statements very useful so we could print the value of I so this thing here we're trying to find the square root of and we can print the square root of that value right and so if we actually add it to the print State uh to the the code here we see the four values that we grabbed 99 100 1001 and 1002 and now that we wrote this code we can actually make really um simple changes to it and we have some pretty useful code right so if we make our boundary bigger 10 plus or minus one we're going to get more values that match this criteria right so in fact we got 40 of them right all the way from uh 81 all the way up to 120 they all match the criteria which is when you take the square root of that value it's plus or minus uh uh 10 uh 9 to yeah any questions about this example I know it's kind of involved but I hope that actually drawing a picture helped explain what we were trying to get at and then at that point it should have been pretty easy to figure out the structure of the code itself any questions yes question regarding the r why does it to like that large a number like it could it would be it could be smaller yeah I mean it we could have done n n n to the^ 4 we just couldn't do n s because then we might miss we well we would definitely miss1 and2 in that particular example and in fact if our Epsilon is really big we might actually I'm not sure about the math but if our epsilon's really big we might actually need to go bigger than n cubed as well I'd have to think about that but we just it it's okay I I mean it's fine to make it big it doesn't take that much longer to compute because the you know running the function is is very quick to python anyway yeah uh yeah there's a question yeah I had a similar question so is there the reason why we chose n cube is like an arbitrary number that's big enough yeah arbitrary number that's big enough um what we could have also done just along those lines is we could have done a little something a little bit smarter in here where once we find this uh a number that actually works like once we start incrementing our count we could have some sort of flag that keeps track of as long as we're incrementing the count right keep going but at some point you know you're going to reach a number that's too big and at that point you can just end the function early right you can just break out of the loop and you don't need to keep looking at you know uh all the way up to n cubed so we could have done something a little bit smarter to make the function just a little faster with flags which you can try so see if you can have the program stop as soon as you hit 103 right see if you can write the program that uses a flag to uh trigger that event and then when that event is true just break out of the loop or return immediately or something like that other questions okay so let's zoom out a little bit on functions we did this a little a little bit last lecture uh this is a function that we actually wrote last lecture it was Su of odd numbers between A and B this was essentially our black box right remember that now we're that we're writing functions we are kind of separating ourselves as some as a programmer who writes a function right you basically make this nice modular piece of code that can be reused over and over again so we're separating that aspect from somebody who's using a function so once there's a function already written for you you just use it in code right like we used the bisection route here right I know we wrote it but I guess technically I wrote it but here we just kind of used it right and we used it to write this nicer more complex piece of code and so this is what we do we basically create this black box and once you know the specification or the dock string of the Black Box you don't need to know how it's implemented in order to use it um but what I wanted to mention is something I mentioned last lecture is the function definition is just creating a function object inside uh inside the memory and the name of this function object is the name of the function so if we're thinking about the the program there is the orange uh box we have an object that just happens to be a function which has some code associated with it whose name is some odd and kind of drawing a parallel to that is when we create just a variable as we have been so far right here we're creating an object to whose name is low so in that same way that black box is basically saying I am creating a function object that has some code associated with it whose name is some odd okay so in this case I've got some odd low and high as three sort of objects inside my program and then only when I make a function call does the uh code associated with the function object run right so up when I'm defining the function it does not not run it just stays inside computer memory as an object that exists and when I make my function call is when I use that object so the function call basically takes my variables and um and matches them to the function definition so a gets matched to low and B gets matched to high and low and high in the function call have actual values associated with them two and seven and so that function will then go ahead and do the work and at the end it's going to return something either an actual value or none and then that actual value replaces the entire function call so in my program the variable my sum here is going to be equal to the return just a little recap but hopefully this kind of keeps bringing that point home so now we're going to talk about in more detail what exactly happens when we make a function call so when we make a function call you can think of the program as sort of taking a pause right I've got my main program and in my main program I have a function call that main program will just pause for a bit and that function call you can treat it as sort of a little mini program that needs to run and terminate return of value before the main program can resume executing okay so that little mini program that function call basically creates its own little environment that it lives in right so in that little environment it can create variables just like we would in a regular program it can modify variables it can print things right it can do all this work within its body and at some point it'll finish its job finish its task and it'll have some value that's the result of all of that work that it did and that value is what it hopefully returns back to the main program and then the main program can can finish its can finish it its job okay so what what's key here is that every time you make a function call you basically create a new environment okay and that environment is completely separate from the main program environment as soon as the function call terminates that uh function call environment disappears so any variables that were created within that environment of the function call will also disappear okay so all we're left with is just what's in the main program so now we're going to talk a little bit about environments okay and if you understand this you'll understand 80% of of functions and what to do with them okay so basically when you first run your program uh the program enters what we call the global environment the main program environment and anytime you make a function call we're creating this new environment okay so what exactly happens when we create these when we do these function calls how do these environments interact and the answer is they don't actually interfere with each each other that much they only interfere with each other through passing in parameters and through returning values but beyond that these two different environments the main program environment and a function call environment can actually have variables that have the same name but don't interfere with each other because they exist in different environments okay so we're going to look at this example uh to to Showcase that so here's a function it's pretty simple it does not do much it takes in one parameter uh probably a number and adds one to it right so takes in an X and uh does X+ One reassigns X to it and then it does this print statement and then Returns the new value of x so it added one to whatever you passed into it and it returns that new value so that's the definition again this just sits in Python memory it doesn't actually get run until we make a function call the parameter here when we wrote Our function are called formal parameters because there's no actual value associated with them right we're writing this function assuming that at some point we're going to get a value for x but at the time we're writing the function there's no value for x it's just this abstract variable okay and we're using that variable X within the function body assuming that at some point we're going to get an initial value for x right so X is equal to three and then at which point the body can then execute now when you make a function call in the main program scope that's when you uh pass make a function call with the with an actual parameter so here you'll notice I'm using the same name X but this x inside the main program is different than the X that's this formal parameter of the function this actual parameter when we make the function call is mapped to the formal parameter so at that point the formal parameter can get the value of the function call which is three okay and in fact it doesn't actually matter what we name this variable out here right we can name X is equal to three and make the function call F of of X but we can also have y is equal to 3 and we make the exact same function called f of Y right because we want to pass in three as a parameter to this function called okay so this x out here is different than this X over here so the re oh yeah go ahead which one is the formal the formal is the one from the function definition we say it's formal because there's no value associated with it when you first write the function right you write the function first there's nothing going on here and then you have some code that actually now is taking on some values and you can run it yeah so let's Trace through this code little by little to see exactly what environments get created uh as we make function calls so again this is my Black Box it's a function uh when I first run the program we finished the function definition so we're at this point in our program right before we do X is equal to 3 inside my sort of computer python memory what I have is one environment created and that's the environment of the main program the only thing I have in this environment is by F right because at this point in the program where the red uh arrow is I just had a function definition so again it's a definition it's it's a function whose name is f and it's an object right I it's not being run quite yet it's an object that contains some code now we have X is equal to three so that's pretty easy inside my main program environment I've got a variable named X whose value is three and then I have my function call so as soon as python sees a function call it creates a new environment and the current environment where the call is being made from so the main program one will be put on hold okay so here I'm calling function f so now I'm creating this new environment that think of it like this mini program this little task that needs to get done before the main program can continue executing so I need to figure out what's going on in this mini program right in this function called to F all right so here's my new environment the scope of f the first thing that we need to do is figure out what are the parameters of f so we look at the function definition and we see it has one parameter named X so we're going to take that X and the first thing we're going to do is map the formal parameter to the actual parameter okay so we're going to make the formal parameter of f named X take on the value three okay that's kind of what we've been doing already but now this is getting getting down to sort of details just details we've mapped all the parameters the body of the function executes I've again kind of blurred out this one because we're not in this Global scope we're trying to figure out what f is doing so the body of f says take X add one to it and reassign it to X so what's X inside my function it's three we add one to it and we make X be before uh I skipped one thing which is if in my main program I had Y is equal to 3 and F of Y nothing really would have changed right my formal parameter of f is still X and I'm still mapping x to the value that's uh in my uh here in the actual parameter okay so in my scope of f I've got X is three I incremented by one it gives me four and I resave it back into X and again there's 's no collusion there's no Collision here right in terms of naming because the scope of f the environment at F has a variable named X and I'm just doing stuff with the x that F knows I do have another X inside my Global scope but that one's put on hold for now okay all right so I've done xal x + one then I do the print statement so in f ofx x = 4 that gets printed out and then I return X so the thing that gets returned is the value of x so four and this again replaces the function call so this gets returned back to whoever called me and the environment that called me was just by main program and here I'm going to return four and this is going to replace that with four as soon as the function sees the return and returns that value back it goes away so notice that X that we had created is gone now we're in the main program there's no there's no confusion right my main program has its own X that other X that was part of of the execution of f is gone because that function finished its job and it doesn't need its environment anymore so now the return of the function replaces F ofx and we see Z is equal to 4 okay that was super detailed um but that's kind of what happens step by step when we make a function call with the new environments being created so if you can understand that it should be uh it should be pretty straightforward not you know and you won't get confused when you see an X out here you have F ofx you know as one function and then maybe another function that has G of X um and so on okay so in order to know the scope that you're in the environment that you in you need to know what expression you're evaluating right so here we were evaluating this function call so that means that we were inside the environment of f another example and this one's a little bit weird it shows some of the nuances of python um and these aren't necessarily true in other languages so I'm just going to do the drawing of the Scopes out here so let's start with the one on the left so you can see here I've got one function f of Y and I've got the main program that creates X is equal to 5 and then a call to Y so inside my main program I've got X is equal to 5 and then I have a function called to X function call means we need to create a new scope so this one's put on hold for now until we figure out what F parentheses x is right here okay so the first thing we need to do is grab F and take all the formal parameters of f there's one its name is y and map them to the actual parameters so I'm calling f with five so I'm going to map y to five this function is going to take uh uh now do its the body of its function X is equal to one so it creates also an X whose value is one just within its scope it adds one to X so this becomes two and then it prints X so it's going to print two and then the function terminates it returns none right there's no return statement and it the function is done so this line has now finished and the last thing that the function does after it's done the return is the scope goes away and the last thing we need to do now is print X so this will print the value of x in the global scope which is five so the output of this a little piece of code on the left side here is two and five okay what about the middle code similarly I've got a function definition and then I create X is equal to 5 and then I make a call to G all right X is 5 so as soon as I see a function call I need to create a new scope and I need to map all the formal parameters of G it has one formal parameter its name is y that one will be mapped to whatever I made the function call with five right X is five out here so that gets mapped to five what is this function going to do well it prints X what's X inside the scope of G do I have a g inside F an X inside G no so this is something that python does it says well if your environment doesn't have a variable named X in this case look further out and see who called you well which environment called this G the main one right does your bigger environment the one who called you have a variable named X it does right it's five so python grabs the value associated with that larger environment and if that larger environment didn't have one it would look further out and further out out until it doesn't have an environment to look at so G is going to print the value of x which is five and then it's going to print X + 1 which is six and then it's done it returns none and then as soon as it returns none this scope goes away and what we're left with is the global program and we print X which is still five what I want you to notice is that that function G printed x + one but never modified X right we never said you know something like X is equal x plus one or something like that that we just figured out what X+ one was and printed it okay all right one more example and this one will actually end up in an error so here I've got X is equal to 5 just like before and then I have a function call to H so again a function call means a new scope is created I've got one variable y That's My formal parameter it gets mapped to whatever I call the function with five oops that's an S um and then what is this function doing that line x + = 1 is X = x + 1 this is actually an error python doesn't let you do that and the error it gives you is actually what it says there so Unbound local error local variable X is refer refed before an assignment so it doesn't actually grab the value from the outer scope like we did in the middle bit it doesn't grab it because it thinks you're trying to create a variable named X inside H and you're trying to add one to X but you never had a line that said X is equal to something originally inside h okay and so when you're trying to say x is equal x + 1 it's trying to look for an X inside the scope of H but it doesn't have one and so that's where we get that error from okay and this is not some I mean it's it's just the Nuance of python but it's kind of important to understand that you can access variables but you can't change variables outside of your scope okay so the middle one just accesses a variable adds one to it and prints it but we never said X is equal to this value okay and it's kind of like I guess the error you get is kind of like if you made this be something completely different like Z you would get the same error you know it would be error uh variable z uh referenced before assignment right it's like you can grab X+ one but I don't know what Z is something the like and then do like you're taking it from outside and like so if you uh no because if you want to if you want to explicitly say that you're taking it from outside there's a keyword called Global that you'd need to write that explicitly says hey I'm grabbing this Val variable that is not part of me it's part of the it's in the you know the main program the global scope okay the last thing I want to talk about is using functions as arguments to other functions so um the way I've sort of been explaining a function definition is basically saying that when we Define a function python essentially puts some code in memory whose name is the function name right so basically the function name creates for me an object inside memory that happens to be a function object and just to show you sort of what that means is uh we have a function is even right we've definitely created it if we say the type of is even it's function right so the function is even actually has a type and its type is a function in Python so functions are basically just objects just like an integer is an object a Boolean is an object a float is an object right a function it look it's an object it just looks different it has a bunch of code associated with it so if a function is an object what that means is we can uh use an assignment operator on a function name so we can have two names that functions that point to the same function code we can use a function as an argument to another function like a parameter to a function or we can return a function from another function okay so here's an example uh pretend that this is our uh code file we've got uh the memory the first line of code here the definition basically creates this function object for me in memory it's kind of like a variable right iscore even is the name of this function object and this variable is bound to my function object with some code associated with it right so you think of the function as just an object similarly right when we write R is equal to two I think of that as the same thing right R is the name and I've got an integer object whose values to that's exactly what happens when we create a function definition right similarly Pi is equal to 22 over 7 right Pi is the name associated with a float object that's has that value so what we can do right now that we've established that a function is basically an object with a name we can say a line like this my funk equals to is even the right hand side here is just the name of my function it's not a function call right notice there's no parentheses after is even there's no parameter none of that it's literally the name of my function so inside memory what I've ended up doing is I have two uh oops I have two names my funk and is even that both point to the exact same function object so that means that that function object so this is even function can be referenced by both of these names so on the next two lines here a equals this and b equals this I'm running the same code just referenced by different names right so then a is going to be bound to false and B is bound to true because I'm I'm accessing the same code fundamentally by different names does that make sense yes awesome so everything in Python is an object including functions it's strange to think but there you have it so let's look at this code I've got three function definitions and only one function call what are the functions uh function definitions one I have named Cal it takes in three parameters one I have ADD it takes in two parameters and one I have div it takes in two parameters add does something pretty simple div has maybe a print statement but also does something pretty simple Cal is the one that's really strange right because it takes in these three parameters but what's the thing it's doing in here it's kind of treating one of the parameters op operation as a function okay that's what stranger about Cals and let's Trace through the code to see exactly what that means for us so when I first run my program I have three function definitions so I'm creating three function objects inside memory calc a function object that has some code add a function object that has some code and div a function object that has some code and then we get to the good stuff re equals the function call so re is going to be a variable that's going to have a value what value we need to figure that out Cal is a function call every time we have a function call we need to create a new environment so now we are creating our calc environment so we've put aside the main program scope for now and we're focusing on what Cal is going to do first thing we need to do is take every single one of our parameters and map it to the actual parameters right so the first parameter is op it gets mapped to add the next parameter is X gets mapped to two the last parameter is y gets mapped to three is everyone okay so far yes okay I've literally just matched names of formal parameter to actual parameter okay so now we finished mapping the for the parameters next we get to run the body of the function return what is this let's replace op X and Y with the actual values this basically becomes return a function call add 2 comma 3 I've just replaced the names that's it what's add 2 comma 3 it's another function call right so calc is going to have to be put on hold because I have to figure out what ad is going to return okay so what's ad going to return for me well add 2 comma 3 is what I'm trying to figure out so I'm going to map a to 2 B to three it's going to do five as the uh return so it returns five to whoever called it and whoever called it was Cal right here so this expression here op X comma Y which was add 2 comma 3 is replaced placed with five everyone okay so far awesome okay and then Cal can now finish right notice ad finished its job so it went away now Cal can finally return its value so it can finish as well so this one will return five to whoever called it which was the main program and finally Cal has finished its job and it returned five so step by step we just kind of Trace through the code you know functions out to in and replacing variables wherever needed so it's your turn tell me what's the value of Rez given this uh function called a cal and what's going to get printed so we can even write our functions so in the main program what do I have yep Cal and div are my [Music] functions that's it which one yeah res will be the the result yep and there res we will have a question mark because we don't know what it is yet and what's the first thing I need to do yeah make a new scope exactly so that's the scope of calc and we're going to map op to div what do I have X and Y two two and zero thank you so what's op going to do yes exactly we make another scope for div a is two and B is zero so we're kind of two Scopes deep what's div G to do yep so div prints out the thing denom was zero and what's div returning none perfect so div returns none here to Cal and then div is gone and then none gets returned from from Cal here and then Cal is gone and all I'm ref left with Is Res equals none exactly the return of Cal one more example uh showing scope I'm just kind of showcasing these uh sort of the same idea so I've got three functions here Funk a funk B and Funk C Funk a takes in you can see no parameters Funk B takes in one parameter Funk C takes in two parameters and if we scan the code we see that one of them is weirdly doing something so it's actually going to be a function right because you see we're calling it like a function inside here so we know f is going to have to be a function so if we run this program first three function definitions basically put some code for us in the memory when we make uh Funk call sorry Funk a call this creates a new scope a has no param or Funk a has no parameter so there's nothing to bind all this function is going to do is print inside Funk a and then return none right so that whole thing is going to print none next Funk B is going to uh be another function call right here so it creates a function scope right here we m M the formal parameter y to two and then we finished mapping all the parameters and what we need to do next is do the body so we print inside Funk B and it just Returns the value you passed into it so not a very smart or interesting function so it prints that and returns two back to whoever called it whoever called it was here so this print statement becomes print 5 + 2 the return so that's going to print stuff into the console and lastly the interesting one is going to be Funk C so Funk C notice I'm calling it with an actual function I have in hand Funk B right one of these that I've defined here so Funk C is a function call so there's my scope I am mapping formal parameter F to Funk B and Z to three so just mapping one one by one and then I'm doing the body of funk C so the body says now print this and return this so we print the statement and then the return basically says well what's F function called FZ we have to figure out what the actual values are and it's Funk B parentheses 3 so that's another function call which means another function scope again not a very smart or interesting function this funk B it just takes in the three prints inside Funk B and it Returns the three back to whoever called it so that fun that function is done and then the funk C can terminate and return three to whoever called it which was out here and notice as soon as a function call terminates and does a return it immediately it you know all of its variables everything that got created inside that environment uh go away they get wiped out okay give you about a minute to try this so write a function that meets the following specifications so I have a function named apply criteria is a formal parameter right so at some point you're going to have a function that does this it takes an inte a number an integer and returns a Boolean right so however a function does that that's what's going to be passed in and then and is an integer and what I want you to do is tell me how many numbers from 0 to n match criteria so when I apply the function criteria to numbers 0 through n how many of those actually return true on that function so just to show you something uh you know what this means concretely here's my function apply here's a function that I could call the apply with is even sorry I lied I guess we are seeing is even a few more times in this lecture um so here's a function is even and basically I run apply by saying I want to run function apply with the name is even right so here I'm mapping name to numbers 0 through 10 so I'll give you about a minute to to try it out and then I can write it just so we have some uh so we finish on time does anyone have a start so we know we want to touch each number zero through through n to see whether this criteria applies to them right so what's the start to get that going yeah for ION range n + one because we want to include n how do we apply the function criteria to each one of these values yeah exactly we just say criteria and this name will be replaced with whatever function we're going to call apply with I right and this criteria I will basically be the return of criteria what did I say criteria returns it takes in a number and returns a Boolean so we know that this is a Boolean what do I want to do with this Boolean if it's true I want to count it if it's not I don't so if criteria I count plus equals 1 right put this up here and let's remember to uh initialize our count and then that's it right if it's if it doesn't match then I don't care about doing anything with it so then we just return count so notice I'm using my function here that's just a parameter kind of like a place holder for any other function so this is even function when it's a parameter to apply will tell me six right 0 2 4 6 8 10 that's that's six values that match this criteria and what's cool is that I can actually create any function so if I want a function that's called is Five For example right it takes in a number and returns true if that number is equal to five right it's still a function that takes in an integer and returns a Boolean all I need to do then is run this apply with the function is five right so I just changed that here and then if I run it it should just give me one value right the five of course is one that matches this is five criteria between zero and 10 yeah so that's basically it so we saw some uh uh function a lot more you can do with functions they're basically objects in Python so they can be manipulated just like you would any other object you can have them be parameters to a function you can have them be returned from a function uh you can assign another name to this function body things like that uh I showed you what to how to think about environments right so that the naming doesn't get confusing right as soon as a function call is made that means another environment is created so variables created within that environment have no influence on other variables created in other environments okay um and functions are very nice oh very nice way for us to write code that can be easily be built up on okay that's it thank you