all right let's get started last lecture we began talking about an entirely new topic in uh computer science and we have begun uh learning about how to figure out the runtime of our programs right so we did um we looked at how to actually time the program by figuring out exactly how long it takes and then how to count the number of operations in the program today we're going to do very same thing uh to begin with so for the first half of the lecture we'll time a bunch of programs and then we'll count the number of operations just like before but we're going to do them in the context of slightly different slightly more interesting programs or functions um involving just pure numbers as our parameters and then functions that involve lists as our parameters um that'll be the first half of the lecture and then from there on we're going to look at the idea of order of growth which is kind of what we're building up this set of lectures to and then the order of growth um there'll be a little bit of math a little bit of graphing but not uh not too much and then we're just um we're just going to uh see how to actually uh evaluate the order of growth of functions from there on out okay so let's begin by just figuring out the runtime of our programs right this was a really quick and easy way to First to figure out exactly how long our programs take so last lecture we imported this time module and we're doing that again this time but instead of actually running the um the time function that we had seen last lecture um here right uh instead of running the time function which gave us this sort of global uh AB um absolute time since some some date in the past we're going to run this slightly different function called performance counter and this is what is typically used in the real world um to figure out how long an actual program or function takes to run the reason we're using this is because it's more accurate so the time.time function that we used last lecture gave us um maybe uh Precision to 1 * 103 or something very uh very big like that the performance counter can actually give us Precision to something uh that's a lot lot smaller so maybe one * 10 8 or some something very small so we'll be able to see uh the timings uh of some functions that were basically zero in the last lecture okay so just a quick review of how we actually get the time that a function takes to run we run this performance counter time and this one gives us not a absolute time but more of a um a shorter time frame not from some time in the past and the performance counter is very useful when we're getting these DTS right the difference in times so we're uh running the performance counter to get the quote unquote starting time we run the function we run the performance counter again to get the quote unquote stopping time subtract the starting time to get the DT okay so uh and then we will'll print that that time to see how long the function actually takes to run uh yeah that's what I said okay so we're going to look at two different functions uh than than last time but they're going to uh they're going to have sort of the same uh overarching themes that we saw last lecture so the first function we're going to look at is called convert to kilometers taking in some miles and Returns the value in kilometers and the second function is a function named compound so this one should seem uh very familiar it will bring flashbacks to problem set one um it's a function that takes in a monthly investment an interest rate for the month and some number of months to invest that much and it returns how much money you've made over those number of months so you can see here you have a total initialized a loop that goes through that many months and it updates the total based on the interest rate and how much money you have there right now plus whatever you've invested for that month okay so the three questions we're going to answer just like we answered last lecture is how long in actual seconds does it take to run these functions which input parameters does the function actually depend on and do these two functions actually run at for for different amounts of time and and sort of what is that difference right does one run in 12 seconds and the other one R run in 0. five sort what what is the the actual time that it takes for them to run so this is our code so these are the two functions um before we go on let me just show you how we're creating the inputs so just like before we're creating a list of all of the different different inputs we're going to run the function with so here I've got this Ln that will contain the numbers 1 10 100 a th and so on and these are going to be the parameters to my function one at a time of course and then I've got my Loop here for each one of those inputs one 10 100 a thousand I'm just going to run my function right so here I'm measuring the time it takes and then I'm going to report the the time that it took to run the program and just for fun I'm also going to report how many times this program could run in one second because for me it was a little bit hard to read you know one time 10 negative you know 20 you know eight or something like that but it was a lot easier for me to see this big number for how many times that function could have run in one second so here I've got uh convert to kilometers so I'm going to run it and we're going to see it's this right here how long the function actually took so last time we ran a program that was really simple like this all of it basically said it took zero seconds right it was just so fast that that time. time function was wasn't able to pick up that precise uh time difference but this performance counter can right which is a lot nicer so now we see that no matter what the input it looks like the time is pretty much the same right 3 * 10 7 Seconds no matter what the input is right that was expected now what about the count uh the compound function this one's going to be a little bit more interesting because there are actually three parameters to this function right so what we're going to do is change each one and see which one of those parameters actually has an effect on the runtime so here this bit is going to fix my interest rate and fix the number of months and I'm going to change the amount I invest every month okay so if I run that that was pretty fast um again we look at the results here and no matter how much I invest every month it looks like the program doesn't really change how long it takes to run right it's always about 1 time 10 the6 seconds to run all right what if I change the interest rate so this one's was a little a little bit harder to change but I settled on this as the thing I'm varying uh sorry I'm varying it in this way so it's going to be 1 Point um 1.1 or 1.01 or 1.01 that's what I'm going to invest uh the interest rate for whatever I'm going to invest in and I'm going to fix $10 as my investment per month and fix the 12 months again so if I run that same deal it looks like changing this investment isn't really making much of a difference in how long it takes the program to run all right one last parameter to try so now I'm going to fix the initial investment to $10 a month and I'm going to fix my interest rate to this per month and I'm going to vary how many months I'm going to invest this so again this n will be one 10 100 a th000 10,000 and so on so let's see what this is going to do already it's doing something different than the other two because it hasn't finished running yet right so it's still working on this last one down here but we can see that more interesting things are happening now right so here I've got um initially it's a little bit hard to tell for those small numbers which is fine but luckily we're able to run it for a bunch of uh a bunch of inputs so starting from about here right when I when I start investing a thou sorry when I start investing my money over a thousand months 10,000 months 100,000 months and so on it looks like we can kind of see a pattern again for a thousand months it takes the program takes about 5times 10 to neg 5 Seconds to run if I increase the number of months by 10 it takes 5 time 10 10 to the4 uh seconds to run and then as my input increases by 10 the number of months my time to run seems to increase by 10 as well right so 0.005 0.05 78 something like that okay so this is from a previous run of course each run will be different because we're just calcul we're just purely grabbing the time that the program took to run um so the actual time will be different but um few things to notice so python actually reported the time it took the program to run in scientific notation which is kind of cool so this is 4.3 * 10 -6 so it knew how to show it to me like that so it's not uh doesn't have a bunch of zeros in there um and then the observation as we might have you know as you might have guessed is uh um for this convert to kilometers was independent right so this is the kilometers not the compound function but then the compound function here this is again from a previous run we can make a few observations so so the first was that the time only change only uh actually changed with the with the input when we changed n months right when we changed the uh initial investment or the interest rate the program just basically took the same amount of time to run so it was only nend months that actually made a difference for us second observation again something we noticed is as we increase the number of months by 10 the time it takes the program to run also increases by 10 again something we've uh we talked about and the last observation um is that we have this relationship very apparent as the input is really big right as the input is small I think I mentioned this last time if for some reason my computer you know updates or decides to dedicate some time some resources to do to running an app in the background for whatever reason as it's trying to figure out the compound function with an input of one this number could be changed dramatically right because 2 * 106 can be affected a lot by just a little bit of time dedicated to something else whereas you know 4 seconds or 14 seconds if that my computer dedicates a little bit of time to something else that four or 14 won't be affected as much right so when the numbers are big that's when we can see the the behavior here of our function a lot more clearly right not when the numbers are small okay so now I'd like to look at some more functions um these functions are going to have the input being a list as opposed to just numbers right we've seen a bunch of examples with numbers but let's see what happens when my input is a list so here's a very simple function it takes in a list L and it sums all of the elements in the list l so we've seen this a bunch of times already we initialize a total to be zero we iterate through each element in L and we keep our running total by just adding the element to to that total right pretty simple and we return it now how do we actually run this function with a whole bunch of different inputs well that's what um we're going to see next so this bit here is exactly the same as before it's actually creating for us the list of 1 10 100 a th000 10,000 and so on but clearly the number 10 cannot be an input to this function right because this function is expecting a list right so L cannot be 10 it needs to be a list with some things in it so instead what we're going to do out of that number one 10 100 a thousand and so on we're actually going to make a list with just some random dummy numbers in it I don't actually care what these numbers are so let's just make them be the numbers zero to 9 0 to 99 0 to 999 and in effect each one of these lists will then have one element in it 10 elements in it 100 elements in it a thousand elements in it and so on all right everyone okay with that right so the input is now different it needs to be a list we're just creating a bunch of lists of varying lengths so the Rel relationship between these lengths are that the lists are 10 times as big as the the previous list right okay so then now I have my input list here I do the exact same thing as before not yet um I run the performance counter uh to I create my starting time I run my function and I get the DT and I report the exact same thing as before all right so let's run that down here right running running running again we have to wait a little bit it looks like it's working but it's just getting slower and slower which is fine so um what do we notice so when we had one element in my list it took 1 * 105 seconds to run when I had 10 it took 1 * 10 -6 seconds to run it was actually shorter to have more elements in it see this is what I mean when um it's very unpredictable for low numbers but as we get to lists of length a th000 10,000 100,000 uh a million and so on we can start to see the pattern so with 10,000 it took four * 104 seconds to run with 100,000 it took four * 103 seconds to run and then as the input increases by 10 that is the length of my list increases by 10 it looks like the program takes 10 times as long to run okay a very similar thing as before so the first observation that we can make out of this uh this this function is that um the size of the input obviously is now uh the length of our list right it's not just the number 10 or the number a thousand it's a length of length a list of length 10 or a list of length a thousand second observation is that again just like in the previous case the average time uh increases by 10 as the length of our list increases by 10 okay again very good um and just like before this relationship between the size and time is more predictable for large sizes than it was for small sizes right as we just saw here which little surpris me a little bit as well is if for us a list of that's longer it took a shorter amount of time to run which is counterintuitive but again that's probably because my computer did something here to uh take a little bit longer to run okay and then the last observation this is uh this is compared to the compound function where we change the number of months it looks like the time that this program actually takes to run is pretty comparable just in terms of pure you know seconds is comparable to how long it took for the compound to run right so here when my input was 100 million I think yeah 100 million it took about 8 seconds to run and when my list had 100 million elements in it it took about 7 Seconds to run right and then 10 times faster going uh uh when we decreased our input by 10 okay so already we're starting to see something something that we're going to get yeah go ahead is the of function um oh sum of is just this function that I wrote here yep that's just yeah I did I name it something differently in here no it was yeah yeah so already we're starting to get at this idea where I have two uh functions that do wildly different things right one sums the elements in a list the other one just Loops over some number of months and does some calculation but it looks like they're sort of in terms of just algorithmically wise they are very similar they take similar amounts of time they increase at the same rate um and basically they just have a for Loop right or some sort of loop that iterates through the input and does something so algorithmically we want to consider both of these functions the same even though they Implement completely different things other questions before we go on to another list function okay so let's look at a slightly different uh problem uh dealing with lists so this function or these three functions deal with finding an element in a list and we're going to compare the runtimes of these three functions so the first function is going to be a very brute forcey method to find the element in a list it's going was there a question yeah all right no worries um okay so the the first function will do a brute force uh search to find find an element X right here one of my parameters within a list F the other one of my parameters basically given a list of a bunch of elements this function will just painstakingly look at each element one at a time and ask whether that element is the one that I'm looking for right so starting over here the beginning of my list and going to the end of my list that's what is in does the next one binary search also looks for an element in a list making sure that the list is ordered but the way that it's going to do it is in a slightly smarter way so I'm actually going to draw my list this way so each one of these is going to be um you know elements in my list so this is going to do a bisection search to find the element in the list so again we're looking for element X within this list L and remember by section search we start with a l with a an a beginning end point and an ending end point and our first guess for where for the element or whatever we're looking for is to just say what's the is it the middle element right so look at the element in the middle and ask are you the one I'm looking for in this particular case you look at the element in the middle and you say are you the X I'm looking for right good so that's this one right here so the midpoint calculation is Right Here Right the reason why we're doing SL slash for integer division is in the case where I have a list where I would actually you know look at the midpoint here right obviously I can't um ask the I ask python for the element at index 3.5 right it doesn't work like that so I'm just going to round down you could also round up if you wanted to I just made the choice to round down just so I'm actually grabbing the element at an uh an integer Index right so I've grabbed my middle element and then I ask are you the one I'm looking for and if not I ask whether this one is too low or too high and then if it's too low then I know I need to search this part of my list and if it's too high I need to search this part of my list right so that's what this little if else is doing right and when I make my decision as to which side to look at then I reset my end points and I do the process all over again by asking the midpoint there are you the one I'm looking for so on and so on right so this does a bisection search uh also called binary search for the element in a list and the last way for us to search whether an element is in a list is one that we've already been doing it's this little one liner here is x in L so using the keyword in right so that's I call that the the built-in function the built-in operator in okay so it would be unfair if we just asked python to figure out um or to just uh pick a random number and ask whether that element was the one we're looking for Okay so instead what we're going to do is to kind of take an average for each one of these three functions just to make it fair so we're going to say when we're searching for an element in the list I'm going to say that I'm going to take the average of the case when the element is the first one in the list and I can find it maybe right away in this case or maybe not right away in this case the average with that plus when the element is the last one in the list and plus when when the element is the middle one in my list right so in that way we're actually you know kind of covering all our bases kind of best case worst case medium case scenarios right so each one of these three functions will be run with that in mind so that's these three functions so this is my brute force is in this is my binary search and the in obviously I'm just going to type in in when I run it so I'll just show you for one of them so we're going to uncomment this entire bit here and run it um but you can see here so instead of just running the performance counter and making one function call I'm actually going to run three function calls iterated over this little Loop where I'm looking for the element at the zeroth location the element at the halfway location and the element at the end of my list and I'm just averaging those down here the time it takes to find those three does that make sense okay all right so this is a lot to look at luckily I'm going to summarize it in the next few slides so we don't have to stare at that uh at that python uh uh screen there okay so we had three functions to run let's first look at how each of these three functions did individually and then we can start comparing them to each other so the first function we ran was the is in so remember this was The Brute Force One we're painstakingly going through each element and asking if it's the one we're looking for so no no smart way about that just root force your way through we notice that as the input list Grows by 10 the time it takes for to find find the element in the list whether it's the first one last one or in the middle on average also Grows by okay all right next let's look at the buil-in function we'll worry about the binary one later the built-in function so just using the in operator and you see um this was down here so this in so basically the function I'm running is purely just asking whether X is in L right and that returns true or false so I didn't need to make a function for that but that builtin in operator also has a very similar Trend right as the length of my list increases by 10 the time it takes for my program to run is also 10 times as long right I went 05 to.5 and the next one would be five and so on right okay so those seem to be doing approximately the same sort of they they have the same uh performance now what about the bisection search or binary search well this one is not so clear right if we look at the input right the input clearly increases by 10 from here to here the time increases 9 * 10 -6 to 1.1 * 105 right and so the factor how many more times it took is very unclear right it's not quite one if it was one that meant it's independent right it's constant it doesn't matter what the input size is it's always going to give us this amount uh it's always going to run in this amount of time so it's not quite one so it's almost independent of size but it's not linear right like the other two functions were right it's not 10 when the input Grows by 10 so we're not quite sure what this function is right but clearly it's not as bad as the other two but not as good as no relation okay observation that was observation three observation four will now compare the function that we wrote the is in this one here to the binary search this one down here well binary search was orders of magnitude faster than Brute Force right Brute Force when the input was what is this 10 million or 100 million I'm not sure um when the input was 100 million Brute Force took 1.6 seconds but the bisection search the binary search took 0.0000001 seconds so it's not like we went from 1.5 seconds to 1.2 seconds or to.5 seconds we were orders of magnitude faster right 10 to the5 right so there's a really big difference between this algorithm the one that Brute Forces its way through and between this algorithm that does something smart about removing half of the search space with each each Loop right all right so that's important to know and last ly just kind of comparing pure time that it takes these programs to run let's compare the function that we wrote the one that Loops one at a time through this list and the buil-in in function the built-in in function see while it's still the same sort of has the same relationship linear right with the input size it seems to do a lot better consistently by about uh 10 second sorry 10 times as fast right so when our function took uh 1 seconds the built-in one took 0.005 seconds where when our function took 1 second the built-in function took 0.5 seconds so consistently it's just faster to use the built-in in function than to make our own okay all right questions about any of these observations they make sense are they interesting yeah okay so what do we see just a quick recap of those three functions right the first one we saw is linear in the size of the argument so when the input list size increases by 10 the program takes 10 times as long to run but this other one is something less than linear but not constant so we're not quite sure what it is all right we'll come back to this in a little bit we'll end up plotting some of these uh runtimes so we'll actually be able to see the relationship um at uh in in a few slides the next thing I actually want to do is do one more sort of function this one is called the diameter right and I'll explain what it's doing because it looks a little bit scary but suppose we actually have some points in a 2d plane right so it looks like this basically what this function is going to do is it's going to figure out the biggest distance between all of these points so you know the distance between these two points is you know something this the distance between these two points is something else which two points yield the biggest distance right that's what this function aims to tell us and what that distance is so the way it works is it has nested for Loops so this is different than what we've seen so far right we saw an example of this last lecture but now we're seeing it in the context of something something actually useful so in this particular case we're going to create an input list all right so again our input list will just have some dummy values in it I don't actually care what these numbers are I just want to populate a whole bunch of points in a 2d plane so what we're going to do is pretty much just iterate from number0 to 10 sorry 0 to 9 0 to 99 0 to 999 and so on just like we did before and to get us a little coordinate in the 2D plane based on those numbers I'm just going to take the cosine of that number comma the sign of that number so that together so like cosine of you know one or whatever sine of one will be this point here right set up as a tuple and then this one might be cosine of five right comma uh s of five something like that so so I'm just making a whole bunch of coordinates in a 2d plane ensuring that I have n coordinates okay now the loop uh sorry there's going to be two Loops the outer loop will basically take us through each of these elements okay I have five in this particular case and the inner loop will go through every other element right but notice it starts from I + one and I'll tell you why that is instead of starting from zero so let's just walk through let's say we start out with this element this look as our first uh element in our outer for Loop so right now we've grabbed the first element in our our outer for Loop and what we're going to do is figure out the distance between it and everybody else so now we're iterating through the inner for Loop going through each element except for myself so I'm going to get the distance between this one and this one since it's the first one obviously it's this the biggest one but then I'm going to get the distance between this one and this one right and I'm going to say are you bigger than this one it looks like no so we're still keeping this one as our longest one then I'm going to grab the distance between this and this one and this and this one and as I'm going through this little if statement here keeps track of the farthest one so the one that has the biggest magnitude right in this case that's probably the first one we looked at and after I've gone through each element each other element I've concluded my first iteration in my outer for Loop okay so now the outer for Loop goes to the next element in the list let's say it's this one doesn't actually matter okay this one we'll look at the distance between itself and everybody else except for the one we already looked at because we already know this distance right we kept track of it already when we iterated through this one so as I'm going through my outer for Loop keeping track of this uh this point here it figures out the distance between this one this one which is suddenly bigger than that one which we had kept track of and then this one right here right all right good so now we're still keeping track of the biggest distance we've seen it's probably this one here and I've concluded the second iteration of my outer for Loop and now I go to the next element let's say it's this one doesn't matter again now this one is going to get the distance between itself and everybody else except for the two that we've already seen this one and this one right so that's why our inner loop starts at I + one so this one will get the distance between itself and this one all the way back there and this one all the way over here right and then next iteration in the outer for Loop takes a look at this one let's say and it finds the distance between itself and everybody else but you know what there's only one left that one there and then the last time through this one doesn't even get a chance to find the distance between itself and anybody else because everybody else already found the distance between it okay and so in this way we're basically finding all the possible pairs of all of these points in this 2D plane and keeping track of the longest of the biggest distance okay so in terms of the list the input list the way that looks like right this i+1 business here um the Loop basically says I'm going to start with U and I'm going to get the difference between U and the element at index one the element at index two and the element at index 3 this outer for Loop is done next we're going to get the difference the distance between this one and everybody else right so obviously not the element index zero because we already know that distance so we're going to get the distance between element at index one and index two and index 3 and then we're done and then the last Loop uh outer loop gets the distance between element and index two and index three and then it's done right so just these the two nested Loops just does all of this um uh until it finds the all all of these pairs it basically uh uh pairs up everybody together okay so if we run it what are we going to see so my input for this particular function you'll notice first of all is going to be much much smaller than the inputs for everything we've done so far right some of the inputs we had seen in the past were a million 10 million 100 million in this particular case I'm only going to go up to 6,000 because it's just going to take way too long to run if I make it go for any much any longer than that so what do we see already we've got um 100 points so 100 of these right finding the distance uh finding the maximum distance between a bunch of these pairs took about 03 seconds if we doubled that to 200 points it took 0.11 seconds if we doubled that to 400 points it took 0.005 seconds and so on and so on so just like before let's take a look at big numbers to see our Trend so as the numbers increase right by two if my put increases by two it looks like the time that it takes for me to find out the biggest distance increases by four right so my input increases by two the time increases by four uh and I'm not going to run this but you can make a new list on your own and change this to be uh inputs that are multiple that are uh yeah multiples of 10 right increasing by 10 each time and you'll see a very similar pattern where the out where the time it takes to run that program will be about 100 times as slow so the relationship there is a n n s kind of relationship all right so a few observations here as well um first one I already mentioned is this program just on just takes a lot longer to run in general right so here we were able with the uh compound and with finding whether in elements in the list and getting the sum of all the elements in a list we were able to run you know 100 million a list with a 100 million elements and it still took about you know one one something seconds whereas with this diameter function we can barely get to you know 6,000 and it's already taking 14 seconds so just way way way slower program in general right and then the relationship seems to be an N squ kind of relationship relating the input to how long the program takes so let's actually plot well I already did this but um here are the relationships for these sort of three types of algorithms that we've seen so far so the um this is the finding the element in a list those three versions sorry those two versions that we saw and this is the diameter function so if we uh plot how long it takes the program to run when the input increas when sorry when the input is this size we can see that there is a linear relationship so the time it takes for the program to run is linear in the input um the diameter we'll talk about the by binary search in a bit the diameter we again notice this just by looking at the pure numbers but it's a lot easier to see it visually when the uh this is on the x-axis the size of the problem so how many points we actually are finding the diameter between and how long it actually takes the program to run again the relationship is quadratic now that we plot it we clear clearly see the quadratic relationship and then this binary search we were very unsure of what it was right it wasn't quite constant it definitely wasn't linear but now that we've plotted it so this is the input size and this is how long it actually takes the program to run you can see it drastically increases when the uh input size is very small but then it kind of um sort of ASM totically reaches some sort of value um it's actually a logarithmic relationship okay all right um last thing I wanted to mention about timing before we move on to Counting is just pure running just purely running these functions on different computers will just give us different values just right off the bat so for my uh on this you know newer is computer uh how long did it take to run this compound well no what it like three seconds or something 1 point something seconds on an older laptop it took you know 663 seconds on an even older desktop it took 1226 seconds right so just you're just purely timing things the machine you're running it on is going to make a difference okay and then that's fine right it's it's important to know how long it takes but if you're just looking at the relationship between input and how long the program takes to run that's the same so it doesn't matter what machine you're running it on when you increase the input by 10 the program will take 10 times as long to run no matter whether you're running on a fast laptop old laptop or a super old desktop okay so just timing a program is really important right you'd like to know whether the program you wrote you're going to have to wait you know an a month for it to finish or a couple minutes for it to finish that's an important thing to know but what we're going to get at towards the end of this uh lecture is something that's complimentary and that's this idea of um ASM totic complexity so kind of mathematically saying you know what this program is not going to be that bad to run right it's you're not going to have to wait for it for months to run without actually running it of course so you'd be able to glance at a program and say this one is reasonable to run um and so we're going to do that in terms of uh this idea of order of growth which we'll get at to at in a little bit okay any questions on timing before we get to Counting oh yeah yes can you assume that all built-in functions are optimal in terms of running time yes certainly more better than when we when we write them um uh yes in Python and then of course in other languages you know there would be there maybe take advantage of other speedups as well like putting things in memory efficiently but yeah generally it's better to run something that's already been made than to make it yourself yeah okay so now what we're going to do is we're going to count operations just like we did last lecture clearly timing is nice but it doesn't give us a nice relationship besides us like spotting it right um there's no formula there's no relationship that relates the input to how long it takes the program to run right counting will get us a little bit closer to that and we saw that last lecture let me remind you the idea of counting so the idea of counting is that we're going to take a bunch of these operations like mathematical operations comparisons uh indexing into something um assigning a value to a variable all of these things right when we run them yes they might run for different amounts of Time 1 * 10ga 9 versus 2 * 109 something like that but that's very that's not a very big difference and so what we're going to say is that every one of these operations will consider to be constant right they will take one unit of time so if we say that we can actually come up with a relationship that tells us according to you know that that relates the input to how much this how many operations this program will will run so here in the convert to kilometers what do we have we have one multiplication and you know just for the heck of it this lecture let's say the return also counts as an operation so in this convert to colomer function we have two operations notice that it's not really related to the input at all so the the amount of operations that this program takes to run is always two it matches what our timing said right it basically didn't matter what the input was it always took approximately the same amount of time to run okay the sum of function so it takes an an input list and it gets the sum of all the elements this one will do we'll have one operation for doing this assignment it'll have one operation for grabbing an an uh an element in my list L and assigning it to I it'll have two operations for this total plus equals I right remember total plus I on the right hand side is one operation and total equals that is my second operation so that's two operations and then let's not forget our for Loop that's kind of the important part of this function how many times will these three operations repeat this one plus these two well it's going to repeat however many elements I have in L so length L times okay and then again let's say we count the return the return will also be one operation so the total number of operations for this sum of function will be one for the total equal Z Plus length of L * 3 because there's three operations being done for each length of L plus another one for the return so that's going to be three length L + 2 that's a nice little formula that relates uh how how how many units of time we'll have to wait depending on the size of the list right that's pretty cool so the way that we're going to count the number of oper options again I'm going to do it slightly differently in the last lecture just to show you that there is another way to do it so this is our function is in it's going to count how many operations we have and I'm going to use something called a global variable I'll show you again the difference between them so it's just these three lines that I added and you should never ever use Global variables in your programs except in this situation the idea of global variables is that you can Define variables just in the main program outside of any functions and you can access those variables within some function purely by saying you know if we defined count out here right before this function definition count equals zero or whatever inside of any function we can say hey python I would like to access this variable that I defined outside of this function you say that uh you tell python using Global and then the name of that variable and python will grab that variable that's B basically quote unquote shared across the entire program and modifi that variable right so in there in essence we're basically saying this is now a shared variable if I modify it within this counter within this function it'll be you know obviously modified for everything else it's very tempting to use Global variables because you know all the variables you could ever want to create are going to be accessible by everybody right no need to pass in parameters no need to do but it's it's very very bad programming so we won't ever do it except in this particular case because we'd like to keep a counter of things that are happening or for debugging purposes and things like that so the count variable will keep track of uh it'll just increment in key places where we have these constant unit of times happening so I've got count plus equals 1 here because I've got my return value I've got count plus equals 2 here because I grab an element from L and I do the equality check here and then that's it okay oops Sor so if I run that it's down here what are we going to see well I didn't actually do how many how much more it ran but we can see the the relationship ship right we go 9 to 37 to 3007 to 37 to 30,7 and so on so again the same relationship where we increase the input by 10 the amount number of operations we do is 10 times as more exactly like the formula said it would be what about the binary search so again we're going to use this Global variable and we're going to have the counter keep track of all of these operations so this count uh incrementing by three accounts for setting the low to zero setting the he is this thing and grabbing this actual value of length incrementing the count within this while loop will keep track of this subtraction as one operation and the test that it's greater than one as another operation counting uh uh increasing by three here accounts for high plus low the integer Division and assigning that value back to Mid count plus three here accounts for indexing into this l the less than or equal check and then either doing this reassignment of low or this reassignment of high right so that's three operations and then lastly count increases by three once more because I've got these operations here so indexing into the into low checking for equality and then doing the return okay so the actual number of operations will be kept track of in right by the counter so all doing is just kind of reporting how many uh times how many operations we've done so as we increase the input by 10 uh just like with timing we can't quite tell what the relationship is right again it's it's like one point something right with each run all right so this is uh these are the uh the results so the observation one as I mentioned when we increase the input by 10 this Brute Force I ered it but the brute force is in function also is uh does 10 times as many operations the binary search again we don't know what rate it is at but we can plot them so here I have the plots just like when I plotted the input size versus how long the program actually took to run I'm now plotting the input size versus actually just the number of operations being done so the isin function that Brute Force way of finding whether an element is in a list grows linearly no surprise there and how lucky for us um the binary search matches uh the graph matches the one that we had for timing right so as I increase my size in the binary search method the number of operations that I do is logarithmic in in time just like we saw in in the actual timing okay so timing and Counting are really nice right timing gives us pure number of seconds or you know months or whatever we need to wait for this program to finish but counting gives us a nice little formula right that relates the input to the number of of of operations that you have to do you might have noticed I briefly touched upon this that throughout this entire lecture and last lecture we basically just saw something like you know three different algorithms right we saw something that's constant something that's linear something that's you know quadratic and something that's B uh binary C logarithmic in this particular case right so that's four different algorithms but we saw way more functions run right so what we'd like to do is evaluate the algorithms not the different implementations right and what we'd like to do is evaluate these algorithms as the input gets really really big so what we're going to do is figure out a relationship between the programs run time time and the input but what we're going to do is focus on the biggest terms that contribute to the program's runtime right so we saw these examples last time right this my sum which basically summed all the elements sorry all the numbers from 0 to X and this the silly Square function that had nested Loops kind of like this diameter one right we were able to say something like um you know when the input increases by 10 the program is 10 times as long to run right so the efficiency of that program was on the order of X when the input increased by X the program took x times as long to run the square had a similar we could have said it in a similar way right when the input increases by X the program took X squ as long to run so I don't actually care right about all of these differences in the exact timings 1 * 10-6 1.3 * 10 to6 I don't care what I do care is the order of growth how does the program run in relation to the input okay and I care about that when the input is really really big so what we're going to do is Express the program's runtime in an order of not exact kind of relationship so while counting was really nice right it told us a nice relationship between the input and the number of operations when the input is really really big like 3x+ 4 when X is really really big I don't care that the number of operations is 3x + 4 right because when X is really really big that plus4 might as well be plus Z and that 3x is basically like X when the input is really really big right so that's what we're going to try to do all right now before we do that we need to decide what to measure right because when we write functions we're going to have functions that have a whole bunch of inputs potentially right so the input could be an integer like in convert to kilometers it could be a list in which case we would be interested in maybe the length of the list and if you have many parameters you'd have to decide right what is the parameter that contributes to the to the growth of this function so here's an example uh this is our is in function it looks for an element e in list L right so there's two parameters to this one we can ask does the program take longer to run as e increases right it's one of the parameters let's see what happens as we make e bigger so we can look at a little example if we find out whether zero is in this list containing One Two Three or whether a thousand is in the list 1 two 3 does the program take longer to run no no exactly so e is not really relevant in my runtime sort of uh calculation here all right well let's consider L now when we say l is going to change it could change in two ways right the elements in L could have different values right or the list length itself could be different so in this particular function let's say that the elements in L are small numbers versus big numbers okay that's certainly something that could happen and certainly with some functions that's going to make a difference so let's say in this particular function if the elements in L are big versus small is it going to make an impact on my runtime well here's a little example let's say I'm looking for the number zero inside a list with one two three and the number zero inside a list with a th 2,000 and 3,000 is that going to make a difference no right so the size of the elements themselves don't really matter and one last thing to ask ourselves is what about the length of the list so if L has different lengths will this make a difference in our runtime right so if I'm looking for zero and a list with three elements or zero in a list with 10 elements where clearly that zero is nowhere to be found is that length list L going to have a difference yeah in this case it will exactly so here in this particular function the input I'd be interested in uh in in sort of uh reporting the runtime from is the length of the list right not the elements in the list not e itself but the length of the list okay so the last thing that I'll mention is for this particular class we're going to talk about the worst case scenario so you might have noticed in this previous example here right I always looked for an element that wasn't even in the list right so when you're faced with a function you ask yourself this particular class at least what is the worst case scenario and finding out whether are functions in the list the worst case scenario for us is if it's not in the list at all right um so that's sort of another um um aspect of of runtime that we don't actually we won't talk about because for us we're always interested in the worst case but there are certain certainly analyses where you could look at the best case scenario which is well the element is the first one in the list right in that case you're always going to find it right away so it's constant um or an average case scenario which is kind of what people do in the real world right you're not always encountering the worst case but for us we're going to look at the worst case scenario so our goal is going to be to describe how the runtime grows as the size of the input grows in a really General way so we're not going to be interested in figuring out the exact number of operations no 3x plus 2 kind of deal here we're just going to focus on terms that are really that grow the fastest we're going to eliminate any sort of additive multiplicative constants and things like that so we're just going to focus on terms that grow the fastest and that will give us our order of growth so the way we're going to denote the order of growth is using this notation called Big O and big Theta okay now warning we're going to have some math coming our way it's going to be like three slides of just pure math okay you can sit back you won't need to know it uh won't need to know the details but it will motivate us to to to kind of give us the idea about this ASM totic order of growth all right so this is the the mathematical definition of Big O right so what we would like to do there will be a drawing don't worry so what we would like to do is figure out uh an upper Bound for our function so the function might look like this and I know this is just an F but we relate this to our class by saying you know what if we did the order of calculation sorry the number of operations analysis right for a function we could basically come up with something like this right we came up with 3x + 2 we could come up with 3x^2 + 20x + 1 for some random function that we wrote right so that we consider the function now the Big O is going to be the upper bound on this function so if I plug this function in my in my uh XY AIS this is what it looks like the Big O will be some other function that's going to Upper bound this one the blue one okay and it's going to Upper bound it for all values Beyond some X right so for all values Beyond some x uh some some number on the x axis some crossover point this big O of G this G will always be bigger than my f that's the idea here so clearly X is not going to Upper bound it right because after this crossover point x will be below my function no matter how big how big of a constant I tack onto that X I could have a THX that's still not going to Upper bound my little blue line here so what we're going to do is we're going to increase the the the exponential there so let's take x s well X squ is getting closer it looks like they're both quadratics but uh this uh orange line is not above the blue line for some crossover Point 2x getting closer 3x getting closer 4X is an upper bound on my f because after this little crossover Point here at about 20 my orange line the G will be always above my blue line my f right so far so good just visually speaking yeah one below it there do that matter yeah the orange one is below it that's totally fine because what we're interested in is the behavior when the input is really big okay so that's why I don't care about like weird stuff happening down there all I care about is when when my X is super big okay so now I found this G so I can say that after this point 20 my orange line will always be above my blue so I can say that my f is Big O of G is Big O of X squ okay because I don't care about this four so much because it's just a multiplicative constant because this 4X is always greater than my function for all X greater than this crossover Point here right that's it that's the definition right so the G here is basically this function without the multiplicative constant in front of it okay so I say 3x^2 + 20x + 1 is Big O of X2 so generally speaking that was just an example generally speaking the Big O is an upper bound on my function okay and this is now just using uh variables like constants and things like that but it's exactly the same situation that we had from before okay so I'm going to try to map the blue to the blue and the orange to the orange and the purple to the purple to help you um kind of match up what we saw in the previous slide so basically we say that our function f is Big O of this Orange G right if we can find some blue constant right where this constant was this four here where that constant multiplied by G the X squar is greater than my function for all uh values beyond that crossover point right so I found my four because 4x2 is always greater than my function Beyond 21 right that's what we saw in in the picture right so then we can say that my function f is G is Big O of G of X where that g is X squ just matched it all right so in terms of the the picture here right this is kind of a little zoom in of what happens Anything Can Happen down here but beyond the crossover point which is here in the big picture that crossover Point uh beyond that crossover point my orange is always greater than my blue okay so what does this mean we're going to talk about this in a few slides but you might have thought about this I can actually pick any function that grows faster than uh what is this 3x2 right I can pick X factorial X factorial grows super fast or 2 to the x that also grows super fast all of those functions that grow way faster than mine are also upper bounds on this on this function okay so that's Big O it's just an upper bound then what is Theta for the reason I just stated right I said X squ sorry X factorial 2 to the X all of these functions that grow much faster than my function are all upper bounds and that's not really helpful for us when we say oh this function is Big O of whatever right because you can just pick something that's ludicrously fast that grows ludicrously you know fast and say that that has no meaning so instead what we usually report is the Theta which is actually an upper bound and a lower Bound for our function right so using the exact same reasoning we're going to find some constant tacked onto that g of X such that that function grows um is is always underneath our function okay so I again I'll put up a a lot of math but basically these first two lines here this one here there exists blah blah blah blah blah that first here this is a is the Big O definition so we've already know what that means all we're going to do is tack on another condition which is we can find another constant for that same G where that function Beyond some crossover point is always below my blue my blue line so here's an example right 4x^2 we saw that it grew faster than 3x^2 Beyond a crossover Point well we could say 2x^2 will always grow slower than its own crossover Point okay so the constant four was the same as we had seen before but this constant two now becomes a lower bound right so I'm basically trying to have that same G both upper bind and lower bound my blue function right and that's the definition of theta so now I can no longer say that 2 to the X right an exponential both upper bounds and lower bounds it because that 2 to the X will grow faster than my function no matter what constant I attack attack onto it okay so now what we see is that really the G of X is going to be the term that grows the fastest it's just going to be that term here right it's going to be the thing without the fastest growing term in my function without the constant on it okay so yes we will never remember all that but we're going to do a bunch of exercises and you're going to see just how easy it is to figure out the order of growth okay but I will mention this just again because it's very important right so when we're talking about upper bounds you can pick any function that grows faster than yours right F ofx this 3x s thing is O of x s yes but it's also o of X cubed o of x to the 5 O of x to the 100 o of 2 to the x o of X factorial all of those things that grow much faster but my f ofx is only one Theta and it's Theta of X2 right and that's the term that grow that's the term that grows the fastest in my function here so when we look at a function right based on the number of operations or however you know you know you're given the function when we look at the order of growth of the function we just focus on the dominant term right so in the first one the input here is n and the function is n^2 + 2 n + 2 which which one of these is the dominant term you tell me yes exactly n squ so this function is just going to be Theta of n^2 that's it how about in the next one what's the dominant term here yeah exactly 3x squ even though 100,000x is going to be huge for a while and this constant is also going to be huge for a while as X gets really really big this 3x and in fact just X2 will kind of take over everything else right so this next one is Al is Theta of x^2 how about the next one what's the term that grows the fastest here yeah exactly a right log is is is is slower growth right so this Theta of this function is just Theta of a so notice what we're doing here is just focusing on the dominant term we're going to drop the multiplicative constants drop every other term and relate the Theta in terms of the input right so I don't just use Theta of n all the time right in the previous one it's tempting to say the first one's Theta of n s the next one's Theta of n squ the last one's Theta of n but n is not always the input to your function right if it is great if it's not you always have to relate it according to the input of the function maybe it's length L maybe it's you know something else okay so let's have you try a couple more what is the Theta of the first one here what's the term that grows the fastest yeah Theta of X next one n cubed exactly theeta of n Cub I told you this is going to be so easy I know that math was scary how about the next one that's the term that grows the fastest but then it's Theta of drop any multiplicative constants and it's just Theta of Y the last one is going to be TR what is the Theta if the if the variable is only B yeah 2 to the B what about if the variable is only a a cubed exactly and if my function is both a function of a and b and a plus 2 uh plus a cubed right because both will contribute to the runtime of this function right not just the B right so if this function whatever this crazy function is that I wrote that takes so long to run was uh had both inputs b and a right as its parameters the Theta for that function is both is in terms of both BNA right the dominant terms of each yeah no no need to worry about negative coefficients have a yeah Yeah Yeah question oh some different param variable that's not even here yeah if the if we were if the parameter the function was C let's say for this last one but the formula was this then the Theta would be just constant Theta of one because it doesn't even depend on these variables so these are just considered constant time that's a great question yeah if the parameter was C or something else okay so now we can actually look at functions that we write and we do the exact same thing we can first start out with just saying how many operations does this function take come up with that relationship and just Theta that right just like we did on the previous slide so here's a function that uh that calculates the factorial what do we have here well we've got this is constant here right we've got just one while loop where there's five things going on here there's the comparison there's this uh times equals which is two operations this minus equals its two operations so this function is just 5n + 2 by the same analysis we did you know a few slides ago right so if we say what's the Theta of this function well what's the Theta of this 5 n plus 2 super easy right it's just Theta of N and in this case the par parameter to our function is truly n um when we have functions that are slightly more complex and we've got things that are in series like for example here I've got two for Loops one right after the other um we basically use this law of addition to take care of that so that means we figure out what the Theta is for the first for Loop the Theta for the next for Loop Loop and we just add those two uh thetas together okay so the first for Loop here is Theta of n because it's something that depends on parameter n and the next for Loop here is Theta of n s right and this this uh because the parameter here is n * n the stuff inside the for Loops are constant so they don't contribute anything to our thetas right there's no more things to multiply the complexity there so so the if this is my entire function here the Theta for this function is Theta of n plus Theta of n^ 2 right and the law of addition just says Theta of n plus Theta of n^ 2 is just Theta of sticking those two inside as as part of my function n plus n^ s and we know how to do that that just simplifies to the dominant term which is n^2 okay so that's the law of addition so that's when we have loops or things like that in series what about when we have loops that are nested right then we use the law of multiplication because for each one of these things we're going to have to do this that many times right so in this particular case we need to be careful the outer for Loop is going to be Theta of N and the inner for Loop is also Theta of n even though I'm dividing n by two right 0.5 * n is still Theta n right that multiplicative constant in front of that n is 0.5 which is just you know it's just uh it's still leads me to be Theta of n the print is constant so there's nothing else to multiply there so the law of multiplication just says Theta of n * Theta of n is Theta of n^ 2 inside there okay so let's look at this program what is the Theta for for this well we could do it sort of in very grave detail we've got X as our parameter so we only count loops and things like that that are a function of x if I had a loop that was a function of I don't know n or something that doesn't count because it's not a function of my input so only look at things that are function of X I've got one outer four Loop that goes through x times so that's Theta of x I've got an inner for Loop that starts from I and goes to X that's a little bit tricky but in the end overall it's going to be Theta of X because it's going to be the first time it's going to go through x times the next time it's going to go x - one then x -2 then x - 3 so we're effectively just kind of adding over all of these runs X plus uh sorry uh 1 plus 2 plus 3 plus 4 plus 5 all the way up to X and that's just some function of X right it's definitely not going to be constant so the inner loop is also Theta of X um everything else is Theta of one right there's nothing else that that depends on X so this whole function is going to be Theta of one for this uh assignment here Theta of X time Theta of X for this nested Loop here and Theta of one for this return down here so overall it's just going to be Theta of all right so that's sorry that's that and so overall it's just going to be Theta of x^2 just by the laws of multiplication and addition all right think about this and then tell me what you think it is what do you guys think it is yeah Theta of length of L absolutely right so this is constant this stuff inside the loop is constant the return is constant and the only thing that depends on L is the length of the list right this Loop so the answer is Theta length L perfect how about this one so here we're assuming the Len all the inputs are the same length yeah Theta of length of pick your favorite one Theta of length L is reasonable you could also say Theta of length L1 or Theta of length L2 cuz these are uh two Loops that are in series right right so this one just Loops through the length of L but inside we're not doing anything that costs more than just constant time right here we're just comparing two numbers like three and two we're just assigning something to true so nothing else really depends on the the lengths of the list so this is Theta of length L this is plus Theta of length l so that's just Theta of length L all right so we saw a bunch of different algorithms right sorry no we didn't say a bunch we saw a bunch of different programs but we could kind of classify them all into one of these categories right and this is all basically all the different algorithms that you could ever write in general right so something that's constant Theta of one something that's logarithmic is Theta log n something that's linear we saw many of these is Theta of n something that's log linear we haven't seen any yet but that's Theta of n log n Theta of n to some constant like n s n cubed is polinomial and Theta of some constant to the N like 2 to the N 3 to the N is exponential and when we're writing our programs you can do a quick analysis of the of the program that you just wrote look at the loops look at to see how efficient you wrote it and you could basically classify your program into one of these categories right if you had nested Loops that both depend on the input you probably wrote A polinomial type algorithm if you just had one Loop that depended on the input you probably wrote a linear type algorithm right and when we write these algorithms at a first pass we want to be somewhere up here you don't want to do anything that's polinomial or definitely not exponential because things get slow really quickly with those numbers right so we never ever want to be in that situation although sometimes it's unavoidable right so that's all I've got next lecture we will be going through a bunch of those different complexity classes and looking at different programs that land in the those classes right especially the the logarithmic and the log linear all right