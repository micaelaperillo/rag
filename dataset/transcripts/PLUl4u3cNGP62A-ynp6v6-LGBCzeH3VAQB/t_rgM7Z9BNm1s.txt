all right let's get started so today's um lecture is lecture three out of four on the idea of object oriented programming and creating our own object types through python classes the majority of today's lecture will be on this idea of inheritance but before we get there I'd like to do a little bit of a recap of the big things that we've seen already and um along the way we'll be writing a new uh data type for something more abstract an animal class more abstract than what we've seen before but then when we get to the idea of inheritance we'll build upon this animal class with some um more animal objects so the big idea behind uh creating our own data type is that we want to mimic what's going on in real life right and in real life we basically have all of these different objects in the world right but these objects kind of can be grouped According to some categories right so in this particular slide I've got six different objects but the three on the left can kind of be grouped together right we know that they are a kind of cat and as such we know that all these cats have you know we can describe them using some common properties and common behaviors so for these cats I would give um I would say that all these cats have a name an age and a color associated with them right so I know that all cats would therefore you know generally have a name and age and a color and then some similar set of behaviors the items on the right right those three objects I know they can be categorized together let's say that they're wild rabbits and let's say that for the wild rabbits I don't actually give them a name so I would categorize them again using common properties properties just an age and a color right no name and then those three objects on the right also have a common set of behaviors different than the objects on the left and so we're trying to mimic these uh the idea of these categorizations data types that we see in real life okay so um little bit of recap right when we Define our own data type in Python we decide on a bunch of attributes and attributes can either be data or they can be procedures the data is you think of them as sort of what variables make up your object and this is something that you decide so for coordinate object we've seen this example A lot of times we decided on X and Y values for this more abstract idea of an animal well we can just say that we can describe an animal by its age so how long it's been alive right since birth um in terms of procedural attributes these we implemented using methods in Python classes um and these are the idea behind these is just how can somebody or somebody who's creating an object of this type manipulate the object what are some ways to interface with this object so our coordinate class we one of the more interesting things was to find a distance between a coordinate and another coordinate but some of the simpler things were you know to just you get the value of the x coordinate the y-coordinate things like that for our animal class that we're implementing today it's going to be a little bit more abstract but one of the simplest things is to just say hey tell me how long you've been alive that's basically just grabbing the uh the value of the attribute the AG right so here we're defining our object uh our data object right um the class keyword tells python we're creating our new data type this is the name of our data type so the type of this thing that we're creating is animal in parenthesis here animal inherits uh uh animals is parent is the generic python object and later today's lecture we're going to see what happens when we put something else in those parentheses so the uh the parent of a class that we create is something other than just the generic python object and then the very first method that we always write in our new object definition is the init method this tells python how do you create an object of this type like a very basic uh information that python needs to know so the init method is a special Dunder method double underscore init double underscore and by now you're familiar the first parameter of every single method that we Define inside a class is this thing called self and remember self is um is a a variable right it's it's a variable name that allows us to talk about an object without having created one yet because all we're doing here is defining the class right we don't have actual objects created and so this method here the init method and all the other methods are run on an object of type animal but we don't have that object yet so the first parameter will be that object in this abstract sort of way and then you can put other parameters in uh in that list and so we say that when we create a new animal object we're going to initialize it by its age so some number okay um within the init what do we usually do well we usually um initialize all the data attributes also called uh instance variables so here how many data attributes do I have for the animal class two exactly yeah two the first one self. AG right is a data attribute and we know it's a data attribute because we have that self appearing again right if it just if was just a variable name like age or years or time or something like that it would just be a regular old variable and as soon as that init method ended did that variable would go away but the fact that we've inti we've initialized this variable using self dot tells python hey this is a variable that I want to persist for as long as this object exists in memory okay so it's a it's an instance variable so self. age equals age we'll create this data attribute age and assign it to the parameter PED in age now selfon name is also data attribute it's just not being passed in the parameter list and that's okay not everything has to be passed into the parameter list so here what we're effectively doing is saying when we create a new animal object we have to tell it the age how long it's been alive for but then the name data attribute is always going to be none so there's an absence of a value for the name for every animal we create right off the bat okay everyone okay with me so far yeah what's the purpose of defining this to be none well later on I'm going to add some methods that allow you to give a name to an animal if you'd like um but again this is uh a design choice that I made so you yeah you might not make the same design choices so that's the definition for my class right just these four lines of code and then down here we saw uh in the past couple uh lectures how to create actual new objects right so this is where the uh the acttion actually happens right so here I'm creating a new animal object uh a variable my animal is bound to that animal object right so that's my variable name you can name it anything you want and then you're uh telling python to create a new animal object simply by invoking the name of the class and then passing in all the parameters that we're expecting here except for self right because self becomes this thing like if I were to draw a box around animal three that is self that is this object that I just created okay so that's the init method last lecture we saw some Dunder methods and I think I said uh probably the second method you'd ever want to implement for a new class is this Dunder St Str method now the dunder Str method tells python how's how python should print an object of type animal right because initially right off the bat if we didn't implement this Dunder Str Str method python would default to the Str method of the generic python object which just tells us the memory location this object has been created at which is not very useful when we print an animal object and again my design choice is to uh say I'm going to uh print animal colon the name of that animal colon and the age of that animal again my design choice right and remember the dunder strr method Returns the string you want to print out it doesn't print it out straight up okay everyone everyone okay with that so far should be review okay so then the other things that we we want to include in our uh class and this is something that you includeed no matter what um the uh language you're working with is these things called Getters and Setters so Getters are these two right here Getters are basically very simple functions that return the values of the data attributes that this object has this object just has two right an age and a name because they were defined using self. age and self. name so here's a getter to to just tell me the value of self. age so all it does is return self. and name all it does is return self. name very very simple Setters same idea except that now we're allowing uh someone using our class to set the values of these data attributes through this through these methods right so here all it's doing is taking in a parameter for the thing you want to change the age or the name to right and all it does is say well s self. AG is going to be equal to the thing you passed in okay um that's the age so we're changing this to a different number uh and then the set name is changing the name data attribute to a different string and here I'm using this default parameter that we talked about way back in um in when we talked about functions right so if you don't pass in an actual string value will default to the empty string okay so let me show you how this works so this is my animal class exactly as in the slides I've got my nit St and my two Getters and Setters and then I've got two animals being created here right so here's a print for animal with age four and here's a print of animal age six so if I run these it should print animal colon none because I didn't set the name to anything for these two and then their respective ages right so this is using the Str strr method for uh on a and this is using the EST method on B okay and then we can access of course using do notation all of our uh data attributes so here I'm accessing the age directly but since the get or get age just returns for me the value of that data attribute these will actually print the same thing so I'm just going to comment these out so if I'm accessing a age through either the data attribute directly or through the getter method it'll print four for both right pretty pretty straightforward um and then we can do some like this so I can call the set name method so here I'm passing an actual name for it and then I can print the name or I can use the the getter to print the name right so if I run that you'll see the name has now been changed for object a and then if I run the print method on on a then WR it prints animal colon the new name that I just said it to fluffy and then the age has been unchanged if I run set name without a parameter it'll revert to that default parameter for the name which is the empty string so the new name of my animal a will just be an empty string so it's just going to be colon with nothing in there right so just empty no space or anything just nothing okay everyone all right so far hopefully a little review so we saw that we can actually grab the exact same value right um for the age using uh by by accessing the age data attribute directly right using do notation or our getter that we wrote one of these is better than the other uh in terms of style and in terms of uh you know good coding practices and in terms of writing code that's easy to read easy to modify robust things like that the one that is better to use is the one that accesses the method right both are using Dawn notation but the first one is actually accessing the internals of of my um of my class definition right we're in order to know the value of my data attribute as someone who's just using this code for an animal class I'd have to actually go in and read right the init method to know these data attributes that are being initialized I don't know about you but I actually let's take an example of a list right something we've used a lot have you ever gone into the definition of the list class to see the data attributes that are being initialized I haven't right all we've been doing is working with methods that allow us to make changes to lists to do operations on lists and things like that so the internal workings of the list class is hidden from us and that's just the way we like it right I don't care how the list is actually implemented and the same thing should happen here right I shouldn't care how I implement the animal class I shouldn't care what variable you know what uh instance variables they're being they're using so let me show you why so if someone who's writing the animal class decides in the future that age was a strange variable name to use and they decide to change that the um the variable associated with how long this animal has been alive to to be years right so here I've got oops I've got uh self. years equals age that's the only change I've made to my uh animal class right so I've made the design decision to change the this data attribute to be years and then of course since I'm making this class I need to make sure all my Getters and Setters and everything still works with this new data attribute so my get age will return self. years right I'm returning this very iable uh data attribute that I've I've changed to well this is the full code so this is you can see the changed data attribute here I'm using self. years equals age and then my getter is going to oops my getter is going to return self. years and my Setter is going to set self. years well if this this implementation should be hidden right from me somebody who is just trying to create a bunch of animals in their code so this code down here will work if I use my method right because the method should still work no matter what the data attribute is called right age or years or time or whatever but if I had code that access that data attribute directly it doesn't work anymore it throws an air because surprise that dat attribute no longer exists right so it's much better style and you know you can uh more robust to use only Getters and Setters only methods to make changes and to manipulate the objects you should never ever really have to use the uh the data attributes right questions about that okay good because that's uh something that you'll have to keep in mind on the quiz next Monday okay not using data attributes all right so having said that python does allow you to do a bunch of questionable stuff so first of all it allows you as we just saw to access the data attribute of a particular instance that you create right so you create an object it's a very specific animal with a specific age you can just access the use dot notation to access the the value of all of these um data attributes fine we're not you know we're not we'll we'll mess ourselves up in a future because you know maybe this won't work but it's not so bad however python also allows you to change the value of a data attribute outside of the class definition right so this is code we write not within the class it's code we write as somebody who's using the class so what does this mean well now I'm going to set the age data attribute to be whatever I want outside the class definition right I could even set it to a dictionary if I wanted to um in this particular case I'm setting it to a string infinite but if I do this then I risk you know code on this animal class not working further on because maybe they assume that the age is always a number and so a different method I might run will not work anymore if I happen to set it to the string right um and then one other thing python actually allows you to do is to add data attributes to instance es so now the problem with this is that let's say I create a whole bunch of instances of animals right this animal's got age four this animal's got age six this animal's got age five and then one of these animals I decide to add a new data attribute to it like only one of these instances now has three data attributes associated with it a name an age and now the size all the other data uh all the other animal instances I've created only have a name and an age associated with them just this one happens to have this extra data attribute so now the whole reason why we're creating our own data types right was to be consistent to bundle the specific set of data and specific set of behaviors together flies out the window because now I have one instance that now has this extra data attribute associated with it and nobody else does right so all that consistency has has um you know is has gone out the window so never ever do any of these outside of the class definition it's totally okay to access data attributes while you're defining class right but not okay to do any of these outside of the class definition even though python allows you to do them okay so one of the things I wanted to show you in this lecture is something we haven't really seen so far and that's actually just working with objects that we create yes when we created fractions and coordinates we just created a whole bunch of objects and then you know printed you know the numerators or you know printed the object or multiplied them together but we never actually wrote nice functions that kind of work with objects of our type so one of the things I wanted to show you is how how to do that so here's a function that creates um a dictionary out of a list so the input here is going to be a list of whatever I want and uh the function what I would like it to do is to pick up from the list only numbers that are non- negative and just integers so in this particular case I would like my function to pick up the two the five and the zero ignoring everything else and I would like to create a dictionary out of these numbers and what the dictionary should do is map each one of these numbers so the two the five and the zero these would be my keys and they should be mapped to animal objects with these ages right so that's an animal with two of age2 and this is an animal with age five and this should be an animal with um age zero right so my keys types are ins and the values associated with the keys the type should be animal this object that I just created all right so the code is uh pretty straightforward we just have a little Loop that goes through each element one at a time in my list that's for n and L and then I'm just going to do something to the elements that are integers and greater or equal to zero right non- negative so that'll extract only the two the five and the zero as we go through the loop over the elements in L and then the key line here is this one in red I'm going to say I'm going to this line just adds an entry to my dictionary right so this is the Syntax for putting something in a dictionary right there's no append or Plus in a dictionary or anything like that it's just straight up indexing the key you want is n so either a two a five or a zero and the value I want to associate with that key is an animal with age whatever this is two five or zero right so exactly what I wrote here everyone okay so far all right the loop goes through to the end of the list and then we've created our dictionary and we're done as we're writing this code how would we debug it or how would we check to see that it worked well the instinct is to say okay well let me check to see if this function worked so here this line animals equals animal dict L will run this function and it runs it on this L and at the end it returns a dictionary right something that looks like this so our instinct is to just print that return to dictionary okay but if we were to print that and you can actually run the code in the python if you print that you get something like this and that's because python doesn't dig through elements of dictionaries or even elements of lists to run the print method sort of recursively right it just runs the print method top level and the problem is it knows how to print integers just fine but it doesn't know how to print a dictionary where the values are animal objects and so we run into the same problem where now the value associated with key2 is this animal object at that memory location but how do I know that I didn't screw up sort of my you know I created an animal with um age five where it should have been to right so the solution and you'll probably encounter this um on the next Quiz if you're debugging your code um the solution is to just iterate through the dictionary right in such a way that you run that print statement directly on an object of type animal python knows how to do that right we told it the Str method right we have an Str method here so it knows how to run the print directly on an animal object it just doesn't know how to run the print where the value of a dictionary is an animal object so let's replace this print of the dictionary with a little Loop it goes through through uh this the dictionaries items right so n is going to be my key and a is going to be the value associated with that key and I've just got the print statement here so I'm print I'm using an F string here that prints key and whatever value that key is with Val whatever value that that is right so now the print statement is being run directly on an object of type animal and now the result of this uh loop will be this right so key to with value and then it uses the print statement on my animal object does that make sense everyone okay so far it's conver yeah exactly it's converting the stuff in the dictionary strings because my print statement is being run directly on that object right of type animal and it knows how to do that I implemented the dunder SDR everyone okay okay so let's have you try this let's have you write a little code so this function it's going to be very similar we're not making dictionaries you'll be making a list but you'll encounter the same problem um the input here is going to be two lists of the same length one list has numbers one list has strings and what I'd like you to do is create for me a new list and the new list is going to have animal objects where you match sort of index by index so the uh the resulting animal object at index zero will basically create for me a new animal with age two and named blobfish right the animal object in the resulting list at index one will create uh will be with age five and named Crazy ant and then the animal object at index two will be age one and named parap Fox so we're just doing the same thing index by index where you create a new animal object with the uh age this value right one one at a time and you set the name to be this value one at a time and then return that list okay so that should be line uh 79 okay who has a start for me okay should we call it L3 okay yes but then if you're doing L2 of n then this should be the index right so how do I make this be the index instead of the element directly yeah uh yeah yeah exactly right so instead of looking at the element directly let's just look at the uh the range so for I in range and then we need to do Len pick one of the lists because they're the same length so now I is 0 1 two 3 four five like all the index uh values so L1 at index I um so I need to create an animal with that age right so let's do let's do this um uh age equals L1 at index I right just to save it as a variable and name equals L2 at index I right does we agree so now that I have age and name stored in these variables how do I make an animal object with with that age yeah well the init method creates for me an animal with that age right right so when we just create a new animal object we just pass in that age right like the Constructor requires the age of the animal right so when we construct a new animal object we just invoke the name of our animal uh where is it here right or sorry our animal type our animal class and then we pass in the age that we want to create this animal with right and that according to the in in it method creat self. AG be whatever is passed in and a name none so we're halfway there we've created an animal object with the age that we want but the name data attribute for this object is none everyone with me so far so how do we how do we make the name of this animal object be the one that we saved right from that L2 list yeah exactly we can use a Setter function yeah set name right here right don't access the attribute directly but yeah we can use a Setter function so um so this created for me that new animal right but I need to actually save that animal somehow right because I need to reference it later so let me do this a equals animal with that age and then we run the setter function on this object a right set name it's just a function and what name do we want to set it at this thing here so name here is this variable that we extracted from the L2 list everyone okay so far so so now what I have is a object a is a variable that's bound to an animal object the name the the the age was set when we first created it and the name we just set through the setter function and now we should just put it in my list my list is originally empty right so now let's instead of I don't have a a bunch of elements to add it to so let's just append it to L3 like that right I mean theoretically I could have created an empty list that was you know three elements long and then I could do L3 at I but this works too and then at the end let's return L3 right questions about this is this all right okay so if we run it and we just print the list with these animal objects we run the same problem as that dictionary one right you see I've got a bunch of memory locations here so to test that I did it right instead of printing the list let's iterate through our list through this little for Loop and just run the print method directly on my object right so now if I run that it should just run the print statement directly on each of these animals right so that's correct I think yeah does that make sense yeah oh so instead of printing the list this thing I looped through my list and printed the elements that's not in the function no that's just yeah that's outside but this is something pretty common that you'll run into you'll make a you know a list dictionary or some structure or tupal or something like that with objects of your type and when you run the print statement directly on that structure it doesn't go deeper than top level and so it prints you know that uninformative stuff okay so we um in this particular in this examples we saw that it's better to access the um attributes through Getters and Setters so you know in addition to the init the Str strr method writing Getters and Setters to have a consistent way of accessing and modifying these data attributes is really important and then you can even impose restriction something like you know the types have to be this or maybe they can't you know the age can't be a negative number or something like that and it allows you know a lot more um uh consistent use of the object so now let's move on to hierarchies okay and this is where we're going to talk about inheritance so there's something like maybe 28 objects on this slide right there's the six we encountered at the beginning of this lecture and 22 up there so there's TW 28 separate objects on this slide and all of these objects we could say are of type animal right because by our definition an animal has the the attributes for an animal is how long they've been alive and these all are objects that have been alive for some time but in addition to having uh how the attribute for how long they've been alive and an unknown name we can actually then create separate categories right and each one of these boxes that I've uh that I've I've created is a different subset of animal right we call it a we'll call it a subass or a child of an animal class and that's because they will bring about different uh data attributes in addition to what an animal's data attributes are and they will bring about different behaviors in addition to the behaviors of our really generic animal object right so the things a cat can do a rabbit might not be able to do and things a person can do a cat won't do and a rabbit can do right so then they're all animals but they all are going to uh have additional data attributes and additional behaviors that are different in these different categories right so I might say something like the cat has a name an age and you know a pattern or a color the rabbit again I said are wild so maybe they don't get a name but they'll have a color or pattern and then um the age of course from the animal people of course have the the person object has the the age right that comes from animal but in addition they might have a list of friends or something associated something like that associated with them right in a list of friends something doesn't something a cat doesn't have something that a rabbit doesn't have you so you see what I mean and we can even go further we can say well if I take my person object I can now subcategorize that as well say well this is a student class and in this student class I would say a student is a person so all the data attributes and all the behaviors that a person has the student also has and of course all the animal stuff because a person is an animal so for example let's say uh right an animal is a generic object it doesn't speak but let's say a person gets the behavior to speak right so they for speaking I might just print hello to the screen or something simple like that a student is a person so maybe they they uh they also get something like uh their age the name and maybe a list of friends associated with them but a student might also have a major or a favorite subject in school associated with them something that a person doesn't have right so that's a new data attribute associated with a student that's not associated with a person a student might also have uh different behaviors like tell me your favorite subject in school things like that or it might override behaviors of a person so a person speaks you know says hello prints hello to the screen we can say hey if I ask the student to speak they might say I have homework instead or something like that right so what we're trying to do is take those relationships and Implement them in code so here I've got an animal class which is uh sort of my Base Class um it's going to be my uh also called uh parent class or super class and then anything that an animal has all the data attributes and all the behaviors of animal will be inherited by person cat and rabbit so anything so a person is an animal a cat is an animal a rabbit is an animal so everything they have all these three subtypes will have as well but all these subtypes will be different amongst themselves right a person will have an ability to speak maybe print hello to the screen a cat could also have the ability to speak but maybe they'll print me out to the screen a rabbit won't even have the ability to speak at all um a person might have a list of friends right whereas a cat won't a rabbit won't things like that so we can either add more information like list of friends was an example of that we can add more Behavior like the ability to speak is an example of that and an example of overriding behavior like I mentioned is let's say we have a subass student of person if a person's uh speak method said uh you know said to uh say to print hello to the screen we can override that behavior through a speak method inside student where where you don't just print hello to the screen you can print I have homework so let's try to start implementing this relationship this is just our animal class there's nothing new here I'm just doing a little refresher on what this class looks like so we've got our nit where we initialize an age and a name that's none uh we've got two Getters two Setters and this Str Str method that prints animal colon Name colon age Let's uh so yeah okay this animal class inherits from object so the generic python object and now let's work on the subclass cat so when I create my subclass cat the way I tell python that this cat is an animal is by putting in the parentheses here the name of the type that I want this class uh to inherit from so a cat is an animal now one of the things I kept coming back to is anytime you create a new data type you have to have an init method this doesn't specifically have an init method right I've just got two other methods here so you might think that it's missing but it's actually not because as soon as you put another data type here in the parenthesis so that cat is an animal think of it like python going into the animal class copying and pasting everything that part of that animal class or copying everything that's part of that animal class and pasting it inside cat so since I don't have an init method in specifically defined in cat python will say oh we'll just use the init method of your parent animal so the way we create a cat is going to be exactly the same way we create an animal except that the name is going to be cat as my object type instead of animal okay but we just pass it in one thing which which is the age of this C so since we're copying and pasting everything and yeah question also yes exactly so the parent class of animal is object so cat will also be a python object but that's super generic stuff like binding a variable name to this object things like that yeah um so not only does the unit get copied in but every single data attribute age and name every single way that that data attribute gets created so the self. age is going to be a data attribute of cat and it's going to be set to whatever is passed in as a parameter self. name will be initialized To None just like for animal I've got my two Getters my two Setters that also work with cats and then the Str method of animal will also be inherited in here but now we notice one thing and that's we have an Str Str method defined in the animal class but then in my cat class I Define an Str Str method as well right so that's called overriding your parents's class and when we create an object of type cat if this object has a method that's has the same name as their parent we use this method there's no reason to go up to your parent to ask for their method we use the one that is for this object okay and Cat in addition to having everything that animal has implements a new uh Behavior which is the ability to speak and all it does is print me out of the screen okay so let's look at some code so here's my cat so I created a new cat object the same way I would create an animal but you know I'm uh invoking the name of this class cat um the way I create an animal is just by passing in the age of this thing right so here I'm creating a cat whose age is five the name of this cat is none right because that's what the init method of animal does but I can run the methods on animal on my cat object because a cat is an animal so all the methods that work with animals will work with an object of type cat so here I can just run the set name method on my cat object even though the method's not explicitly defined in here it's defined in my parent so if I set the name to fluffy and then I print the cat object it's going to print it's a cat colon the name colon the H um speak is just going to print me out of the screen um we can do the getter methods as well right so all of these methods that were implemented with the animal work with cats as well now a here object a was created up here when we talked about animals right it's an animal object because it was created using the animal uh invocation here does the animal class have a method to speak no so if I actually run this it'll give me an ER right it just says there's no attribute speak which makes sense I never Define that I Define that in your child not the parent okay questions about cats Okay so uh I want to briefly touch upon overriding methods because it can get a little bit confusing so you notice the Str Str method right was implemented in both of these objects the strr method is in cat which overrides the animals method to print cat colon Name colon Ag and the animal method Str Str method prints animal colon Name colon AG so the rule is um when you uh when you're running a method that you know exists in a whole bunch of these inherited uh uh objects you look at uh which one is it it's the S strr right so it would be the print method right or any method it doesn't matter what it is you look at the object you're calling the method on right so if it's a DOT notation you look at the thing before the dot if it's you know one of these special methods what's the object you're running this method on so here I've got the print method on object C python asks what is your type oh you're a cat do you have an Str strr method defined yes you do so then it uses the one that it finds right away but if for some reason the uh the current object doesn't have that method so an example of that is set name right right set name is not a method defined in cat right C is an object of type cat it doesn't have that method python says oh you don't have that method let me look at your parent does your parent have that method and then it you know looks through in here and it finds it good if it finds it it uses that one if it doesn't find it it looks at your parents parent right if your parent parent has it it uses that one and if it doesn't it looks at your parents parents parent until it gets to the generic python object this one right here if they have it it uses that one and if it doesn't then it throws an air so an example of something that the generic python object has is the Str method right it just prints the memory location and that's why when we don't Implement our Str strr method in our class python defaults to the generic python object one um questions okay let's look at a person so let's create a person object um this person object again will inhered from animal because an animals the only things we we we said an animal is to defined as is being alive for some period of time and it has no name right the name is none so we don't even pass that in so let's say the parent uh class of person is animal but this is my design Choice also to highlight a bunch of stuff but let's say that this parent this sorry this person class when I create a new person object I would like to pass in an age and a name right so I don't just want to create a person with an age I want to actually create it using a name in that parameter list so as an example in my code here when I create a person I would like to pass in their name comma and the age two parameters to make a person okay well I can't use the animals in nit method right I could for cat because cat was happy to just be created using an age but I can't do that for a person because I would like to create a person by passing in two parameters in the creation of the person so what I have to do is effectively override the init method of Animal by implementing it in my class definition right so here I have to Define my own init method and I do it because now I'm not just passing in an age I want to pass in a name and an age on the parameter list and then beyond that what do I do inside the inet method well I know that this person is an animal so what I'm going to do to make my life simpler is to call animals in it method so here we use this do notation on the name of the class sort of similar to how I showed you that sort of long way of calling methods well here's the name of the class dot the name of the method in it and now I pass in all the parameters self and age um so I'm going to call animals a nit method which will create that self. AG set it to age and create create that self. name and set it to none so I'm taking advantage of the fact that that init method already does those two lines for me right so I've turned those two lines into a one line here and then I'm going to say well I'd like to set the name of my person so I'm going to call the method set name with the parameter that's passed in and then I'm also going to initialize another data attribute for a person which is a list of friends initially empty so what's nice about this and when we implement the student class it'll it'll look even nicer what's nice about this is we're taking advantage of the fact that the init method of animal already does some work for us but at the same time we can clearly see in this subass what uh what the person object brings in addition to the animal object right so in addition to just being an animal we give a name and get a list of friends right so it's very nice uh to see the extra data attributes or what what uh what you need to change with respect to the animal to make a person and then beyond that so I think that's going what I said sorry I didn't go through that as I said it and then beyond that I've got some uh you know we can add some Getters and Setters I just did a select few but you should add them for all of them so the get friends just returns a copy of my list because maybe I want to keep my original order or something like that it's just good style to return a copy of a list um the ability to add a friend to my list basically just adds a friend name as a string if it's not already in the list so I can't have you know two anas in my list I consider them the same um ability to speak just prints hello to the screen and then I I added this cute little function to tell me the age difference between this object that I'm calling age difference on and some other person right and all it does is grab the two ages take the absolute value of the difference and print that to the screen and then lastly we're going to uh override the St strr method of animal to instead of saying animal colon Name colon age to say person colon Name colon age so this way it helps me figure out the the the type as well so in my uh code here I've got two people right P1 P2 here's Jack age3 he's Jill age 25 if I run the get name get age on both of these right right this will run animals get age get name right I've not defined these in here which is fine we inherit from animal and animal knows how to grab the agent name so there they are if I ask if I print P1 it'll print person colon name AG if I ask P1 to speak it just prints hello if I ask the age difference between P1 P2 no matter what just takes the absolute value prints fiveyear difference and then and let's add some friends to P1 so here I've got two Bobs but it's just a list keeping unique names okay so let's have you try this for a little bit um it's a little bit again working with objects of this type so it's a function that takes in a dictionary so I'll tell you what the dictionary looks like it Maps a person object to a cat object all right so that's my dictionary so this is the key this is the value so I've got all these person objects right being mapped to cat objects um so as an example here's an input dictionary P1 is this person here and P2 is this person here right so my two keys P1 P2 are person objects right they're not integer float strings they're person objects and then the values associated with those are cat object so here's an object of type cat with this name I just rans set name on that cat after I created it same here here's the name uh set to this new cat object so I've mapped P1 to C1 P2 to C2 so if I run this function what I'd like to do not return anything this function it it just print something on each line as you're going through all the items in the dictionary it just prints the name of that key colon the value of uh the name of the value right so all I'd like to do is write code that extracts the name from my person object and from the cat object okay I know what you're thinking I look really young for 86 but it's um diet exercise and hanging out with you guys Ed candy for sure so here let's let's write this code on 178 all right does anyone have a start yeah do do items yep let's write a note for ourselves K is person V is cat yep yep so k. get name you want to save it as a variable oh or no oh you want to put it on the one nine that's fine yep print K.G get name yep V do get name exactly yep perfect uh and yeah nothing to return so let's run that cool does anyone have questions about that right so we're just manipulating these object types and again if it's confusing I highly recommend quiz situations and things like that now that we're working with object typ just make little notes right I know we're iterating through a dictionary and it's kind of convention right keys are integers things like that but this particular case just a little note that K is a person will help you remember that you need to run a method on this K variable right like we did here K.G name and then v.g get name okay uh yeah how do you ensure that the key keys are person uh just be um you can't ensure it in this particular Cas I mean you could say if type of k equal equal person capital P person then do the code and else probably just skip it or raise a value error or something like you could enforce it that way but in this particular case we're just assuming that the tester will make person objects mapped to cat objects yeah but yeah certainly if you're making like a software for something more complex you should probably make sure that enforce that okay so the big idea with inheritance is that now that we have subclasses also known as child classes those subclasses use a parents's attributes so everything that a parent has and can do a child has and can do as well but that child can override certain parents's behaviors and a and the child can add new behaviors or new attributes in addition to the parent let's look at one more subass student before we go on to one last uh thing so um student here from our uh pictures and diagrams inherits from person not from animal but indirectly from animal right so a student is a person and when I create a person I would love to create it using a name an age and a major but we can use a default parameter for that major to be none if we don't actually want to pass it in but I would like to create it using by setting its major their major as well so now I can't use the parents init method because I've got three parameters I would like to initiate my student with so I would uh I would like to create my own init method inside person so here I am defining my own init method and now it becomes uh apparent why it's nice to call the init method of your parent because if I say a student is a person all I need to do to initialize a person type like all the attributes associated with a person and the init method of the person is just call the init method of the person that will um create my name my age set my name create my list of friends all that stuff so those five lines get compacted into the one line and then it also becomes really easy to see what the student has in addition to the person well it just has a a major uh data attribute right self. major is set to whatever is passed in and then beyond this um it's just you know methods here and there to do stuff so here I've got a change major uh method it just sets the major to something I should probably add a getter in there as well but I'd ran out of room and here's a speak method that gets overridden from the method of person so the speak method for student I made it um uh slightly more uh complex than what the the parent has so here I'm using this random Library uh not a random Library I found like arbitrary Library it's a library called random and it has a bunch of functions that allow you to deal with random numbers so one of the functions that this random library has gives you a number between zero and one at random so a float at at random so what I'm doing in the speak method for student is randomly printing one of four uh strings right according to where that random number that's gotten lies between zero and one okay um and then oops not yet and then here I've I've got I'm overwriting my S strr method so we can see in the student class here here I've created two students so this this one actually has a major this one's major is going to be set to none just the default value and then if I run this code you can see every time I run it the student one says something different student two says something different so it's just you know running this random number and then choosing what to print maybe more often than not I should bias it towards something um all right so one more class I'd like to talk about rabbit that's the one that we actually haven't talked about from those little subcategories and as we talk about this rabbit class I'd like to introduce one more idea of a variable so far we've had just plain old variables right that go away as soon as like a uh environment disappears we've talked about instance variables AKA data attributes right which are consistent for objects that you create of a certain type but have different values for different instances the last kind of variable i' like to talk about is a class variable what's cool about a class variable is that it's you think of it like a shared resource so it's a variable that any instance of this particular type can access and modify and if it's modified all the other instances will see this modified value right so it's just shared across all the instances of type rabbit in this particular case and so there's many different ways to use class variable uh you know for in objectoriented programming they're they're pretty useful the way I'm going to um use it here is to give me the ability to basically count how many instances of a of this type rabbit I've created in my program so when I run the program I remember I can create a whole bunch of instances I'm going to try to use this class variable as a way for me to basically keep a counter of how many of these instances I've created all right so let's look at the code so the first thing I'm going to do is just inherit from animal gets a name and an age and that's about it all those those Getters and Setters and the SDR method Now to create my class variable notice I'm defining this variable just plain old variable outside of any methods within the class definition right so here's tag is equal to one the very first variable the very first instance of a rabbit I create will grab the value of whatever it says here but then if any instance changes this value other instances we'll see that changed value okay so what we're going to do is we're going to um Implement uh ID numbers for these rabbits right so sort of like you know tagging them to keep track of how many there are so in the inet method of animal or of rabbit I'm going to create a new rabbit using an an age and two parents so again different than animals so I'm going to have to implement my own init method but I'll call animals init method because it does some work for me then I'm going to add two in uh data attributes for the two parents to be whatever is passed in and then down here is where I'm going to use this class variable the shared resource these two lines so the first thing I'm going to do is add one last data attribute for my rabbit which is the rid value so it's the rabbit ID and this is going to be a unique value for every rabbit I create first rabbit will have a value of one that I created in my program second rabbit I create will have a value of two and so on so what am i setting it to well I'm going to set it to whatever the tag is so the very first rabbit I create their R ID will be one that's what the tag is initially set to but then before I finish the inip method there's one other line of code rabbit. tag plus equals 1 so this instance right before it finishes creating itself is going to take that tag and increment it by one so the next rabbit I create it's going to grab the tag value that was just changed okay let's visualize it so we're going to do it with actual rabbits okay so first I'm going to so there's going to be three lines of code and this is the program I'm going to run so the first thing I'm going to do is create my first rabbit right it's our um it's R ID will be whatever the value of tag is originally right so originally we said the tag is one so behind the scenes what's going to happen is python says oh you're the first instance of rabbit class so the tag was initialized to one so your rid is going to be whatever the value is one one okay so I've got this rabbit its age is eight two parents are none and R ID is one but then before I finish creating this rabbit the last line of the init method says take the tag and increment it by one okay all right next line in the code says here let me create another rabbit this one I'm going to pass in age six as my parameter so that's the age six two parents are none by default so python says all right well here's a new rabbit object its age is six the two parents are none line that says self. rid so the r ID of R2 will be whatever tag is right now well the previous rabbit incremented it to two so the r ID of this next rabbit is two right okay the last line of code before this rabbit finishes it creating itself is to increment the tag to three right so now if I have one more line of code I'm creating one more rabbit this age is 10 right so behind the scenes python creates this variable named R3 it's uh bound to an object a rabbit object whose age is 10 two parents are none of course because we didn't pass in any parents and the r ID is whatever the tag is right now three okay well here's the one with idea three and before we finish creating let's just increment the tag so that we set it up for the next rabbit okay everyone okay so far yeah yep yes yes it gives you two because when you run this line rabbit 8 it has to run the init to completion and the last line of the init always increments it to be one more than what it started with like you can't uh I guess pause the function run in the middle to check yeah okay so let's look at a couple other methods um that we can Implement for sorry other questions about that very cool way of creating rabbits yeah yep uh yes let's go back here yeah the mostly just this yeah mostly you you want the object to have things associated with it so you know really sh shared stuff is is nice but it's a little tenuous in using it just because like you should use it for pretty specific situations right you don't just want to define a whole bunch of variables that everybody can access here and there only specific situations yeah most of the time you just have methods in the definition yeah but maybe there's other stuff I just don't know about it right now yeah um okay let's look at a couple more methods for the rabbit so here I've got uh getter just three Getters I should probably put some I don't want to put a Setter for the rid because that would mess up my my counting um and probably I don't want Setters for parents too but maybe we might I don't know um the only thing that looks a little bit weird for the get R ID is this Zill and I added that as a cute little thing to basically make the ID look like an ID number so it prefills the front with zeros like it pads the front with zeros so for the IDE of one you can see it's 0000 one for an IDE of 123 it would be 0123 right so just like it just makes it look nice when we print it out uh when we print out the ID and otherwise the two parents just return the parent objects um one interesting method that I would like to add and we'll play on the fact that rabbit's mate here um is to add two rabbits together so we're implementing the dunder method double uncore add double underscore to have the ability to add two rabbits together in our code all right so again this is a design decision I made so when I create when I add two rabbits together I'm going to create a new rabbit object and that's exactly what the code is doing inside here right so I'm going to run this ad uh Dunder method on self and other right and then behind or in front of the scenes I guess is going to be this plus operator so the self will be the thing before the plus and the other will be the thing after the plus right just like what we saw last lecture so when we add R1 plus R2 what I would like the result to be is another rabbit object who who has one parent R1 and the other parent R2 right those are the things we added together and let's say this new rabbit object is age of zero right it's a newborn so to implement that we just have uh we're returning a new rabbit object here right so we're just creating a new rabbit object on the fly in this method uh how do we create a rabbit object we need to give it a an an age and the two parents originally when we created those three R1 R2 r3s right their they didn't have parents right they were just unknown or something like that but in this particular case we do want know what their parents are their parents are the thing before the plus and the thing after the plus so one parent will be self and the other parent will be other the thing that's in the parth uh parameter list so let's continue on with our program here right we had these three three lines of code that were run and I created these three rabbits with these IDs or yeah one two three um if I add two rabbits together R1 plus R2 to give me a rabbit object variable R4 python says all right well let me run this Dunder method behind the scenes of the plus so our four effectively becomes what well we replace right the in the previous slide right here here the return is rabbit zero one parent comma the other parent so when we make this addition we have rabbit zero comma one parent the thing before the dot comma the other parent or the thing before the plus and then the thing after the plus so my R4 becomes the result of adding R1 plus R2 right so its parents are these two now how does this rabbit get created right it's a new rabbit object so we run the init method of the rabbit object right which means that here's a variable it's bound to Rabbit object its age is zero it has these two parents that are objects bound to other rabbit objects up here R1 and R2 and the ID just like before is whatever the tag is right now well we already created three rabbit objects ahead of this one so this one's tag will be four and then right before we finish we increment the tag to five so no matter how we're creating these random these rabbit objects either just plain old in our program directly or through an indirect method right in this case the plus we're still creating rabbit objects in our program right so that counter that shared variable tag is still coming into play right so we're still counting all of these rabbit objects created does that make sense okay good um so uh yeah that's fine so one last method so this is a method that checks for equality between two rabbits and again my design choice is to say that two rabbits are equal so if I say R1 equal equal R2 that will tell me true or false and my designed choice is to say that two rabbits are equal if they have the same parents so if I create another rabbit object right um four was R1 plus R2 but if five is R2 plus R1 I want to say that five and four are equal because they have the same parents right I don't care that it was R1 plus R2 or R2 plus R1 they have the same parents it's just an opposite order and so that's what this EQ method is is doing it's a Dunder method to to implement equality between two rabbits so parents same is a Boolean here that just checks the r IDs so this Boolean parent same is going to check that the addition was made R1 plus R2 R1 plus R2 right and parents opposite is also going to be a Boolean either true or false that checks if I made the rabbits R1 plus R2 and then R2 plus R1 so backward in the parents but they still have the same parents and and the reason I'm checking for IDs is because IDs are unique so originally when I wrote this code a long time ago I actually ended up my first iteration checking just the straight up parents values right so it was comparing basically rabbit objects together but the problem with that code is that at some point it tried to compare a nun some you know some some rabbits might have a nun as their parent with an actual rabbit object and then it the the code crashed and then I realized I can just compare the ID values directly because those are one just numbers so very easy to compare and two they're unique so I know I'm not going to have two rabbits with the same ID right and so in this particular case I've got these two rabbits should say they're equal but then if I add you know R2 plus R3 you know R six th this one is not going to be equal to any of my other rabbits so here's my code um so here I've got my three rabbits right so this is just I think we've printed this out already but um right so here's our one it's a rabbit with this ID rabbit with this ID rabbit with this ID and then you know our one's parents our two's parents and our three's parents all have none are are are none but then when I add R R4 as R1 plus R2 um I can print um R4 right is a rabbit with idea four and then R1 and R2 are as usual what we just saw and then when we grab the parents of R4 it's going to be R1 which is this rabbit with this ID and R2 which this this rabbit with this ID right and then we can uh check the equality so here I can create our for R5 and R six so R3 plus R4 and R4 plus R3 they should be equivalent right so here I've got R5 and R six down here see I'm just running the double equal sign on objects of type rabbit which is pretty cool um and they are the same right because they have the same two parents I don't care that they're in opposite order but then R4 and R six have different parents right R4 had one and two and R six had what is it three and four questions about this code okay so class varibles pretty cool um you share them across all the instances so one instance modifies it they'll be modified for all the other instances so we have one more example to look at next lecture we're actually going to implement our own uh Fitness tracker class so it's going to be a little bit more complex but we're going to see a lot of the same ideas that we saw today just in this slightly more complex um setting of implementing our own Fitness tracker so it's still kind of an abstract thing but more useful than animals and rabbits and person and and student classes all right