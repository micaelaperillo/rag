two countries Austria and it's the other one hungry right this Hungarian yeah so like Austria and Hungary that could be an answer so the way you thought about this problem was if you think about it was pretty different from from like normal search problems you hide this constraint in your head that oh I have two countries that are right next to each other that's one constraint and you were thinking about or one of them needs to start with an A so you had a bunch of constraints when you think about you have a bunch of constraints when you think about a problem that that's like this and that makes it pretty like that that helps us to use different types of model that could be pretty different from state based models so this is more of a motivating example you're going to talk about these types of models so so far we've talked about reflex based models state based models so I spend some time talking about search problems and the piece adversarial games and then what the plan is to talk about variable based models specifically constraint satisfaction problems today and on Wednesday and then we are going to talk about Bayesian networks next week so we'll have three lectures on Bayesian networks so what's gonna happen is Rita is going to talk and talk about the CSP the second lecture of CSP on Wednesday and then Percy is going to be back next week talking about Bayesian networks and I will do the third lecture of Bayesian networks so I'll be whole mix of us talking about variable based models you'll see all views of us so that's that's apply okay all right so um okay so going back to our paradigm I saw our paradigm is starting with modeling so how do we model various types of problems and then how do we develop inference algorithms that try to answer questions we care about objectives we care about based on those models and we've been talking about learning a little bit so if you have these models and they're not full models how do we go about learning learning these models so so here is just a review of what we have talked about so far in terms of modeling we talked about various frameworks like search problems or MVPs or games so these were various frameworks that we had and and we had different objectives so we had things like minimum cost path for search problems or we cared about other things like maximizing the value of policies for for MVPs or games so this was kind of some of the frameworks we talked about in terms of inference we discuss tree based algorithms and we discussed we discussed graph based algorithms so if you remember backtracking search was the simplest most naive thing we tried out to our search problems for for games like we looked at minimax and expect Emacs which was also going down a tree and then you can have more graph based type algorithms or where you're looking at a recurrence relationship and an examples of that are things like dynamic programming uniform cost search a star in terms of MVPs and games you look at value and policy iteration and an in terms of learning we discussed a few types of methods for each one of these frameworks we looked at structured perceptron Q learning TD learning so so these are some of the topics that we have talked about so far so we are midway through the quarter these are all the cool things we have learned so far and these were for state based models okay so state based models were kind of cool and we had a couple of takeaways from state based model so let's just summarize like two main takeaways from state-based models one of the key way and key takeaways was was that when we were modeling these these state-based models we had we had local relationships so our model would specify these local interactions and local relationships that we had between the states so for example if I wanted to go from s to a my neighboring state a then I would think about what would be the cost of going from s to a so I had this local relationship between them and the goal was to do inference and an inference was more trying to like we had a global property can I find the shortest path from some state some other state in this whole graph so so the idea was let's actually model and specify these local relationships and then do inference where we find globally optimal solutions so so that was kind of the whole idea of state-based models and the thing that they use the thing that they made like made them powerful was this concept of a state so so let's just summarize what state was well a state is a summary of all past actions that's sufficient to choose future actions optimally and and that's how we define States that how we went about States okay and and once we had state when once we had the notion of our state then our mindset was I'm going to move through these states through actions so so I have states that I can think of them as notes here and I have actions which where I can think of them as the edges in this graph and the question is how do I go through one state to another state and what is the sequence of actions I should take so so if you think about a policy like we were talking about this sequence of actions and then the sequence actually matters right like I would take this action another action and the goal is let's say for me to go from here to the door and I would have a sequence of actions that need to go one after each other for me to achieve the task okay so the type of problems that you want to talk about today don't have they have a little bit more structure they don't really care about ordering and that's kind of the key difference so so when I asked that very first question of pick like two countries one of them the name of one of them should starts with a the other one should speak Hungarian and they're not right next to each other then the way you think of like all those constraints all the things that you need to satisfy you don't really need to like follow specific order they're a bunch of constraints and you decide so I all of them it really doesn't matter to start from where and then that's kind of the idea that a variable based models and we're gonna go through this example throughout the lecture so the example is it's a map coloring example so so the idea is let's say we have a map of Australia here and Australia has seven provinces so these are all the provinces here and what we want to do is we want to color this map so so the question is how can we color each of these seven provinces with three colors I have red green and blue so that no two neighboring provinces have the same color so so that's that's a task we want to do and and kind of the key idea again here is the order of things doesn't matter right I can pick any of them I pick a color and then just go from there it doesn't matter like if I'm if I'm it matters in the sense of the algorithm side of it things but in terms of the model it doesn't matter - to include that so so here for example this is one possible solution right I can have the map of Australia I can have these different colors like red green and blue for four different parts of it and no two neighboring countries have have the same color so this is one possible solution that we can get we can have other solutions to get and our goal is to find these types of solutions right all right so so I can think of this as a search problem I can I can perfectly think of this as a search 'fat one where let's say I start with a partial solution and my partial solution is somehow I have decided to choose I'm just going to refer to these provinces by their first letters so I'm going to choose W a V and T I'm gonna just make them red and now what I want to do is I want to figure out what other colors to use for the rest of the provinces yeah so I can just go down like a search tree so my state here is this partial assignment and I can go down the search tree and I can choose Queensland I still as my next thing and then I'm gonna call her that red so if I call her that red everything looks good everything is great so now I'm looking at Northern Territory so and T I'm gonna pick the color I'm just gonna color that green let's see so color that green then if you look at si I only have one option for it right because I've already picked red and I've already picked green and si is connected to all these red and greens so so the only color I can pick for us a so that is that is all I have then how about NSW then that has to be green right cuz cuz I've already picked blue right there so that has to be green and and here is one solution so I just went down a search tree and picked a solution to this problem I could have picked some other solution like that decision that I made over there to make aunty green that was kind of random right look I can just pick blue tur so let me just pull there and then I can just have another solution that's a perfectly fine solution and I'll have my way math koi how about I choose I choose a different color for Queensland so I decided I decided to make it red maybe I want to make it so if I make it blue then and T has to be green because that's the only off I can have and then when I get to Istanbul you I don't really have any options SW I have no colors for it that would work because green is taken ready sake and blue ii SW is connected to all three of these that's not really gonna work how about I choose Queen to be two queens line to be green same story and she has to be blue SW I don't really have a solution for it okay okay so so this was just going down through this example assuming it's a search problem I don't have these states that represent partial assignments and I'm gonna pick actions and the actions are going to just give a coloring to the next to some next variable here so so the state is partial assignment of colors to provinces and the action I'm gonna take is assign the next on color province to a compatible color so I can perfectly think of this problem as a state-based using state based models using this particular state in action but but the thing is there is more structure to the problem and the structure in this particular case comes from the fact that again ordering doesn't matter so so variable ordering does not really affect correctness here it's just a bunch of constraints it doesn't matter in what order I'm satisfying that those constraints and then in addition to that the variables there they're kind of interdependent in a local way so so for example if I just look at Tasmania like right here it's not connected to anything so I can just pick whatever color I want for that and it's not affecting the rest of my problem so I don't really need to have some order to like pick TFS or pick a class right I can just pick a color for T and it doesn't affect the rest of the rest of my system okay so the idea of variable based models is let's let's kind of make our models like make how let's make our models simpler than state based models let's let's not try to figure out what is this the state thing that's sufficient for us to make make decisions in the future and then pick actions sequentially let's try to have an easier language to represent the model of the problem that kind of looks like this so so the idea is to come this new framework and and in this new framework we're going to have variables as opposed to state so we're gonna call these things variables and we're gonna have assignments to these variables so so the whole job of modeling is to figure out what the variables are and what sort of assignment we're picking for those variables and this decision of well what order should I call our things or what value should I pick for speak for each province like like that decision of what order values should I pick what order variables should I pick I can push all of that to inference okay so so it's not going anywhere I'm just pushing it to nference so another analogy here is you can think that you have a difficult problem and you can have like an ad hoc way of going about and solving it and an analogy in programming languages to that it would be I would be solving it using assembly language if you look at state based models you come up with the idea of state you're doing something something more general and you're doing a lot of work and why are you doing that because you have a higher level abstraction so when you're using something like state based models an analogy to that is maybe you're programming in C so you're moving the level of abstraction and then we were using things like variable based models it's even moving the level of abstraction it's a little bit higher it's it's even like programming in Python so so sure you can do the exact same thing in c2 but now you have this higher level of abstraction to think about problems and that makes your model much simpler and the order of things that can become the problem of inference okay all right everyone happy but why we want to do state-based we want to variable base modeling all right so so I've kind of motivated this but I haven't really said what it is how we go about solving it so what I want to do for the rest of the class is I want to start formalizing variable based models but this idea call it factor graphs and then after that I want to talk a little bit about inference in the case of variable based models so specifically I'm going to talk about dynamic ordering and arcus inconsistency as ways heuristics that allows us to solve these variable based models and then towards the end I just want to show a couple of examples other examples of why variable based models are so powerful and where they come in and just give you some ideas of like some other examples to look at all right so so that is the plan for today so so let's let's start with a simpler example so let's say that I have three people maybe I can draw that here so I have three people person 1 2 3 and each of them they're gonna choose a color either red or blue that's what they're gonna do okay and each of them have a set of constraints so the idea is maybe this guy really wants to pick so so really wants to pick woo maybe this third person prefers to pick red but maybe he doesn't it's not like as bad as the sky so prefers red and maybe we want to make sure that they pick the same thing the first person the second person and maybe we want to ensure that the second person and the third person we prefer they pick the same they pick the same color okay so these are some sort of constraints almost that I'm putting on on this example and the way that we can think about these constraints that I've just like laid down and this picture is using this idea of a factor graph so a factor graph is going to have a set of variables this is like analog of states as we talked about in a state-based models it's going to have a bunch of variables I'm gonna have three variables because this person is gonna pick something this person's gonna pick another color this last person is gonna pick a color so I'm gonna have variables X 1 X 2 X 3 okay let me actually write down some of these so we're gonna go over a bunch of definitions for the first part of the class at least so we're going to talk about factor graphs factor graphs are going to have some number of variables we're gonna represent variables with capital letters so capital X so in that particular example the variables that I have are x1 x2 and x3 okay and each one of these variables they're going to they're going to live in some domain there or either going to get red or blue right so so each one of these x i's they're going to live in some domain so we were gonna say X I lives in some domain I so in this particular example the domain is just red and blue so each one of these x i's are gonna live in either red or blue and if I pick a value for them if I like come in and say well this guy picked red and this guy picked blue and this guy picked red then I'm giving an assignment so that's called an assignment so an assignment I'm gonna write it with small X and it's going to tell me you know what X 1 took and what small means kind of red or blue so capital means the actual variable next 2 and X 3 what were they so maybe for this particular example okay so that was variables they live in a domain and then we can pick an assignment okay so now I have all these constraints and I can write those constraints as something that's called factors so these factors are going to be functions that tell me how happy I would be if this x one takes value red or value blue so their function so this in this case F 1 is a function of X 1 so so I'm gonna write the factor graph needs factors these factors are fj's there are some number of them there might be a lot of them if J's of some Exce taking some value X I some excite aching some value X I or some number of I'm just write the most general form right now X and these fj's have to be greater than or equal to zero okay so they're kind of telling me how happy I would be right so so here I would have F 1 of X 1 so if I really want this guy to pick blue then what would be a good factor to put here what should I say for F 1 of X 1 so I can write it as an indicator function making sure that X 1 definitely takes maybe I can write it like this so so if it is an indicator function what does it say what does it tell me if it is an indicator function if X 1 actually takes blue then the value of this factor is going to be 1 if X 1 takes red the value is going to be 0 so I'm kind of treating 0 as this thing that I don't want and anything above 0 as something that I actually want to get so so I'm going to have another constraint this constraint is going to be F 2 it's a function of X 1 and X 2 that's why it's connected to both of them so I'm going to draw these squares as has kind of what showing what the factors are so so the circles are are my variables and then and the scores are my factors these functions that kind of tell me what are the constraints what are the things that I need to satisfy so if 2 is going to somehow encode that they need to pick the same thing again it can be maybe an indicator function making sure this is these two are equal to each other and maybe I will have a 3 of F 3 is going to be a function of X 2 and X 3 this ensures that sometimes victus a or sometimes here kind of means that you can have an indicator function but maybe if they don't pick the same thing you wouldn't be too sad so so maybe don't put 0 for that so it would be an indicator function plus some constant that's one way of going about it and then X 3 is going to be take prefers red so it's going to have a factor that says it prefers red okay all right so let's look at same thing on a slide so that's a factor graph so I can actually look at the values of the factors maybe F 1 of X 1 maybe what I want is I want if for that to be equal to 1 if X 1 to X blue I want that to be equal to 0 if X 1 picks thread for the 2 they have to agree for the case that they have to agree then I can define it as an indicator function where if they're not equal to each other I'm gonna get 0 I'm gonna be very unhappy if they are equal to each other I'm gonna get 1 so I would be happy and then for the case that X 2 and X 3 needs to kind of be equal to each other then maybe we can do something like an indicator function plus 2 this means that if they don't pick the same thing I'll be happy but like if they pick exactly the same thing I'm gonna be even happier so I'm gonna get 3 and then for the last one similar thing I prefer the last person to pick red so I'm gonna give it a value of 2 to that and I'm gonna give one for the case so so these are my factors so the good question so question is does a pack of value matter or is it just like if it is above 0 or not in general it does matter like what you were picking for you're soon going to be talking about a specific case of consider a satisfactory graphs where the 0 & 1 is the only thing that's that matter so I'm not focusing too much on the exact values it's just if you get 0 that's pretty bad if you get non 0 that's good so I'm treating them like that cuz soon we were going to talk about csps constraint satisfaction problems which are just factor graphs where you have zeros and ones alright so so let's try to actually write this up so here is this environment that you can play with it if you want alright so here you can define variables so I have variable X 1 it can take now your red or blue X 2 and X 3 similar thing they can take values red or blue and I have 4 factors so I'm gonna write up what those there's our factor f1 depends on x1 it's a function and it's going to return the result of this indicator and and similar thing I'm going to define the second factor also as a function of x1 and x2 and it returns the value of the indicator and this all these other factors and then on the right you can kind of see these factors being generated so we're going to look at this environment even more next time when we talk about more fancier inference algorithms but for now all right so all right so what is the factor of F so more formally a factor graph has a set of variables x1 through xn and each one of these variables each one of these x i's lies in some domain in this case that red or blue was our domain and then the factors are going to be f1 through FN we have M of them in this case let's say and and each of these factors is just a function over X that is going to be greater than or equal to 0 so that's a factor of f it tells us what are the things that we really want so let's look at one example here so in this in this particular map coloring example the variables are the provinces that we have we have seven of them the domain is going to be red green and blue so those are the colors that we can take and then the factors well the factors here are just going to be telling us that don't pick the same color for two provinces that are neighbors so I'm gonna have factors that are indicators insuring that we don't give the same value to two neighboring territories so on so we have factors that basically connect every neighboring territory and again the square here corresponds to each one of these functions so the question is is the domain always the same for all variables it depends on the problem not really also we're going to talk about how to reduce the domain as we go so that's that's another reason that I'm emphasizing on the domain because when we think about the inference algorithm the domain is not gonna stay the same throughout if I pick red for example for waa then and she's not gonna have red and its domain anymore so the reason I keep bringing up the domain is very gonna look at how to update the domain for that for the inference algorithm okay all right so this is a factor graph let's define a few more things just so we have a common language to talk about things so so we're going to find a scope so scope of a factor is a set of variables it depends on so it's really simple so so scope so I'm gonna write scope here scope so it's just set of variables a factor it depends on so for example for this case if I have F 2 it depends on two variables X 1 and X 2 so the scope of F 2 it's just X 1 and X 2 so in this order case when we looked at the map coloring example if we look at F 1 as a factor that tells us W a at NTU should not have the same color the two variables that are used or W a ante okay so that's the scope then now that we have the scope we can define something else called arity which is the number of variables in the scope so each one of these squares just how many how many edges is it coming out of it that's arity so in this case this particular square depends on two variables it is - I can have a setting where maybe I have a factor that depend on three variables and air it is three I can have a factor that depends on only one variable then arity is 1 and if arity is 2 then we call it we call the fact they're a binary factor if arity is 1 we call the factor a unary factor okay so just common language so we have arity and then we have which is which is a number of variables in the scope and then we have unary factors when air it is 1 or binary factors and every taste so for example in this case of map coloring f1 is a binary factor so in the case of map coloring all our factors were binary if you if you look at it go back to this so I have a bunch of factors that just say these two variables should not be equal to each other so I have a bunch of Winery factors and that's pretty much the only thing I have in this case I have a binary Factory or have a binary factor I have a unary factor all right okay so so far so good so we talked about assignments right assignments are going to be a setting where we give actual values to these variables and an assignment can have a weight that tells us how good that assignment is so so remember if factor tells us how good this particular site like how happy I would be if X 2 takes the value and X 3 gets a value a weight tells me how happy I would be for the full assignment so so what it is going to be is like in this case we can we can look at weight to just be a product of my factors so I'm gonna write maybe I'll just write it in front of here so I'm gonna define weight an assignment X and the way I'm writing that is I'm just gonna write it to be a product of s JS j from 1 through m so i have n factors so it's going to be f JS of X taking assignment X ok so for this particular example we looked at the tables and each one of these tables represents our factor but but now if I talk about a full assignment then I'm looking at what does so what happens if x1 x2 and x3 take all possible values that they could be taking so I have 8 possible options here and then I'm looking at a weight as a product of all of these factors multiplied out by each other so so remember I was saying well 0 is the thing that I really don't want to have so if I have a 0 ever like that's super like hard constraint that I'm trying to enforce and that makes my weight equal to 0.so so if x1 ever picks red that was like a hard constraint rule you wanted the first person to pick so the first person picks red then the weight is going to be equal to zero the other thing we really wanted was the first and second person to pick exactly the same color if they pick different colors then my second factor is going to be zero weight of that is equal to zero otherwise I would have different I would have different weights maybe the thing I care about is to maximize the weight so I'll pick the one the assignment with the value for so going back to this demo and why I meant we were just looking at what we can do is we can basically we've defined our factor graph and we can actually step through it and you can play with this but you can basically get these two different different assignments that give you nonzero weights and you can pick your favorite so we're gonna talk about various types of algorithms that allow you to compute these weights alright okay alright so weight of an assignment X is just a product of the factors and then our objective is to maximize the rate of the assignment so I what I want to find is at the end of the day what I want to do is I want to find an assignment so I want to find that small X that maximizes the weight of all right so going back to the map coloring example so here let's say that we define all these indicator factors so if it is an indicator factor I'm either going to get 0 or 1 I'm not gonna get anything other than that then if I have this particular assignment which kind of looks right then the weight of that assignment is just going to be a bunch of ones multiplied by each other so I'm just gonna get 1 so if I find a solution to this map coloring problem the weight of that that particular assignment is going to be 1 I could have another assignment where I don't get a good solution I had to up two of these these neighboring territories are going to be have the same color if they're both going to be red then in that case two of my factors are going to be zero if they're going to be zero the weight is going to be equal to zero so for this particular map coloring example where my factors are just indicators the only rates I can get or zero or if I get one I find a solution if I don't get one I don't find a solution alright so we have been talking about Factor after these more general thanks now we are going to start talking about CSVs constraint satisfaction problems which are just factor graphs we're all factors are called constraints and the factors are going to take values 0 or 1 ok and the constraint is satisfied if the factor takes value 1 so we talked about factor graphs we're gonna talk now about constraint I'm just gonna write CSP constraint satisfaction problems CS B's okay they also have the same variables as before and we were gonna pick assignments for them so same thing Symonds but the factors are going to be called constraints and these factors fj's of X or either 0 or 1 and if you find an assignment where your rate is equal to 1 then that means that you're satisfying all your factors and that's called a consistent assignment so you have consistency consistent assignment that is when the weight is equal to 1 if the weight is equal to 0 then we have an inconsistent assignment so it's either 0 or 1 you have consistent assignments or inconsistent assignments okay so an assignment X is consistent if and only if the weight of that particular assignment is 1 that means all the constraints are because constraints are just give me one and zeros I'm multiplying one on zeros if anything is not satisfied then the thing is you're all right so so far summary so far is we have just gone over a bunch of definitions factor graph is the more general case of it constraint satisfaction problems is more of an all-or-nothing kind of a situation so you have hard constraints everything is hard to constraint and then you have so so for example if you think of math coloring you can think of that as as a constraint satisfaction problem because everything is a hard constraint like you don't want any to neighboring countries to have the same color so you're either going to give one if that constraint is satisfied or you're going to give 0 if that's not satisfied you still have variables factors are called constraints assignment wait if that is equal to one we have consistent assignment otherwise we have an inconsistent it's a more constraining factor but yeah it is dr. graff is this big picture CSV is an instance of a factor graph alright so that was factor graphs and constraint satisfaction problems so so let's talk about how we go about solving these so how should we find an assignment our goal is to find an assignment so we have consistency because if you are talking about CSPs you want to get rate 1 that means you want to have an assignment that's consistent and makes all my factors 1 so so how do I pick how do I pick that ok so so let's look at an example it's just like let's just see how we would do it normally like if you wanted to solve this like if I was solving this I would pick one of these like one of these notes or variable so I would pick W a maybe I would say well let's just pick red see how that goes with that and then I would go to a neighboring neighboring node like NC and I do have a constraint to constraint as W a NT should not be equal to each other so the only thing that tells me is that NT should not be red so I'm just gonna pick a some color let's just pick green so then I'm gonna go to some other neighboring neighboring note so that's si I have two constraints the two constraints are as si should not be equal to W a not be equal to NT so it shouldn't be read or it shouldn't be green the only option I have is blue so I'm gonna set that equal to boo then I'm gonna go to cue the only option I have for cue is red because it's green and blue are already taken then I'm gonna go to NSW the only option I have there this green want to go to V the only option I have there is red and then I can pick whatever color I want for tea okay so so this is a thing that we would probably do if we were to do this right we would go over these notes some order and we would pick colors and some other order and I know that's important but but the way we would do it is just just pick some more day maybe you would have some lipstick that picks the order and picks the values and tries to like make the constraints satisfied so so what we want to do is we actually want to spend a little bit of time talking about doing that and and having actually heuristics that that tells us what order we should use we should use for the variables and what are their values we should pick so we were gonna talk about a few here is six mainly this time so so so to do that we need to define one more things the last thing I'm gonna define and and after that talk about the algorithm so so we're going to define dependent factors so dependent so a partial assignment is going to be partially assigning values to variables in this in this CSV right so so a partial assignment for example here could be that W a needs to be read and only needs to be green that's a partial assignment then I can define dependent factors to be a function of partial assignments and a new variable X I so let me depend just write that number different color occurs X so we have something else called dependent factors V of X and X i where x is partial assignment and X I is a new variable I'm picking and dependent factors is going to reach a set of factors it's going to return a set of factors that that depend on X and X I so so for example in this particular case this we said this is a partial assignment let's say I'm asking what are the dependent factors of this partial assignment and si so I'm picking a new variable on picking si and I'm saying what are what are the dependent factors and and these are going to be the factors that depend on this new thing si and depend on the partial partial assignment so it's going to be this factor and this factor right I'm going to be factor that says W a is not equal to si and I'm gonna pick a factor that tells me NT is not equal to si and that kind of like the idea of different factors is that allows me to think about the next thing I should make next things I should be worrying about so so if you remember like tree search algorithm if you would look at children of some note here we're gonna look at dependent factors because those are the factors the next factors we should we should care about that that's why I'm defining this dependent factors all right so so now this is the algorithm kind I want to write it up on the board because it would be good to have it pseudocode so all right so the algorithm you're gonna talk about right now is just backtracking search it's not doing anything fancy we're gonna talk about fancier things next time but you have backtracking search it does the thing that you expect it to do so it takes some partial assignment X it takes the weights that we have so far and it takes the domains domains of those variables that I have so far okay so if X is a complete assignment if you found a complete assignment then you're gonna update the best thing we have and we would return or we would do whatever you're supposed to do for the problem right like you might have different types of problems here like maybe the question is find one assignment if I find one complete assignment I can I can just return maybe I'm looking for another question which which tells me count all possible assignments that you can have so if I'm counting assignments then I'm just gonna update my counter and try to find the next assignment so depending on what the question is I might want to do different things but I find my complete assignment but let's say I find my complete assignment then I update okay well yeah um if not then we're going to choose an unassigned variable so so if X is complete then then we're gonna choose and on assigned variable on assigned so choose a variable choose another side variable X Y and well how do I do that I'm gonna talk about a heuristic to do it so we'll talk about that but let's say I have some way of figuring out what is the next variable I'm picking and then after you've picked a variable you're gonna pick some value for it right map coloring you're gonna pick a province and you're gonna say red so how do you know it's red like how do you know about the next value you need to pick it's red well that comes from another heuristic which says order values in domain so values would be red blue green so ordered the values that are in domain I of chosen X so you pick tech in the next I may be the only colors that you can use right now are red and blue so so then you're gonna order red and blue using some heuristics but maybe some heuristic says you should use red first and then you do you do this red first order it in that domain in that order and then for each of these values in this order so for each V in this order you've decided you're gonna update your weight or you're gonna have this Delta weight value and the Stealth await value is going to be product of your factors okay and these factors are factors of your partial assignment whatever you've decided so far maybe you have assigned two colors for two territories already and you're looking at the third one so it's going to be the partial assignment Union whatever value you're looking at for this new x.i that you're trying to pick maybe a color for and what are these a choice that you're looking at well these fj's are going to be the fj's that are in the dependent factors of the partial assignment and your variable that's why we defined dependent factors these are the factors that we care about these are like I'm not gonna look at Tasmanian if I'm not looking yet that part of the graph I'm just gonna look at the things that depend on my current partial assignment and my my ex I okay if Delta is equal to zero return or I'll continue zero continue so that means that this assignment you continue continue this means that this is particular value that you have picked just made everything zero it didn't work so he should try other things the other thing you're gonna do is if this value works is you're gonna update your domain so we're gonna talk about how to do that that's the thing that's going to save you save you time because like you have now found out that you only need to care about colors red and blue and you don't need to worry about green so so dad that's updating the domain making sure that you don't need to worry about all the colors and then after that you're just gonna backtrack on this new thing backtrack on this new thing so in this new thing is X Union you have picked value V for X I so this is your new assignment you have extended your assignment like value V your weight is going to be whatever weight you started times Delta Delta and then you have updated your domain so you're just gonna use domain Prime yeah domains prime so this is domains of every one right like domains of all the other notes alright so so we're gonna talk about this a little bit more so but this is the basic of the algorithm okay so first talk a little bit about updating your way so so how do we update domain so one very simple way of updating domain is is this thing that's called forward checking which says well if you pick a color so let's say that you pick W to be red then just look at the rivers of waa and then see if we can update the domains of them so this is the simplest thing I can do right like I've picked waa I've decided W a thread so the thing that I'm gonna do is I'm just gonna look at the neighbors the neighbors are NT NSA they cannot be read so I'm gonna just update their domains to be read to be blue angry I just draw for it so that's like the simplest thing what we do so it may be alright what option is this forward checking so let's go further so maybe now I'm at NT I am deciding NT to be green if I'm deciding NT to be green I'm gonna look at neighbors of NT something look at sa and Q they cannot be green anymore so I'm gonna drop green I'm gonna look at Q for whatever reason and Q I'm gonna pick blue for Q because I want blue for Q and and then I'm gonna look at the neighbors and my neighbor si does not have anything in its domain so I realized that at this point like this particular assignment is inconsistent I don't need to worry about the rest of the notes and what I'm picking for the rest of the notes it's kind of like equivalent to pruning like I don't need to worry about anything else because I've just found out that there's this assignment does not work okay so that's kind of the whole idea of update in doing so so forward checking is the idea of doing one step look ahead so after assigning a variable X I you want to eliminate inconsistent values from domains of excised neighbors so you want to reduce the domains of Excise neighbors and if any domain becomes empty then and you don't recurse on that and then you're in a site and it's something to notice is if you're honest signing X I you have to restore the domains so as you change the domains if you're honest sign if you're reciting or green was not the color to go then alright so the other question was this heuristic so it's this heuristic updating domain one way to go about it is forward checking just update the neighbors another place that that we need to pick things wisely it's choosing the unassigned variable so which one which which unassigned variable should I start off so so which variable to look next and again one heuristic to look at here is to pick the variable that's the most constrained variable so so choose the variable that has the fewest consistent values so so you're gonna pick the one that's the most constraint variable why do we want to do this why would I pick the most constraint thing yeah so you're a bit less options and and the idea is if I'm gonna fail let me just real early like this is not gonna work let me just find out that it's not gonna work early so so that's the whole idea of it and in this case like if you're left with this option where we where we choose red and green here and now we want to pick what should I look at Nick's I should be looking at si because that only has one value so that's not gonna work like nothing else is going to work right so so we want to choose choose a variable that has the fewest consistent values and again the reason this works is if we have some number of constraints in our factor graph so so these are more general for factor graphs too like everything I'm saying is not just about CSPs it's about factor graphs and then the reason this works is we have some constraints right we have we have some what some of these factors are going to return a zero because they're going to return us zero that is why I would like to follow a heuristic like this because that allows me to not look at everything so this this heuristic only gives us benefit if we have some factors that are constraints all right so so that's one heuristic the second question is okay so now like using most constrained variable I pick my variable what value am I gonna pick for it and then for value okay it's interesting cuz for value you want to pick the least constraint value so and then the reason again is you pick the most constrained variable cuz you wanted you wanted to know if you're gonna fail wanted to fail early but now you've committed to that variable now you're going with that variable so you might ask well you have to like a sign of value for it so you might as well pick the least constraint variable here to leave options for for the other variables around you so so an example here is and then how can you think about so that an example here is you're gonna look at this the setting where what is it you're picking Q right and and you want to choose what color to use what value to use for Q right you can you can call her to you red if you call out you red you're gonna do this for we're checking and if you're gonna do forward checking you're gonna update the domains and when you update the domains you have two options here two options here two options here so that could be a measure of consistency so you have six consistent values if you decide to use blue for Q what's gonna happen is you're gonna update and T and then that's gonna have one value as a is going to at one value and SW is going to have two values so you have one plus one plus two and that's equal to four consistent values and then you're gonna you're gonna basically pick the one that that leaves the most options possible so you're gonna order the values the colors values here refers to colors of selected x i but decreasing number of consistent values of quality of the domain of neighbors and then one other thing is like these heuristics are only going to work if you are doing forward checking if you're not updating our domains they're not gonna give us any benefits and also another note about this particular heuristic which is for ordering the values the only like place that this is actually going to give us some benefits and is when you're working with the espys and when we actually have everything as constraints because if we don't you actually need to go through all the all the values and then figure out where the value of the factor is for for that so this is only going to be beneficial then we have we have everything is it's just one so it isn't recurrence yeah so so depends on what we were doing right so so that's kind of this part so the question is are we finding for the optimal solution I'm finding for a solution it depends on like that's kind of this slide if you find a solution and you're happy with that one solution you can just like return it here and be happy if you want to find the best solution and you need to like iterate this multiple times then maybe you have like a counter here that still it keeps iterating for CSPs you won't find a solution because we just want to satisfy the constraint and constraint but if i have a factor graph I actually want to optimize my my my weight all right yeah so so yeah so this are the idea of this most constraint variable is we must assign every variable so if you're going to fail let's just fail early it's kind of similar to pruning and the idea of what order we are picking for for values is we're gonna pick values with least constraint value so I'm kind of the reasoning behind that is we've got to choose some value right like we have to choose values for all these things so so true thing so so choose a value that's the most likely to lead a solution for everything okay and this is just okay so so going back to this this algorithm now we have a heuristic to follow for all these three different red wines and and doing so we're just doing backtracking and then we can update this and then just go through it and it does it does find a solution all right so um so now I want to spend a little bit of time talking about our consistency so what our consistency is is just a fancier way of doing forward checking so we talked about the heuristic for this one and here is it for this one the only algorithm we're talking about today is this that's the only thing and we said well in this algorithm we got to update the domain the way we have been updating the domain is just looking at the neighbor and trying to update the domain using forward checking so another idea is to do something slightly better which is called our consistency and our consistency doesn't just look at the neighbors it goes through the whole the whole the whole CSB and tries to update the domains of event like further knows ahead of us so it doesn't just look at the neighbors so that that's what this whole section is gonna be about how to do our consistency alright so so the idea of our consistency is let's eliminate the values from domains so I have this this giant domain I don't want to go over all those values yeah I have a for loop here for all the values if I can update my domain that's gonna be much better so let's just try to reduce branching yeah so so here's an example so let's say that I have X I and X I lives and so I'm looking at X I and XJ and X I takes value the domain of X I is one two three four and five and then the domain of XJ is one and two okay so now what I want to do is I have a constraint the constraint is X I plus XJ is equal to four so if this is my current domain of X I I don't really need to worry about all these values in X I because the constraint tells me well five never works because X I plus XJ has to be 4 so that's not gonna work this one is not gonna work the only way for things to work is to have 3 plus 1 and 2 plus T and that's it right so so the only variables that I actually need to worry about for domains of X I is 2 & 3 not 1 2 3 4 so so what I want to do is I want to take the domain 1 2 3 4 & 5 and reduce that to just looking at to it because those are the only values that I should actually care about and this can yeah because this constraint it's kind of enforcing that okay so an enforcing our consistency basically tries to get to this smaller domain okay so all right so a variable like sisal is actually formally defined variable x i's are consistent with some variable XJ if each each value X I in the domain of for each value X I in the domain of X I there exist some exchange a domain of XJ so so the factor is equal is not equal to zero so basically it's ensuring that everything is going to be consistent so if you're having consistencies remove things from the domain of X I so our consistency ensures that if there are any sort of inconsistencies between two variables X I and X J's its let's say star star X I and it tries to remove from the domains of X I to make sure that so we start from one and so we pick X 1 and let me try all these other variables X J's and values of them and then we keep like iterating we've been doing iterate on over all of them but we got a like pick one and update the domains of that yeah yeah so so what we're gonna do is we're going to just write have a function enforcing our consistency and it's going to remove values from domain of I to mix and make X I are consistent with respect to some other XJ so the only thing I'm touching is domain of X I all right so so what's actually like go over an example of how this works pseudocode for it so here's our example I'm gonna start from W a I'm gonna pick correct for it okay so that's my current domain for W a is red if I was doing forward checking what would I do I would just look at Auntie on si I would update the domains of NTN si so now what I'm gonna do is I've realized that NTN si their domains are changed so I'm gonna push them to the to the same to the same list of things I have and I'm gonna look at each of them and see the neighbors of them too so the arcs that come from them so I'm gonna look at Auntie well that is right here actually Susan so so everything looks consistent there everything is great I can't update anything more I'm gonna pick aunty now let's say I decide aunty is green so aunt is green I'm gonna look at neighbours of NT so neighbors of NTR waw is red everything is great sa has a green I need to get rid of the green because it can't be green anymore you has a green I need to get rid of that so let's update that so Q and sa their domains are touched right their domains have changed so I actually need to look at them and then see how the domains of their neighbors are going to be affected for example I can look at Si and I can see well si is is blue the only way for si to be consistent with the rest of these guys is that they don't have any so I'm gonna remove blue from Q + SW + V coz because they cannot have to be consistent again if si here is kind of my ex I so I'm sorry it's actually my ex J so I'm gonna pick x IQ here and I'm gonna update the domain of X I so it becomes consistent with Si right so I'm gonna pick change the domain of Q get rid of I'm gonna change the domain of - W get rid of blue I'm gonna change the domain of V get rid of okay so what is updated Q is updated and SW is updated V is updated they're gonna go to go back and then you're gonna go through them again and see if if their neighbors need to be updated okay so going back to the - - q Q is red and s w's domain needs to be updated to be consistent with Q so I'm gonna remove red and it's double use domain is touched so so now I gotta go back to me he's going to become red and T so if I do like this fool like enforcing our consistency here I'm gonna end up with with something that looks like here so all my domains are kind of pruned and I have just like have a solution like I don't need to actually iterate over any values and this is just done by by updating the domains and then doing this our consistency approach rather than doing backtracking search so so all of that is done in this step okay all right so so if you want to give if you want to actually so so this whole like pruning is only like useful right if you want to find this so like air solution in a CSP but if you have a factor of a new actually if you have a graph you need to actually try out all these values to see what is the value you're gonna get for each of each one of the callers if we did forward checking instead we actually would have arrived at the same conclusion taking more steps like filling marquees if you were doing forward checking we had to do the like we actually had to do like like we wouldn't get to this like you would get to this much later because because if you were doing forward checking you just look at the immediate neighbors you update the domains and then we would go to the next like notes in the neighbor neighbors and do backtracking search again you're like I'm not having like called that like I'm here I've updated my domain and I'm with that scenario and I haven't called backtracking search yet alright so yeah so for we're checking is kind of a simpler version where you're assigning XJ to be equal to XJ and and you're enforcing our consistency on all the neighbors of X I with respect to XJ our consistency what it does is it repeatedly well they're different algorithms that try to do our consistency the particular algorithm we were talking about in this class is called a CSV it's just the most useful like the most common way of doing our consistency and what it does is it repeatedly enforce our consistency on all the variables so so it goes over everything but you watch so so what it does is you're gonna add XJ to your set then while set is not empty you're gonna remove an XK from from that set and for all neighbors let's call them X L of this this XK that you have picked for all the neighbors what you're gonna do is you're gonna call enforce our consistency on X L with respect to X X K okay and if your domain is change if you don't change the domain of domain of L then you're gonna add that back in and that's kind of what we were doing in this previous example look at me we kept adding the notes back hit so oh yeah so in terms of complexity of this algorithm law worst case scenario it's going to be order of e times T cubed where E is the number of edges and D let's say is the maximum number of values that you can have so the reason it is that is when you're enforcing our consistency this line takes order of D squirt so you have D values for each of them you have the values you need to consider all that coming all those combinations that's these squared you're you're doing going over all the edges right so so you have all the edges so that's easy squirt and another thing to notice is you're sometimes adding these things back in the set so why are you adding them because their domains can be changed their domains can be changed at most D times so that's the texture D so so that's order of e D cubed if you're interested in it you can look at the notes for it that's worst case scenario in general it doesn't take that long in general like I'm not going to keep like adding the same value like a million times like back in or the same excel back in my set in general way so much faster alright so so again it's a heuristic it's not the best thing in the world like if I like ideally you would have wanted a c3 to not return the solution if there doesn't exist a solution but but here for example a c3 is not being very effective here's an example right so you have these three nodes and let's say you're left with these domains so blue and red if you're enforcing our consistency the domains are now going to change these domains are very consistent with each other but but there is no solution that actually you can find here right because if you choose blue and red here you don't really have an option for the third one so our consistency is actually not going to be able to figure out that this doesn't work and there are more complicated versions of our consistency that consider not that go beyond these binary relationships but they're they're going to take exponential time so so our consistency is simple you run it it's usually useful but it's not going to find everything for you huh okay yeah so and I'm kind of the whole intuition of our consistencies we were looking at this graph in a local matter and locally we are trying to like update our domains to be more efficient but it's it's not it's not going to give us a global answer of course it's not going to give us a global answer because if you wanted to have a global answer we had to I consider the relationships of all our all our constraints with respect to each other but it's basically making sure that locally at least everything looks good when you should so in general you can so I would in general I would say use eighty-three because it's going to proven things usually if you have a lot of dependencies between like if you have if you have like the circle or type of dependencies it's not gonna figure everything out but it's usually just going to be useful so running it in practice it doesn't take that long running it is usually going to prune are the part of your domain so we recommend using it but it's not going to figure out everything because you have you have connected like everything is going and everything is connected with everything then you have dependencies between all your variables all right okay so so sorry so far is well we've been talking about backtracking search on partial assignment we talked about dynamic ordering so how to order our variables and how to order our values we decided to order our variables based on the most constrained variable because if you're failing you want to fail early and we decided to order our values like if I'm picking red blue or green based on the least constrained value because if you're if you have decided to be a value we should try to succeed so that's kind of the intuition behind it and look at is useful for we're checking is one way of doing it so it enforces our consistency only our neighbors are consistent consistent ac3 enforces our consistency on neighbors and their neighbors and just goes over all the arcs in the graph all right so that was kind of a set of algorithms I wanted to talk about but next time we're going to talk about more more and friends and learning type types type algorithms for CSP so now what I want to I want to spend a little bit of time talking about modeling so you've talked about two examples that write the map the map coloring and this one is also like picking colors you said these are the examples you have talked about so far so let's look at another example so so let's say that we have three sculptures a B and C and they gotta be exhibited in a museum we're in an art gallery and I have room 1 & 2 so they can be either in Rome one or room two and I'm going to have a set of constraints so maybe my constraints are sculpture a and B cannot be in the same room sculpture B and C must be in the same room and room to can only hold one sculpture so so these are my constraints how would I go about this well I need to write a bunch of factors I need to write I need to actually so let's try to do this so this was my domain so I have three sculptures so I'm gonna define variable a all right so that's sculpture a it can be in room one or two okay then I have three sculptures so I'm gonna have variable B and variable C each one of them can be in Rome one or two yeah so now I gotta define factors right I had all these constraints one of the constraints was a and B cannot be in the same room so so that's a factor yeah let's call that F fun it's going to depend on a and B right cannot a and B cannot be in the same room but is that factor it's a function right over a and B and that function is going to return something what should it return it should return a not being equal to B okay so that's one factor what else do I need just make sure okay here so so far what I've done is I've defined a B and C they can take values 1 & 2 have defined one factor that connects a I'm gonna define another factor f2 that is going to connect B and C and I really want to sculpt her B and C to be in the same so what I want is B and C to be equal to each other yes it could be the same so that's factors F 2 that's just created here and what was the last thing I want it yeah so every room get one right second room okay second room only get only gets one so that's a factor that depends off on all three of them right it depends on a B and C and one way to enforce that is what I'm gonna say is well if a is in two or if B is into season two right so I'm gonna I'm gonna write indicator functions if is into B's into season two and if I add those up well that should be what that should be less than or equal to 1 right because I don't want to be more than one of them in in so okay I have this third factor this third factor is not a binary factor anymore right it depends on all three of them and then if I step then we're going to talk about these algorithms next time but here is assignment that that you're gonna find so we're gonna find that sculptor a is going to be in room 2 B is going to be in room 1 and that size wise all the factors so if you're interested in writing up more models use this environment so that was another example of C ESPYs so now I want to talk about one more example so I think two more examples okay so this is an event scheduling example so so the event schedule example is I have events but say these are classes different courses that you're taking and then you have T times lots so you have e events and t timeslots yeah and you want to schedule you want to schedule a time slot for an event that that's what your plan is so it's a scheduling problem anyhow I watch of constraint so the first constraint is each event must be put in exactly one time slot so each event in exactly one time slot one time T so that's one constraint another constraint that you want to have is maybe you want each time slot T to hold at most one event because we don't want them to overlap so each time slot T you want that can have at most at most one event event and then maybe I have a set maybe maybe event E is allowed in time slots T only if event E and time slot T are in some set that someone gave me some a set so I have another constraint that ensures that some e with its time slot is in some predefined okay so these are some of the constraints that I have and what I want to do is I want to I want to formulate this problem as a CSV so so how would I go about it what should be my variables so you're going to go over the events okay so let's say that so we can actually have multiple formulations for this so one formulation may be the most natural formulation here is to say that my variables are going to be events so those are going to be my X is here and every event can take a timeslot so the value that it's going to get is 1 through T where T is the time we have T different time slots okay so then if I if I start with this if I start with a setting but I'm saying every event is a variable then I kind of get this first constraint for free so each event E is and isn't exactly one time slot because I have my variables e they're not going to get multiple values assigned to them they're gonna get one assignment so if I if they get one assignment I kind of already get this one for free the second constraint is this constraint which makes sure that each time slot can have at most one event so so to ensure that then I need to make sure that X is not equal to any some other XD prime right because because X E is my variable my event variable its gonna get a time time slot value the two times thought values for two different events should not be equal to each other so the constraint that I have is X is not equal to XD prime XD prime okay and and how many of these do I have oh I have like order of e squared of them because I have events so I have so then I have e times e options here to make sure that they're not equal equal to each other so I have e squared binary factors okay so I know I have another constraint which tries to ensure that these these events and their time slots which is the x value is going to be in some set a you can kind of treat this as a unary factor so you have some number of unary factors you have any unary factors here yeah so and then the number of variables that you have is the number of variables you have is e but their domain is size T so it's good to think about that these if you have multiple choices so I'm gonna talk about the second choice in a second but if you have multiple choices for modeling this it's a good idea to think about what type of factors do you have how many of them do you have so here are like the worst case scenarios I have a squirt binary factors so I have another option right so this option what I did was I took the events as my variable the second way to formulate this is to say well maybe my variables are just the time slots so maybe I'm gonna go a different different approach take a different approach for modeling this I'm gonna call it YT I see are the times so I have variables for timeslots each one of them can either take an event or maybe there's no event at it that's empty empty you so so they either take an event or no event and if I model this this problem using using the second approach then I get the second the second one the second constraint for free because my variables are again time slots so I can I can I can satisfy the second constraint and then for the first constraint I actually need to write something for the first constraint which says each event is in exactly one time slot so I'm gonna write a constraint that says YT this time slot is going to get an event for exactly one T so this particular constraint that I have it's it's how many variables does it have if I want it to be exactly one time slot remember the sculpture example I wanted to be exactly in one room you needed to depend on everything else so this is going to be a cheer you can straight right so I have T variables here so previous formulation everything was binary or unary here I have a tea or you can straight have less of it but I have it Eureka straight okay and then I'm gonna have another constraint to just ensure this this last this last so so one way to think about these two different approaches is how many of these constraints do I have so so we just saw that we have it's here you constraint here one thing that you can actually do and I have a slide afterwards about that is if we have some can some N or you can some tea or you can strain some constraint that depends on T number of variables I can actually change that to order of tea winery constraints so I can actually like reduce down to binary constraints so so I can make these two algorithms another make these two models to have all binary or you know registry so that part is fine but what one of them is going to have T number like order of T a number of factors the other one is going to have order e type factors and and the question is well which one should we use and it really depends on if your is greater than T or T is greater than E right so so if you have if you have more time slots than events you've got a lot of time slots and you have like five events let's say that you want you wanting point set then you should use the first algorithm because that that was where we had order of e squared number of constraints but if you added the other way around which is again less natural but maybe you don't want to you don't want to Euro cave it not assigning all events a time slot so so if you're if you have it the other way around then then you can use the second formulation so so the point of it is you might have different ways of formulating a problem you should use the one that that is the most beneficial depending on what how many constraints you have and then one last thing to before before we head out so I just said if you have an NRI constraint we can actually write down binary constraints that are equivalents to this and the reason is usually our algorithms require having binary or unary constraints here I haven't have a setting where I have this or between X 1 X 2 X 3 and X 4 so the way to make this make the binary constraint is what we can do is we can define an auxilary variable so so I'm gonna define a new variable and this new variable I'm gonna call these a ice and these a ice are going to be just the result of the or of a I minus 1 or X okay so so what what's happening here is it's real quick so I have a setting so I had X 1 X 2 X 3 X 4 I can have an energy constraint that connects all of these together to one one factor graph what I can do is I can actually define new variables so I'm defining that many new variables a 2 a 3 a 4 and then I'm ensuring and I'm defining new factors where a 1 is the result of these tours so I'm gonna just draw this like this a 2 is the result of our of these two variables a 3 is the result of our of these variables and so on this is not binary right what is there a 3 so we need to do one more step like after we were defining these auxiliary variables after that we need to define we need to do one more step where we define a new variable B which kind of represents AI and AI minus one so I'm going to replace these two you're just one variable we call it v1 and I'm gonna just connect that to get the idea so the eyes are just going to be representing AI and that allows me to have binary binary factors here okay and then Y doing so I'm adding actually one more constraint I actually need to add a consistency constraint that makes sure bi minus one of two is equal to bi minus vbi my just ensuring that like pre and post are staying the same as we move away through that graph alright let's add next time