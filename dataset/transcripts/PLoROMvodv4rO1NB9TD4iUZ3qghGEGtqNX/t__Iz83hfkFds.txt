ok let's get started so before I get into logic a few announcements the exam is tomorrow remember that next week is Thanksgiving break so we won't have any classes there's no more sections and after you guys come back from Thanksgiving break on the Monday there's going to be a poster session from 2:30 to 5:30 so there's more details on the website and we'll post more details on Piazza as well and then finally the day after there is a logic homework due so that's pretty much it aside from the final report of things that you should keep track of in this class I want to take a few minutes to talk about coda lab worksheets so this is a platform that we've been developing our group to help help people do research in a more efficient and reproducible way and the thing that's relevant for 2:21 is that you will get a opportunity to get extra credit by using collab worksheets and also it provides additional compute if you're running low on that as well I want to give a quick demo to give you an idea of how this works so if you go over to worksheets that co.org you can register for an account I'm going to demo a kind of a newer interface that you're actually gonna see on the website just because that's what's gonna be rolled out soon so let's create a worksheet CSTO and demo a worksheet is like a jupiter notebook if you are familiar with that and you can do things like write up write text so i'm going to run some sentiment classification yeah let me try - I always spell this correctly so let's suppose this the title SC 21 final project okay and then you can upload code or data so I'm going to go ahead and upload the sentiment data set hopefully this sounds familiar to some of you and then I'm also going to upload this text class now py which is a source code so each of these resources data or code is called a bundle in code allowed and you can look at the contents of this bundle you can download it and so on it has a unique ID which specifies forever the precise version of this asset and now the the interesting thing you can do with this right now is you can run commands so cool lab it's pretty flexible you can run basically any command you want you specify the dependencies that this command will need to rely on and then you can type in whatever text class not your Y train polarity train test polarity test and then you hit confirm you can also see over here you can specify how much resources you want whether you want GPUs where you need to access the network and so on so this goes and creates a docker image that's actually running or docker container that's actually running this command and you can visualize the standard output in kind of real time as the command is is running and you can see the files that are generated so for example one of these files is just a JSON file that has the test error in it so suppose you wanted to visualize the your experiments a little bit better because this is kind of just the default information how much house big the bundle is and so on you can go this is a little bit more events but I want to show you how this works you can define custom schemas so if you define a schema which is called run you add just some fields you can actually specify test error as a custom field and you say go to stat saw json read it out and and then now you use that table to the scheme at the finest table you can see this is the tester let me make this a little bit nicer and format it to three decimal places okay and then you can go in you can modify this command and as you say rerun maybe i wanted to try some other parameters this ada is the the step size let's try some more you can rerun this 0.2 and so on so you can fire a bunch of jobs and you can kind of monitor them so this one's running this one's created and you can monitor kind of various statistics that you want so this is generally a good way to just launch jobs and kind of you know forget about it and keep keep track of all these things so then you can say larger step sizes are hurt accuracy or something so the idea behind a worksheet like in jupiter is that you document your experiments as you go along and so every asset data code and bundles and the experiments are all kind of treated the same way so that you can go in here and six months later and you know exactly what command you ran to get this result and the exact dependencies so there's kind of no question so you should think about this as kind of a get four experiments and if you go to the main side you can actually fire some jobs with GPUs on them there depending how many people are using it there might be a queue or my not so if you have want some extra compute that's a good way to go as well question how much memory can you typically get so there's so one thing that if you want to find out so it varies depending on what kind of races are available but if you type any sort of command like free you can actually see the exact environment that your job is running so I think on you can get like maybe let's say 10 or 16 gigs of memory yeah any other questions about this so there's some documentation here and if there's any issues that you run into a file or github request or email me or something Piazza won't have the highest of you know you can post on Piazza too but it'll be probably faster if you submit a github issue because I'll go directly to the team that's working on this yeah does this work only with Python you can run any command you want so you can C++ Java it's it's yeah you can run it on Julia so the thing when you do a run you specify the docker image which is basically contains your environment so if you have Julia probably has docker images available we have a default one that has I don't I'm not sure if it has Julia but it but it has kind of the standard Python tensorflow pipe torch libraries yeah yeah so if you want to install some dependencies there's two things you can do you can build your own docker image which you know takes a little bit work but it's not too hard or you can if you want to be lazy you can just do pip install here in the command and you for that you have to make sure you turn on network access so it can actually download from pipe I yeah yeah you can have the requirements file yeah does this support pop-up windows no this is more like a batch run so the way there's there's several ways you can do this there's uh you can actually expose like a port so you can connect if you're using tensor board or something you can actually connect to your job on the fly or you can actually there's a way to mount the contents of your bundle while it's running to a local disk and you can run whatever scripts you want maybe a hold of further questions you come talk to me afterwards if your if you're interested in want to know more okay just wanted to make that clear that that thing is available go check it out okay so back to the topic that we've been discussing so on last Wednesday we introduced of logic and remember there's three ingredients of logic there's the syntax which defines a set of valid formulas for example in propositional logic it's rain and what is a particular formula so syntax formulas are just symbols they have no intrinsic meaning to themselves the way us define meaning is by specifying the semantics so we talked about the interpretation function which takes a formula and a model which represents state of the world and returns either true or false and the way you should think more generally about a formula is that a carves out a set of models which are configurations of world where the formula is true so in this case there are four possible models and rain and wet corresponds to this set of models which are in red here where it's raining and wet and finally we talked about inference rules where if you have a knowledge base which is a set of formulas what new formulas can be you know derived so one important thing to remember is that these formulas are not meant to can replace the knowledge base these are things which are derived which could be very simple things as you might you have a lot of knowledge about the world but you might want on it any given context you might know that it's it's raining which is so f is much generally much smaller than the knowledge base in terms of complexity so for rain and wet you can derive rain okay so in general we run inference what does it mean to do launch going friends you have a knowledge base and then you have a set of inference tools that you keep on turning and turning and then you see if you produce W sorry F so an example we saw last time was modus ponens which says if you have wet and weekday and wedding week a implies traffic then you can derive traffic so the things on the top are called premises and the things on the bottom are called is the conclusion and more generally you have this a modus ponens inference rule so now the question is what does this inference will have to do with semantics because the this is just simple manipulation you just you saw these symbols you produce some other symbols and in order to anchor this in semantics we talked about soundness and completeness so entailment is a property between a relationship between a knowledge base and a formula which is given by the models right so the models of F have to be a super set of models of Kb that's the definition of entailment and separately we have the notion of derivation which is simple manipulation you can derive F given a set of inference rules from KB and soundness means that the set of formulas that you derive are always entailed and completeness means that you can derive all the entailed formulas so remember this a water glass analogy where this set of things in the glass are true entailed formulas and you want to you know stay within a glass but you don't want to spill over so so far we've looked at propositional logic which is any legal combination of symbols propositional symbols and their connectives we also look at a subset of that called propositional logic with horn clauses where all the formulas look like this you have and of a bunch of propositional symbols implies some other propositional symbol and so there's a trade-off here so we saw that propositional logic is not if you use modus ponens improvisation logic your you're gonna be sound but you're not gonna come be complete there are certain types of formulas which which you won't be able to derive so we could either restrict a propositional logic to only horn clauses and we show last time that this indeed is complete or we can say we really want propositional logic the full expressive power and instead we're gonna do this King called resolution which we're gonna talk about in this lecture okay so this lecture has two parts we're going to talk about resolution for propositional logic and then move on to first-order logic yeah is your attire asking about this last statement or so is the question is anything I can do with the last one in I can do with a previous second-to-last one depends on what you mean by do so these are different statements about expressive power and inference rules propositional logic subsumes propositional logic with only horn clauses so you could just say I only care about propositional logic but it turns out this is going to be exponential time and this is going to be linear time so there's a trade-off there yeah so what is completeness I'm using a very precise way to talk about of a completeness of a logical system a set of inference rules means that anything that is entailed by the semantics of propositional logic is derived Bal via a set of rules and this particular set of rules here is modus ponens for this case and then resolution for this case yeah so the completeness is really a property of resolution of the inference rule with respect to a particular object yeah any other questions okay so let's dive into resolution now so let's revisit one clauses and try to grow them a little bit to do that we're gonna take this example home clause a implies C and we're gonna write it with disjunction for reasons that will become clear in in a second I'm gonna write some of these identities on you know the board so these are things which are hopefully you you know I also wrote this last time this is just just true I guess this is I want to say definition but it's not really the definition because the definition is the the the interpretation function but you can check the two by two truth table and this is no true intuitively P implies Q really just is the same as saying either P is false or Q is true if P is false then the kind of the the hypothesis is false so it's irrelevant what Q is and if Q is true then then the whole statement is true okay so what about this a.m. and B implies C so I can write it as not a or not B or C so this invokes another identity so which is that if I have not of P and Q that's the same as not P or not Q okay so and there's also another version which is P or Q negated is the same as P not P and not Q so what I'm doing intuitively is pushing this negation past the the connective into the propositional symbols and when I push it past negation pass and it flips to an or and when I push a pass an aura flips to an end okay and hopefully you guys should be comfortable with this because when you're doing programming and you're writing if statements you should know about yeah yeah it's a good question so the word is the order of operations it's here it's a and B parenthesis implies C okay so if you apply the second identity on the board here you have a and B is not a or not B and then you apply the the first identity and that thing or C is is the same thing over here okay so now I'm going to introduce some terminology first is a literal so this is going to be either a propositional symbol or it's communication there's a notion of a clause which is just you know disjunction of literals so the structure means or so these things are all clauses and finally there is a particular type of clause called a horn clause which I introduced last time but here I'm defining in a kind of a different light here which is clauses that have at most one positive literal okay so in these clauses there is indeed only one positive literal so these are horn clauses if you remember from last time if you have snow or traffic I'll have appearing on the right hand side then that has two positive literals which is which means it's not a horn clause so now I can write modus ponens the following way so a and a implies C which can be written as a disjunction allows me to derive C and here is another intuition which is that I'm kind of effectively canceling out a and not a and I'm taking the you know the resulting things I'm putting them on the bottom okay alright so now let's introduce the resolution rule so general clauses could have any number of literals so this is not a horn clause but it is a clause and the resolution rule for a particular this particular example looks like this so rain or snow and if you have not snow or traffic allows you to derive rain or traffic okay so this is not a horn clause right because I have two positive literals and how do we intuitively understand what's going on so you could say okay it's either rainy or snowing and snow implies traffic which means that it was it was snowing that I can get traffic there was not snowing I still have rain here so I can I can conclude it's either rainy or trafficking so in general the resolution rule looks like this so you have a clause up here with some P Papa's you know symbol and then you have the second clause with not P and what you can do is you can cancel out P and not P and then you can take everything else and then hook them up as a big you know clause okay so this is a rule I've kind of sketchily argue that it's a reasonable thing to do but to really formally verify that you have to check the soundness and the way you do soundness remember how do you check soundness you go back to the semantics and of propositional logic and you verify that that's consistent with what resolutions trying to do so in this rule you have rain or snow the set of models of rain or snow is everything that's not white here the set of models have not snow or traffic is everything that's not white over here and when you intersect them you get the dark red and that that represents your where you think the state of the world is if you only have the the premises and if you look at the models of the conclusion rain or traffic it's this green area and you just have to check that what you derived is a superset of what you know and again this might be a little bit counterintuitive but you should think about knowledge as restriction knowledge means that you actually have pinpointed the state of the world to be smaller so this fewer colored boxes you have the more knowledge you have okay so this is sound completeness is another much harder thing to check yeah question you mentioned that we wanted to have a super set at the end not a subset but there's the two topmost room tiles for snow alone or snow room yeah that are not there is that because we've eliminated this is so why are these there this is so this this square is only true in rain or snow this is only true in not snow or traffic's but remember the the way to think about a knowledgebase is the semantics is an intersection of all the four models of all the formulas so when I've intersected the models of everything up here I'm only left with a dark red there's well there's two these two I will after those because of the fact that here it's our conclusion is rain or traffic but I'm just sort of wondering when you're mentioning this two percent versus subset conclude so let's see why are the ones up here not included because they're not part of the intersection so here's your question why are these squares not part of the intersection so they're not let me clarify so if you only look at the premises up here the set of models is this Square this square this square in this square then you look at the premises are sorry the conclusion and look at the models independently of the premises and you get these six squares yeah so this is the green is just arrived from the the green yeah alright so it turns out that resolution is also complete and this is you know kind of the big result from the sixties that demonstrate that even a kind of a single rule can kind of rule of propositional logic but you might say wait a minute wait a minute there's clearly things that this resolution rule doesn't work on because it only works on clauses so what do you have what if you have formulas that aren't clauses at all so there's a kind of this trick that we're going to do is that we're going to reduce all formulas to clauses okay so another definition that is important here is CNF so it stands for conjunctive normal form so a CNF formula is just a conjunction of clauses okay so here is an example of CNF formula here's a clause here's a clause and you can join them so it's important to remember that so just to refresh so this is a CNF formula it's a conjunction of clauses each clause is a disjunction of literals and each literal is either proposition or symbol or its negation okay so or is on the inside and is on the outside and the one way to kind of make sure you remember that is a knowledge base remember is a set of formulas but really it represents the conjunction of all those formulas because you know all the facts in your knowledge base and so you can think about of CNF formula is just of the knowledge base were each formula has a clause okay so we can actually take any formula in propositional logic and we can convert it into equivalent CNF formula which I'll show in the next slide and once we've done that then we can use resolution and life is good okay so the conversion is going to be just a six step procedure and the I mean it's a little bit grungy but but I just want to kind of highlight the general intuition so we have this formula so this is not a CNF formula but we're gonna make it one okay so the first thing we want to do is we want to remove all the symbols that aren't ands or ORS or negation because those definitely don't show up in this in a clause or CNF formula so we can use the identity the first identity on the board to convert implication into a knot and or you do that for the inner guy here and now you only have symbols that you're supposed to have the second thing is that remember the order in which these connectives is important for CNF so negation is on the very inside negation is only allowed to touch a propositional symbol then you have or disjunction on and then you have and so we want to change the order so that that is is true so first we want to push the negation all the way inside and this is using the de Morgan's laws so the first the second and third identities on the board and so we push this inside so that now all the negation is on the on the inside we can remove double negation you can check very easy to check that that's valid and finally so this is not us CNF formula it might look like one but it's not if you turn your head upside down it actually looks like a CNF formula but the reason is that and is on the inside but it really should be on the outside and to fix that you can actually distribute or over and which allows you to say this is summer or if is a bizarre and not snow or bizarre okay so now this is a CNF formula and then you're done this is a general set of rules just to recap you eliminate bi-directional implication implication to get the symbol inventory right and then you move negation all the way to the inside and you need limonade in a spurious negation that you don't need and then you move any or from the outside to inside the the and okay so long story store take any propositional logical formula you can make it a CNF formula so without loss of generality we're just going to assume we have CNF formulas okay another place that CNF form you might have seen CNF formulas come up is when you're talking about in theoretical computer science when you're talking about 3sat 3sat is a problem where you're given a CNF formula where every clause has three symbols and three literals and you're trying to determine if it's satisfiable here we know that to be a very hard problem okay so so now let's talk about the resolution algorithm remember there is a relationship between entailment and contradiction so knowledge base entails F is the same as saying knowledge base is incompatible with not F like F really really must hold it's it's impossible that not F you know holds okay so suppose we wanted to prove that F is derived from the knowledge base what we're going to do is this proof by contradiction strategy where we're going to say insert non F into the knowledge base see if we can derive a contradiction okay so you add naught F into a knowledge base convert all the formulas into CNF and then you keep on reapplying the resolution rules and you return entailment if you can derive false ok so here's an example over this looks like so here's a knowledge base and here's a particular formula and I want to know whether KB entails F or not okay so you add it add not F into knowledge base so that's not C and I'm gonna convert this into a CNF so that only affects the first formula here and then I'm gonna repeatedly apply the resolution rule so I can take this clause resolution says allows me to cancel not a with a I get B or C and then I take B and not B cancel it out C and I cancel out C I mean when you see see and not see that's clearly a contradiction and you can derive false which means that the knowledge base entails f in this particular example okay this also maybe gives a little bit intuition of the mysteries of defining the goal clause and horn clauses as deriving of blah blah blah and implies false because you can add something that you're trying to prove and you can use modus ponens to see if you can derive false and if you do derive false then it's a it's a contradiction alright so as I alluded to before there's a time complexity difference between modus ponens and a resolution so for modus ponens each rule application adds only adds a clause with one propositional symbol so imagine you have n propositional symbols you can really only apply modus ponens and times so that's linear number of applications there whereas the thing with resolution is that you can add each rule application can add a clause with many propositional symbols and in the worst case you can imagine any subset of the propositional symbols can be added and this results in the exponential time algorithm this should not be surprising because we know that 3sat is you know MP complete so unless there were some magic here there's there's no way there kind of circumvent that yeah and so question is why is resolution preferred so you could just convert everything to CNF and check do backtracking search or whatever on say enough resolution turns out that ou have generalizations to first-order logic which model checking doesn't right so so remember there's two ways you can go about you can do basically reduce things to CS piece and then you can solve it or you can try to use inference rules so this inference rule doesn't as far as I know people don't really use resolution in propositional logic but in first order logic you kind of have no choice the question is whether the two our resolution looks like kind of like nan there's quite a bit difference there maybe you could talk about it offline okay so summarize there's two routes here you can say I'm gonna use propositional logic with horn clauses and B using modus ponens this is fast but it's less expressive or I can embrace the full complexity of a propositional logic and use resolution and this is exponential time it's slow but it's more expressive yeah right what do I mean by expressive I mean the the ladder which is that there's simply some things you can't write down in in with using for closets like you can't write down rain or snow at all any sort of branching or disjunction you can't do in one clauses so in some applications horn clauses actually turns out to be you know quite and enough so these type of horn clauses show up and programming languages where you're just you know you see some premises and you're trying to derive some other quantities so like in program analysis this is actually quite useful and efficient okay so let's move to for serologic so what's wrong with propositional logic I mean it's already exponential time so you know it better be pretty good so remember the point of logic is to in general from AI perspective is to be able to represent and reason with knowledge in the world so there's a lot of things that we want to represent but might be awkward in propositional logic so here's an example so Alice and Bob both know wherever it may take so how would you do this in propositional logic well propositional logic is about propositions so this has two propositions which are statements which are either true or false Alice knows arithmetic and Bob knows arithmetic okay fine so what about all students know arithmetic how would you represent that well you probably do something like this where you say okay if Alice's student an analyst knows rhythmic if Bob is the student involved knows arithmetic and so on because all propositional logic can do is reason about statements so what about this this is Goldbach's conjecture every even integer greater than 2 is the sum of two primes so good luck with that you might we'll have to write down all the integers which there so propositional logic is clunky at best and not expressive and the worse what's missing when we have knowledge in the in the world it's often more natural to think about there as being objects and predicates on these objects rather than just opaque propositions so Alice knows arithmetic actually has more internal structure it's not just the single proposition that has nothing to do with anything else it has notions of Alice and knows an arithmetic in up and finally once you can decompose a proposition into parts you can do fancy things with them you can use quantifiers and variables for example all is a quantifier that applies to each person and we want to do that inference without you numerating over all the people or all the integers okay so I'm going to talk about first order logic going through our plan if first talking about the syntax then the semantics and then inference rules so I want to warm up with just some examples I'm not gonna do as rigorous of a treatment of first-order logic as propositional logic because it gets more complicated and I just want to give you an idea of how it works so I was involved in both no or this picnic this is going to be represented as there was Alice Riddick and knows Bob arithmetic okay so this is a there are some familiar symbols like and and now the propositional symbols have been replaced with these more structured objects and all students were no arithmetic gets mapped to this where now I have this quantifier for all X student of X implies those X arithmetic okay so a bit more formally so there's a bunch of definitions I'm gonna talk about so first-order logic so I mean first-order logic there's two types of things there's terms and then there's formulas in propositional logic there were only formulas so terms are expressions that refer to objects so it could be a constant symbol it could be a variable or it could be a function applied to some other terms so for example arithmetic is a is just a constant it's a think about it as a name there are variables like X which I'll explain later and there's functions of terms so 3 plus X would be represented as sum of three of X okay remember these are just symbols and formulas refer to truth values so there's atomic formulas or atoms so this atomic formula is a predicate apply two terms so those X is a term a rhythmic is a term therefore a nose is a predicate so knows X arithmetic is an atomic formula so atoms are supposed to be indivisible but here there's a sub structure here so maybe you can think about these as subatomic particles if that is useful there's a connectives as before so what we're doing right now is you're taking these atomic formulas atoms and they behave like propositional symbols so given these atoms are generalizations of proposition symbols we can strain them together using any number of connectives as we've done in propositional logic and then finally we have quantifiers applied to formulas which means that if you have a formula with a variable in it we can stick a quantifier over these variables to specify how the variable is meant to be interpreted okay so no connectives and quantifiers alright so so let's talk about quantifiers quantifiers are in some sense the the heart of why first-order logic is useful there's two types of quantifiers and Universal quantifiers and existential quantifiers so Universal quantifiers you change to think about as just glorified conjunction so what I have for all X P of X that's really like saying P of a and P of B and P FC and for all the constant symbols and existential quantifiers are glorified disjunction when I say there exists X such that P of X holds that's like saying P of a or P of B or and so on its own so I'm cheating a little bit because I'm only I'm still talking about the syntax of first-order logic but I can't resist but give you a little bit of intuition about what this syntax means I'm not formally defining the interpretation function here but I'm just trying to give you an idea of what the symbols correspond to so here are some properties so if I push a negation through a universal quantification then that goes on and inside and the for all becomes and exists does this sound familiar to people or what is the name for this kind of thing yeah it's just the Morgan's law about apply to first-order logic and supposed to process show logic and it's really important to remember that the order of quantifiers matters right so for all exist is very different from exists for all okay so one more comment about quantifiers it will be useful to be able to convert natural language sentences into you know first-order logic and on the assignment you're gonna do a bunch of this but so this is kind of there's an important distinction I want to make so a natural language you talk have quantifiers in natural language are words like every or some or and so how do these get represented in in formal logic every student knows arithmetic every generally refers to for all so you might write something like this but this is wrong so what's wrong about this sorry saying it yeah so so the problem is that what does this say this is says everyone's a student for all X X's is soon and for all X X notes rivers so it's basically saying everyone's a student and everyone knows a resident egg which is different so what it really should be is implication right so for anyone that's not a student I don't I don't care in terms of this assessing the validity of this formula and only if someone's a student then I'm gonna check whether that student knows arithmetic okay so what about existential quantification some new student knows arithmetic this is student of X and knows X rithmetic so those are different connectives and a general rule of thumb is that whenever you have Universal quantification it should be implication and whenever you have existential quantification it should be an and so of course there is exceptions but this is the general rule okay so let me give you a few examples just just to get you used to think about quantifiers so imagine you want to say there is some course that every student has taken so what how is that so there exist some course so there should be a exist why why is a course that every student has taken so every is it for all X and here I want student implies takes XY okay remember exist has usually has and and for all has implies okay what about go box conjecture every integer is greater than grand two is sum of two primes this is every even integer so every even integer greater than two implies that what about these is the sum of two primes so notice that there are no may be explicit hints that you need to use X essential but the fact that these two primes are kind of under specify means that it should be exist so there exists Y & Z such that both of my prime and the sum of x y&z is X and finally here's the statement if a student takes a course in the course covers a concept then the student knows that concept whether that's true or not is a different matter but this is a valid formula and it's can be written as follows so one other you know piece of advice is that if you see word if that generally suggests that there's a bunch of Universal quantifications because if it's kind of like saying there's a general rule and Universal quantification says like in general you know something happens so this is for all X or Y all Z if you have a student and takes some course and that course covers some concept Z then that student knows that concept I guess technically there should be also and concept of Z in there but spread it getting complicated ok any questions about first order logic what the syntax is and any of these intuitions and that we're having for it so the question is why don't we just use the equal sign so I'm being a little bit uh I guess cautious and you know following the strict syntax where you have functions that just take longer it gives you it shows you the structure of the logical expressions more so now in certain cases you you can use syntactic sugar and you can write equals if you want but remember the point of logic is not to be able to write these things down manually and a reason with them but to have a very kind of primitive really built system formulas that you have general rules like resolution that can operate on them ok so let's talk about the semantics of first-order logic so in propositional logic a model was something that map's propositional symbols to truth values in other words it's a complete assignment of truth values to propositional symbols so what is this infrastruc so still we're gonna maintain the intuition that a model is supposed to represent a possible situation in the world so we're gonna give you of kind of some grant a graphical intuition so imagine you only have unary and binary predicate s-- so these are predicates that only take one or two arguments then we can think about a model as being represented as a graph so imagine you have three notes these represents two objects in the world so objects are kind of first-class citizens in for sort of logic and these are labeled with constant symbols so you have Alice you have Bob and Robert and you have arithmetic here and then the directed edges is our gonna represent binary predicate and and these are going to be labeled with the predicate symbols so here I have a nose predicate that applies to O 103 another nose predicate that applies to o two or three and a unary predicate here that applies to only a one okay so more formally a model in first order logic is a mapping that takes any every constant symbol to an object so Alex goes 0 1 Bob goes over to over the MCOs 0 3 and it maps predicate symbols to tuples of objects so nose is a set of pairs such that the first element of pair knows the second element of the pair I'm skipping function symbols just from simplicity but you would define them analogously as well okay so that is a model it's a little bit more complicated than propositional logic because you have to define something for both the turn of the constant symbols and the predicate symbols so now to make our lives a little bit easier I'm gonna introduce a restriction on model and it's motivator the following example so if I say John and Bob are students then in your head you might imagine well there's two people John and Bob and they're both students but there could be technically only one person whose name is both John and Bob or someone who's anonymous and doesn't have a name and there's two simplifications that rule out w2 and w3 so your unique names consumption says that object has most each object has at most one constant symbol and domain closure says that each symbol has at least one constant symbol so the point of this restriction means that constant symbols and objects are in one-to-one relationship and once you do that then we can do something called propositional ization and in this case a first-order logic is actually just a syntactic sugar for a propositional logic so if you have this knowledge base and first-order logic student of Alice and BA soon enough Bob for all all students are people and there's some creative student then you can actually convert very simply into propositional logic by kind of unrolling it's like unrolling your loops in some sense so we just have student and Alice implies person Alice student Bob implies person Bob and because there's a finite set of prop constant symbols it's not gonna be a infinite set of formulas there might be a lot of formulas but it's not going to be here for that set okay so the point of doing this is now you can use any inference algorithm for propositional logic for first-order logic okay so if you're willing to make this restriction unique names and domain closure that means you kind of have direct access to all the objects in in the world via via your constant symbols in which case you've you're just propositional you just have propositional logic okay so why might you want to do this so first our logic as as a syntactic sugar still might be convenient you might still want to write down your expressions in first order logic and have the benefits of actually having you know propositional logic where the inference is in some sense much more you know developed but later we'll see that there's some cases where you won't be able to you know do this okay so that's all I'm gonna say about the semantics of first-order logic so now let's talk about inference rules okay so I'm gonna start by talking about first-order logic with horn clauses and we're gonna use some generalization of modus ponens and then we're gonna move to full-on first-order logic and talk about the generalization of resolution okay so let's begin by defining definite clauses for first-order logic so remember a definite clause in propositional logic was a conjunction of propositional symbols implies some other propositional symbol and now the propositional symbols are now these atoms atomic formulas and furthermore we have might have variables so we're going to have quite universal quantifiers on outside so intuitively you should think about this as a single template that gets real if you were to propositional eyes it would be a whole set of definite formulas in a propositional logic so this another way to think about this is that this single statement is a very compact way of writing down what would be very kind of cumbersome in propositional logic because you would have to instantiate all the possible symbols okay so here's a formal definition so a definite Clause has a following form you start by a set having a set of variables which are all universally quantified and then you have atomic formulas which are all conjoined implies another atomic formula and these atomic formulas can contain any of these variables okay so now let's do modus ponens so here's a straightforward generalization of modus ponens you have some atomic formulas a 1 through a K that you pick up and then you have a 1 through a K implies B and then you use that to derive B ok so it says the first attempt so you might assume I catch on the fact that this actually won't work so why doesn't it work so imagine you have pee valise and then you have for all X P of X implies Q of X so the problem is that you can't actually infer a Q of Alice at all because P of X here and P of Alice just don't match right this is supposed to be a 1 this is supposed to be a 1 and P of X and P of Alice are not the same a 1 so this is kind of an important lesson because you remember these inference rules don't know anything they have no kind of intrinsic semantics there's just pattern matching right so if you don't write your patterns right then it's just not going to work but we can fix this and the solution involves two ideas substitution and unification so substitution is taking a formula applying a final replace to generate another formula so if I want to replace X with LS apply to P of X I get P of Alice I can do to find replaces X with Alice and Y with Z and I gonna replace X with Alice and why would see and so in general a substitution theta is some mapping from variables to terms and substitution theta of f returns the result of just performing that substitution on F so it generates another formula with these variables replaced with these terms so pretty simple idea ok unification takes two formulas and tries to make them the same and to make that I'm saying you have to do some substitution so it returns one substitution and need it to do that ok so here's an example knows Alice arithmetic knows X arithmetic these expressions are not syntactically identical but if I replace X with Alice then they are identical so that's when your vacation does so what about this how do I make these two identical I replace X with Alice and why was e and what about this one I can't do anything because I can't I can only remember substitution only can replace variables with other things it can't replace constant symbols so it can't replace a light sweet ball so that just fails and then things can get a little bit more complicated when you have functional symbols so here to make these the same I need to replace X with Alice and then Y with F of X but X has already been replaced with Alice so I need to make this Y goes to F of Alice okay so to summary summarize a unification takes two formulas F and G and returns a substitution which maps variables to terms and this is the most general unifier which means that if I a unify X and X I could also replace X with Alice and that we find but that's not the most general thing I want to substitute as little as possible to make two things equal so unify returns the substitutions such that and here's an important property if I apply that substitution to F I get identically the same expression as if I apply the data to G and if I can't do it then I just fail okay so now yeah question so the question is F f of X is this a variable or a formula so f of X F is a function symbol so it takes a term and returns a term so the technical term f of X is a term which represents an object in the world and you can check that knows is a is a predicate so it needs to take terms so f of X visitor okay so now with substitution unification we can now revise our modus ponens to make it work so I'm going to have a 1 prime through a K prime which are distinct syntactically from 8th a 1 through a K and what I'm gonna do is try to unify the primes and the not Prime's into some substitution and once I have the substitution I can apply this to be and derive B Prime and that's what I'm gonna write down okay so let me do go through this example now so suppose Alice has taken 221 and 221 covers MVP's and I have this general rule that says if a student takes a course and the course covers topics then that Suman knows that topic so I'm need to unify this takes Alice 221 covers 221 MVP with this abstract version and when I unify I get the substitution to be X you need to repeat a replace with Alice Y with 221 and Z with MDP and then I can derive I'll and then I take this theta and I apply that substitution to knows X Z and I get knows Alice MDP so intuitively you can think about a 1 prime into 8 K prime these are concrete this is concrete knowledge you have about the world this is a general rule so what the substitution does is it specifies how the general variables here are to be grounded in the concrete things that you're dealing with and now this final substitution grounds it out grounds this part into the concrete symbols in this case Alice 221 and MDP okay so what's the complexity of this so each application of modus ponens produces an atomic formula just one not multiple one so that that's the good news and if you don't have any functions symbols the number of atomic formulas is most the number of constant symbols to the maximum predicate already so in this case if you have like a hundred possible values of X hundred possible values of Y a hundred possible values of Z that would be the number of possible formulas that you might produce is a hundred to the third so you know that could be met you can imagine this being a very very large number so it's exponential in the arity but if the arity is you know let's say two then you know this is not too bad it's not exponential so that's that's a good news the bad news from a complexity point of view is if there are function symbols then actually that's infinite like it's not just an exponential time it's like infinite infinite time because the number of possible formulas that you could produce is kind of unbounded and when what might you have something like this well if you remember one of the functions could be some so you could have like some one and some of one and some of one and so on so you can kind of essentially encode arithmetic using this first-order logic okay so so here's what we know so modus ponens is complete for force or logic with only horn clauses all right so what does completeness mean it means that anything that's actually true that's entailed there exists a derivation a way of applying modus to get there but the bad news is that it's semi decidable this means so first order logic even when you restrict it to horn clauses this semi decidable this means what if F is in entailed forward inference using complete inference rules in this case our modus ponens will eventually prove or derive F in finite time because it's complete so eventually you would get it but if if it's not entailed we don't know we don't know when to stop because it could go just keep on going on and on and actually no algorithm can show this in finite time so this is a complexity throughout a result that says it's not just exponential time but it's actually there's no algorithm it's like if you're familiar with a halting problem that's this is very related to that okay so that's a bummer but you know it's it's not the end of the world because you can still actually just run inference and get a partial result so you might succeed in which you know for sure because it's sound that it's the F is entailed and after a while well you just run out of CPU time and you stop and then you say I don't know ok so now let's talk about resolution so we've finished talking about first-order logic with restricted to horn clauses and we saw that modus ponens is complete there's a small wrinkle that you can't actually compute everything that you hope for but that's life and now we're going to go to resolution so remember that first order logic includes no more clauses so here's an example so this has all students know something and the fact that this is it exists here remember existential quantification is like glorified disjunction so this is like our example of no snow or traffic so what do we do with this so we're gonna follow the same strategy as what we did for propositional logic we're going to convert everything into CNF and then we're gonna repeatedly apply the resolution rule and the main thing that's going to be different is now we have to handle variables and quantifiers and use substitution and unification but the structure is going to be the same so the conversion to CNF is a bit messy and gross and slightly non-intuitive I just want to present it so you know what it looks like so here is a example of nada seeing that formula so what does this say just you know to practice this says for all X so if anyone who loves all animals is loved by someone okay and what we want to produce is the final output is this CNF formula which again CNF means a conjunction of disjuncts and each disjunct is atomic formula or atomic formula that's been negated and here we see some functions that have emerged called skull on functions which I'll explain later and that's that's basically it so we have to handle variables and we're gonna have to handle somehow and the way we do this is we remember there's no quantifiers that show up here and by default everything is going to be universally quantified which means that the existential quantifiers have to go away and the existential quantifiers get converted - these are functions okay all right so part one so there's a again the sick or I can't remember six to eight step procedure we start with this input what is the first thing we want to do we want to remove all the symbols that don't shouldn't show up get our symbol inventory correct so we eliminate implication this is the same as you know before so here is this thing implies this thing and we replace that with not that the first thing or not the second thing so now the expressions are more gross but it's really the same rule that we identity that we were invoking before it would do that for the inner expression we push the negation inwards so what it touches the atomic formulas and eliminate double negation so this is all in old news and something new hero is we're gonna standardize the variables so this step is technically not necessary by standardizing variables I just mean that you know this Y and this Y are actually different it's like having two local variables into you know different functions they have nothing to do with each other because we're gonna remove quantification later I'm just gonna make them separate so this Y gets replaced with a Z okay so now I have this I'm going to replace existentially quantified variables with skolem functions okay so this requires a little bit of explanation so I have exists Z loves Z of X okay and this existential is on the inside here so of this universal quantifier fire so in a way Z depends on X for every X I'm gonna have a different Z so to capture this dependency I can't just drop um exists Z what I'm gonna do is I'm going to capture the dependency by turning Z into a function and the same thing happens over here I have exists Y and I replace this lowercase Y with a big why that depends on the the variables that are universally quantified outside this the scope here yeah so loves all animals is on in the I guess the first part so everyone who likes all animals is loved by someone so this is the sum one part because here I push the negation inside yeah yeah so remember when I push negation if pasta for all it becomes it exists okay so now I can distribute or over and to change the order of the of these connectives so that because in CNF I want a conjunction of disjuncts not a disjunction of conjuncts and finally I just ditch all the universal quantifiers okay okay so I don't expect you to you know follow all that in a complete detail but this is just giving you a basic idea okay so now we're ready to state the resolution rule and this should look very familiar it's the same resolution rule as before but now all of these things are not propositional symbols but atomic formula and now this is not P and not P but P and not Q and I because these in general might be different and I need to unify them and then I would take the substitution return by unification and I'm gonna apply it on the result it's the same way we did for modus ponens so here's an example of this I have animal Orlov's and over here I have not loved or feeds and what do I do I try to unify this love's with this not loves and I get this substitution so you has to replace with Z of X and V with X and that allows me to cancel these now now I've made them equal and now I take the remaining parts and I apply the substitution so this feeds you of V becomes feeds Z of X and X okay so there's a bit more intuition I can provide but this does become a little bit abstract and you just kind of have to trust that resolution is doing its job I personally find it kind of difficult to look at intermediate stages of logical inference and really get any intuition about the individual pieces but but that's why you define the principle as prove that they're right and then you trust that logical inference does the right thing okay to summarize we've talked about propositional logic and first-order logic so for inference in propositional logic you could just do model checking which means that converted to a CSP and solve it I mean first of all logic there's no way to enumerate all of the possible infinite models so you can't do that but in certain cases you can propositional eyes and you can reduce versa logic to propositional logic in certain cases or you can stick with inference rules and if you stick with inference tools you can use modus ponens on the horn clauses or you can if you don't want to restrict your horn clauses you can use resolution and the only thing that's different about first-order logic here is a plus plus which means that you have to use unification and substitution okay um final takeaway is you know there's a lot of kind of similar notation and details here but I wanted to kind of stress the importance of logic as expressive language to represent knowledge and reason with that and the key idea in first or logic is the use of variable so these are very not the same notion of variables as in in CSPs those variables are propositional symbols which are like the simplest thing in logic so in logic first-order logic we've kind of gone up of kind of a layer in the expressive hierarchy and variables here allow you to you know or give compact representations to a very rich thing so again that kind of you don't remember anything just to remember the takeaway that logic allows you to express very complicated and big things using kind of small formulas okay so that's it on the on Wednesday be giving a lecture on deep learning and there's one and then we have the poster session after Thanksgiving and then the final lecture will give that will sum everything up so okay I will see you at the poster session and good luck on the exam