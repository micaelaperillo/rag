all right hello everyone happy Friday welcome to CS 109 now I am not the usual person Chris is here he as well it is uh it is only customary for the head TAA to give the lecture on algorithmic analysis so in in continuing with that tradition here I am and we have a good amount of content today so the coverage today will be um expectation uh law of to law of total expectation we have five problems prepared today of those five one of them is extremely difficult so I'll give a bit of a heads up and a warning before that throw throw around some some candy get some goost going for that problem and then afterwards it's more or less of a it's more or less straightforward so yeah let's have a good time happy Friday hope uh hope the last week was good cool oh by the way so the so the so the briary today is we got kid Kats and we got and we got some chocolate truffles and I'll throw I'll throw these in uniform uniform random distribution weighted by how many there are okay all right and with that let's get started a little bit about what happened last time um there's a null hypothesis um so how can we use Bo boost trapping to deal with null hypothesis uh uh so this will be a little bit of a review but the idea is we have this thing called A P value and the one kind of Crystal idea that we really wanted to get across is the P value is the probability that your hypothesis is from noise and that's why we do that's why we can do bootstrapping with like replacement as samples just to say hey if I got these two different samples and I just take like subsamples with replacement what is the what is the probability that I'll actually see the the hypothesis that we're trying to to claim just out of random noise that's it P stands for oh what did I just click I didn't click anything okay P stands for what's the probability that your hypothesis is just from noise that's it okay all right so on to the main topic for today algorith algorithmic analysis and one of the in one of the problems of the five that I said we'll cover today is pertinent to Netflix streaming so in particular the caching system that Netflix has had up until I believe like a year or two ago when it switched over to AWS but that's some those are things in the news but we'll see we'll see how they actually like stream some of the videos okay so but first we should do a little bit of a review especially about um expected values uh so fundamental definition of expected Val value how do you calculate the expected value of a r a variable and here we're we're assuming that it is discret so we take a sum over X is the value that each kind of varable can take on probability that and the P probability that X takes on that value is just like P of x x okay this should all be review this was like from from material from before the midterm okay so a little bit more General than just the expectation is linearity of expectation so when you have the sum of some random variables you can just carry you can just carry the expectation into each one of the terms so the why is there two clickers on this interesting um so the the expectation that of a sum of random variables is equal to the sum of the expectation now we'll be seeing this a lot in class today like I think there's at least like five other the sides that have this particular like like like that have like switching this little e with this big capital Sigma that kind of looks like a e so if you're like the Big E little e switch just a few sides of this okay so here's one kind of limitation about what we can do with expectation um the issue with expectation is it tries to capture all of the characters of a probability distrib of a probability distribution using a single value so this is good and bad good as in if we if the underlining distribution is just way too hard to capture we can at least give some kind of a reasoning about it the bad is it's a single number like I can tell you what the expectation here is of this big curve but sometimes what we really care about is like okay what is going on in this like 7,000 range it's like that's that's your tail like you should really be optimizing for your tail in certain situations too so we'll talk a little bit about like how that kind of plays into like like software selling or so but this is the primary limitation of expectation okay all right so couple other things law of unconscious statistic just expectation of a function on some random variable X is equal to the sum of the function on the values that X can take on multiplied by their probabilities and then one particular example that we see probably like I think on the midterm two was when we're calculating the variance the term the terms are expectation of X squ like X random variable Square minus the the expectation of X the random variable all squared and for that first term the way you calculate it is you just take the output of any of the ex any of the event values exit sorry any of the values that big X can take on little X's Square it and then multiply it by the probability okay so there's a lot of unconcious satis the the idea is like so it's quite simple and an an unconscious sa satis station could do it but it's debatable but now we can like recognize it immediately in the wild okay so that's all for review and here are some like kind of like practice problems and revisiting a few of the random variables that we've seen so far so first first of all let's start with bu so let's let's say we have some events E1 through n and they're indicator random variables okay so what does an indicator mean indicator means beri okay and if each of the beri random variables occur with like okay if they occur your bruli is going to take on value one if it doesn't occur then it's going to be zero okay so we we have said in the past that the expectation of whatever the r whatever the brly random variable is is equal to just the probability of the Val of the like event yes how do we know the indicator means oh it's defined so it's the yeah it's defined like the indicator is really defined as the indicator is defined to be the function where if the random variable occurs it's one if the random variable does not occur it's zero okay yeah this pops up in two examples so we should like like we should clarify that now okay so why is this the case we take the so we just expand using the expectation like take okay the two values that the that the Bly random variable can take on is zero or one multiply them by by the probabilities and take a sum okay that's it so here's a here's a term that that should be used a little bit earlier but PRI also known as the indicat ROM variable where was studied by like the guy named George Bull and uh bull actually died of being too cool like he uh like this is exactly how like he uh he died he died of pneumonia after walking around in the rain in Queen in I think like Queen's University or something in England okay so uh in other words don't run out in the rain and be cold like I think I've seen like two rain storms here in like the past quarter or something so like like take care of yourselves like if you if like don't like don't don't be running around in the water right it's a it's a b it's a big coal for that don't get ponia Okay so a little bit harder uh binomial so we've like kind of alluded to or at least I've alluded to my section that a binomial is just a sum of brly random variables so one thing that we could take is okay take take each brly random variable take the probability say this n independent Trials of them um Define the indicat Define like the indicator variable over them by the way indicated variable BR R variable they're like kind of really really similar here say say each bruli is is say each indictive variable is from a bruli take the sum over them okay so this is the sum and Y here is actually a binomial so y can be defined as both the binomial here or it can be defined as the sum of Bly random variables okay with the same P for each one of the bis IID Etc okay how do we take the expectation of this we take the expectation on the outside of the sum switch the Big E and the little e and we get and we get the get that the expectation it's just the expectation of the sum is the sum of the expectations which is just n of the random variables times the probabil times the probability for each okay make sense all right cool expectation of a negative binomial so in class we've seen that the negative binomial is the number of Trials until you see R successes okay until you see R successes can also be model like okay so R successes each one of them is like the number of Trials success after after the I minus first success those can be modeled as geometrics and then the negative binomial is actually just a sum of the geometric random random variables okay so as a pattern with B with bom uh binomi random variables we will be taking the expectation over these and just switch around the sum and the expectation and we get that the expectation of a negative binomial is exactly as we would expect our trials divided by toal probability P for each okay make sense well good we're just using the same trick over and over again just swap your expectation with your sum this is a key idea we use this all the time all the time in 109 it's uh pretty important okay so with that let's move on into the first of the five problems that we have today computer cluster utilization so consider if you have a computer cluster with K servers that means you have like K little desktop Towers running some program or you have one single desktop Tower running five different running K different programs requests are independently go go into each server so some so call one of the servers server I with some probability Pi okay let AI be the event that is server I has no requests okay so actually maybe it would be helpful to do board work for this [Applause] one so if I get the so if I have these like five different servers right or four of them for now and just like S1 S2 S3 S4 okay and then the number of requests that I have can be like R1 R5 r10 okay the other one because the other ones have got have gone process or so S1 here does not have does not have a single request is processing so it's sitting idle so in this case a the a indicator variables would just be A1 equals 1 because it's true that S1 is blank then there's A2 oh by the way is this too small for people to C okay cool A2 is zero dot dot dot dot dot all of these are all A4 is zero as well because they all have a requested servicing so each of these A's just monitors if a server is Idle or not okay so X is going to be the number the total the sum of A1 through AK so the total number of servers that are idle and the thing that we want to kind of monetize or the thing that we're like really interested in is what is the what are the number of servers that are actually doing useful work at at this like point in time with this many requests so the question here is how do we go on ahead how do we go on ahead and solve for the expected number of servers y that are not vacant given like some certain number of requests Okay so so let's see okay so maybe like take a minute or two discuss a little bit and see how we can kind of solve for expected value of y here yeah maybe like turn turn to your neighbor find some find uh find someone nearby to talk to you or just like shot that answer so it's not the expectation of a single add because okay maybe let's come back and uh Sol solve this as a group a little bit so Y is defined as so okay so I went ah and cheat a little bit and like click clicked on the clicker for a little bit of a start so Y is defined as just K the total number of servers we have minus those that are Idol so by linearity of expectation we can just say Okay expectation Y is equal to the expectation of K expectation of constant is a constant and then and then propagated to the expectation of X so here okay now we just need to solve for the expectation of X okay um for the expectation of X we know that okay so what do you know about x x is the number of events of A1 through a k and their indicators okay so that's just going to be the expectation of the sum over all over all the indicators okay does that make sense anybody have any questions yes where's the formula for y coming from here uh request yeah it's equal to yeah this is a it's just given yeah it's given a logical reason why that's the yeah totally if the if x is the number of servers with zero requests the number of servers with more than zero with like more than zero requests are all the other servers right so there's K total servers X of them are idle and we're looking for the ones that are not idle so that's just K minus X yeah okay oh I should be giving upes here kick that oh my yeah okay any other questions I got PL I got plenty of K of kiat here can can you just repeat again what VI uh VI so VI is the broli indicator for some for the AI so actually AI here can already be can can already be modeled as a brol just by itself but we explicitly say hey we know that this event AI that like a server I does not have like a request is either a true or false but to kind of cast that true or false a one or a zero we need to say that it's an indicator like this is useful for if you for if you have if you make an assumption over like what the pro over like the probability of like your case servers being idle or not and in this case it's kind of like okay like semantically we could just say AI equals like bi equals Ai and it will be the same difference okay yes can we always just encapsulate all of the individual terms in linear equation as expectations and are there any specific cases where we can't do this because we had Y is equal K - x yeah and then we just apply the expectation to both sides we have the value that's always going to be valid oh yes yes yes it's always valid even like KX it could like X be dependent on k k could be dependent on X if you have a subtraction and you have and you were interested in expectation just propagate that expectation to to each term expectation is linear which is like super cool okay oh sorry okay anyways okay so okay we we we do the usual thing we swap in the the expectation into the sum then we calculate okay what's the expectation of each one of the indicated ROM variables it's going to it's going to be the probability of B that's just equal to the the uh the probability of each of each request going into a server times the number of service there are or sorry times the number of requests there are n or to the power n and then there's going to be K of those so that's it you like like there are n so there are n n requests the probability that one of them will go into each server is one minus p is 1us pi and then and we can and then there are K different servers so we just sum across them okay yes when you go to is that exactly yeah so when so to repeat the question going from E of bi to P of AI here this is this is because the boli the expectation of beri is just a pi it's is a probability okay all right so why is this important because so Amazon actually uses this in AWS they say the number of ser the number of servers that are occupied at all times and the number of servers that are idle at all times has a direct impact on their efficiency and how much money they're spending on their W on like AWS like Compu Computing warehouses and they can actually monetize this and okay yeah there's a drone there's a drone that I made a while ago but the important thing is AWS web services is actually 52% of all of their like profit like that's more than they're like whole North American Commerce operations so like everything that we use on like the Amazon website that's like they make less money from that than they do from just like AWS like services so like the idea is like they rent out these computers they're like elastically sized for for consumers to kind of like rent out the computers and they can make they can make money in the fact that your consumers are not going to always be using using your computers so like there like you could you could Shuffle around the consumers on each computer and make money off off a t off a like kind of renting out compute okay all right so yeah that that was pretty cool this is a pretty big game game changer a lot of people started doing like cloud computing for this like Azure gcp or AWS um yeah okay so okay so remember how I said I'd give a warning before the problem that's going to be the hardest in this whole lecture so a little bit of background about this particular problem it's it's a name problem so there's a so we gave this problem out I think a few years ago in like a final exam and I cannot and well it was very difficult there's uh it's it's partic it's particularly famous and I've actually like when I first got the slides I like wrote out a few like quite a few more slides just to kind of give it like more motivation about like why this problem is important so if the last if the last like example kind of like we went a bit too fast on is because like I really kind of wanted to like save some time for like this particular example okay so before before we start with this one anybody want a kit cat oh my God okay this is gonna all right can I deliver the kit cat yeah sure yeah okay or you can just okay okay here here uh here go one here okay all right okay let's go to the back okay so there's two this way there's looks like huh let's see one two three that way sorry okay this is probably not going to work but okay we're going to okay keep it okay okay there was a spread okay BR the that's a no that's a no huh oh yeah oh I'll put it uh it's here okay that's actually code okay all right so let uh okay let's hit the heart let's hit the hard question then get some get some glucose it's a Friday let's not let's not check out just yet for the weekend all right so here's a little bit here's another key for this problem okay when you when when stuck just brainstorm about random variables it will be very good to like kind of like okay just like start thinking of very creative random variables because like when I saw this I was thinking geez I could not do this on a final but okay so here's a premise you got a hash table with nend buckets okay you have a set of strings each string is equally likely to get hash into any bucket so just like you you you have a very good hash function that just equally distributes these strings okay let X be the number of strings to Hash until each bucket has more than or equal to one string okay what is the expected value of the number of of the number of times you're going to have to Hash A String that's it this singular question has a name it's called it's typically called the coupon collector problem and I've seen it in about like two or three classes first time I saw it was in 109 second two times were were in like other CS Theory classes pretty popular it's got a really it's got a really nice solution but it takes quite a bit of motivation to if you're sing it for the first time okay so to kind of demonstrate here's a hash function here's here's five buckets all right we're going to start hashing some strings and see and get some like get a little bit of like motivation about how we can solve this so we have a string okay here's a string our like our CS online students are the best we hash it and it gives us a and it gives us a little sun in the first bucket by the way this is going to be like all the strings are going to be like subliminal messaging for like a for like a like a please feel gun on a Friday okay so this is round one okay so X here is like X here has okay it's not X but like the number of rounds here that that has happened is one because we've only hash one string okay here's string here's round number two we hash this other string into the third into the third or fourth Bucket over here index by one index by zero then we hatch another string and this is round three so now we have a collision and we put and we put two suns in in in the first box okay then on the third on the the third one or on the fourth one we hash uh we hash another drink and it puts a smiley face and yes please eat fruits it's a it's a there there there's sickness going around hopefully this will help um this puts so this puts a smiley face into one of the other into one of the other buckets the only two buckets I have to cover now is the bottom bucket here and a middle bucket here once you cover those two we're done okay so we hash another strink and and we finally get a get a little symbol in the bottom in the bottom bucket but we hash another like okay so now we'll be done if we Hash A String into like the third into like the middle the middle bucket right yeah but s but sadly I put a heart in like a little weird place because we need a space for another heart so we don't actually get what we want we have another Collision okay and then finally on the seventh round we're actually done okay so the value that X took on here is seven because it took seven rounds for this whole table to be filled okay did I go to on that people good do we understand the premise here Nots all right cool so the question is what is the expected number of rounds all right okay uh maybe turn to your neighbor talk about it come up with some pretty come up with some uh good ideas for random variables that we can use here to try to solve the expected number of rounds um few good a few good considerations are like maybe there's something geometric in there maybe there's something like a binomial looking in there all little all little suggestions but uh yeah it's uh this is not an this is not like one could probably yeah one could probably think of it like a span like with fresh eyes can think of it like a span of like a few minutes but like it's it's pretty it's the one that we have is pretty hardish okay go for it trial we CRA br that that's and then I do you guys want a little bit more time or think we think we could take a stab at it oh all right so okay so who's got a good suggestion tell tell you what uh for these ones I'll give out I'll give out Chate chocolate truffles okay uh yes I don't know if it's a good suggestion but I was thinking like can you speak up a little bit I don't know if it's a good suggestion but like if we have buckets you can like think of like each bucket as being success I was think like a geometry where each bucket be a success for that one a lot of them like ative great suggestion so I like that so there's I heard like sum of geometrics some of some something about binomial they're very good um the only issue with the binomial is it assumes that they're independent of each other yeah I was thinking like a negative binomial because negative binomial is some geometric I know some geometrics yeah but then you need to like I had the same thought last night and I was trying to I was trying to see if I could explore it a little bit more but I think the so the way that the approach that we actually have is like pretty close like a to a negative to a negative binomial but it's uh at stages it's kind of quite quite close here can can you can you pass this back can you pass this back oh yes yeah uh to the general over there in in teal gray blue huh okay thank you okay uh what if we did a summation of different geometric random variables where the first geometric the probability of a success being picking a new bucket is exactly one so we're for sure going to get a success and each subsequent round the probability lowers therefore the expectation of the geometric 1 over p is going to get greater and we just add all those up okay yeah I'm pretty sure that that that's 80% of the solution we can go with that so suggested was using a geometric at each round um and say that quantify success as a new bucket at every single round so what this means is the let XI be the number of Trials to get a success after the I success okay so what does success here mean success is hashing strings to previously empty buckets okay and after I buckets have like greater than one strings prob like we can calculate the probability of like of a success as being like nus I / n let me clarify what that means so we have a string we have some partially filled area here there's uh I like here I equals 3 there's five buckets and we have and we have this region over here of like three kind of like consecutive buckets of just like emptiness I put them consecutive they don't have to be consecutive but they're just there it was easy to to draw um so here we see that like the success the success here will be like hitting any one of these three buckets okay and the geometric variable that we're going to be looking for here is we want so we already have like ey strings that are like in that are like like there's already two two successes here there's two of them right there's like two buckets that have strings already they theyve satisfied our criteria and the probability that we're going to hit that like we're going to hit any of these is n minus like IID n which is going to just be like three fits okay so that's the probability that we're going to be successful at every round from whatever the I round is that we have here did I say eyes or something okay I just realized okay anyways so the so the random variable we're going to choose is a geometric and it's going to say okay after the third round what is what is the expect amount of time until I throw like a piece throw a string into one of these bottom three buckets okay does that make sense this is like the critical this is like the critical piece like this is this probably like this single like this single little thing here like this little like thinking of this really creative random variable probably took like many hours of trying or or like I don't know take takes nothing okay any questions like I don't want to lose people at this one yes yeah okay so I have a there here's a typo round here so I I wrot the round here is like I I should be two here the round the rounds are like I counted rounds and number of buckets as a even though they're not so this is uh like the these these sides are like really like the yeah the these sides that this is supposed to be a two I'll like I'll correct them before before we post this but should yes so to clarify What's Happening Here is that we're studying a bunch of geometric functions and we're summing the probabilities together because every single time you know the the chance you're going to fill an empty bucket is going to be yeah and so we we' only sum five abilities this time uh for this one five geometrics not just five right because you could like actually yes you some five geometrics but the chance you have multiple rounds but like is it five no it's not five on the fifth round the chance of success is one5 so the expected is one over 1 or five expected trials M sorry could you repat that it's like you wouldn't you sum five different GE for example on the first round the expected number of Trials is one because the probability of success is one one over one is one the fifth trial the probability of is 1 yes you Su end so you Su you sum for the number of buckets that that you have I I have yeah yeah you do some you do some numbers the thing that was unbounded is um the geometric itself is unbounded because it could take you like an infinite amount of time to actually hit each one of the buckets yes how do we yeah where does where does p come from where does p come from yeah what do nus oh n minus n minus I is just a number of buckets that don't have a string in it already and then divided by n is like the probability that you're going to hit any of those of those probabilities for this one partic for like the next round oh yeah yeah okay okay all right let's move on so okay here's the full geom here's like the full like like geometric p p pmf of it um your XI are going to be distributed with geometric n minus I / n okay so this is the main important part the part that comes after is just a bunch of mathy math and like there's something there's something there's something complicated about those but don't worry too much about it so the part that comes after is okay well look it not not that part but you take the expectation is n / n minus one as defined by the geometric variable you take the sum exactly as I said over here there'll be five of them so x0 all the way to 5 - one 4 okay because you have five different you have like five different buckets or here and different buckets you some and you sum over the probability for all of them and then there's this thing which is okay if we really want to compute it each Val each one of those those X NS has probability like n/ n like the first bucket you're going to you're going to fire off probability one that you're going to that you're going to hit an empty bucket because that's the first thing you're going to hash then after that I like okay now I got to Hash the other n minus one and then after the second round then you have to hatch like I don't know the next like n minus two buckets right so this particular sum has a name of a harmonic sum and in math and that particular harmonic sum is some constant times log of n that's it there there there's no like where there's a I I actually tried I actually tried to figure out what that what that o was it was actually like bounded between like two two little log things it was easier just it was easier just to say okay like it's like Big O of like n log n oh by the way the outer nend is from like the the n in the in the numerator or n in the numerator I forgot I had this clicker okay and yeah that's F and yeah this part right here this part right here will be your final answer if you get this part right here um your grer will be very happy to see that but that's about it okay all right so that's the end of the hard part the rest of this the rest of this lecture is going to be about uh this one cool cool like cash farming thing I saw um some some little things to help you out in like 161 uh and this one little thing about uh well not one little thing like a pretty important thing about um different differential privacy okay so what did we just see we saw expectation we saw conditioning and let's and let as all good things whenever it does a slide with a peanut butter and jelly and jelly sandwich it means we're putting the two things together and getting conditional expectation okay so for conditional expectation have one um X so X and Y are joint need discre random variables okay recall that a conditional pmf of x given some y some Y is use a little Y is just this like expansion here this is by definition of like of uh of just like a random like conditional expectation or sorry conditional probability okay we Define the conditional expectation to be okay if we have some run of variable X and some condition we just call that the sum of whatever value the X can take given whatever the the value that y was okay so this is all just like notation no notation sugar notation syntax it will be on the sides right and then okay if the thing is a if the random variable is continuous you would take an integral instead of a sum yeah okay like yeah the notation like that first equation p uh subscript like the uppercase X and Y that's just implying like uppercase x equals Little X right oh yeah so in this one like we're conditioning on like yeah like we're conditioning on some Y and it say okay here's a here here's like if I give you X and I give you y this is like what the like what the this is how you can evaluate what the probability is yeah so it's like the notation like the subscript notations oh sorry you mean this Oh you mean this part yeah exactly that that's just like which which did distributions are they're drawn from because it's kind of long to write this whole thing like board space right yes how do we get that second line is it just like oh no no no no no this is just a definition we're just defining the conditional expectation as just this as just distinct so like theot the conditional expectation takes some value times the probability of that value happening and it mult find the probability of like that Val happening we need a condition on y That's it okay all right here's some practice so the practice is okay we got two six-sided die D1 D2 Define random variable X to be the sum and Define the random variable y to be the value of the second dice okay what is the expected value of x given that we know what the value of the second dice is okay um yeah sure take maybe like take a minute or two uh think think about this for a second it should be pretty like like should just be able to like like just apply the definition should and it could be straightforward but uh yeah chance to talk to your neighbor I'll give out I'll give out some more Kit Kats is it too easy okay all right let's just uh let's get some let's get some some ideas coming out here okay so what what is okay what's one thing that that we could do here yes we just of count it out okay yeah yeah yeah you could just count it out yeah yep boom count it out just cck take this GI take all these numbers right and they like okay so you know that six that that we have that we starting from six just add one add two to all of them right and then multiply and then just multiply the probably by 1 16 and you get 9.5 intuitively this is the same thing as just take the six that we already got by linearity of expectation on okay should be D2 here but D1 and D2 same same thing that's equal to 6 Plus 3.5 9.5 both both cases okay make sense any questions so yeah I'm going to call him FR it back more because like this a okay okay so we're going to Define G of Y is equal to expectation of x given y okay so we want in this in this segment we're going to highlight that the expectation here is going to be a function of Y so Y is like some like predetermined thing we're going to try to take it as a function so here's a backbox of whatever y could be okay so the input is okay well okay I guess we I guess we we write that out explicitly the input is say Y is equal to 5 okay then what's the expectation over all the X's given that that y was something I haven't told you anything about like the probability like Mass here or the probability density here anything like that so but this function should just give us a number it should give us like an like a like an exitation over X if I tell you what Y is okay likewise if I say Y is three okay then this function might just tell me that it's six okay that's it all we're trying to say here is this part this like expectation of of x given y equals little Y is a function on on y okay it is not a number okay so key Point e ofx is a number e ofx given Y is a function and E ofx equals like say something like e of x equals like five doesn't really make sense okay so like we we can't like this is like a thing that we've like seen in the past where where like students were like oh yeah we we're like really out of time on like P something we write something like this we be like okay like we don't really know what to do with this okay makees sense okay so here's some here's a few interesting stats that we collected like okay I'm pretty sure these stats are like from like five or six years ago but still pretty relevant at least quter Trends so here's like fa like we have a joint distribution over favorite number and the year in school here's the marginal meaning like okay if we just condition uh if we just like say okay like ignore the year part and just take the take the the like the probability over all the favorite numbers these are people's favorite numbers everybody likes seven because I guess like that's a jackpot in like a casino or something right like 777 jackpot I don't know um my personal favorite is five I'm very happy it's number two good taste so how do we actually calculate the expectation of this thing you just sum you just sum you sum each each value and multiply by their part by their like uh their their pmf here okay so okay one tricky question is like why do we know that all of these probabilities that that they sum to one like what do we have what do we what do we have to do to like make sure that all of these like some are like some to one yeah yeah yeah you marginalize you normalize marginalize somewhere the wise divide okay all right so here is the here is like a condition table we're like okay so condition that you're you're a sophomore your expected value the expected number that you will like is like 5.5 okay very tasteful number five great if you're junior deviate a little bit is you're more likely to like a number around 5.8 senior 6.0 I think they meant 4.0 for GPA but like two but like six is also fine and then if you're fifth year just go down to 4.7 don't know maybe they maybe they also like number five but they just uh like undershot it okay everyone see what we did there so it's hard to like we didn't want to write out the whole joint table on like a side it was kind of difficult so like we just we took the we took the expected value and used that as a representation and that's exactly what the what the expected value should should do okay okay so um yeah this is this is another thing on like a graph what the pre what the previous table look like and here is one about the expected number of units you're going to take given which year you are at Stanford okay Frost so Frost oh my God you guys are working hard like the expected value of a number of units there is quite high and then you and then I think what happens is you realize you're too hard and try to take it a little bit slower in like soft more year but like kind of overshoot it a little bit and you pick a back up in junior year right but in junior year maybe you take a really really hard winter it's like n no no no never again and then senior spring all the senior year and then the the fifth year are left like me are probably just gunning for the gunning for the sorry for the units to actually graduate so we have to step it up a little tiny bit all right the first time I saw this was pretty interesting because I I think we took the I think we took this particular value over um all the over like CS 109 in general so like this particular group of like frost are like the frost in like CS 109 and the southt in CS 109 so it's like it's a like like this is a distribution over like our class in the past yeah it's quite yes you seen like a couple examples of things like this sampled like culations like where is this data and can you use it uh figure data probably somewhere on Chris's computer I need to figure that out but can you guys use it sure I mean like just yeah just like ask whoever has it like I think send yeah send send Chris an email we probably know where this is there probably like some forms and documentation around it but it should be okay yeah great idea for a great idea for extra credit project yeah okay all right so I built in a little bit of a break I don't know if it's halftime I think I went over by 5 minutes but yeah let's give people like a two-minute breather go use the restroom uh come up ask some questions I got some extra I got some extra candy yeah how about it okay all right so it's been two minutes I think if the clock is right all right so let's uh come back a little bit and then start talking about the other parts that I have planned for the rest of lecture all right so real question what is this what is this thing huh s nah it's like the expectation of an expectation okay so so so what is he so so like let's let's consider expectation of x given y as a function on Y and then I take the expectation outside of it on y right like what is the expected value of like the Rand so the r this function right here like expectation here that's a random variable based on like whatever Y is and then we just like expectation over it yes like on the previous example with the years versus the units would that be like the expected value of like if we were to pick one year like how many units would we expect yeah exactly so the expected so the expected value of all the of okay so the expected value of the expected value of x conditional y trick shot or it's a it's a it's just the expected value of x that's it that's it huh it's because of this it's because of a math trick so we actually have a proof for it okay so uh the the proof here the proof here for why this for for why this for why this Tower Property H is like okay like in other math classes we call this like the Tower Property it's uh pretty important and actually like I think I use this one time like a like a finance interview or something was interesting but so here's a full math proof let spew don't worry about it for now I will go over line by line with expect with uh with a with a cursor and some notes so first line we expand this using the law of unconscious satis because expectation of x given Y is a function of Y okay so click great okay lav on content satiation okay so I get this big so I get this big sum then by the definition of conditional expectation I extend out the first term okay then I use a change rule to smash back in the probability the probability that y equals a y okay and then I and then I do this really like simple thing of okay switch the order of the sums here because because like there like doesn't like the ordering doesn't matter on the sums and this say X is not really like X doesn't depend on anything y here right like every single one of these y terms is multiplied by the same X we can just pull it out and then we'll if we're going to sum over the joints of all the Y that's just going to give us the marginal on X and if you if you just get the marginal on X and you sum over and then you sum over the X's here that's just the expectation of x marginalized definition of expectation of X cool yeah it's Tower H yeah this is Tower Property um I can I can go back and Trace through this a little bit more carefully uh any questions yes could you go over the first line again how we the law ah yes that's because this thing right here expectation of x given yal little Y is a function on is a like we can view view this as like a function on um it's a fun on little y so whatever the Y so whatever y value we can take here we can just like say okay we're going to take the xation of X over that because this will give us a value back it's a function y okay make sense almost uh yes can I get intuition for this by thinking of e of X and Y a function uh over all possible y over all y y the expectation of that is just expectation of X is that why it's called to law of total expectation yeah it's kind of like like lot of total expectation comes out of this and it's actually it's actually a little bit simpler than this but the idea is like okay we have the expectation G of x given whatever we see on Y and then we take the we take the expectation again over all the Y that we can possibly plug in over all the W yeah and then that comes out to just be the expectation X that's what this whole that's what this whole statement is trying to say yeah we have expectation of X we do like 1 n right times all you know what I'm saying yeah why is there not term like that is B equation oh it's because one/ n if you have a finite sample so like if you're like like a sample mean right that's a slightly so just multiply by X when I these up is that the is that the equivalence it's equal it's equ yeah sorry here why is it called the tower rule Tower rule because I think I think the idea was like actually I'm not even sure why we call it a tower rule I just saw one time we like oh yeah this is a tower property I think it's because if you if you keep chaining the expectations oh like like you can like we can like make this longer and it will still come down collapse down to a little white here right like we can take like expectation of Z and then pipe in another Z into the conditional and it'll still give you back x m so it's you can make the left side like you can you can collapse the tower down to this little tiny thing all the like anytime come on come on cursor there it is that makes sense yeah it's uh it's pretty cool here sorry okay all right so with that here's the LA total expectation and here's okay so here's a little something I I prepare oh yeah um this is key like this for the next problem this will be the key uh just take like uh the lot expectation is you can condition on some y and then time multiply by the probability of Y okay this looks a lot like the law of total probability except you put you put the expectation on the posterior okay poster means the larger part cool all right so here's a little something from my past so when I first so when I first came to Stanford I wasn't sure if I wanted to be a CS major or a math major and in fact I actually wanted to do e but then I saw this one question came up of like okay how fast does this piece of line does this line of code take to run and I think I've been trying to figure this out for the past three years and to be honest I'm I still don't know so Netflix streams millions of hours of videos per day so they really really care about how long it takes to get a movie from their database okay here's a qu here's a question how long does this line of code take say you have a movie file that's 52 megabytes that is not a movie that's probably like a tiny episode of something but 512 was a number that that I like that kind of worked here and here's some options okay like we live in big old land in all of introductory computer science but for this particular segment and this particular problem we're going to actually talk about like real values all right just real quick any takers here just uh choose one of these one right okay two all right any take for three three three all right I think it's four the reason is because okay so here's it's very cheeky it's they're all correct because it's a random variable let me explain why so the reason is because I haven't I haven't exactly told you where this movie is like is this movie stored on your computer is this movie stored elsewhere okay so to see the first one okay your your computer has the movie file okay that's 3 seconds you know dis C uh read it through read it through put load into your OS fire it off on on your on your monitor 3 seconds seems reasonable good computer very good computer if it's in SoCal you got to go through some Network Hoops the the packet has to go to your router the router has to go across some power lines and some and some telephone cables to actually get to your computer that's going to take longer that's going to be like 1.6 minutes okay all right so what if we go even more extreme and go to Japan for a file all right great so now you go through cell towers and you have this giant under like under the ocean like like pipe there's actually like a whole pipe of like of just like of just like wires going under the ocean here that connect the internet from continent to continent and you have to get the file that way so that's going to take a even a little tiny bit longer it's going to take you five minutes to get the movie right okay we just went across the world in five minutes because of a giant internet line so are we done right actually though somebody in space has a computer whenever someone has a computer the first thing that they do is watch a movie yeah okay and when they watch a movie somebody in space has a movie okay anyways it probably takes about 2 hours to get a movie this is actually this is actually made of number like I'm pretty sure like even if we like linked up all the linked up all the satellites and do the little like Optical thing it's probably not even two hours but like tentative tentative like depends on depends on how things go the next four years maybe the site will live okay all right so what's the expected run time our alien friend is backc so assume the file location is distributed with the following pmf 10% chance is on your computer because we're going to assume that you like don't watch the same videos all the time 50% of the time is going to be in SoCal because people are going to be interested in the same movies across California that's actually true that's how they like do some like the clustering for the for the for the databases probably there in Japan okay if it's not in Japan it's going to be in space my example so I just put all the probabilities into Japan okay probably that it's in space I hope it's not in space because that will take you a long time to get the video and I'm not sure which Alien made it so you can make could you imagine coordinating a movie with aliens man shooting that would be terrible so what is the expected runtime of this following line of code given that you have these particular like expected values for your runtime okay yes sure yeah yeah yes please probabil multipli by the situation exactly so sorry what what was your name yes okay so was let's just multiply each one of these like each one of these values like three by their like probability and then just sum them together like law of total probability and that's exactly what we're going to do so for home we multiply okay get Movie Database time I'm going to make a very long name for it because good style multiplied by the probabil multiplied by the probability that it's at home and the expectation is going to be condition on that is in your house okay that's the first term do that for all the other terms and you just plug and chug all the values and you get the raw numbers okay multiply them together you get six 6.25 minutes just some value out there on average going it's going to take someone 6.25 minutes okay all right now another interest interesting thing we can do is okay let's take this single line of code and actually wrap it in an if statement so like let's pretend that your computer actually has a cache that can like take more like like that can like taking more like taking more movies okay there's a 10% there's an 80% probability that the movie is in your like local cash in your computer cache and getting a movie from the cach takes the same amount of time as getting a movie from like your like local computer because you know they're both on your computer what's you expect at run time of this so here's a trick that I that we that I kind of want people to see is if you have an if else statement here and you want to take total and you want to take expectation do total do the law of total expectation based on a branches is so if else here law of total of expectation first term will come from the if second term will come from the else okay it's exactly this just okay get the first get the values like here's your first term this is from the this is from the else okay I put the else first and then the if second okay we already know this value up here if the movie is not a cash that's just a database read right so that's just the expectation of whatever we had from the previous side multiply that by 6.5 add them together 1.2 okay we didn't the important thing is we didn't have to redo the work to get us like 6.25 minutes okay following all right let's do one more thing what if you have many files so I just wrap wrap that if El statement inside of a for Loop okay assume we are interested in end movies assume the retrieval time of a movie from the old cache takes 0.3 0.3 time time what is the expected runtime the expected and what is the approximate distribution of the runtime okay approximate distribution here we have some assume these assume all the movies come in IID yeah normal Central limit theorem it's exactly normal here and then in the normal the mean is n times the the expectat value for each one of the movies so n * 1.2 minutes okay all right great so with these three pieces combined we've actually implemented one of these little dots so here's a giant map of Netflix's cach location maps that's stale out by two or three years so they probably have less now because I think they migrate over the AWS in each one of these dots is a building called the internet exchange point so it's just just this giant building that hous us well servers probably has some really good air conditioning good place to work okay within each one of these servers learning a big chunk of code that we just basically imple implemented so especially like maybe too it's too small to see batch load was the last example we saw this if L statement is the example that we saw that we saw like two examples ago okay that's it this is the this is how Netflix does like cash locality for all of the databases well okay very simplified very simplified there's a lot more like underpinings in it but this is kind of the general idea of like how you of how you would do caching okay oh by the way here's a here's a full code and why would they care about the expected value the initial the initial functions can distribute a copy per GE per geolocation the getting getting the movie you can say something about like okay the average customer could get a could get a clip in 1.2 minutes while the user is either watching other videos or asleep you can do the you can do a batch load and load all n of the of the files or all n of the movies okay so this is literally this is just a concatenation of like we did this on the third example this is the second example this single line is like the first ex or uh this single line is like the first example that's it and we're calculating the expected value over all these and they can use these metrics for the like video quality team or for like other people other people trying to stream Services over Netflix and sell them like hey here's some streaming capacity for your video like we'll charge you x amount for it and here are the guarantees that we're going to put for they're going to put for that like particular stream okay those are called slos service service level objectives not that important this is just like like an example to get people warmed up for like expected for um expected values in algorithms okay all right so that's it for Netflix that's it for our little friend the alien um we have a little bit more of a dry problem afterwards because it's uh grounded in theory land I shouldn't say dry actually it's a it's a pretty interesting problem too but it's uh there's I I couldn't find a very good story for it other than hey this probably helps in one in 161 okay you have your cursive code you take each Val each time you hit the recur recursion you take a random variable you take a random value between one and three if the value is one you return three okay that's it if the value is not one if it's two you return five plus another iteration of your recursive code and if and if it's not one or two which means it's three then you return seven plus whatever your recursive code returns okay and then the question is let y be the value returned by one iteration of recurse what is the expectation of Y okay so the thing to note here what do we have we have an if else when you see an if else the first thing that you do is a law of total expectation okay why does that make sense huh why does that make sense oh because every single time you go down an if Branch you're conditioning on entering that if branch and the condition I and conditioning on like the if statement right here right these if conditions are all are all like random variables they're all like condition on like whatever X takes so every single time every single branch of these can be thought of as like a posterior distribution across like the X okay okay so just fire off the law of total probability you have the expected value of like okay like Y which is this value here so Y is like recurse given that you've seen xal 1 times the probability that you went down this branch and then given that xal 2 given xal 3 etc etc you just expand out using the law of total of total expectation because you have an if statement okay so we we take each term and we can unpack them the expected value of y given that X is two right that's the second if statement and it actually ends up just being like five plus whatever you recurse on so by linearity of expectation you can just say Okay expected value of five is five expected value of a constant is a constant plus the expected value of recurse which is exactly what we have right now so expand all of these and then we can plug them back in by the way any questions here people follow me all all right cool so we have to about so we know what the probabilities are because it's a random integer uniformly and we we now know what the expected values are we can just plug plug them in and now notice you have you have expectation of Y on the left hand side of the equation and you have expectation of Y on the right hand side of the equation but importantly you also have a standalone you have a standalone constant which means that you can do you can subtract over all of your terms of v y and then so and then solve for solve for E ofy okay so you can just subtract like okay like the there there there is some math unpack here but it's Mo it's mostly just algebra you like subtract okay like a third of a y over here you subtract like another like third of a y over here and then you subtract like uh like 2/3 of a y of a expectation y over here and then you can just see that that's going to be equals some constant yes if we didn't have that Standalone constant then we would then wouldn't this imply y d of y equals uh is like can be anything it can be yeah uh like what if like we had e if we just had like instead of like three five plus recurse but this but like if recurse if this thing then recurs if this thing then recurs yeah like would like we resolve the Paradox by saying the algorithm doesn't terminate then or like so your expected value y actually be infinite it would it would diverge because you would just keep summing yeah okay any any other questions about this about uh did I go too fast I could go like I could go back a little bit and like see if there something yes in the back yeah I think just that last step of going from okay so this last step we substitute in E of YX right into all of these terms okay so we see here that there is like a a standalone like one like three times 1/3 is one right and then there's like an a a term for E of Y here there's a so one3 term for that another third term for over here so that makes 2/3 of a term and then here we have another 2/3 of a term of e okay so 2/3 of 2/3 of e here 2/3 of of e here gives us 4/3 so we can just subtract 4/3 from from both sides and get netive 1/3 of Y is equal to whatever is is equal to like the remaining constants on the right then you divide both sides and you should get a value for expect expectation y does that make sense very hand wavy sort of yeah like what I recommend is maybe like like in your own time like take a look at this P side and actually just make sure that like you can solve for E of Y here it's a very it's a very like algebraic algebraic computation okay yes you have question if we modify this algorithm to say xal random in1 2 and then we also say uh X like if xals equals 1 then return recurse minus one if xal 2 return recurse plus one so that it's perfectly balanced that that constant term cancels out but it's still the algorithm might or might not terminate there oh but your expectations is going to be fine though because it will terminate in expectation it will terminate an expectation yeah it will terminate an expectation if you don't return ever you will not you will not terminate on expectation because there not a single case where you would we would terminate but if there is a case where you could you could terminate then there might be a chance that that in the expectation you will terminate I see yeah okay all right so let's move on Pro tip use this a 161 this will be very useful in that class also like on a finance interview about like coin coin flipping but that's a that's a that's a tangent here's a few things about differential privacy and maybe like the last 3 minutes I can just go with this like quite quickly um it will not do it just justice so like please look at this look at these sit on your own but like um so here's so here's cnth at work and she aims to like provide means to like maximize the accuracy of like machine learning models without like without like with a low probability of them actually like taking of them actually like identifying the DAT the data set you trained on this is particularly helpful in medical AI where like a lot of your data is like is like uh IR Irv like shielded meaning like people can't or should not be able to to look at your training set and if you publish a model trained on like like Health sensitive data that's a big issue if people can reverse engineer model to get your data set okay so to account for that we do a thing called obfuscating which just means hey for everything s we're just going to inject a random noise into each into like the into like the labels and with some random probability some training sets will just get injected with some noise okay and then we TR a model on it so uh someone might actually ask us okay what's the expectation that someone could actually take like extract the XI here like in in equation like this right and what we see is that like okay this random over here is like it's like a Boolean between true and false what's the expected value of whatever the output is we get here that's just equal to the probability that like okay so e of x i equals like probably that y equals 1 which because they're both of these both of these are are beri probability is like okay to law of total probability if else Branch if Branch you get the you get the 1/4 else Branch you get whatever the original P was okay sorry okay then if you then okay so say someone say someone went in here took a sum over all of the over all the values like they ran your model many many many times and then they took like some sample average what they be to extract out whatever this P value is turns out they could get some estimate they could say that the expected value of like whatever the Z is is equal to like 50 * P plus 25 how good is this estimate that's an open research problem and it's being explored by Omar Walmart wrangled yeah the guy that used 154 okay so that could be a challenge you could use this as like a like extra credit like extra credit project or so but it's something that exists and then and here's here's the paper that was that was written about this and it's still like yeah it's an active area research differential privacy is a big thing um I did a project about differential privacy back in 229 it was really fun uh it's a good area just this is just like another way to like use uh to use um expectation in like Al algorithmic analysis okay so that's it um today we ended the algorithmic analysis part of Cs 109 um next Monday we will start doing machine learning so ml Maps the all the all all the all the big names they're they're really cool a very fun it's a very fun section thank you guys thank you guys for for coming have a good [Applause] weekend