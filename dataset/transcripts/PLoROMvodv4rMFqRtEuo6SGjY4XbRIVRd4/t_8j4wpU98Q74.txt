all right hi everyone um welcome to the 224n python review session um the goal of the session really will be to sort of give you the basics um of python and numpy in particular that you'll be using a lot in your second homework um and the homework will come after that as well um we're sort of taking this tutorial from the background of anyone who hasn't touched programming languages to some extent um but also for people who have will be sort of going through a lot of that material very quickly and we'll be progressing to numpy as well um and as I mentioned first and foremost the session is really meant for the people who are here in person so if you'd like me to slow down speed up at any point need time for clarifications feel free to ask us and it's really meant for you first um here and that I really would like it to be sort of an interactive session as well all right so this is a topic the topics we'll be covering today um going through first of all why python is a language why have we chosen it for sort of discourse and in general why do people prefer prefer it to some extent for machine learning and natural language processing um some basics of the language itself common data structures and then getting to sort of the meat of it through numpy which as I mentioned you'll be extensively using in your homeworks going forward and then some practical tips about how to use um things in Python all right it's first thing why python um so a lot of you who might have um been first introduced to programming might have done Java before a lot of people use Matlab in um other in other fields as well um so why python python is generally used um for one because it's a very high level language um it can look very very english-like and so it's really easy to work with for people especially when they get started out it has a lot of scientific computational functionality as well similar to Matlab so when you talk about numpy you'll see that it has a lot of framework so very very quick and efficient operations involving math or matrices and that's very very useful in applications such as deep learning and for deep learning in particular a lot of Frameworks that people use particularly for example Pi torch and tensorflow interface directly with python and so for that those main reasons people generally tend to use Python within deep learning okay so the setup information is in the slides if you like to look at them offline um I will be sort of jumping over that for now because I want to sort of get to the introduction to the language itself and if you have time come back to sort of the setup information a lot of it's pretty direct you can walk through it um it gives you steps for sort of how to install packages um what is a conda environment for example and gets you set up with your first working python environment so you can sort of run simple and basic commands to get used to the language but for now I'm going to be skipping over this and coming back to it if we have time all right language Basics so um in Python you have variables and these variables can take on multiple values the assignment operation there's an equal sign will allow you to assign this particular value to a variable a nice thing with python is you don't have to instantiate the type of the variable to begin with and then only instantiate or only assign values of that type so for example in certain languages we first say that this variable X is only going to be of type intent any value aside from that assigned to it will throw an error Python's pretty flexible so if I want to I can reassign it I can start with X is equal to 10 and then later on like five lines later I can say x is equal to high as a string and there would be no issue um you can do simple mathematical operations such as the plus and division signs you can do exponentiation which is Raising one value to another value so x to the power of Y for example using the double asterisk um you can do type castings for float division so if you want to ensure that your values are being divided resulting in a float value and not just dividing two integers you can cast two different types like float if you want something to be explicitly an INT you can also just put an INT instead of the float with brackets around the result and that'll give you an integer value and then you can also do typecasting to for example convert from integers to Strings so in this case if I wanted to instead of doing 10 plus 3 as a mathematical operation I just want to write out 10 plus 3 then I can convert the X and Y values for example to Strings and then add the plus sign as as a character as well to create a string and so a lot of these common operations you can look online as well people have lists for them and just see how they're sort of dot in Python all right um some other quick things um so Boolean values the the true and the false um they're always used with capital letters and some of the languages they might be lowercase so just one thing to know um python also doesn't have a null value the equivalent of a null value is none so sometimes when you want to say that this value you want to return none saying I'm not really doing anything here you want to do checks protect for example in if statements um to say that this doesn't have a value then you can assign it to none so none sort of functions as a null equivalent so you're not really returning anything it doesn't have a value not the same as zero and um another nice thing about python is lists which are sort of um mutable we'll come to that a little bit later but sort of mutable lists of objects that means that you can change them they can be of any type so you can have a mixture of integers non-values strings Etc and yeah functions can return the non-value as well um and another quick thing instead of using the double and and uh in some of the languages as people might do with python I mentioned earlier it's very english-like so you can actually just write out um if x is equal to three and and in English Y is equal to four then return true or something um it's it's quite nice that way so you can use and or and not um and then just the comparison operators of equal equals to and not equal to we'll check for equality and inequality this one's pretty standard I feel across many languages and you can use them in python as well and yeah remember just clicking the equal equal to sign is different from the assignment operator this one checks for equality that one is just assigning a value so single equal sign versus two of them all right and then also in Python you don't use brackets so python you can use basically spaces or tabs so either indents of two or four to be able to break up what is contained in the function or contained within like an if statement a for statement um or any Loops for example um and so the main thing is you can choose whether to do two or four you just have to be consistent throughout your entire um code base otherwise they will throw an error now go to some common data structures and for this we'll transition to the collab so this will sort of show you in real time this is by the way a collab a collab is basically um a Jupiter notebook for those of you who are familiar with those um that you can use that it's hosted on Google servers um the really nice thing about jupyter notebooks is you don't have to run an entire file altogether you can run it step by step into what are these called cells so if you want to see like an intermediate output you can see that pretty easily and that way and Indian also writes for example a lot of um like descriptions um pertaining to cells which is really really nice to have as well so a lot of people like tend to use these when they're sort of starting off the project we want to debug things and colab allows you to use these jupyter notebook type applications hosted on their servers for free basically so anyone can create one of these and run their code all right so lists are mutable arrays mutable means that you can change them so that once you declare them you can add to them you can delete them and they're optimized for that purpose so they expect to be changed very often we'll come to what are called numpy arrays later and those tend to be pretty much fixed when you create a new one you'd have when you change one you'd basically have to create a new array um which will have the additional information so this is highly optimized for changing things so if you know for example and you're in a loop you're adding different elements to let's say a bigger entity you'd want to use something like a list because you're going to be changing that very often so let's see how they work so we start off with a names array with Zach and J um you can index into the list um by so what is this index into the list by index which means that you can um list out the elements in the list um depending on What's called the index so it's what place that value is at within the list so zero refers to the first element so Python's what's called zero index which means it starts with zero and then it goes to one so here zero will be Zack and then let's say I want to append something to the end so the to add something to the end of the list the term is append not add and so if I want to append I can now create a separate list which is the original list itself with the added last element and what would currently be the length of this it would be three because you have three elements and you can just quickly get that by using the Len function not length just three letters Len all right um it's also really nice because python has overloaded the plus operation to be able to concatenate lists so here I have a separate list right and all you need for a list definition is just brackets so this is a separate list altogether even though I haven't saved it in the variable just Abby and Kevin and I can just do a plus equal to which means that names is equal to names plus Abby and Kevin and this should output this full list you can create lists by just putting the plain brackets or an existing list and then as I mentioned earlier your list can have a variety of types within them so here this list contains an integer value a list value so you can have a list of lists as many sort of sub lists as you like a float value and a none value and this is completely valid within python slicing refers to how you can access only parts of the list so if I only want for example um in this numbers array I only want 0 1 2 slicing is a way that you can extract only those parts so the way sizing works is the first element is included and the last element is excluded so here I start with 0 1 2 3. so 3 is not included and so 0 1 2 will be printed out there's also shorthands so if you know that you're going to be starting with the first element of the arrays if you know I'm starting I want zero one two and it starts with zero then you don't need to even include the first index you can just leave that and include the last index that would be excluded so that would be blank semicolon 3 and same deal with the end if you know that you want to take everything let's say from like five and six till the end of the array you can start with what would you like so 0 1 2 3 4 5 till the end and leave that oh sorry um fun fact so this um semicolon when you take this just the semicolon it'll take everything in the list but it'll also create a duplicate in memory that's that's a very slight um very useful thing to to know um because sometimes when you're like past Less in an array uh sorry in Python which is out of scope of this tutorial um you can only pass the reference to it so if you will change the array that gets changed this will create an entirely separate copy in memory of the exact same array so if you make any changes to it it won't affect your original array so this is a very pretty neat way to do that um and then another fun thing that python has which is pretty unique is you can index negatively so negative indexing means you index from the back of the array so -1 refers to the last element of the array minus three will refer to the third last element and so what minus one will give you will be six in this case when minus three will give you will be everything because you're starting with the minus three elements so minus one minus two minus three till the end and then this one seems kind of confusing right three to minus two so this will do is it will give you 0 1 2 3 so you start with three and then minus one minus two so you leave off the X the last because you excluded within list um you'd only get three and four so that's what this is okay that's about lists tuples are immutable arrays so once you declare the values of these they cannot be changed so I start with remember we started with like the list of Zach and Jay tuples you start with Zach and Jay um and you can still access them you know I can still print out name zero same as I did with lists but if I try to change it in this case it'll throw an error so two pulls once you've instantiated them they cannot be changed and to create an empty Tuple you just create you can either use just a tuple sign or oftentimes you can just use the parentheses backwards so you can just say for example as you did here just parentheses to instantiate something all right and yeah this one we'll we'll come to a little bit later in shapes but you can also have a tuple of a single value and all you have to do there is just put the value and put a comma so that just shows that you have a tuple which is like with like an immutable array so you can't change it it's a list but only of one item and that's here okay I'll quickly move to dictionaries um for those of you who might be familiar with other languages this is the equivalent of like a hash map or hash table um what this is useful for essentially is mapping one value to another in a really really quick way um so if I want to map for example a string to an index which you will happen to do a lot of in your homeworks um this is a really really useful way to do that and so what what it does is you can instantiate this dictionary and it says corresponding that DAC is going to correspond to the string value whatever it is and so anytime I want to retrieve the string value I just use this dictionary I indexed by it which is what I do here and then it outputs the corresponding value and it does that really really quickly um and yeah so it's really useful very very commonly used especially when you sort for example you have like a list of strings or a list of items and you want to have a corresponding index for them because and as you'll see in NLP oftentimes you're using what you're working with indices and numbers in particular so it's a really great way to sort of move from like string formats to just like um numerical index values there's some other things you can do for dictionaries you can check whether certain elements are in there so if you for example try to index phone book is equal to monsie they'll throw an error because there's no string that says Monty in that phone book dictionary and so sometimes you might be wanting to do checks before you extract a value and so this will just check for example if I do print monsie and phone book it should say false or for example here Kevin and phone book it should say false while something that's actually in that dictionary Zach will be true okay and then if you'd like to delete an entry from the um from the dictionary you can just do that using the Dell command all right let's move to Loops um quickly so Loops are a really great way to optimize for the same kind of app same kind of operation you're doing it's also a great way to um start to sequentially go over those list type or array type objects we were talking about earlier you know you have like a list of names right how do you access all of them so Loops are a really great way to do that um in Python they've abstracted away a lot of the confusing sort of um parts and other languages that might be you can really for example first index on numbers so what you do is you have like a range function that you call so here you say range and the range of the last number you'd want so with this range function will return is 0 1 2 3 4 and that's what will be stored in this I value and here it's just printing out that I value so if I wanted for example Loop over the length of a list of size 10 I just have to do 4i and range 10 and then index that corresponding part of the list you technically don't even have to do that because in Python you can just directly get the element of the list so here I have an a list of um names where I have Zac J and Richard instead of saying first the length of the list and then doing this range operation I can just directly say for name and names and then print out the names and it will just directly get the element in each list but sometimes you might want both you might both want this element Zach as well as its position in the array and for that you can actually use this really helpful function called enumerate and so enumerate will basically pair those two values and it'll give you the both the value which is here name for example and its corresponding index within the array both together so that's really really convenient versus for example having to do this like a little bit more complicated range operation where you first take the range and then you index the US how do you iterate over a dictionary so for dictionaries if you want to enter um iterate over What's called the keys so all of these first items that you first you know put into the dictionary you can just iterate the same way you would a list you just say foreign name and for example phone book and you can output the keys if you want to iterate over what is stored in the list which is called a value you'd have to do the dictionary dot values and if you want both you use the dot items function and so that will print out both of these all right so this is sort of covering the overarching most commonly used sort of structures lists dictionaries and then loops and how to sort of efficiently use them within your code we'll quickly be moving to the sort of meat of what um is really really strong about Python and what you'll be using a lot for your coming homework essentially homework 2 which is numpy okay so for numpy also I'm going to be going to the collab we just quickly wanted to mention um what numpy is so numpy is basically an optimized Library um for mathematical operations you know people tend to like math lab because it's very very useful for these mathematical operations which people use in their research um pythons sort of solution to that is to have a separate Library entirely where they make use of subroutines which are sort of like sub languages sorry sub scripts that are written in a different language called C or C plus plus that are highly optimized for efficiency so the reason C and C plus plus are much faster than python is because they're closer to what's called machine language which is what the computer will read I mentioned earlier one of the nice things about python is it's kind of high level it looks like English right to some extent you know we say literally like is you know if x is equal to one or X is equal to two right but um that also means that there's a lot more translation required on the computer's part before it understands what you mean um and that's useful when you know we're writing out code where we want under understand it but it's a little bit less useful when you're sort of running a lot of operations on a lot of data so the real benefit of something like lumpy is that if you have sort of your memory and your data in a particular format it'll call the these like species scripts or what are called subroutines in a different language and it'll make them very very fast and so that's the real benefit of using numpy and almost everyone um in in sort of NLP is very very familiar with this because you'll be running a lot of operations on for example like co-occurrence matrices which are really really big and um it's very useful to have them optimized for time so that's really the benefit of using numpy and numpy basically it's involved for all these like math and Matrix and Vector calculations and it's different than a list although you can easily translate between a list and a numpy array numpy arrays are specifically as I mentioned designed to be used in these subroutines so they have a specific format they're instantiated differently and you can translate between this and sort of your standard lists easily but to know that you can only do numpy operations on numpy arrays you can't do numpy operations on lists directly you'd first have to like convert them which is really simple you just use this numpy.array function but just know that they operate only on numpy arrays okay so for numpy we're going to be going back to the collab and then as I mentioned earlier the real strength of numpy is you know it supports these large multi-dimensional arrays and matrices for very very optimized high-level mathematical functions um and just to go back step back for a quick second what is a matrix matrices are basically like rectangular um structures of numbers that are used and you can treat them with specific rules um for operations between different kinds of things so if you have like a lot of data instead of you know individually potentially multiplying things if you can store them in this rectangular format you have specific rules about how this Matrix for example interact with a different one and by doing that which is matrix multiplication or Matrix math um you can do a wide variety of mathematical operations a vector is generally this is conventional none of these are like hard and fast rules but conventionally a vector is a matrix in one dimension so it's usually like a row vector or a column Vector which usually just means that it's a list of values and only one mentioned so it's like for example here when I come down to X is equal to numpy array of one two three that's a listen only one dimension versus for example Z when I this is z down here that is what's called like a two-dimensional array because you have both rows for example like six comma seven and then you have eight comma nine um versus in this first one you only have three values in one dimension so that's sort of the conventional difference between the two another convention is matrices generally referred to two-dimensional objects so this as I mentioned is like Z this is two dimensional you might have heard the word tensor also tensors by convention usually are like higher dimensional objects so instead of having two Dimensions you know two comma two you can have like n Dimensions you can have two comma two comma two comma two comma two for like five or six dimensions and those are very valid to do mathematical operations on um and those are often colloquially sort of called tensors in addition and this will be covered in the next tutorial in pi torch um those larger sort of tensors are also optimized for efficiency um to be used on gpus and so they're called tensor in a more concrete way because you're using these tensors with pytorch and other sort of packages to directly do those quicker GPU operations on for deep learning so those are sort of this is a quick sort of terminology difference between the three okay so now um let's start off with just some quick sort of representations of how are these matrices and vectors represented in numpy um this sort of goes back to your question about like what is the difference between like three comma versus like one comma three um so usually three comma and numpy arrays usually just means that you have one list of like one two three for example there's like three values versus if you add another list on top of that this one comma 3 essentially refers to the fact that there's a list of lists so anytime you have two Dimensions it always means that there's a list of lists um and that being like a list of lists for example like a row so here one comma three means that there's one row and then three columns so it's saying there's one row of three comma four comma five essentially and then each of those is a column separately you can easily reshape them so these are basically the same format but from numpy's perspective you'll see a little bit later for operations such as broadcasting you need to have it for example sometimes in this one comma three format or three comma one format um and also like what like as I said three is this he just like she represents three numbers one comma three means like one row of three elements three comma one will mean you have essentially in each column you'll have a separate array so you'll see sort of boxes around each of them there's an example that comes a little bit later in this collab which will make it a little bit more clearer so here if you can see the difference between like X and Y one of them has only one bracket which just says it's one list only one list of one comma two comma three the second one is two brackets which says it's a list with only one list in it if it's a list of a list that's really the main difference between like these sort of two representations so I could have like let's say like a separate one I'm going to call this a and I just do this so it's the same sort of elements but this will be one comma three because it's showing that there's one outer list which shows the rows and then one inner list which I like to have each of those values so the benefit will when I'm coming to what's a little bit later which is broadcasting and so it essentially will help you determine what dimensions you want to match against because sometimes you'd want to have one comma three like one comma two comma three applied only two rows in some other Matrix well we'll come to that a little bit later um but sometimes you might want to have it only applied to columns and so like if I have a separate Matrix for example of zero zero zero zero zero zero zero zero and I want the resulting Matrix to be for example one two three one two three one two three along the rows let me actually draw this out it might be easier so let's say I have like the zero zero zero zero zero zero zero zero and if I want to have a matrix that does one two three one two three one two three versus one two three one two three one two three the difference in how to generate these two um will be the difference in the shape like how you represent their shape it's the same one two three but the resulting array you're generating by repeating the one two three values um requires a difference in shape and so we'll come to that a little bit later because this process of how do you generate these arrays is called broadcasting but that's the real benefit of having an understanding of the shapes the same one two three values are the same it's just how they're sort of used with regards to other arrays all right so yeah vectors can be usually represented as sort of and this is what I talked about earlier as like n Dimensions n by one or one by n dimensions and they can result in this different Behavior kind of what like this that I talked about um matrices are usually in two Dimensions represented as M by n um these are just two examples if for example I generate let's say an engine also reshape so I start with for example this array which is a list of 10 oh sorry it's important on Pi quickly so I start off with this Matrix a which is basically a one-dimensional list of ten values I can reshape it into a five by two Matrix so you just have to make sure that your Dimensions match which means that like you can multiply them together and get the original size so if I start off with the 10 matrix I can make a two by five Matrix I can make a five by two Matrix I can make a ten by one one by ten I can't make it for example three and five because that it wouldn't fit into the original size um and for that this operation called reshape is really useful um you might be wondering why is there two parentheses the way that reshape works is essentially it'll take in a tuple so remember that what I was talking about earlier with tuples is that these they're immutable objects and they're defined by parentheses so the outer parenthesis is representing what you're inputting to the function and what you're inputting is a tuple so it uses a second set of parentheses so now let's go to some array operations um so I started off with you know this array X um when you apply simple operations for example a Max operation sometimes you might want the max of the entire array so if I do the max of in the entire array what's the max value of the entire array by the way just the entire thing six right so if I just do NP dot Max of X it'll return one value and return six but let's say I want the max of every row right like and every in each of these rows I say I want let's say the max of each I want two and then four and then six how do you do that and so numpy always has like usually in most of their functions an access variable and what the axis variable will do is it'll tell you which of these Dimensions do you want to take the max over and the way to sort of think about it is this is going to be a little bit tricky but the way people describe it is the access is what you want to apply your function over what you want to reduce over and what that means is I print out the shape of the original array it's three by two I want to apply access one or as I remember you know numpy is zero indexed it'll be zero one so I want to apply the max over the second dimension the second dimension means that for each of these essentially you know that like for like the row Dimension is the First Dimension so it's not around along the rows I'm going to be comparing columns and so compare this entire column to this entire column and so just remember for axes um usually the axis zero refers to the row axis and then axis one refers to the column access um if you don't even want to remember that you can just remember that from the original Dimension which of these it's referring to um and that's the dimension you want to compare over or reduce over so it can be a little bit harder to grasp around it usually the best way to sort of get around is like just play with a bunch of sort of operations of min max and things like that but just remember like the access is what you want to compare over not the resulting thing so axis one means here column I want to compare between the columns I want to get for example comparing one to two three to four five to six does that make sense okay and what this will do is if I just do numpy.axis it'll just return basically since I'm comparing these columns it'll just return a resultant column and so as I mentioned you know um for over the axis one you get three values because you're comparing over these columns and each column has three values I'm comparing over rows as you mentioned I get two values right um and so this will just be the Tuple comma which is just indicating that it's just a list it's not a list of lists it's just a list but let's say I want a list of lists you know maybe I want to do those operations I talked about earlier um instead of reshaping which is always there it's always an option you can also use this um feature called keep dimms and what that'll do is it'll take the original Dimensions which is two Dimensions right because you have three comma two just two of them and it'll keep that consistent so it'll be three comma one but it just means that instead of returning just the extracted column which is just a list it'll basically keep the column in the context of the original sort of X and it'll be it'll keep it as like a two-dimensional value all right now these are just some operations so in numpy um you can use an asterisk as a an element-wise multiplication so an asterisk means that I'm going to be comparing every single value um to every single corresponding value in another Matrix and it's you need your matrices to also be the same size for this one so this one it's basically an element wise matrix it's not a matrix multiplication so you need to have them be the exact same size so this will compare for example one into three two into three three into three and four into three all right um you can also do matrix multiplication which is a different operation entirely um for those of you unfamiliar with matrix multiplication um you would basically be multiplying a row of one Matrix with the column of another Matrix and for that to be necessary you need to have the second dimension of the first array be equal to the first dimension of the second array so for matrix multiplication if I have an a and two B comma 3 in tune c um shaped matrices these two have to be equal for matrix multiplication just something to keep in mind because oftentimes if you're doing matrix multiplication um you need you have to make sure these dimensions are the same which means that for example this is a valid operation um but this can sometimes throw an error sometimes so it's just important to make sure that sometimes you you want to make sure that these are exactly equal you can actually just print out the shapes and make sure that these are equal to be doing matrix multiplication and then for matrix multiplication um there's a couple of functions you can use the first one is just np.mat mule which is NP dot matrix multiplication you can also just use the um the at operation and that one both of those are overloaded you can choose whichever one they'll result in the same exact operation and just a quick session show you can to show what this will do is we'll multiply one into two so it'll come like one two versus three four so it'll do one into three two into three and add those two values so that's what matrix multiplication will do okay and then dot products will what what a DOT product is that it takes two vectors so usually it operates on vectors and a vector as I mentioned is just like a one-dimensional matrix so it's just basically Three cross one for example a four cross one um it'll element wise multiply between two different vectors and we'll sum up those values and so here what a DOT product do would be like one into one plus two into ten plus three into a hundred and for a numpy you can just do NP Dot and then both of those vectors um this one is just a side on how you would want the structure of the dot product to be um for arrays that are more so okay so the phrase is the best way um for single dimensional vectors this operation Works directly anytime it's a multiple dimensional Matrix um then it treats it as a matrix multiplication the NP dot dot function so for two by two Matrix versus a two by two Matrix dot product it's not going to return the sum it's going to return um the matrix multiplication so that's just something to keep in mind if you want to make sure that your your dot product is happening in the correct way you would want to make sure that sort of similar to what I was talking about earlier that here this is I think the best way best way to show it okay so you would want the second like that what I mentioned like the last dimension of the first one to match with the first dimension of the next one because it's treating it as like a matrix multiplication um here the error that it's throwing is it's three comma two combined with three and so the way to sort of like fix that would be to have this be like for example like um switch the two so you have two comma three and then three comma it's really a dimension matching thing at this point so it's it can be a little bit confusing but when you sort of the main thing to keep in mind is like for single dimensional vectors you can just do NP dot dot directly and they'll give you the dot product value for higher dimensional matrices it treats it as a matrix multiplication um and so for if you still want to like for those higher dimensional values to ensure that you're getting a DOT product um you'd have to make sure that the dimensions are aligned similar to these so anything that's two by two plus for both um any any Matrix who doesn't have a single dimension in any of them yes it would treat it as a matrix matte Neil the same thing okay all right um okay I'm going to move to indexing so similar to what I was talking about earlier remember with list I was saying if you just do the semicolon it'll create like the same array same deal here the the semicolon just means that you take everything from the original array in fact it returns a copy so it returns a deep copy means if you have a completely separate copy in memory um okay now I'm going into sort of more details about how do you want to index quickly so if I for example have let's say this three by four Matrix and I only want to select the zero and the second rows how would I do that so what's useful is that you can sort of treat a numpy you can treat different dimensions differently for indexing so a semicolon means you select everything in that Dimension which for example here there's a semicolon in the second dimension which means I'm taking all of the column values um versus what's in the First Dimension here it's saying a numpy array of zero and two so it's saying only the zero index and only the two index which means only the zero would throw and only the second row so what this would look like would be something like I have a matrix okay I have a matrix and I only want to select the zeroth row and I only want to select the column the second row 0 and second and everything in the columns all right and then similarly for example if I want to select in the column Dimension um I want to select the first and second rows at only the first row I can do that so you can basically treat them separately you can think how many columns do I want how many rows do I want and then index so separately and that goes for as many dimensions as you want in your entire tensor um some nice things also if I want to for example take it I have this like let me print that actually X here I'll just generate the X okay so this is X right so if I want to take all the values of X that are above 0.5 for example I can do that by using what's called Boolean indexing so I just basically would say x indexed by everything in X that's bigger than 0.5 so it's pretty direct and it'll just output all the values in this entire array that are bigger than 0.5 all right this one is also another way to do reshaping so I kind of mentioned earlier you know sometimes you won't have this like list of three elements and you want to reshape it to a three by one array for example you can also use what's called numpy.new access this will essentially add another access in whatever Dimension you want so if I want to change go from like this three by four array to a three by three by four two three by four by one then I can just add a numpy.nu axis there an even simpler way to think about it would be like a 2 comma to uh two comma one and so it's just it's another way to do what essentially what would be the reshape reshaping operation does that make sense also what this would look like for example let me just a little bit more concrete this is so as we see I have this list right I have like a singular list and then each in in that list I have a list of lists so I have a list with element one and list of element two so this is what that reshape operation will do and what numpy.new access will enable you to do as well all right um I think we are a good time um so the last main topic we'll be covering is broadcasting um and what's really great about broadcasting is it'll allow you to operate with numpy arrays that are of different shapes but can be sort of with many operations in them can be repeated it allows for that in a very efficient manner and this is actually one of the most I would say useful things about numpy and one of its defining features and what that means is um if for example in this case right if we go back to this example that I had with I start off with the zero zero zero array how do I generate this array versus how do I generate this array right instead of me saying okay element zero zero plus one element zero one plus two all that stuff right instead of doing that one by one what broadcasting allows me to do is I can have only one vector of size one two three and it'll depending on how I do the broadcasting which I'll come to in a second I can duplicate it along the row Dimension or I can duplicate it along the column Dimension and numpy allows for that it'll do that on its own in the back end and so that's really what broadcasting means is I don't need to for example create a new array saying I want to like create a new array to begin with which is already like this and then add those two together I can just duplicate this and get this all right so now some rules for broadcasting and let me just quickly visually also just show what broadcasting will do oh sorry so broadcasting this is a pretty good visual analogy um I had this one by one comma one comma two comma three Vector right um and I wanna basically add let's say only the columns with this one comma two comma 3 Vector so what broadcasting allows you to do is you'll you only pass these two values in and on the back end it'll duplicate this along the column Dimension so let's say I have one two three one two three one two three one two three and then it'll do the addition similarly if I pass it a vector one comma two comma three comma four and I want it to be added to each of the rows instead of each of the columns it'll be able to do that by sort of duplicating it on the back end so this is visually what's happening with Broadcasting all right now some rules so how does numpy know when and how to do broadcasting so the main two rules to keep in mind with for broadcasting is one um it can only happen if all of the dimensions every single Dimension between two arrays are compatible and when they say what is compatible either the dimension values are equal or one of them is equal to one and that is the only rule required so for example I start off with this x array right I have this like a three by four x array um will Y is equal to three comma 1 be compatible yes it will be why because you have three in the First Dimension between the two which is the same and in the second dimension you have four and you have one so those are compatible values and so what this tells numpy on the back end is I'm doing for example an addition Operation X Plus y it knows that okay three and three are the same but four and one are not the same you know one of them has one dimension so I need to duplicate this y along the second dimension which means I need to duplicate it along the column Dimension and once it does that it duplicates it it'll get four three comma four in Array and then it can do the addition and it does that really fast so it's better to use broadcasting in this way but then for you to create a separate array already duplicated and then add them similarly I have this Z array which is one comma four what x into Z will do is first I'll check okay three comma one okay is that compatible yes because you have three in one dimension you have one in the second and four and four are compatible okay so say I know that these two are compatible in the second dimension I'm going to change anything in the First Dimension it'll know to duplicate them basically so in order to duplicate Z and so add it three times in the row Dimension create a separate array and then multiply those two so this is giving you an example of saying I started off with X I have y and then the final shape will be three comma four so a lot of times in deep learning um you will have the same um because you'll have different batches of different images coming in but you want to apply let's say the same weight Matrix to all of them and instead of duplicating that weight Matrix a hundred or even like potentially depending on the size of your batch size like a thousand times and then adding those together you use the same Matrix and it'll know okay if I'm going to be duplicating over the batch Dimension it'll do that for you on the back end so it's use a lot of times in deep learning because of this and basically in your second homework that's basically what you'll be doing implementing a feed floral Network in numpy and it'll say you have like this W Matrix yeah this like B Matrix which is a by we'll come to those in class and it'll ask you to implement their numpy because that's basically what you're doing is if you have this input image you have a weight Matrix which will somehow scale it to an output and that weight Matrix will be applied to multiple images in your batch and those images can be different but their sizes will be the same and it's optimized for that okay um so this is just more examples of sort of the same thing your final thing that you'll be coming to is a size of three comma four um let's see this one's sort of the example that I showed right here right which is that I have this array of flight say zeros I have this numpy like this B array of size what size were they would this be yes good because you have one outer list and inside this you have one inner list so it's just basically one row and then three values inside so yes and so would this be compatible yes and so it'll know basically to duplicate um over the row Dimension and so you're going to get duplicates in the row Dimensions you're going to get one two three one two three one two three and that's what's Happening Here um so these are for example a little bit sometimes when it says more complex um Behavior what this basically just means is that like if I have this B Vector which is three comma one if I'm doing this B plus b dot transpose by the transpose is just changing the dimensions and switching them so if I have a two by three Matrix uh transpose will be a three by two Matrix um what that means visually is something like your row and rows and like column Dimensions will get switched six goes to I believe it's like one two three four five six so like three row rows versus like three columns um and what this is just saying is that uh a three by one and a one by three um both of those vectors will be compatible because remember in each Dimension it's either the same or one and so it knows to duplicate uh over both of those dimensions and that's what's Happening Here uh okay so I think we are right at time um and what I would recommend is basically playing with variations of this for broadcasting and see December the two rules for broadcasting is just if it's compatible it's either the same value or it's one and whatever is the one dimension is what's going to be duplicated over on the back end so yeah it's not going to be compatible if they're divisible for example right so if you have like let's say six and three that's not compatible um you can reshape it and then see if you'd like to have one there's tricks you can use um where you're sort of thinking like on the back end how do I want this data to be multiplied you can maybe reshape everything into like an eight one like one by eighteen Matrix and then multiply everything and then reshape it back that's what you can do but you can never just directly for example six by three make that compatible okay um so I think let's wrap up this one's just a quick example of another use of efficient numpy code um quick note never preferably don't use uh Loops whenever you're dealing with large data matrices mostly because Loops are almost always about a hundred times slower numpy is usually very very efficient as this is just an example of what you can accomplish with numpy and same thing using Loops so what this is saying is that I have an X Matrix of size thousand by thousand and I want to apply you know let's say I want to add everything from row 100 onwards um with a plus five so visually what that will look like is something like I have this full Matrix and I wanted everything here basically to be add with plus added with plus five um then in in the loop format I can basically Loop over the First Dimension um of 100 plus and do that or numpy I can basically do what's called numpy.a range which will generate um integers in like we see one two three four five six all the way up to that hundred value in this case it's between hundred and thousands let's start with hundred hundred one hundred two all the way two thousand in the First Dimension and then just add that with five so this is just an example of how you would switch from using Loops to using numpy and it's a lot lot faster