the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or to view additional materials from hundreds of MIT courses visit MIT opencare at ocw.mit.edu so um let me uh let me start uh session three is about System model languages but before I um before I start uh I'd like to remind you that A1 is due today the first assignment is due today and uh I think neither yuanna or I or Le did you get a lot of questions about A1 no I didn't get any questions yeah so we didn't get many questions so uh I think I interpret that as a positive but I guess we'll find out every sub everybody submitted okay well uh so we we're hope we're hoping to have these graded in about a week uh give you feedback and we'll also post a master solution okay and uh A2 is is out right now and the other good news is there's no new assignment uh today that's being hand the next A3 is going to go out next week okay um any any any questions about A1 was was there something that was particularly uh difficult or confusing or was it straightforward any anybody want to comment on A1 wow Sam push push the button no our team thought it was fairly clear on what we what we had to do based on the lectures okay we didn't have any trouble good all right um well let's keep going then um so the the V model is our our road map for the class uh we're starting to fill in the v we're still in the upper left corner and today's lecture is actually a little different uh it's sort of in the center of the V system modeling languages as a as a precondition or precursor to what we've been calling NBC modelbased system engineering so um uh what I'd like to cover to say is uh why do we need or why have these system modeling languages emerged uh particularly what do we mean by onology semantics and syntax and then we're going to give you a um I would I would characterize this as a sampler of three different uh system modeling languages that have emerged really within the last 10 15 years the first one is called OPM object process methodology the second one is called CML system modeling language and then the third one is called uh modelica and then we'll sort of quickly wrap up with uh the question you know what what does this mean now for system engineering today and and tomorrow in the future so I'd like to motivate this with a little exercise so you remember Mr Sticky from last time you came up with some requirements so it's kind of the simplest system I could think of here so what we'd like to do is um have you work in pairs again and the assignment here is to uh describe this system uh as as clearly as you can provide a description so last time the assignment was you know write a requirement right come up with some requirements that led to this to this design but today I would like you to describe what the system is how it functions and so forth as as clearly as you can and I would like you to do this so hopefully uh you're on the WebEx uh logged into the WebEx I would like you to do this in teams of Two And as you're doing this um I don't know if you noticed but on the WebEx there's actually a uh note notepad feature uh where is it uh tell me left right oh I see so I can't share and use the notepad at the same time annotate yeah yeah stop sharing but then they can't see it right can they see this so you can write text you can draw the shapes okay so uh the reason I want you to do this on the Whiteboard is such that we can then sort of go around and look at some examples okay so the assignment is take five minutes uh turn to your partner and try to describe this system and then we'll we'll go around and look at some uh we'll sample people's uh descriptions go for it all right so so we'll modif so keep working on the assignment but do it locally on your computer not on the Whiteboard right and then we'll uh we'll sort of discuss it and share it and uh maybe not use the Whiteboard because I didn't realize there's only one whiteboard that we all share I thought that you have individually the Whiteboard and then you can sort of pass it on to different people so but but if but if you do it locally on your machine uh then we can share the screen so it'll work so do it in you know do it in PowerPoint or or word or or sketch pad or anything you want sorry about that okay um all right so let's uh let's do this we're going to sort of go back and forth between here and epfl uh let's start Maybe over here with uh naric um are you ready so I'm going to uh give you the ball and then you can sort of explain how you guys describe the system so what we decided to do was identify the primary function of the of the uh sticky Mr Sticky um so the primary the primary function is to trap the fly we thought this is enabled by a couple of other functions that are sort of at a lower layer of abstraction it's attracting the fly immobilizing the fly transporting the object uh to where you need to immobilize the fly and deploying the Mr Sticky and we ma this to the physical forms that enable the function so the canister the physical form of the canister is helping with the transporting function the sticky tape is helping with the mobilizing function the scented material we thought that would be helping through the attracting function and the hook maybe on top that you use to hang it would help with the deploying okay good so nice uh function form separation and you use primarily text right human language to describe it so uh let's see at epfl who would like to share and we'll give you the ball okay we can try maybe who is speaking Maxim Maxim okay can can we give the ball to Maxim yes do you see something yeah it's good oh perfect so we draw uh like two the same system when deployed and deployed so we begin with a container containing the basically the sticky setup rolled then when unrolled we have the container that should be linked to the sticky setup with the but whatever and we have like um an external input from the in T that were that come to be stick onto the yeah go ahead okay so that that's all okay so uh so I'll note here that you guys use Graphics right you use some kind of graphical language and at the highest level you have a it's like a state diagram right rolled unrolled so you show the system in two different states very nice um somebody else here on the MIT side and then we'll go back one more time who would like to share here okay so let's uh okay so uh we did a diagram showing the use of the of Mr Sticky so we have a user because Mr Sticky has to be rolled and unrolled well unrolled the user installs or disposes of U Mr Sticky the flies are attracted to or Mr Sticky attracts the Flies and the Flies stick to Mr Sticky and then we decompose Mr Sticky into the different components that that are below at a lower level and uh yeah so it's basically at a higher level a use okay diagram so here we have again a graphical description uh the states are sort of implied but you're focusing on decomposition right the sub elements um very nice uh anybody else at epfl did anybody just write a paragraph of text or you know more of like sentences at epfl who wants to share uh Chris here Chris okay no we didn't uh so we didn't write a text it the text seemed a bit heavy to convey a a description um in efficient terms uh what we prefer to do is decompose in uh elements and uh for each element gives some um uh some properties okay and is is that did you do this in the form of a of a list or in in in the form of a table or or how did you actually describe it so wait I'm trying to share the screen okay all right so this is we just walked on first half here we have the band and we give here properties though so it has to be made of paper or soft material has to be 1 to5 M long 3 cm 3 to 5 cm large uh it needs to have a coating which itself is a sticky material and be scented in order to attract flies needs to have visible color and then uh well the other parts here which I'm highlighting um would be really uh related to the to the packaging so a seal cylindrical container uh with a single Us opening including a hanger um with possibility of uh branding on the packaging and uh well the nontoxic material would still refer to the the the sticky material good good thank you very much this is great so what you showed I would that's more like a list right and I would describe this looks like a what I would call a bill of materials right it's essentially a list of the primary uh elements of form of the system but there's there's some uh attributes that are associated so this is a a list format with um in the form of a bill of materials with attributes attached so thank you very much that that's great so let's get um I'm going to share here again and you're probably wondering you know uh what what the heck why why did we do this uh why did we do this exercise and um that's the point I want to make next so here's a very simple system and we had four examples of of descriptions that were quite different right and um of course if you had more time they'd become more complete but they would be really different so uh this is fundamentally the issue that we've been facing in systems engineering for a long time the means for describing our artifacts whether it's you know something simple as a Mr Sticky or an airplane or a spacecraft or a medical device or even a service how would we describe it for first of all natural language the human natural language and uh as we know uh the human natural language is a very rich right there's very different uh ways in which we can express essentially the same facts the same things that's a wonderful thing if you're a poet or a writer uh but it makes system engineering challenging right because uh because it gets confusing when we're describing the same thing in very different ways uh or graphical so we saw some boxes and we saw some great examples sketches drawings uh so fundamentally the way we describe systems and this gets to the left half and right half of the brain is using language words sentences l lists or graphical right those are the two fundamental ways of describing systems and then we we put all these descriptions together in what we've been calling documents right uh we aggregate this in documents so examples of documents would be a requirements document that's what essentially you're doing in assignment to or a a drawing package right here's a even with if it's in CAD it's still essentially a document um so in in typically in system engineering all of this gets assembled into what we call a TDP technical data package and fundamentally when you're designing a new system you're producing a technical data package that has you know software drawings descriptions and and that's the deliverable from the design process is this TDP technical data package and from that you should then be able to build and operate the system with uh as few errors mistakes misunder understandings as possible and uh fundamentally as our systems have been getting more and more complex you know we're now talking about the systems that need the three four five layers of decomposition uh it's very easy to have you know errors omissions uh different interpretations of this information so that's fundamentally uh but there are advantages I don't want to say it's it's it's uh categorically bad to use natural language and Graphics they're definitely Advantage familiarity to the creator of the description so it's it's easy it's comfortable it feels familiar and also it's not confining so you can be quite creative uh by creating descriptions in this way but the the list of disadvantages is quite long uh for allowing an arbitrary description uh room for ambiguous interpretations and errors uh it's quite difficult to update so if you make a change in one description that that change will not automatically propagate to the other descriptions um handing off these descriptions from one life cycle phase to another there's discontinuities uh in these handoffs um unal level of abstraction so what I mean by that is you may describe one part of the system in very detailed right so the last example we saw uh with the with the with the list with the bill of materials there was quite a bit of detail there on you know the scent and the attributes of the tape uh but but one of the other at least a couple of the other descriptions didn't have that level of detail when it came to the tape so the the the level of abstraction could be quite different uh in the different uh ways to describe it and then you know for a complex system you can imagine that uh the amount the volume of information grows a lot and so you can walk into any uh program manager and systems Engineers office and see bookshelves right full of binders dozens and dozens of binders with with documents thousands and thousands of pages and many of them are never read right that's the big issue so that's that's been the the kind of way in with which we've been doing system engineering uh traditionally so the idea here is that um in order to uh mitigate yes Justice than phase a conceptual design phasee B preliminary and detail design uh phase C is is testing and launch you know phase e is Operation so usually uh not the same people do conceptual design poor design testing so all the the technical data package these artifacts have to be transferred and handed off to new people who who then work on the next phase that's what I mean by handoffs and yeah so so the idea is in order to mitigate some of these disadvantages of natural you know language and graphical description um there has been a and this has been recognized for a long time a need to be uh more precise perhaps more confining but to create languages that allow us to describe systems much more precisely um and so I'll mention a couple of the past efforts and you can you can read about these um each of these has a so I'll mention Bond graphs first 1960 uh this is was actually invented here at MIT by a professor in mechanical engineering um his name his name was Harry painter Professor painter created Bond graphs you can think of bond graphs as block diagrams where different blocks have uh ports or interfaces where information material energy Flows In and Out and you can comp ose a system out of these blocks these Bond graphs are essentially and uh naric will will talk about modelica and uh which is sort of a a modern version of bond graphs it has other features too but this has been this has been sort of one attempt uh another one that's very well known is idaf IDF uh about 20 years later this was uh created uh by the Air Force the US Air Force and this is essentially a description of systems that's very functionally oriented so it shows you what functions are involved and we saw one of the descriptions was very functionally oriented and and how the functions of the system uh relate to each other and uh but but generally um these these system languages have not fully been deployed right some organizations use them others don't use them and the main reason for that is twofold first of all uh some of these languages were incomplete they they would focus only in one aspect like functions or you know the the the block nature of the system the block diagrams and uh a lot of them were not executable so they would be graphical but you couldn't actually simulate and actually check whether that description was complete or accurate so um since then and the other thing of course important is domain agnostic so what I mean by this is that the system modeling language should be applicable for any kind of cyber physical IC System again if you're designing you know a spacecraft a an aircraft medical device any kind of product the language shouldn't have to be adapted the language sort of covers all these applications that's the idea so whatever language it is that you're that you're using or developing it has to have these three things any language has these three things so the first is ontology and I I uh reference here the Wikipedia articles on these things some some of my colleagues in Academia it's a big debate you know is Wikipedia a legitimate source of information or is it not uh my position on this is that it is I think Wikipedia is is is it's definitely not perfect you know depending on what topic you're looking at but it's a self sort of self-correcting system so I actually go to Wikipedia and then I there's references and you can di dive deeper so I give you the Wikipedia links here for these three things first ontology so ontology is a very fancy work word uh what ontology actually is Mark why don't you come up here you're you're an instructor today ontology fundamentally is uh describing the the entities that are allowed to exist in the language right uh subjects nouns adverbs uh what are the the objects the entities that can exist right so it's a very it's a kind of very abstract thing but it's essentially the library of words and objects that are allowed to exist in that language um and then how these entities can be grouped uh perhaps in a hierarchy and subdivided so it essentially constrains the universe of things you can describe in that language the the shorter the smaller your ontology is the more uh confined the language semantics semantics is uh basically it's a it's a branch of of of of Science of of philosophy which is fundamentally assigning meaning to those objects that are described in the ontology and so uh the the way that's that that we say this is that it's the relationship between the signifiers so the signifiers are words letters symbols right graphical symbols so how do we describe a resistor for example in electrical engineering a squiggly line right it's the zigzag line well if you don't know electrical engineering or you never you know you just see a squiggly line it's meaningless to you but if if if you know that semantically that means it's that's a resistor that's the symbol for resist that's what we mean by semantics and then the third is syntax what is syntax it's the set of rules uh the set of of principles and processes by which the um the objects or the entities in the antology can be combined to build up higher level information like sentences paragraphs and and so forth forth and so that's essentially the construction rules uh for the language so every language has these three things so any questions about this before we move into our first language so we're going to give three examples of system modeling languages and you'll see the similarities and differences but as you see these languages keep in mind they all have ontology semantics and syntax any any questions about that okay so OPM uh let me describe to you OPM this is uh one of the younger languages um and so OPM stands for object process methodology and it is uh it was created by Professor do Dory uh at techon uh colleague of mine um do is essentially a computer Scientist by by training and you'll see the Heritage here of OPM um and the the big news here about OPM is OPM is not that well known yet it's you know if you ask around not too many people know OPM but I predict that in the next decade that will change very quickly and one of the reasons is that OPM was just now adopted as a as an ISO standard and if you know ISO the international standards organization they're located in Geneva it's a big deal to become an ISO standard it took like five years the whole process with committees and reviews and so the iso standard is actually uh OPM was adopted as an ISO standard as a means to describe and develop other standards so it's kind of a meta language because as you can imagine when you read different ISO standards which by the way have a lot of influence uh they're also written in natural language and graphics and lots of inconsistencies so the idea is that future ISO standards should be written using OPM such that they're clear clear and consistent and so forth so the the the history here is that um if we go back further uml there wasl which is Unified modeling language which I'm not going to talk about today is a software this is a language that was developed primarily for software engineering you know to consistently describe use cases to consistently describe uh activity and flows in software the structure of software uh but it's really softare centc so from uml2 we then uh sort of branched off into csml which uh Mark Chas who just joined us we'll we'll talk about uh and and then OPM so these are sort of derivatives ofl and there's a book it's not it's not one of the mandatory books for this class OPM 2002 uh if you're really interested in OPM I I recommend you you invest in that book it's it's really very well written so uh let let me um give you an example okay of how how OPM can be used so like like we said typical product representations are sketches engineering drawings or uml diagrams and software but uh the the need for a unified representation and fundamentally um we have functions and then we have objects Form and Function in systems and so what we would like to do and what the the premise of OPM is that we can show everything in one diagram type okay uh so the functions the functional attributes uh the objects uh and there's different types of objects operants system components consumables the attributes of those objects and then the the links and I'll show you the different types of links between these that exist in OPM so it's a generic modeling language and it has been successfully applied to System architecting of complex products in organizations I'm going to try to give you a pretty simple example here which is a refrigerator so think about we're going to look at the at a small kind of household level refrigerator Through The Eyes of OPM all right so here's the basic ontology of uh OPM it's very very simple and that's the the idea is to have as as few objects as few entities as possible in the language to keep it simple so uh the first one is the idea of an object okay what is an object and objects are drawn as these rectangles objects are defined as entities that have the potential for stable unconditional uh existence for some positive duration of time and objects have States within them so what would you what would you uh what would be an example of an object that we've talked about today go ahead maybe the sticky tape yeah so the sticky tape itself that's an object it exists right unconditionally it's there and what's important is um it could be a physical object so it has a physical existence but it could also be an a sort of informational object so for example if you have an an an idea right or a vision uh that's an object too it's not physical in that sense but it does exist as an informational object okay uh what are states uh let's see it epfl what would be an example of a state that's associated with an object yeah that's okay can somebody give an example of a state yeah uh red and and red for the sticky tape rolled and unrolled exactly so or furled and unfurled so that's kind of a binary State there could be you know halfway unrolled or or you know the the sticky tape is full of flies or it's a kind of empty right those would be describing the object in terms of what state it is in exactly so the form is then the sum of all these objects uh so that's that's that's one building block and then processes are the other so what are processes oh is there another example yeah go ahead I ask a question is this uh is this k go ahead yeah it's Kia uh what do you mean by positive duration of time well mean meaning that so the object could be uh created right it didn't exist before it's created and it exists and then it could be destroyed again it could disappear or it could be consumed but it means that the object needs to exist for you know a nonzero period of time in order in order for it to be called an object right so objects uh in you know in in the world that can be described with OPM fundamentally objects can be created objects can be modified particularly their States can be modified and they can be destroyed or consumed that's that's basically it that's a complete set okay does that make sense okay so processes are what are processes processes are really fundamentally different from objects processes are shown as these ellipses and uh there are the patterns of transformation applied to one or more objects and processes change States so processes unlike objects cannot exist on their own processes only make sense if they're associated with at least one object okay so there processes are essentially the the functions that we develop in systems are processes that transform or create destroy or trans form objects so function emerges from one or more processes and then we have different links uh between objects and processes I'll show you two example here one is the arrow with a pointy head okay that's that could be a um consumption or uh consumption or production type link uh or a link with uh this little Lolli poop symbol uh this is known as an instrument link and so the difference there is that if an object is linked to a process using an arrow it means that something's happening to that object it's being created or destroyed or modified if an object is linked to a process using the lollipop symbol the instrument link it means that in order for that process to happen this object is needed it's an instrument but the object itself the instrument does not get modified in any way by the process but the process couldn't happen if that object did didn't exist did you do you see the difference and so one of the really I think important things about OPM but any of the languages is that every box every arrow every link has precise semantics and you know usually when we kind of doodle when we just think about we we put arrows and links between boxes we often don't really deeply think when I put a link in here what does that link actually mean what does link imply so when you do system modeling using these languages you become much much more precise yes please and would you push the mic button when you yeah Mark go ahead uh can an object be a process or a process be an object no so what about if you have um I guess I'm thinking in terms of like uh if you're there's some process for doing some procedure and like you're assembling a satellite or whatnot uh you need to modify that process so how is that sort of thing represented in the process modifies objects but processes cannot modify other processes because processes are fundamentally in OPM acting upon the objects now processes can invoke each other so is it if there's a sequence of processes you know you have to do this assembly step before this other assembly step you can have an what's called an invocation link but that's a logical dependency between processes but fundamentally the process act through the objects in OPN okay okay so um let let me let me be a little bit more so let's go into some more detail so at a high level uh when you look at the economy right products yes go ahead um I have a question why create another language and not just stick with uml um so good question um there's a couple so when uh we'll we'll talk about CML which is very similar tol it's sort of generalized for cyber physical systems not just software so the the the reason that OPM was created because uml was found to be somewhat too confining this is more General and also the idea of a unified representation one type of diagram and description for any application so it's it's basically a kind of a more General version ofl but but the the other really important thing about OPM is that objects and processes are sort of the processes are often in object oriented thinking OB processes are embedded inside objects and in OPM the the processes processes processes have been emancipated to stand at the same level as objects those are the main differences so um let me let me go in a little bit more detail so if you think about uh you know the economy uh in General goods and services uh goods are objects and services are processes okay so if you um if you buy a new um iPad right or a new U pencil or whatever it is you're actually buying an object right you're purchasing an object that's that's obvious but why are you purchasing that object so if let's say you you're buying uh a new tablet you're buying the tablet but what why are you buying the tablet Sam go ahead uh you're buying the tablet to perform an action or process on something else to do something so what do tablets do I mean not stone tablets but modern tablets um they allow you to work with software or communicate yeah so they're information right processing they're they're information processing devices and you know there's an argument our T tablets are great for consuming information they're maybe not as good for generating new information but uh so it's it's fundamentally you're purchasing the tablet which is a good an object in in order to be able to do information processing and information consumption so the process is then implicit right um what's an example if you purchase a service what would be an example of a service what would be an example of a service uh let's see at epfl what what be an example of a service that you could purchase going to the dentist going to the dentist yeah one of our favorite one of our favorite things to do so have you been there recently or yeah one month ago so uh I don't want to be uh you know I don't want to violate your privacy but can you share with us what happened at the dentist um usually it's the yearly checkup you know you have to um uh check that there's no hidden I don't know how do you call that in English the carries yeah cavities yeah yeah cavities uh check that uh wisdom too don't mess up what you've been working on tirelessly when you were younger with braces and um yeah so PL also these kind of things get checked very good so so the the the going to the dent the dentist provides a service which is either checking your teeth or you know filling cavities which is a process and all the objects the chair on which you sit the instruments you know the uh I guess we still use gold sometimes in some places right those are those are objects that are used in the performance of the service you you see the you see the relationship so uh objects and processes always come in pairs thank you for that example so um let me talk about the links in OPM briefly so there are two types there's the structural links which link objects to objects and we typically use arrows you know is related to or we can tag these as well so for example something Powers something else this is known as a tagged link it suppresses the processes and then there's these triang Les that are uh essentially there's a kind of hierarchy implied there and slightly different meanings so the solid triangle means decomposition so the higher level object is composed of lower level objects okay so that's Mark you mentioned assembly you know you're creating uh the bus of the spacecraft and it has a whole bunch of stuff in it well you would use this this filled in Triangle to show that decomposition the second example is the characterization link so uh this is essentially relating an attribute to its kind of Master object specialization and generalization is the empty triangle and then this this funny symbol here is instantiation so uh essentially the the you have a you have a general object and then you can instantiate that so I have two children okay and then there's two I have two children which is general and uh there's two instantiations of of them one of them is called Gabrielle and one of them is called Christian and they're actual people so that's that's the idea of instantiation processes um processes are uh these patterns of transformation they're tricky that processes are are trickier to understand than the objects because we cannot hold or touch a process it's fleeting uh and the creation change or destruction of objects is what processes do um they rely on at least one object object in what we call the pre-processed set a process transforms at least one object and uh the time is implied so processes Take Along a timeline and in terms of the description in English we use the so-called Geren form so all the all the processes there's some examples on the right side use the ing form of a verb so um we can then put these together objects and processes so here's an example Le of a machine this is happens to be like a printer or copy machine it has a main switch the main switch has an attribute called main switch state which can be on or off um the process of switching transforms in this case the main switch state from on to off or we could go the other way and in order for this to happen we have here um this is actually a slightly different than the instrument link this is a filled-in lollipop which which is known as an agent link so the operator is an active agent to carry out the switching process which changes the main switch state from on to off or off to on and the main switch state is an attribute of the main switch right so transporting this is another example transporting changes the state of a person from being here location a to being there location B okay so um there are seven huh coincidence huh seven uh seven uh object process links in OPM so P changes uh the process changes the object say from State A to B that's the example we just looked at um you can actually hide that if you're really not interested in all the states and details you hide the States you don't want to see them and then you can replace that with What's called the aect tlink which is this two-sided arrow and all you know is that this process is affecting that object right and it's a two-sided Arrow but you you don't know exactly how but you know it's affected uh a result T link so this is an arrow pointing from the process to the object means that the process of transporting produces emissions right that weren't there before so that's a result tlink but the process of transporting requires or consumes energy so the arrow is pointing from energy into the transporting process because it's being consumed uh I did mention the agent link so there's an operator of a vehicle and this you know when when we talk about uh autonomously driving Vehicles big topic right now actually it was cool at epfl this summer there's the the autonomous shuttle right on the campus the electric shuttle did anybody take that did you guys try that shuttle this summer yeah yeah did you like it no I didn't but a friend is working in this kind of shuttle like um sitting for hours waiting for people actually okay so fundamentally uh I mean if you want to think of this in OPM language uh driverless vehicle is basically eliminating this right no longer needing an operator with an agent link and replacing this with a piece of software which would be uh an instrument link um so the instrument the the transporting process requires a vehicle and then uh we have what's known as a conditional link so this process can only occur if this object is in that particular state so this example here obviously ignores the existence of uh credit cards so uh you can do the purchasing purchasing the process of purchasing is conditional upon the uh state of the object money being being in in a state of enough for doing the purchase right okay so here's an example of a little bit more complicated this is a level zero OPM diagram of a car of a vehicle so you can see in the upper right is sort of a a sketch uh of a vehicle and it has these different attributes uh Ed is engine displacement height ground clearance uh overall length wheelbase there's a trailer here with the towing capacity so the way the way you would U interpret this is that we have a transporting process that's our Master sort of the highest level process and it changes the attribute location for driver passengers and cargo from A to B right and that's fundamentally where the value is for the for the owner of the vehicle and then we can zoom into the transporting process and look at subprocesses Towing propelling and housing and if you think about what a vehicle does at the highest level right it protects you it it houses you and it propels you right that those are and then you can break those into more detail and then on the left side here we have essentially uh the the elements of form so the automobile which is an instrument of the transporting process can be decomposed into its major subsystems powertrain Chassy body wheels and each of those are characterized you see those attribute links characterized ized by things like um uh fuel capacity engine displacement this is the design domain we talked about last time right ground clearance and so those are the design variables those are the parts and assemblies and then on the right side the processes the internal processes can also be characterized by uh performance or functional attributes like towing capacity fuel economy acceleration uh PV stands for uh passenger volume and cargo volume and those are things you you know when you're comparing different vehicles to purchase you know those are the things you would you would compare Vehicles against so there the internal functions and then the functional attributes and then up here there's there's the uh Fuel and emissions and safety related issues which that's often where the governments intervene and then regulate and you know this is sort of a highest level OPM of a of a vehicle and then if you want to see more detail you would start drilling down into these and you'd have multiple levels of these like a hierarchy of these diagrams yeah um so here what is the the use of the or the meaning of the open arrows in the it looks like there's a couple different arrows here than what we had in the other diagram um are you talking about these guys no oh these these here yeah so they're they're um it's just a visual repres There's no distinction on the arrows whether they're filled in or or empty that's that's just a a kind of graphical thing yeah okay so one of the um yes Veronica do you want to push push the Buton um how would you represent uh a process that creates kind of a temporary State um so if you were if you're saying this is acted on an object and this changes the form of the object but the object will ultimately return to its original state kind of absent of a of a reversing process if it's a natural tendency for the object to return um how would you represent that change would you need to break it down as a kind of a a subprocess within the object or right so I mean and and this there's sometimes there's multiple is there's non-uniqueness in sort of representing the same thing but there's one process that brings you to the temporary State okay and then there would be a restoring process that restores you back to the original state does the process have to be uh a separate plan within the system because there there are certain objects right that have a tendency I'm thinking primarily kind of of chemical states where reactions would happen naturally um and it's kind of a specific thing but I was thinking about how you might model different systems and I was thinking about the engine of the car just kind of how things might naturally return so do you have to describe the process explicitly if it's not something that um not something that's inherently designed in if it's kind of a if it will happen anyway um I think I would I want to say you have to explicitly Define that so if it if it's a man-made process so to speak uh then you know that's a process you want to happen and then if the restoring it back to some other state is a natural process well it exists right so it it will restore the system to a prior state that process would also have to be modeled is there a distinction between how you would indicate a man-made process or a natural process not fundamentally okay and in fact uh opm's been applied to modeling how a cell function so there's some pretty recent work on you know cells are incredibly the biological engineering is just really complex so some really recent work on describing even you know the RNA and cell division using very much this language okay so it it doesn't matter whether it's an artificial process or a natural process thank you okay let let me go a couple more minutes and then we'll take a short break and then we'll talk about uh sisl and and modelica so um the key thing in OPM is there's only one type of diagram and there's also natural language that gets autogenerated and I'll show you this very quickly in the tool so as you can imagine as you're working on real systems you know these diagrams if You' showed them on one one sort of level you you'd have thousands of objects and links it would be a mess right so how does OPM handle complexity there's three fundamental mechanisms one is known as folding and unfolding what does that mean it's basically um related to the structure so folding unfolding means that higher level objects you can show the decomposition of the object objects or you can hide it that's known as folding and unfolding then the second one is called zoom in zooming or out zooming and so here's an example of a uh here's a process and an instrument and an affect right that's affected by the process I want to know what's what's what are the subprocesses in that process so you can zoom into this process and it will expose the subprocesses that are happening inside that's known as in zooming and then going back the other way is called out zooming and then the third one I've already mentioned which is that States can be expressed or suppressed or hidden uh depending on your interest in what states of the system you want to look at um so here's the sort of level zero OPM of our refrigerator I said that was kind of our case study so how does a refrigerator work at you know at the sort of level zero is you know that's what the stakeholder what the customer sees don't care about the details of What's Happen happening in the refrigerator so we have food and uh we'll get back to this I think next week in the kind of creativity uh concept generation why do we have refrigerators fundamentally if youve you've heard this before you keep quiet uh maybe epfl why why do we have refrigerators any ideas go ahead keep food cold yeah well that's uh if you're a Beer Drinker right you want cold beer right but uh if you really think about it deeply that's not really the primary reason right the primary reason is is this state change there shelf life right so the primary reason why you have refrigerators is to extend the shelf life of the food right so speaking as a systems architect system engineer a refrigerator is a food spoilage rate reduction device you see that so so the attribute of the food is the shelf life and we're going to extend the shelf life of the food that is you know if you think about it sort of architecturally that's why we have refrigerators but but I agree with you on on on the cold beer right we all agree we want cold beer not warm beer so you're right you're right too um so the refrigerator essentially is in instrument of extending the food shelf life so the food is the operand the food is the operand the extending of shelf life is what we call the primary value delivering process that's where the value is the refrigerator itself is the product system and then the operator sets you know the thermostat setting at which temperature the refrigerator should be and then here we have the primary operating process which is uh what what allows us to keep the temperature of the food at that level and in order to do this we consume electrical power we produce waste heat and we also uh require or we conve that waste heat to the exterior air right at a certain temperature how well do refrigerators work in a vacuum chamber they don't right they don't there's no way to well I guess you could radiate the heat a little bit but uh that not going to work very well you're not going to have conduction right because you're sort of in the middle of the vacuum chamber you're not going to have convection so you only have radiation and and it's not going to work very well so the exterior air is is important for the refrigerator to work so then you say well okay that that's fine I buy that but now I want to really know how does it really work so you say operating the refrigerator is operating but I want to do in zooming and understand how is it operating so what's the key to Refrigeration what's the magic word there or two magic words uh yep that's part of it that's just a a sliver of it heat exchange is part of it so the magic word is caros cycle right so here's a little graphic that sort of gets into it so the caros cycle is actually uh a thermodynamic concept right where you're your you're compressing essentially a uh a refrigerant your a coolant is being compressed absorbs the heat from the inside and then expands and condenses and radiates that or or conve that heat to the outside so here's a you know I don't know if you remember your thermodynamics right this is a classic PV diagram you got the four legs of the caral cycle and actually what's really nice here so we we're going through this counterclockwise what's really nice about it is that every leg of the caral cycle is one of our processes right so compressing is this leg here from D to B condensing is from B to a expanding from a to e and then evaporation happens from E to D so the carnal cycle um can be decomposed into four subprocesses right these are the internal Pro internal processes in the system that are governed by physics so so if we take that operating process that we looked at before we can actually zoom in and see the subprocesses emerging um and so we have in cooling we have those four expanding evaporating compressing condensing but I'm adding the absorbing process which is that the heat then needs to be absorbed by the uh exterior air we have to power the device you can decompose that into grounding protecting supplying regulation right keeping it at the set point you can compose that that process into sensing switching and setting the the set point and then we have supporting which is we need to be open and closing closing the refrigerator retaining it and then connecting all the pieces so at level minus one you know we had one process at level zero which was operating right the refrigerator is operating and then as we zoom in to level minus one four processes appear powering regulating Cooling and supporting and then at level minus two we have 15 subprocesses okay so this is a a sort of a a view at level minus one you know our our four subprocesses cooling powering regulating supporting and then we can zoom in more okay so here's the general idea and we've looked at many systems over the years that most cyber physical systems or uh it says opto mechanical here but I I really mean it more generally have this kind of OPM structure on the right side we have you know the output that the the customer the stakeholder cares about the operand we have a set of specialized processes and these can be often organized in a Cascade and then we have supporting processes like powering connecting controlling that uh that provide support for the specialized processes M most systems that we've seen have this generic architecture um how do you generate an OPM fundamentally you can do a top down so you start with your stakeholders that's what we did in the first lecture you know where's the value uh you start thinking about requirements what is this what functions how well the functions should be performed and you sort of go down or if you already have a system you can actually reverse engineer that system and from bottom up uh gen like we we started doing for the Mr Sticky and that's fundamentally reverse engineering so I'm um just for time I'm going to skip this uh demo but what I will do is I will post a video I'm going to make a little video with the opcat demo and post that to Stellar so you can sort of watch that uh so this is one of the it's it's it's still not super mature but it's a Java based program called opcat that allows you to uh generate object process diagrams in uh you know in a computer supported environment and store them in an XML format and so forth it allows you to create a hierarchy and the other thing that's very cool it autogenerator language and you can right now you can go from the graphics to the text but you can't go the other way and you you can see they're complete sentences you know it's not like you know an exciting novel when you read it but it is semantically precise so um we're going to switch to CML we're going to take a very short break are there any any questions about OPM you know in the system architecture class we spend like five six lectures on OPM and you get to do detailed exercises we kind of don't have time for this in this class but hopefully you've you've seen what it is and if you know I've wetted your appetite for OPM then uh the goal's been met any any questions about OPM is it pretty clear all right so let's take uh yes and compared to uh modelica I've seen one of the links there this uh OPM is just for describing the system though it's not for making calculations or simulations that's correct there there are the latest versions of OPM you can do like a logical simulation so you can say okay this process enables and does this St so it's kind of a discrete logical but usually it's not used for any uh mathematical calculations it's really uh the purpose of OPM is really to support conceptual design early conceptual design that's correct okay uh Mark so I just a couple words about Mark uh he's a doctoral student right now in the Space Systems lab he's been working a lot uh on a um on an instrument called rexus I guess you're the chief system engineer right for rexus yeah and uh that was also the topic of his master's thesis so uh Mark really knows what he's talking about he knows CML quite well and thanks for doing this okay so let me let me start by giving kind of a high level overview of what CML is and what it aims to do so it's similar to OPM but there are a couple uh important differences um CML as always said uh it kind of is an extension or inherits a lot froml uh and its aim is to really provide a language that enables you to capture all the different aspects of uh information about a system in one place and this concept of single source of Truth is something that I'll kind of try and emphasize throughout my presentation the idea is if all your information is in this one model then communication is easy uh there's no ambiguity between versions um everyone knows where to go to get the most up-to-date and correct um piece of information so that's one of the the emphases of csml csml is a graphical language similar to OPM um it's defined in terms of diagram types that I'll go into in a second and has more than just one diagram type as compared to OPM um but basically it aims to do things like capture functional behavioral models uh capture performance models capture the structural topology of your system the parts of your system and how they're all interconnected um and any other engineering analysis model is one of the big emphases emphases with cstl is integration with external analysis tools so if you have a thermal tool a structural tool Electronics tool something like that integrating this informational descriptional model with that analysis model and enabling uh making it easy to transformation from transfer information from your descriptive model to your analysis model do an analysis and then incorporate those results back into your descriptive model um is one of the the um things that cstl really is all about then another thing another difference compared to cstl from OPM is it incorporates requirements pretty explicitly and that's one of the other areas that um people are really interested in is if you have good modeling of requirements what sort of information can you glean about your system that you couldn't otherwise how do I Advance this slide oh there we go okay so um as I said system L is composed of diagrams I'll go into in a second kind of what each diagram what all the diagram types are and what kind of their intent is but here's kind of a high level overview um it might be a little bit difficult to read so at the top you have a system model you have requirements diagrams Behavior structure and parametrics um within requirements there's actually a specific requirements diagram that's um supposed to represent the relationship between requirements and your system I'll show you an example of that um in Behavior there are um diagrams that describe kind of the activity of your system the sequence of events that that may happen um there's a state machine diagram if you want to model your system as a States and transition between those States uh things like that in the structure there's uh diagrams that go over the decomposition of your system what is your system and what what parts make up your system both The Logical decomposition and the physical decomposition um and then there's uh topology how are they all connected where the interfaces uh where are the characteristics of the interfaces things like that and then parametrics um which is kind of adding uh constraints and numbers to all these things um whether they be logical constraints mathematical constraints things like that similar to OPM cstl has no built-in analysis capability so you can't like run a model or or do a calculate an equation in system you can't really do that but very frequently the tools the the tools that Implement system that I'll show you um have that kind of analysis capability built into the tool as opposed to the language so you can do things like um use a nric use a parametric diagram with a bunch of equations to create a system of equations that you then can solve um whether it be in the tool or you can move it to an external tool like Mathematica or something solve it and then bring that information back into your system um you also can do kind of um uh sequence-based computation if you have a activity diagram that says you know first you have to build this part of your system and then this part of your system there's things in sequence things in parallel you can run simulations like that um where it's all about you know have have you done everything you need to do to get to the next step um things in a more logical flow as opposed to actually mathematical equations you can do those sorts of computations as well um one note is that these diagrams although they are the main way to define your system and interface with the model um are not the model themselves uh so you can create links between diagrams if if an element shows up in one diagram and that element shows up in the same in in another diagram that's the same element if you make changes in one diagram that's going to propagate to all your diagrams so there's kind of a database back into this whole to the model that uh encompasses all the information so instead of having a bunch of isolated block diagrams there really just views into this model that's hidden in a backend database okay so I'll talk a little bit about the applications of zml um first is requirements engineering as I said when you can explicitly model requirements and the relationship between requirements and your system you can do a lot more you know the way that it's typically done nowadays is with tons of documents I'm not sure if you've ever actually developed a system but there's an ungodly amount of documents um I've experienced that firsthand uh it's a real pain um there are tools like doors that will enable you to link requirements to other requirements and things like that that help that help you manage your requirements but what if you had a really explicit tie between your requirements and your system you can actually represent in syml and I'll show you a little bit about this you can represent Syl a textural requirement you know the mass of your system must be less than 5 kilg or something like that you can tie that requirement directly to the mass property of your system you can kind of division you can start building constraints um requirements don't aren't just textual statements they're actually constraints upon properties of your system those are the types of things you can start to do um with syml you have a question yeah yeah so that isn't something that's built into the language but that is something you can do with um basically there's a whole uh API um and you can you can interface with the model I'll show you this actually in My Demo but you can build in rules and constraints that say check for example that all my requirements at least have they've been defined are satisfied you can run that check and it'll tell you have they been satisfied or not and that's something that's really powerful that you can't really do with um existing kind of techniques yeah thank you um and can you also like let's for example requirement changes um like the mass Ser system has to be this much as opposed to this much then would it go through and check and tell you have to now look at this this and this and then that effect like so you're getting you're getting you're getting down in the weeds that's something that'd be awesome if you could do right um that really again that's not something that cstl enables you to do natively but it gives you the language in the syntax to be able to write queries that give you that type of information that's kind of Where The Cutting Edge is right now is can we do that can we get that type of information from a Syl model that's something I'm really interested in for my PhD thesis so yeah that's something that I think is possible and would be really great to have in the development process of a system um so the next bullet here is on system description so actually one of the fundamental questions is how do you describe a domain specific system within CML I'll show you that CML has a pretty strong notion of inheritance and classes and things like that it's object oriented um and so one of the questions is uh I'm in space system so how do you describe a spacecraft in CML you know CML is very general but how do you actually represent uh for example a CDH system in CML you know what are the types of um uh attributes that are typically found how do you represent that um how does it interface with other parts of your system those type of questions that's another area active area of research domain specific modeling and then finally as I said um analysis integration with external analysis tools so there's quite a lot of lit of papers in the literature about going from a system a model to mat lab to SDK to Thermal desktop you know external modeling tools um taking that information out of the model doing an analysis putting it back in the model um and actually uh I think n is going to talk about simscape which is a kind of um analysis tool external analysis tool and there's actually been Papers written on how do you take system information from a system L model pull it into simscape process it and put it back in the model okay so let's talk about the diagram um there are nine types of diagrams in CML and I'll try and just give you a brief explanation of what they do I won't go into the Syntax for all of them because there's quite a bit of detail in the syntax but I'll show you um some examples of a couple of them so I'll go from left to right so um there's three there's two main classes behavior and structure similar to OPM um in the behavior diagram you have uh in the behavior diagram category you have activity diagrams which are basically represent flows of activities so you do this then you do this then you do this um those can be t to system elements if this system element has this sort of function or property or performs this operation on another part of system you can represent that link as well um there's a sequence diagram which uh is more about um logical ordering so if you have for example a multi-threaded software system and you have different threads that may need different different other threads to communicate with them or finish their computation before that thread can execute things like that you can do that sort of um interfacing between different um uh threads of activities uh in in a sequence diagram this is one of the diagram types that was um kind of inherited directly from uml as a very kind of strong um software element to that diagram um there's a state machine diagram so obviously State machines are very powerful if your system has various States if things in your system are various States you can represent that in a state machine diagram and then talk about what are the what are the criteria for transitioning between states what would trigger a Cause transition between states what are guards that must be met before you can transition States things like that that's what we' represent in a state machine diagram um these type of diagrams are very powerful for describing things like concept of operations so there's been some work uh I did an internship at JPL a couple summers ago and they were trying to build up this capability to model concept of operations for a spacecraft so um what are all the power modes of everything what what are the time you know it spends this amount of time in this power mode then it transitions here um over for for example like a given orbit of a spacecraft that's sort of the thing that you can do with this set of behavior diagrams and then use case analysis again it's mostly focused on early concept development stakeholders how do they interface with the system where do they derive value um how does the user interact with the system things like that that's where you put in the use case diagram um going over to structure the uh block definition diagram is where you define the uh the structure of your system so the logical or physical decomposition I'll show you an example of this so have your system is a spacecraft it has uh various subsystems if you want to decompose it logically has a thermal subsystem a structur subsystem ADC adcs subsystem things like that you can also decompose it physically so your spacecraft has solar arrays it has instruments it has thrusters things like that you can represent those types of things in a block definition diagram and then internal block diagram is where you describe the ties with the interfaces between all the components of your system um and these can be at varying different levels of abstraction as I'll show you uh the parametric diagram is kind of a sub diagram type of the internal block diagram so you can again put constraints mathematical logical things like that on your interfaces and begin to build up uh the infrastructure for doing computation in the model and then a packaging diagram is um not terribly important it's really focused on the organization of your model how do you Scope things it's kind of a a modeling diagram as opposed to a representation of your system then last of all is a requirements diagram up top so again I'll show you a good example of this but that's where you represent how are your requirements related to your system um and then you can see here what's been modified and what's been taken from um uml and then the new diagram types of requirement and parametric there were a couple diagram types that were eliminated from uml that were pretty uh software specific I think there is one called the deployment diagram like how has your software been deployed across various um servers or or users things like that that's not really um that's a pretty software specific thing so in a general system you might not care about that all that much that diagram was um removed so let me quickly go over um some of the syntax so this is an interface block diagram an IBD um this is the type of diagram that I find is really interesting representing these um these uh interfaces so here's the system engineering ontology we typically talk about so these are this is basically a model of an avionics board so you have things like voltage converters you have memory volatile nonvolatile we have a fpga which is our main computational unit um we talk about these as being parts of a system in terms of a system engineering on to and then these are these interfaces these lines right here so in system the way we talk about it is these are part properties of the system um it's kind of like an instantiation type of thing what we're saying is all these parts can represent independent of each other and then the you define a property of that part as being part of a different part if that makes any sense at all so for example this is a board right this main Electronics board is this whole block and then that has subblocks within this block which represent the sub parts that make up the board and these are called part properties of this um overall block we have these green little boxes which are called ports and again that's to support this kind of um system independent modeling so you can you can model like a voltage converter independent of any type of system it has maybe an input voltage and output voltage you can Define what ranges those are things like that and you can model those interfaces using ports and then these uh connectors which are called connectors in cstl which represent the interfaces uh represent how each part is tied into the kind of larger system and you could for example check that you don't have any empty ports you know if a part needs uh an input voltage you could run a a script that checks that all the parts have all their ports kind of satisfied um that's something you can do with syml okay so before I get into the case study I want to talk a little bit about what you're going to see um as always said I work on something called rexus which is the regul X-ray Imaging spectrometer it's an x-ray spectrometer that's flying on nasos asir Rex asteroid sampler return Mission um I've been working on it since 2011 when I was a senior here all throughout my masters and then now for my PhD um basically we're going to measure x-rays that are fluores from the asteroid surface in order to tell what the elemental composition of the asteroid is so that's our main science goal uh and that will basically enable us to uh categorize where the asteroid is within the different meteorite types that have been defined on the ground based upon existing meteorite samples so um what I did from a m thesis was uh model the design history of rexus so how has our design evolved from the various the very beginning where it was very uh open-ended very abstract and you'll see this um to the uh current design which current in this case was CDR which was uh over a year ago now um right now the current state of Reus is we're almost ready to mounted the spacecraft so it's very exciting um just to give you an idea of a timeline um this is something I'm sure Olie will talk talk about in this course is the flow through the system development life cycle so we have system requirements review back in January of 2012 system I think it's definition review uh April 2012 preliminary design review January of 2013 and then critical design review February of 2014 so I created models at each of these design points in csml and looked at what are the lessons we could have learned um we didn't use csml in rexus I was kind of looking back historically what if we had used it could we have designed our system better in any sort of way so um here is kind of a cad representation of how our design evolved and I think you can kind of get the idea back at srr we a lot of things we didn't really know what they would look like we didn't know what the interfaces would be we didn't know what all the parts would be um we had a little more development for SDR you can see there's more arrows uh the cad is a little bit more detailed the PDR um we had even more detail um this was actually like a buildable design this turned out to not even be buildable and then um we had more Evolution between PDR and CDR to get to pretty much what a design is there's actually been some Evolution after this as well um as sometimes happens with with a new system um but you can see just graphically kind of the increase in level of detail and level of fidelity of the state of our system um throughout its development cycle and I'll show you that and how that looks um in the cstl model as well so one of the things you can do if you have a cstl model is as I talked about you can run queries on it and pl out information that's very difficult or impossible to get with our current development practices so this uh this is just uh looking at the different subassemblies within rexus what are the number of parts in each of the subassemblies so you can see the general trend is up for all of them as you would expect um some jump up very high um some kind of stay basically where they were but in general they all increase and this is something you might be able to do with um looking at like a parts list or something like that with current methodologies but it'd be very hard to get this information which is the number of ports per assembly so each interface has two ports so these numbers divided by two basically equal the number of interfaces that we have in each subassembly you can see again there's a general trend of increasing uh increasing number of ports um as you go through the life cycle so this is you know a piece of information you might want to use if you want to manage the complexity of your system and you say this sub assembly is getting you know has way too many interfaces way too many parts it's way too complex we need to think about how we've logically arranged our system and maybe how how can we rearrange it to make it more understandable and easier to work with and then you can divide the two and you end up looking at how many um this is ports per part in each subassembly uh at each of the design reviews and you can see uh Trends here too which are interesting so you can see in the beginning we didn't really know what we were doing some of these had a lot of parts ports per part some of these had very few they all ended up stabilizing um kind of between the three and five ports per part range and then you can look at the literature and say well typically systems um tend to be between five and six ports per part um so what does that mean does that mean that our system that I didn't model it correctly that's one possibility I didn't model to the lowest level of fidelity possible um it doesn't mean that our system is too simple does it mean that we're missing something that we haven't thought about does it mean that our system uh was which was intended to be simple and cheap and implementable by students is actually achieving that goal because it's beneath what you typically expect um those are the type of questions you can ask with this data but this data is not easy to get with the current methodologies um so this kind of uh very simple queries you can do gives you power on managing complexity in your system so let me now transition quickly to the demo uh let's see there's no sound I know but I need to syn it up and I need sound so you can close this so while uh while Mark is setting up for the demo are there any any questions about CML so far any observations you guys have maybe at epfl you see the similarities and differences between OPM and CML what's what's the biggest difference between the two there's two really important differences no questions yes hang hang on is there anybody at epfl who wants to to comment on this no there's not comment from epfl okay good that's fine that's fine marker you set up almost the the what I would say is um so first of all OPM has only one type of diagram right and then you go really deep sort of a deep hierarchy uh CML has nine different types of diagrams split between behavioral and structural that that's one difference and then the other is that CML is fundamentally objectoriented because it comes from objectoriented thinking and software whereas OPM has objects and processes sort of at the same level those are those are two of the most important differences okay all right um so what I'm showing you can everyone see the screen just let me know if you can't see the screen um what I'm showing you right now is a tool called Magic draw um there are basically a variety of tools provided by commercial vendors that enable you to build and work with CML models so CML is a language and then it's implemented in tools and this just happens to be one that's um fairly well fairly widely utilized um unfortunately it's quite expensive but uh anyway so what I'm showing you right now and this is going to be a little bit difficult because as you can see uh you need a big screen uh what I'm showing you right now is a requirements diagram so you can see that right here requirements diagram um and uh each of these blocks as you can see by the um tag here is a requirement so this is one of our operating criteria so while operating the temperature of all our components shall be maintained within operability limits straightforward requirement uh and you can create these satisfy relationships between that requirement and the components in the system that must satisfy that requirement um so right now this is this is being done at srr as you can see up here so this is very early in the design um so we we don't have a we don't have it broken down fully to all the components but we have here's our main Electronics board it has to satisfy that requirement here's our radiation cover has to satisfy that requirement so you can tie these these two things the requirement and the part of the system must satisfy the requirement and here I've tied it to Parts um so these are these are called blocks which are the fundamental unit in cstl is a block um so these represent parts of our system but you could tie it to a property of that part if you wanted to um so then you get into the situation I talked about earlier where you have the requirement is on the mass of must be less than this you can tie it to the mass of the system itself as opposed to the system you can tie it to the actual property um which is very useful so um let me quickly show you uh one of the cool things if I delete these requirements I'm not actually you can see there's no requirements I'm not actually deleting them from the system itself what I'm just doing is I'm removing it from the diagram um but if you wanted to uh you should be able to uh look at related elements of this of the different block so I just clicked on a block and I can I can choose to show all the requirements that are sat or the the things that are satisfied the requirements that that component of the system satisfies and they pop uh these requirements pop up so this this is showing how the the the diagrams themselves aren't the model there's actually back end to the model um and you can kind of work in the diagram and show her show her high things however you want but the information is actually kept um uh behind the diagram um so to speak so my research um looked into into topology so let me just kind of show you a little bit about um what I did so this is a block definition diagram again defining all the parts of your system and I just want to give you kind of a high level idea of uh the type of things um that we saw so it's uh big first of all very big um these are all the parts of the system so we start hide like the mission context and the mission context contain things like the environment and the spacecraft and then rexus and then you can break down rexus we have B various subassemblies broken down into parts and that's how you get this tree structure um and then this tree structure can be tied together um I could zoom in but it's it's big again so these are all the parts of our system um let me give you an example so um we have a couple of boards that we call our detector electronics and those detector Electronics have various ports um one thing they have to do they have this port here and this interface here which connects to our ccds so this is this is um showing how you can build interfaces um in syml so here the green boxes again are the ports the lines are the connectors and they're defining all the interfaces and you can see at a at a high level um how complicated things get very quick right this is the earliest most abstract version of our design and it already has a lot of complication one thing you can do I talked about running scripts uh I'll show you how that works it's quite easy so I just ran a script on the model that told me to find the number of parts in uh in the scope that I defined and the number of ports um and here's the output of that model right here so so the the script itself is not even very complicated it's like 50 60 lines of code and immediately I can pull out you know how many ports how many parts things like that information about my system so let me kind of take you briefly through the development process so that was again the highest the most abstract the earliest version of our system srr this is SDR you can see it's starting to get a bit more uh complex and then uh you can go over to PDR and it starts to get really scary right and you can go to CDR and it's just a nightmare um so I I created all these systems all these models by hand uh you can actually build the model with the script um if you would like um uh you can basically do things like Define a pattern and then apply that pattern to all the parts of that type that's all possible um through the API and just to show you how much of a nightmare it was at CDR let me run the same script uh on the CDR model we have 230 parts and 900 interfaces and this was not even modeling to the lowest level of fidelity possible I didn't for example model all the components all the capacitors resistors off amps and stuff on the board um and now you can already see it's it's quite large so this is just um kind of the idea uh Behind these these models would be to extend this to the lowest level in a real system um and use this basically use all the capabilities that you have with the model to really manage your complexity in a way that is just not possible currently and there's no way you can really mentally uh keep track of all these interfaces and understand how your system is working so having this modeling capability and querying capability is really really powerful yeah what was used during rexus uh for the systems engineering as you had applied this this after the fact what what was used to create these block diagrams or um TOA things doing do you mean during when we were developing rexus um we basically didn't have this so we didn't we were relying as you would typically do upon you know the capabilities of the system engineer or the team you'd have documents we have a ton of documents um but I was talking about how things weren't buildable I found a situation where um because of the way we had done our thermal system we were dumping spacecraft heat to space which you don't want to do I could explain why but you don't want to do that um and that's something we didn't realize at the time like if we had tried to build it you would would have had this Pro property of the system that we didn't know actually existed until I went back and looked at the model so um we definitely miss things and this should have improved the design process if we had been using it so Mark what sort of to wrap up because we got to switch over to modelica what's your recommendation for you know let's say um students in the class got sort of intrigued by csml you know what's the next step um there's a couple different ways certainly if you're interested let me know and I can give you resources um to to kind of further your understanding uh as I said working with these tools can can be expensive to get these tools um so I can help you understand what that would take um uh there is uh there are some beginning to be some uh uh companies that will do like CML training courses um that will sit down for a day or a week and teach you kind of CML basically how to work with the model how to build the model um I took one of those courses it was really great uh so I would yeah talk to me if you're interested and I can kind of steer you down the right path great thanks Mark sure very good um so we did in 20 minutes what usually take about a week right there's a lot more depth there's a lot more dep great so we're going to we're going to switch over now to uh modelica which um I think is we're going to maybe run a couple minutes over today but I think it's important we cover all three languages um so let's get uh the slides back up and I'm going to switch here to naric uh he's another doctoral student in the group and um so introduce yourself and then tell us about modelica great you you using your Compu for the demo I'm onek you so hello everyone my name is NK I'm a doctoral student at aeroastro here uh my background is in gas turban engines and specifically I've been been looking at concept generation of gas turban engines automated concept generation and the way I got acquainted with modelica was that I needed to be able to rapidly reconfigure different concepts and simulate them uh mathematically do physics based simulations so in contrast to the first two languages medel is a lot more about rapidly being able to build physical models of systems and reconfiguring them and reusing them for later on so so like I mentioned modelica is primarily about modeling physics based modeling of systems and rapidly being able to reuse models and reconfigure them um it's a language again it's not a tool like the first two uh that that you heard about there are many different tools which implement this language but I'm going to start off with just describing how the how the language works and then go on to describe which tools that you can use in contrast to CML there are a couple of really good free tools that you can use and rapidly get into and there are a lot of library um that you can use with hundreds of even thousands of actually basic components that you can use for modeling so it's a declarative language and what what I mean by declarative is that you don't in in normal in in in sequential sort of programming you you write commands and you make assignments to various parameters here you just describe the governing equations of the components you you want to simulate and there's no particular order in which you do this the the models are a causal there's no direction to flow all you really need to do is describe what ports like uh Mark mentioned it's similar in this situation what kind of ports you have what kind of interfaces the components can have with other components and the governing equations and the parameters and variables um it's a multi-domain modeling language so it's agnostic to what kind of domain you're working in it's not particular to electrical engineering for example I'm going to be showing an electrical engineering example and also show a gas turban engine example with Aero elastic vibrations so you don't necessarily you're not attached to any specific domain it's also object orientated and it enables you to uh decompose systems into into subsystems or recombine them uh and look at them at various layers of abstraction it's designed to be efficient um so this is a quote from Professor Peter fritzen at linkoping University um so these are just about the sort of scale of problems that you can solve with with the with the medallic language obviously it depends on what kind of equations you're talking about but but um it's it's designed to be a very efficient way of simulating uh simulating systems so I really want to talk a little bit more about this idea of acausal modeling that I mentioned before so on the left hand side is an assignment and that's typically what you do when you program in mat lab uh just the mat lab normal scripts f is assigned to ma or p is assign the value of RT for the equation of state of a gas and what that means is that you know what the mass and acceleration are and you figure out the force and you assign that value to the force in modelica there's almost none of this it's equations not assignments and what I mean by that is this equation can be written in any which way as long as your system has the same number of equations as unknowns the the tool that you're using will interpret the language and will solve your problem so you can write this in any which way you want in any order as long as your problem is properly constrained the tool that you're using will interpret it and solve it problem for you so just to go into a little bit more detail um all of modelas and also other a causal modeling language that I'll mention in a little bit which is one of them is simscape um H models have essentially three parts they're designed to be extremely simple um the first like Mark mentioned is the are ports it's essentially identical in in to to to csml in a way ports are the ways that with which components can share information material or or energy for example you can Define any kind of Port you want all you need to really do is Define what kind of parameters it carries like for gas for example temperature pressure and mass flow or for electrical ports voltage and current um the second part of any kind of model that you're building in modelica or any or simscape which I'll mention a little later are variables and parameters so you just declare those and the third part are governing equations the point is that there's nothing else it's just that and I'll just go through a briefly go through a simple very very simple example so for example a capacitor um at this is the entire code for a capacitor and this is what will generate u a visual image of a capacitor with the correct ports for you first you have pins that carry voltage and current so the key thing to notice here is that there are fundamentally two types of variables flow variables and normal variables here uh flow variables are ones to which the kof's current law applies so mass flow for example every time you connect 15 components together in a network mass flow into that Network needs to be conserved so the sum of mass flows into any any node has to be zero uh that doesn't apply to uh the the the standard variables just um so you then you essentially Define the the parameters the variables and you need to uh Define the governing equations and that's that's the capacitor for you there are slightly more complicated components that you can use for example a pressure drop component did I lose my sharing no um in this case the interesting thing is the main thing to take away from this one is that if you have complicated mathematics describing the fluid mechanics in a component you can actually initialize with one model and then go to a full turbulent simulation that's what this is doing here so just to um get to the tool side of the equation the language I just showed you it's the same across all the tools but there are many different tools which you can use free and Commercial to actually run these models um the main one that you'll be using if you want to get deeper into this is open modelica it's free it's actually become quite user friendly and um and uh it's uh there's a link in the in the slides with from which you can download it um there's one from vram it's integrated with uh with um Mathematica which is quite useful and there's a free trial of it as well there's daa there are other ones but mainly I think open modelica is the one that you guys will be using okay so I think we're actually gonna okay gonna wrap up and then have you back next week are you yeah yeah sure okay so so um so here here's uh just just stay around so um basically we're we're going to uh we're going to finish this lecture next week I think there's it's important enough that you really see the demo and see sort of the and it actually ties in kind of nicely with next week's topic is concept generation right this is the next step in the v and since you know naric your research is also on concept generation will will it it'll tie in nicely so I think we're going to stop here for today so you heard about the the general idea of system modeling languages that are rigorous that have ontology uh syntax and semantics uh there's there's different of these that have been proposed developed some are used more than others there's really important differences between them so OPM is very conceptual uh CML is based onl and has these different type of diagrams and and can really help you flesh out your design in more detail and then modelica allows you to build these blocks it's a causal or uh declarative and you can actually simulate the physics of the system pretty pretty readily um so the big picture here just to wrap wrap up here the big picture is uh is the following and we'll we'll come back to this next week the big picture is is basically that system engineering is in a transition phase the classic way of doing system engineering really for the last 50 years is on the left document Centric you know write your requirements do your drawings even CAD you know computer design is great but it only essentially does the mechanical part of the design right and so the result of that is as you get even rexus you saw rexus is a box like like shoe box size basically and and it go it's going to fit on a much bigger spacecraft and you saw how much complexity is there and it it gets very very difficult to manage all this information to prevent you know errors oversights any change that you make uh it doesn't propagate automatically in these documents so the the transition is happening to the right side a model Centric uh way to do system engineering as think of paperless engineering everything you're doing is in a model the models are linked the models are executable the models um automatically propagate any changes that you make you know in requirements or design we're not quite there yet but that is where things are moving and so uh keep that in mind uh so there's no new assignment this week so next week we have A2 which is due the requirements please let us know if you have any we're here for you so I'm going to have office hours now on the WebEx you have the link um if you have any questions about A2 don't be shy to email me or you know uh yuana or or llu at epfl we're really here to answer your questions so next week topic we're going to finish on modelica and concept generation uh is going to be sort of our creativity concept generation is our our main topic next week