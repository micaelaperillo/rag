good morning welcome back uh today is lecture 12 We are continuing our graph Theory unit this time talking about matchings and stable matchings uh matchings in general are a really useful Concept in graph Theory they come up frequently when you're trying to match um pairs of OB objects you want everyone to have one partner or possibly zero Partners if they don't get a match then they're sad that's fine um but matchings are really useful concept so let's talk about what they mean what they're good at um and a few ideas surrounding these so first of all definition a matching in a graph which remember has a set of vertices and a set of edges which are pairs of vertices um is a subgraph oops M and what subgraph means is we're just taking a subset of the vertices and a subset of the edges uh so long as excuse me uh so long as all the edges have their vertices in the subset um let's see in which uh every vertex in sorry yeah every vertex in V uh has degree 1 in M degree less equal to 1 in M uh and sorry this is vertex set of our subset um said differently a different definition which is just as good um a matching is a subset of the edges of our graph where no two selected edges edges share an end point so we're just choosing some of the edges of our graph making sure that we never touch edges that have an endpoint in common that uh for example I can draw this bow tie looking graph this this this this this here here here and here and then vertex A B C D E F G H so if this is our graph let me give you an example of a matching so an example of a matching is M the this is going to be just the edges be and DG uh this is an alternative uh notation for edges by the way instead of writing the set B comma e Clos curly brace uh I can just write be next to each other and it's clear we're talking about those two vertices so we're dealing with the edge be so that's this Edge and the edge DG which is this Edge is this a matching I see I see some headshakes sorry some head nods yeah this is a matching because none of our selected edges have end points in common if I had also chosen Edge FD if I tried to put FD into there as well then these two edges would be in conflict and we would no longer have a matching does that make sense so said um more similar to our first definition if we look at just the subgraph that includes our chosen edges all of the vertices in that subgraph need to have degree at most one so this has degree one and one and one and one and zeros for the others um if we have edges sharing end points we'd have higher degree which is not allowed in a matching um um like I said this has lots of applications anytime we're trying to pair things up uh for example online dating services um you're trying to recommend um say this user to that user and you recommend them to each other and they go on a date or something like that um and maybe you want to try to match up a bunch of them at once so you can have lots of dates happening in parallel so you want a matching that includes lots of edges knowing that no one can go on multiple dates at once um sometimes you might have a bunch of tasks in a in a an expensive um computational project you have lots of tasks you need to do and lots of servers that can help you out in parallel but each server can only do one job at a time so you want to find a matching that gets lots of servers working on different tasks at the same time so you want to find a matching that includes lots of your servers and lots of your tasks um and find a matching with lots of edges so you get lots done in parallel um so in a lot of these examples we're trying to maximize the number of edges in our matching try to get lots and lots of pairings all at once and there are a couple different Notions of big a big matching a matching with lots of edges that we want to Define we want to define a maximal matching and a maximum matching and I'm sorry that those sound very similar but let's talk about what they mean uh so we'll say that m is a maxim mole matching when it's not possible to find another Edge e that's in our set but not yet in our matching such that M with that new Edge is matching so Maxim Mo means you can't add new edges to the set of edges you already have so in this case with these two edges um all of the other edges I might try to add to these two have an end point in common with one or the other so I can't pick new edges to put into M while keeping the ones I already have so that makes M this matching is maximal does that make sense this is sort of a local notion where all you have to do is look at the matching you have and ask is there any single other Edge that I can put in here as well and if there isn't then it's maximal and if it's not if there is another Edge you can put in well go ahead and put it in then search again if there's yet another Edge you can put in put it in keep going until there isn't and then you have a maximal matching so it's very easy to find a maximal matching you just keep adding edges until you can't the difference is that that maximal matching you find might not be the biggest matching possible ever and that's the other notion we want a maximum matching we'll say that m is a maximum matching when there does not exist a bigger matching a matching M Prime with more edges so this is a global measure of Maximum we'll say of matching is maximum when it's the biggest you can ever do I don't care if you keep these particular edges just is there any matching at all anywhere that has more edges than this so that's the difference between maximal and maximum maximal is about local search can you make a single Improvement by adding a single thing here maximum is a global property is it the biggest possible ever and as you can imagine um finding a maximum matching or proving that a matching you have is maximum is a lot harder than maximal um this matching up here with DG and be is that maximum why not someone someone shaking their head can you tell me yes all right ad d um BG you said and C all right is a matching and is this a matching let's take a look we've got a D here b g here c e here none of those circled edges um that kind of look like coffee beans to me none of those coffee beans share of an end point so that is a matching and since this has more edges than M up there m is not maximum right cool so matchings can be maximal locally biggest even if they're not maximum globally biggest um is this matching maximum or can we do even better oh there was someone raising their hands in the back but it's brinmore there was someone else raising their hand but I think they were just adjusting their glasses all these fake outs plain jokes on me okay so is this is this a maximum matching or can we do better or what it oh yes all right so um let me uh let me say that so everyone else can hear so if we had a bigger matching we'd have to include F or H is that what you said all right um and if we try to include F then it's going to share an end point with a d uh which is not great um so yes that's almost exactly the logic I'm looking for um just a slight tweak to that uh when we're asking if a matching is maximum we're not really talking about adding to this specific matching that's the maximal side of things so instead of comparing what we have or instead of comparing to what we have to this particular matching um I just want to be able to prove that there is no bigger matching at all uh so what would it mean for there to be a bigger matching a bigger matching would include well at least four edges and therefore at least eight vertices but we only have eight vertices right 1 2 3 four five yep um so it would include all the vertices all right and any matching that includes all the vertices in particular includes a and F and we we can't use a and F cuz they would both have edges to D there's only one way to use a there's only one way to use F and they both use vertex D in the middle and we can't do that can't use a and F at the same time and this is our contradiction so if there's a bigger matching bad stuff happens so there doesn't exist a bigger matching that doesn't mean this U these three coffee beans are the only maximum match matching um there are a couple more for example we could replace ad with FD that would be fine that would be a different maximum matching uh so there can be multiple maximum matchings um that all necessarily have to have the same size um different maximal matchings don't all have to have the same size as we saw this two-edge matching is Maximo and also this three-edge matching is Maximo does that distinction make sense wonderful all right let's see so next definition a matching is perfect if and only if it includes all vertices so perfect matching gives everyone a partner and therefore exactly one partner does this graph have a perfect matching no a perfect matching would need to would need all eight vertices and therefore four edges but we already saw there are no matchings with four edges in this graph so not all graphs are going to have perfect matchings um but often in your task allocation Pro uh problems where you're trying to match everyone to another resource um ideally you'll end up with a perfect matching where everyone gets a partner or every task gets a server uh and so perfect matchings are um are very commonly the goal now so far we've been talking about matchings in general graphs um but matchings are very common especially in bipartite graphs so bipartite matchings um so when we're trying to match tasks to servers we have a bipartite graph all the edges connect a task to a server when it's possible for that task to be done on that server and then we're looking for a matching which tells you which servers are doing which tasks um so a lot of problems that involve matchings are naturally bipartite uh let's see and uh to emphasize um remember from last time by partite graphs don't need the same size on both sides as we saw with the Harvard vers MIT bipartite graph we had 7,000 on one side and 4,000 on the other side still a perfectly valid bipartite graph however um let's see let's see perfect matching can't possibly exist in a bipartite graph when the two sides have different sizes right there can never be a bipartite uh sorry there can never be a perfect matching between Harvard undergrads and MIT undergrads because there are more Harvard undergrads than MIT undergrads every Edge includes one of each so even if we max out all of the MIT students and give them a Harvard buddy there's still going to be 3,000 Harvard students that lose out so if there's a perfect matching in your bipartite graph you have to have the same size doesn't mean there will always be a perfect matching when the two sides have the same size but it's at least necessary all right sometimes uh when you're trying to make these matchings not only are you trying to maximize the number of pairs you get or possibly uh get a perfect matching and get everyone a pair um but often edges are weighted uh so each Edge comes with a number so we have a function W from the set of edges to real numbers and each Edge comes with a number you can imagine in the tasks versus servers graph each Edge represents how long that task would take on that server and maybe certain tasks are going to be faster in different servers maybe because that server is more powerful or maybe because it's closer to other resources it might need and it can access them more quickly um but often when we have a weighted Edge like this uh we want a perfect matching with minimum total weight as an example of that here's a nice bipartite graph uh and maybe this Edge has weight three this has weight one this has weight five and this has weight two and I can see two different perfect matchings in this graph there's the one that does this and there's the one that does this I think that's all of them and if we look at the weights well this has weight three and two so this has total weight five uh and this has weight one and five so this has total weight six so you'd prefer this one to that one cuz five is smaller than six the total weight in this perfect matching is better than the total weight in this perfect matching right so these are just very common kinds of questions that you find yourself asking when you're modeling something in terms of matchings or perfect matchings often there's more to optimize than just finding a perfect matching and I mention all of these variations on these problems um because unlike last time where we saw that graph coloring is a useful abstraction but hard to compute exactly or hard to compute optimally um all of the matching problems I've mentioned we do have efficient algorithms for so we have we can find maximum matchings in graphs bipartite or otherwise uh yes question are oh um yeah where did these weights come from um these are just arbitrary in this example um I just picked them for demonstration um in a real world scenario the weights would represent like how much work it takes um to do the task corresponding to this pairing or how expensive this is or how desirable um so usually these weights are going to come from whatever context you're modeling and trying to optimize for but yeah in this example I just picked them um but there is an algorithm to find maximum matchings in graphs bipartite or not doesn't matter um excuse me uh we can find uh and because we can find maximum matchings we can find perfect matchings if they exist if a perfect matching exists it's certainly maximum because you can't use more than that number of edges um we can find Min weight perfect matchings uh in bipartite graphs we have algorithms to solve these kinds of problems so if you ever find yourself modeling a question with matching trying to find a matching with certain properties uh very often there will be algorithms to solve it quickly we're not going to cover those algorithms in this class um you'll see more of them in the follow-up classes six um 121 and 122 um but just know that they're out there and know that this is a useful tool um both for modeling and for computing are there questions about these kinds of things all right no questions uh then let's move on to the main topic for today which is stable match so this is a uh yeah so the topic is stable matchings we are going to be uh in this problem we're going to be looking for certain kinds of perfect matchings in bipartite graphs so in this in the specific scenario let's imagine we have n applicants and n evaluators you can think of these like n interns that are looking for managers and M and N managers where we're going to match them up one to one each intern gets one manager and vice versa uh and we're trying to find a way to match them nicely uh you can think of these as the applicants are um recently graduated medical school students looking for residencies um and I mentioned this example specifically because the algorithm were about about to talk about is used in precisely that way um in practice in the real world in the United States at least um all residency applicants submit their list of preferences about which hospitals they want to do their residencies at um and they do interviews and hospitals submit their preferences for which candidates they prefer uh and they send this all to a national nonprofit organization who does a big global computation to find in some sense the best perfect matching it can and then it notifies everyone on the same day um all residency applicants are told on Match Day which was actually just a few weeks ago it happens once a year uh they're told where they're doing their residency and it's a a big party and um many of them are excited about going at their top school many of them don't get their top school and they're still happy because they still get to be a doctor um but they're going to use EX actly the algorithm I'm about to describe with some tweaks because the real world is more complicated than the simple math we're about to describe um but um this is a real algorithm with real consequences it was uh invented in what the Yeah in 1962 by Gail and shapley uh that's that's two people um I'm going to call it the Gail shapley algorithm uh it was also improved um many years later by El Roth uh together they have found many real world applications and improvements um and it won them the 2012 Nobel prize in economics for uh for alth and for shapley I don't know where Gail was in all of this uh I don't think he got the the prize as well anyway um really important useful practical algorithm that actually has some fairly simple mathematical underpinnings enough that we can describe it and analyze it and prove things about it uh in the next hour we have together so um what is this algorithm what is it for so as I said before we have n applicants and N evaluators um and each of them is going to give a preference ordering for um for all n of the opposite parties um in order of their preference so all applicants and evaluators give a full ranked list of their preferences so as a quick example trying not to run too fast for the cameraman back there so here's an example where we're we have five applicants and five evaluators I haven't said which is which because the relationship is pretty symmetric at this point um and so each person on the left gives a full ranked preference order for all of the people on the right so this person a prefers H then J then F then G then I in this strict ordering so each of these gives some permutation of f through of f through J each person over here gives some permutation of a through e uh with no restrictions on the kinds of rankings that are allowed as long as they give a full strict ranking of all the people not other restrictions if all the applicants want to choose the same evaluator as their first choice they can they're not all going to get it but they can all list it for example if everyone really wants to come to MGH uh for their uh for their residency let's live in the fiction where each Hospital only gets one resident uh so we're trying to match One hospital to one resident and vice versa if everyone lists MGH as their first choice that's fine they can only one's going to get it um so no other restrictions on which per mutations they give uh and we want a perfect matching that leaves everyone [Music] happy happy enough like I said we can't give everyone their Top Choice especially if all their top choices Collide um but we want to make sure everyone's happy enough and so let's look at an example before we describe exactly what we mean by happy enough so let's imagine back to our favorite graph ab and CD so we have applicants AB evaluators CD and a um prefers C over D so I'll list that as a one and a two a prefers C and then after C they prefer D um B likewise prefers C over d c prefers A over B and D also prefers A over B if we write it out more similar to the example over there this is saying that a uh prefers C over D and B prefers C over d and also C uh let's see prefers A over B and D prefers A over B so we're already in a scenario where not everyone can get their Top Choice someone is going to have to take their second choice um and let's look at an example what if we try to match a d and BC so what's going to happen here so a with D and B with C so b gets C so B is Happy B got their first choice a with d d is Happy D got their first choice right B and D have no reason to want to switch but what about a and C A and C are not paired together but they each prefer each other over their assigned Partners so if you think of this as like a a dating scenario o um if we try to say that A and D are paired and B and C are paired uh then what's going to happen is that a and C are going to run away with each other because they each prefer to be with each other than they're assigned partner uh we can we call that a rogue pair uh so we're going to say um a pair so an applicant and an evaluator form a rogue pair in a matching M uh when E and A each prefer each other more than their assigned partner and by the way for the rest of lecture when I mention matching I'm going to mean a perfect matching because we're trying to match all the applicants to all the evaluators and if I forget to say perfect I apologize I mean Perfect all right so a pair forms a rogue pair in some matching if they would each prefer each other than the partners they're assigned in that matching and what we're going to look for so the of the scale shapley algorithm we want a perfect matching with no Rogue pairs so happy enough we want a matching that makes everyone happy enough that you're never going to get two people running away with each other other rather than staying with their own partners for every pair that you match up at least one of them prefers to be with the partner they've been assigned than anyone else who would prefer to be with them such a matching we call stable so perfect matching with no Rogue pairs is what we mean by a stable matching and that's going to be our goal does there always exist a stable matching how can we find out when there does exist one can we come up with an algorithm that will always find one if it can in this example does there exist a stable matching well there are only two matchings in this graph so let's check the other one so we saw that AD and BC is not stable what about AC with BD okay so a with C well A and C each got their Top Choice there's no way they would ever go Rogue right and then if a and C can never go Rogue then excuse me then no one can go Rogue with them so B and D isn't going to break up so because B and C aren't going to run away together C is already happy A and D aren't going to run away together a is already happy so this matching is stable because none of the pairings are rogue sorry because none none of the possible pairs are a rogue pair does this example make sense cool so this particular example um two people with two people each with this preference order has a stable matching will there always be a stable matching well if we if we relax our conditions a little [Applause] bit and we decide let's let's no longer require bipartite let's just let everyone rank everyone and then hope to find a stable matching uh in that non-bipartite graph and here's an example of that so non-bipartite example let me make sure I'm erasing well enough all right so let's imagine we have four people they're going to be a b c and d and everyone's ranking everyone so everyone has three other people to rank uh and in this example a prefers B then prefers C then prefers D B prefers C then prefers a then prefers d c let's see so a prefers b b prefers c c prefers a then B then D and I don't even care what these preferences are uh so let me write this out in the other way so a prefers B then C then D B prefers C then a then d c prefers oops a then B then D and D I don't care D can have any preference order this example is already not going to have a stable matching because this graph is in some sense symmetric so of a B and C are all doing the same thing they each prefer the next in order among a b and c then the one after that and then D is last B prefers the next in order then the one after that among a b and c then D is last C prefers the next in cyclic order then the next then D is last so there are only uh three different matchings that we can make D has yeah D has to be matched with one of these three people and then the other two are paired together but since these three people are symmetric in this way all three of those matchings basically behave the same way so without loss of generality um we can assume that the matching looks like let's say a goes with D and B goes with C the other two matchings are going to are going to do something similar is this matching stable and the answer uh if you look at it carefully if you check all the pairs the answer is that AC is Rogue according to that matching AC is Rogue um and let let's let's check that what does it mean for AC to be Rogue well it means a prefers C more than their assigned partner so a is supposed to prefer C more than their assigned partner and C is supposed to prefer a over their assigned partner which is B so are these two things true well does a prefer C over D well yeah a prefers everyone to D so that's true does c prefer A over B well yeah that's the first thing we said so A and C prefer each other more than their assigned partners and are therefore Rogue so m is not stable so this is an example where if you have a bipartite graph uh and preferences among everyone then there won't always exist a stable matching which is why it's so amazing that the Gil shapley algorithm which is looking only at bipartite graphs it turns out and we're going to prove it always returns a stable matching in particular there always exists a stable matching so let's talk about the Gail shapley algorithm uh this is again just for bipartite graphs as as we set up over there um we're going to prove it always returns a stable matching and therefore stable matchings always exist in bipartite graphs um frequently there will be many many stable matchings for a given graph and for a given set of preferences um Gail shapley is only going to show us one of them it's certainly going to find a stable matching but not find all of them all right so let me describe this algorithm so the algorithm on each day we do the following two steps first so step one all applicants approach their favorite evaluator who hasn't yet rejected them so all the applicants walk up and say hey I want to I want to go to your uh your hospital for my residency and maybe um Mass General gets seven applicants um that morning at step two oops not step one again step two all evaluators reject all but their favorite that approached them that day so seven people all approach MGH MGH is going to look at all seven and say out of the seven of you I prefer Dr Evil um and the other six you can you can leave forever I never want to see your face again kind of harsh but that's how the algorithm Works um so you're going to do step one and step two every day and stop when there are no more rejections if a day ends and no one was rejected then that's the end of the algorithm now what I haven't said is so all applicants approach their favorite evaluator who hasn't yet rejected them if everyone has rejected them then there's nothing for them to do they they go home and cry um if possible so if they get through their whole list and everyone has said no and they have no one else they can approach there's nothing else for them to do they just drop out all right let's yes good question so if an evaluator has two different favorites that are equally preferable are they allowed to save both of them uh so no because of the way we set up the problem there are no ties they give a full strict ordering so among any two people they know which one they prefer they have a they have just a full list so you'll never have ties for preferences out of however many applicants you get that day there will be one clear favorite and you you temporarily hold on to them and everyone else gets the boot yes I'm sorry a good question does this only work for one to one ratios so yes still um in this algorithm we're only talking about n applicants and n evaluators and each evaluator is going to end up with one applicant and each applicant is going to end up with one evaluator uh so we have the same number on each side and we're trying to find a perfect matching that's those are the rules of the game does that answer your question cool um it can be useful to see this algorithm running it can be yes awesome so here's a a 4x4 example uh these preferences are just you know whatever preferences they have we have the evaluators on the top so imagine those are the med schools on the top and the doctors on the bottom that are doing the applications um so on day one um each of the applicants is going to approach the evaluator that they most prefer because there have been no rejections yet so they all just go to their Top Choice um evaluator one says okay well a you're my only applicant today so I I guess I'll hold on to you for now um uh Hospital 3 says oh no I have three applicants among those I prefer D so I'm going to reject B and C so B and C are now Gone Forever Three will never talk to to to B and C again and they get sent back down to the bottom and that's day one did that make sense awesome now in day two um well A and D still haven't been rejected by their Top Choice so they're just going to stay there for the next day um but B and C who got rejected have to to go find someone new so they're going to go to the next one down their list and it so happens that they're applying to the same place again this time uh and now they're in Conflict so Hospital 2 says I prefer B so C get away from me and that's the end of day two did that make sense nice who can tell me what's going to happen on day three at least the first step of day three yep up there yeah C looks through their list and says okay evaluator one is my next favorite that hasn't rejected me so I'm going to go over here to one all right and now evaluator one says oh there's a there's a contest between a and C looks like I prefer C this time so now a goes away so even though a had been held on for a couple days someone better came along so a gets gets kicked out it's a it's a Cutthroat game uh and let's keep going next day a says okay well my next favorite is three next down my list and I want to emphasize it's now day four but we're not looking at A's fourth choice we're only looking at A's second choice because a has only been rejected once so far so we're always going to the next choice for that person which might be at a different place for each person on that day so a goes to a hospital 3 Hospital 3 says nuh-uh and sends a away again now a goes to hospital 2 hospit hital 2 says oh yeah okay I like that one so B can go away and now B has to go fend for themselves somewhere else so B goes to hospital one and says and gets rejected B goes to hospital 4 and finally there's nothing else to do no one is rejected so the algorithm is done did that make sense wonderful um let's make it make even more sense by doing an algorithm ourselves by hand so we've seen it run once now let's run it ourselves once excuse me so let's do this algorithm so on day one uh so so let's see uh let me make sure I'm matching my notes yeah so I want these on the left to be the evaluators and these on the right to be the applicants so every day F through J are going to apply to their best remaining choice and a through e you're going to make decisions so a b c d e what happens on day one F through J are each going to apply to their Top Choice okay so F applies to c g to a h to d i to a J to a okay so F goes to c g goes to a h goes to d i goes to a and j goes to a so these are the the applications on day one and then evaluator a says between g i and J between g i and J I prefer J so G G and I are rejected G and I are rejected G and I are rejected sound good I see some headshake was that a question or is it just funny that we're that we're being so aggressive wonderful all right so that's what happens on day one what about day two um well JF and H weren't rejected so they stay where they are so J a stays here F stays here H stays here but G and I have to go somewhere new so G is now going over to B uh and I is going over to C all right and now C has a choice C can choose between F and I C can choose between F and I oh c is definitely choosing i f is way down at the bottom so f is sad and I believe that's the end of day two stop me if I make mistake I very well might make a mistake here um day three well the only one that got rejected was F so they're the only one that needs to go somewhere new so we can just copy over j g i h and f where is f going F was rejected from C so they're going to B let's let's hope F has a better day today than yesterday um so B is now choosing between G and F and looks like f wins this time so G is rejected okay so G was rejected from B and Tomorrow Needs to Go to e so day four G is going down here to e h i f and J We're Not rejected so they stay put for the next day and finally there's no cont test so there's no rejection and finally we have a matching a with j b with f c with i d with h and E with G did that make sense question excellent question if we flip the evaluators and the applicants do we get the same matching um so as we said earlier the relationship is kind of symmetric right they're all giving equivalent data we could have run this in the opposite direction where F through J are the evaluators and a through e are the applicants and I have claimed so far that we're going to end up with a perfect matching um turns out usually what you're going to get is a different perfect matching um and we're going to say very precisely why that is uh a little later on uh so really good question but yeah just always keep that in the back of your mind you could have run the algorithm in the opposite direction and you'll probably end up getting a different stable matching yes uh does the order of what matter applicants the order of the applicants um so the order of the applicants doesn't matter the only thing that matters for the algorithm is the individual rankings for each person but the fact that like g i and J approached a in that order on day one didn't matter all that matters that these three approached and Jay is the best out of these three cool good question all right um so we we got a matching out of this example is it a stable matching if my theorem is to be believed then or if Gail and shapley's Theorem is to be believed then yes this should be a stable matching and in this case if you check all the possible Rogue pairs turns out yes this is stable for this example so that's at least one point in favor of this algorithm producing correct results question interesting question if we wait if we give a wait for um who gets which preference So like um First Choice gets one point second choice gets two points and all the way down does this give an Al does this algorithm give a matching with lowest total weight uh that's a really great question um um at least if you're if you're counting it on one side I'm pretty sure the answer is yes if you're counting it on the other side I'm pretty sure um it gives a matching with the maximum total weight uh which is probably not the side that you want you want lower ranks um but yeah really great question so there are lots of ways you can see this as in some sense some optimization problem we want to maximize happiness which means minimizing um how far along your ranking list you have to to go before you find a match uh cool so let's let's try to prove why this algorithm does in fact give us stable matchings and there are a couple things to prove here let's see where did I leave off okay so first question we so we've given an algorithm um in this class usually when we're talking about algorithms we're talking about State machines and so we can think of this algorithm as a state machine machine where each state is the set of rejections that have happened so far so to know where you are in the algorithm and where you have to resume to start the next day all you need to know is which things have been crossed off from which people's lists and then you know what happens the next day because each of the applicants just goes to the next one in their list right uh and transitions correspond to run one day of the algorithm this is a way to transl to transform one set of rejections into probably a slightly bigger set of rejections whatever rejections happen on that day are now also part of the new state and now we can ask State machine questions like does the Gail shapley State machine terminate or might it run forever who can tell me yes it terminates why it says so in the lecture notes o appeal to Authority I say it terminates and therefore it terminates o um unfortunately I can't use that justification for myself CU if I wrote the lecture notes then I am that Authority so that that's not a valid proof for me to use so I would ask that you not use it either uh yes down here awesome there are only a limited number of rejections that can happen exactly so every day that the algorithm continues at least one rejection happens but there are only N squared rejections that can happen in total right so there are at most n s rejections possible we use at least one for every transition so we can follow at most n squ transitions uh before ter minating yeah we terminate just because we constantly use up a limited resource and we have to finish at some point before we eat up that resource or in the worst case when we finish uh going through all of that resource so worst case everyone gets rejected from everywhere and then we stop Yes is n the number of applicants yes n is the number of applicants and the number of evaluators they're the same yes all right so it terminates yes awesome next important question when it terminates does everyone have a partner we were saying earlier that if someone gets rejected from everyone they go home crying so does anyone go home crying we'd like that answer to be no we'd like everyone to have a partner at the end all right and the examples we've seen on the board or sorry on the projector and on the board over there um we did end with an actual perfect matching um no one got rejected from everywhere so is that true in general and to talk about this and also to understand the algorithm a little better in general um Let me give us some uh invariance of this algorithm this algorithm is a state machine so let's use invariance and preserve properties to talk about it so um let's see invariant each applicant has been rejected from a prefix of their preference list so on any particular day if you look at one of these blue guys and ask um who they've been rejected from It's Always from the top of their list down to some point and that's just because of how the algorithm runs every day an applicant goes to the Top Choice that has hasn't rejected them yet and either they stay with them for another day or that evaluator rejects them and the prefix gets one longer but either way it's they're always rejected from a prefix uh in particular um let's see each applicant approaches worse evaluators over time since applicants always go down their list from the top um they're always approaching their favorite evaluators every time they can and if they're ever rejected they have to go to someone worse and if they're rejected they have to go to someone worse again um so the the evaluators that they're approaching only ever get worse over time or stay constant if they're not rejected that day but they never get better so applicants prospects only ever get worse and the opposite happens for the evaluators um I claim uh that evaluators evaluators uh let's see each evaluator eval I can't spell evaluator um let's see picks from day to day only get better and if you think about this from the perspective of an evaluator um well if no one has ever approached them then there's nothing for them to do that day but if someone has approached them and they have um they have some number of people in front of them they're always going to pick the best from whoever's there when the next day happens they at least have that same person again and possibly others and if there's someone better then they'll trade up and take someone better but they never trade down the evaluators always ever always only keep who they had yesterday or trade up to someone better for the next day so if valuator prospects only get better and better from day to day we can be a little more precise about this uh let's see so invariant so for all applicants and for all evaluators um let's see if the evaluator has ever rejected that applicant then the evaluator has a favorite has has I'm going to call them a candidate has a candidate better than a um so if Dr Jackal uh approaches briam and women's uh and is rejected on day 12 then for all future days briam and women's is going to have some candidate that they finish the day with that's better than Dr Jackal uh and that's that's just a precise way of saying this every day uh they either keep who they had yesterday or trade up to someone strictly better so when they rejected Dr Jackal that day they started or they they finished that day with someone better than Dr Jackal because that's why that's the only reason you would reject Dr Jackal um and then from then on they either keep or trade up they only ever get better does this invariant make sense awesome so if evaluator has rejected applicant then evaluator is always going to have a candidate better than that applicant from then on so now let's answer this question does everyone have a partner at the end uh and let's see what happens if they don't so by way of contradiction let's pick one particular applicant say Dr Jackal uh so by way of [Music] contradiction assume Dr Jackal was rejected by everyone was rejected by all of the evaluators all right and let's see what goes wrong here well the end of the algorithm at the end of the algorithm since all of the evaluators red rejected Dr Jackal well what we wrote up here this invariant says that all of the evaluators have a candidate that's better than Dr Jackal it was true when they rejected Dr Jackal and it remains true from then on um all evaluators have a candidate better than Dr J so we know we finish and when we finish all of the evaluators end up paired with someone better than Dr J but there aren't enough people for that they're in evaluators and N applicants and if Dr Jackal isn't paired with anyone then there are only n minus one other applicants that can possibly have Partners uh so it can't be that all n of the evaluators finish with a partner better than Dr J because all n of the the evaluators can't finish with anyone or they can't all finish with anyone at all right um but there're only n minus one other candidate uh other applicants so the N evaluators can't all have Partners better than Dr J and there's our contradiction so if we assume Dr J has no partner at the end bad things happen we find a contradiction so that doesn't happen so Dr Jackal does end up with a partner at the end and therefore everyone does so it returns a perfect matching it returns a perfect matching everyone gets some partner but is it stable this is the part we really care about is it stable at the end this is the part we really truly care about and let's prove that it is so to see why um let's imagine what could possibly result in a rogue pair who can be Rogue the algorithm returns some perfect matching at the end what does it mean for some pair of of of entities um to be Rogue well I claim there are three kinds of applicant um in relation to one of the particular evaluators so if we think of tus as one of the evaluators tus Medical Center um then some of the applicants toughs rejected at some point in the algorithm some of the applicants toughs never spoke to and then one applicant toughs keeps until the end and ends up paired with so let's consider each of those three kinds of pairings and show that toughs can't be Rogue with any of them so let's assume Tufts rejected let's let's pick a generic example tus rejected Dr no uh let's say TS um never spoke to uh drct who who's that I never spoke to them and finally tus um is paired with uh the good doctor these are the three kinds of people that can uh that can exist relative to TS and let's show that none of these can be Rogue first of all toughs is paired with the good doctor they're in our perfect matching Rogue pairs are never in our perfect matching they're pairs that are preferred U mutually preferred to the perfect matching so this is never Rogue by definition of rogue if you're in the matching you're not Rogue all right so it's these other two cases that we care [Applause] about so first let's look at Dr no all right so tus rejected Dr No at some point in the algorithm and because of this invariant that we found we know that Tufts ends up with someone better than Dr no um is pair with someone better than Dr no because the moment uh an evaluator rejects someone they know they're always going to have someone better from then on so tus and Dr No can't possibly be Rogue because tus is better with who they end up is U happier with who they end up with than they would be with Dr no remember Rogue pair requires both members of the pair to prefer each other rather than their assigned partner so since tus is happier with their assigned partner than with Dr No TS and Dr No cannot be Rogue does that make sense all right so we just use that invariant to say that since tus rejected Dr No their eventual partner is better than Dr No that's all that that is saying what about the other side what about toughs with Doctor Who Doctor Who Never spoke with toughs during the algorithm all right and since drct who uh never spoke with toughs well remember what the applicants are doing they're going down their list from the top and since they stopped before they got to Tufts wherever they stopped they like better than they like toughs so doctor who likes their partner better than they like toughs right and therefore toughs with Doctor Who Can't Be Rogue not Rogue because this time it's Doctor Who who's happier with their assignment than they would be with TS so in this case tus would be happier or tus is happier with their current partner in this case Doctor Who is happier with their current partner in both of these cases tfts with this person on the right cannot be Rogue so toughs can't be Rogue with anyone so there are no Rogue pairs no rope pairs can exist the matching we get at the end is in fact stable did that make sense awesome okay let's return to this question of how good is this matching is this the one that makes everyone maximally happy or minimally happy or somewhere in the middle does anyone have excuse me does anyone have an advantage if you were participating in this algorithm would you prefer to be an applicant or an evaluator well can kind of go both ways we already said that applicants prospects only get worse over time and evaluators Prospects only get better over time so maybe it's better to be an evaluator on the other hand applicants start at the top and they stay as close to the top as they can until someone grudgingly says okay I guess I'll keep you um so maybe it's better to be an applicant because you're always asking the best um the best partner you you can possibly have rather than the evaluators who have to wait around for people to come to them so it's it's maybe not clear which side is preferable so let me give some let me give a term so we can measure what we mean by preferable uh first of all let's say um excuse me so if e is an evaluator and a is an applicant uh let's say that E and A are feasible Partners if and only if it's possible to put E and A together in a stable matching not necessarily the stable matching that the algorithm gives but if there's any stable matching that pairs e with a together then we'll say that they are feasible Partners all right and now we have the following theorems the Gail shapley algorithm pairs every applicant with their most preferred feasible partner so each applicant doesn't get their Top Choice we know they can't each get their first choice because there might be conflicts there um but each applicant turns out gets the best possible choice they could ever hope to get among all possible stable matchings so up here on the board we see that um applicant a is paired with evaluator 2 and not with one or three and what this theorem says is that a can never be paired with one and can never be paired with three in any stable matching there is no stable matching that pairs a with one there is no stable matching that pairs a with three a paired with two is the highest preference um partner that a has that is feasible and Gail shap Gail shapley gives him that partner so every evaluator gets the best partner they could possibly get in any stable matching I personally find this surprising like often we when we have some optimization problem but we have lots of different metrics that we're trying to optimize um like candidate a wants to get their best possible partner candidate B wants to get their best possible partner and to me it it feels intuitive that maybe these desires might conflict with each other like maybe A and B both have um evaluator 3 as their optimal partner uh and there are just two different stable matchings one that pairs a with three one that pairs B with three um so it's kind of weird to me that each candidate can be given their optimal partner their optimal feasible partner all at the same time and there's no conflict among them so I find this a little bit counterintuitive for that reason beautiful fact but a little counterintuitive and Theorem Gail shapley pairs every evaluator with their this time least preferred feasible partner so exactly the same idea but this time the evaluators instead of coming out as best as they possibly can they come out as worst as they possibly can because evaluator uh let's say because evaluator one ended up with partner c um there is no stable matching that pairs one with anyone worse than C there's no stable matching that pairs one with B there's no stable matching that pairs one with a um so it's best for all of the applicants at the same time and simultaneously worst uh for all of the evaluators at the same time this single matching that Gail shapley returns has all of these properties in it um which brings us back to the question earlier if we were to run this algorithm in reverse by swapping the roles of the evaluators and the applicants we're going to swap from we're going to move from the matching that is best for this set to to the one that's best for the other set and the one that's worst for the first set to the one that's best for the other set and that's why usually you're going to get two different matchings out of it because if there are multiple matchings multiple stable matchings at all for this set of preferences the worst and the best are going to be different from each other do these ideas make sense we haven't proven them yet but are the ideas do the ideas make sense all right uh let me give you just a a brief hint at how we might go about proving this we'll prove it more precisely in recitation tomorrow but the basic idea pause for dramatic effect the basic idea is going to be oh I'm holding chalk I found it um one more uh key invariant so invariant for our Gail shapley algorithm uh so if an evaluator ever rejects an applicant a then EA are not feasible Partners so if e rejects a at any time during the Gil shapley algorithm then there does not exist any stable matching at all that puts e with a together uh turns out we can prove this um as an invariant of our state machine machine uh very briefly let's see if we can do that um okay so uh Al also this is true for all evaluators and for all applicants if any evaluator rejects any applicant at any time then they're not feasible Partners so the the heart of the proof is let's assume um that an evaluator e uh rejects an applicant a today so we've newly rejected someone and so now we're going to show that E and A can't be feasible Partners uh well in favor of applicant B in favor sorry in favor of a prime so if e rejects this applicant in favor of that applicant well then we know that e prefers the new applicant over the old applicant because that's the only reason e would reject one for the other uh and then the claim here um or the the main observation is that let's see in any uh hypothetical stable matching not necessarily the one that comes from Gil shapley but in any possible stable matching you try to set up where a matches with E and then necessarily a prime matches with someone else um you can prove that a sorry that e and a prime are rogue so because e rejected a prime in favor of a on some day in the algorithm um you can show that anytime you try to pair a with e together in a stable matching actually it's not stable cuz e and a prime are are rogue they each prefer each other uh you'll see the details of that in recitation tomorrow thank you so much