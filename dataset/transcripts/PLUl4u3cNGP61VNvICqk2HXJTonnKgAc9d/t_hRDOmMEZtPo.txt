okay can people hear in the back are we good yeah thumbs up okay nice one so uh you you've already seen uh a couple of lectures on on number Theory now and uh so we've already uh some of you have been asking like why are we doing this why is this in 61200 and uh today we're going to see how gcds and modular arithmetic uh can be very important for uh you know something that you that you use every day computer security uh so cryptography has been uh uh you know very important uh subject for you know uh for for daily life for like the last 20 odd years uh you know any time you uh do an online uh like credit card transaction or anything like that like that's using uh you know modern cryptography um we'll see some uh some examples from history where it was quite important uh it's it's you know very much a computer science topic not uh not just math and uh but but it does use all sorts of uh exciting mathematics including you know number Theory okay so can anybody tell me you know just in a nutshell very informally uh what is cryptography anyone yep okay secure information over an insecure Channel yeah that's a that's a pretty good description uh so I I would say that it's uh you know the art or science of of you know dealing with with such uh dealing with protecting information um so like the the basic idea right uh well at least for for what we're going to be looking at today is suppose you have an insecure Channel and you want to send some message to uh you know a recipient but you don't want other people who might be uh EES dropping on your channel to to know what you're doing okay so basically you're going to want to garble a a message that you send privately in such a way that only certain parties can read it okay so let's uh you know take a look at at uh what we mean okay so the art or science of protecting information so our uh you know our setup the convention right is that we're going to have uh two parties Alis Kazam and and Bulbasaur and they're going to be trying to communicate over this communication Channel which you know may or may not be secure okay so maybe Alis Kazam wants to send a message it's it's Pi Day so she's going to send a pi uh over to Bulbasaur right so you know maybe she puts it in an envelope uh pops it in the post and you know Bulbasaur receives it he can open up the envelope and and get the message okay so does that basic setup make sense to people okay so nothing too fancy yet uh but what could go wrong can anybody uh tell me a problem with this yeah yeah somebody could come and steal the message right so like maybe we've got uh some Eve stopper Eevee right and uh you know Eevee wants to uh wants to Eve St up on their conversation wants to figure out what they're talking about okay so it's it's quite possible that you know maybe Alex Alex Kazam pops this in the mail Eevee then opens the mail puts it back in the mail sends it along to bobasaur but now Eevee knows what the message is okay so this is a problem right what else could go wrong any other ideas yeah yeah like what if what if Eevee is is not just an eavesdropper but like some meddling adversary okay so you know maybe maybe Bulbasaur now wants to say thank you for the pie Bulbasaur you know puts this in an envelope sends it over to all gam but you know E's intercepted along the way and so now when uh when alexam gets it it's not quite the same message as Bulbasaur sent okay so that's also a problem we we'd also like to prevent this okay so what can we do well if we think about you know the actual Postal System we could uh you know basically put a put a seal on it like a an oldfashioned Wax Seal uh but you know basically Alice gazam and Bulbasaur are going to share some some key okay so they they have a a message that they'd like to share it's supposed to be secret so instead of just you know putting the envelope in the post they're going to put it in a locked box right and alas exam will will lock it with her key and now when she sends it over the channel Eevee can't do anything with it it's locked Eevee doesn't have the key okay but Bulbasaur has the same key so he can now remove the lock and open the message and everything is awesome okay so key Concepts in cryptography oops that all work okay so the the basic idea you know we're we're trying to send private messages right so we're going to want to what we call encrypt a message so this means just garbling it so it kind of looks like random noise uh so only parties who share your secret key will be able to read it okay uh decryption is the reverse right you're going to take one of these garbled messages if you're the intended recipient and hopefully you can Ungar it to recover the uh the original message but also you know hopefully nobody else can do the same thing okay and in order to do both of these things uh the the two parties are going to share a secret key which is some data that that only they have nobody else should have it and it should look random and it should be hard for for somebody else to to derive or guess yeah that's a great question so like that yeah they have to meet up and and actually share a key uh but then that allows them to you know share messages uh over this insecure Channel later okay but they they do have to establish a uh you know a secure way of sharing the key first uh so we won't be talking too much about how you can actually do that nowadays uh but it is in the notes if you'd like to read it okay uh okay so a cryptographic scheme is basically just you know these things right it's a it's an encryption algorithm paired with a decryption algorithm and they should you know use the same secret key to uh you know invert each other okay so can anybody give me examples historical examples of cryptographic schemes does anybody know what the first one was yeah uh yeah the Caesar Cipher so what was the Caesar Cipher how do you encrypt a message yeah okay so the answer was you offset every message in the letter by you know n letters after it uh not quite you are thinking of something very slightly different the Caesar Cipher was specifically using three not not like some some key n okay so you take every letter shift it over by three letters so like you know C becomes D EF right uh and you know you shift every letter uh individually and then send the shifted message okay and to decrypt it you do the reverse you you kind of subtract three modul 26 okay does that make sense to everybody now what you're thinking of is the Caesar shift which is slightly better right so one problem with the Caesar Cipher right is um you know you're not you don't really have a key right like uh it's kind of what we call cryptography by obscurity so the only reason it might be secure is if nobody else knows you're doing it uh unfortunately you know if uh you know if you're a Roman Emperor Legion or whatever using the Caesar Cipher uh you know it doesn't protect against say maybe one of your generals defects and uh now goes to the enemy and is like hey they're using this cryptographic scheme here's how you can break all their messages right and so then from that point forward you know nothing you send is secure okay so one way we can fix that is you know by as you said introducing a key okay so the Caesar shift is you know very similar but instead of just shifting by three you shift by you know some secret key K okay modulo 26 okay does anybody see a problem with this MH yeah that it is so oops let's not caps lock that uh okay so here is a um oh that did not work what is going on okay so here's uh an encrypted message it's been encrypt encrypted using the uh uh the Caesar Cipher sorry Caesar shift uh as you said right it's fairly easy to guess what the key is right so does anybody have any guesses before I start just you know putting in values yeah 13 why 13 yeah that's uh that's a very good guess so yeah no knowing some information about the message right like this is probably in English right uh you have a a standalone n in that first line right that's probably an A or an I right you you've already got lots of information that you can use to narrow down the key and even if you don't right like if we just start putting in random values here right like most of them are going to look like garbage right okay uh but like one of them is actually going to make sense okay so when we try all of the possible values we're going to you know figure out something that uh that is almost certainly going to be the the correct key okay so how can we avoid this problem any ideas yeah change the encryption method based on the index of the letter okay uh so what you're describing is uh what we call the onetime pad um that is a good idea we will not be covering it just yet yeah okay um similar idea uh let's let's start by making a a smaller more incremental change yeah okay include numbers uh well the idea that I had in mind was to just use a larger key space uh use a permutation instead of instead of just a shift okay so that this is something that was done you know in medieval times uh instead of Shifting every letter over by the same amount right you'd take a random permutation of the letters and so you're kind of Shifting each letter differently okay now can anybody think of a way that you could attack this oh why is this not working H sorry technical difficulties oh well I guess it doesn't matter too much uh I can describe what's going on um so yeah uh what what your classmate suggested was that you know again we can use uh the known plain text attack that that we described a moment ago with the um uh with the Caesar shift okay if we know something about uh about our message right like uh for instance if we know that it's it's probably written in English then we can count how many times each letter appears and whichever letter appears most frequently probably decrypts to e because e is the uh most common English letter or even if not we've got a decent guess right like uh you know it's probably not going to be like X or Zed it might be S or t or something like that uh but the point is it's very easy to start narrowing down the key space and you know once we have a guess we can then start building on it so similarly to what your colleague did earlier right like if you have e and you see threel words you know ending with E that might be the right so then you've got two more letters okay does that make sense to people so you can like knowing a little bit of of information about your key you can kind of incrementally figure out the the rest of the key and decrypt the message yeah that's right so it is a permutation so uh you know it's a it's a onetoone map it's a bje okay uh other questions maybe I can just post this demo on the website so you can uh play around with it uh sorry it didn't work um okay so the next example comes from World War II has anybody uh heard of the Enigma Cipher yeah few hands can anybody tell me what it did mhm okay uh so the answer was it changed the encryption method every day uh that's not quite true it changed the key every day it didn't change the algorithm that they were using uh yes yeah so it it basically oh so the answer was it it changed the permutation every letter uh so yes that's that's the the basic idea behind uh Enigma um it started with some you know permutation of the letters and every time you uh encrypted a letter it would then you know apply some some uh change to this permutation so that the next letter would be encrypted differently so that made it resistant to a frequency analysis um but you know unfortunately for the for the Germans it was still viable to do a known plain text attack right so basically the the way that the Allies ended up breaking this uh encryption scheme was you know they knew something about uh about the messages that were being sent every day right like many of them were weather reports or something uh many of them had like you know the phrase H Hitler or something like that um but like if you know that you're getting a weather report from a certain location you know the weather in that location like you've got a bunch of information about what you know how this message might start right and so this you know similarly to to to a a frequency analysis attack you can kind of use this information to narrow down your key space and uh figure out the secret key and once you've got that you can decrypt everything that's being sent that day uh and so you know this is what the Allies were were doing uh uh in Bletchley Park to to win the war okay so Enigma kind of uh Enigma was kind of the the last uh major example of of what we or what I call kind of um cryptography by hubis uh like basically the the security relied on on you know some German engineer being you know smarter than everybody else on the planet right like you know he he came up with this uh encryption scheme and was like okay this looks uh this looks you know weird and random I can't figure out how to break it I bet nobody else can either okay and so the the Germans kind of worked with this assumption for the uh duration of the war and it was wrong right so nowadays we like to uh you know try and you know prove Security based on you know more reasonable assumptions than that so uh one example which is in the notes that we won't be uh covering too much today is uh called Diffy Helman uh the one that we'll be focusing on though is uh RSA so RSA was uh you know it's it's a a modern cryptographic scheme named after its inventor Clifford Cox um that's totally a lie uh so Clifford Cox did you know in some sense invent RSA but uh he made the rather suspicious life choice of working for the government uh so his work was classified for like 2025 years something like that and in the meantime you know rsna came along uh and you know Ed his same scheme they did it here at MIT uh so this was uh Ron reest Addie Shir and Leonard Adelman uh they got all the credit for it they won a cheering award and you know poor Mr Cox uh was kind of screwed um so more of the story don't work for the government um just kidding but uh yeah kind of sucked for him uh but yeah let's uh why don't we um why don't we get into uh to what RSA actually actually does okay so RSA is an example of what we call a public key crypto system okay so okay so before right I described uh what we actually call a a a private key crypto system right where both encryption and decryption use the same secret key okay in a public key crypto system that's no longer the case so we actually have two keys so let's call them uh KP and KS okay so KP is going to be a public key which everybody can see okay and then it's going to be paired with the secret key KS which you know you keep to yourself okay and now the encryption and decryption algorithms uh each of them uses a different key Okay so we've got uh encryption okay so our encryption algorithm is going to be you know e of some message and our public key okay and this will output you know some Cipher text C okay and then we're going to have a different decryption algorithm D which will you know hopefully take this Cipher text uh C and this time the secret key and it should output the original plane text message M okay so slightly different from the uh uh uh from the the crypto system that I defined earlier right in that one these two keys were the same and so you don't you you can't publish uh you can't publish KP okay so only people who share the same secret key can actually communicate here this allows you know any body to uh to to send a message okay so you can kind of think of this as you know suppose Alex exam wants to send a message to Bulbasaur uh so she's going to use Bulbasaur's public key to send him a message you can think of this as Bulbasaur's like Gmail address right this is something that you know anybody can find uh but then Bulbasaur has his Gmail password which he can then use to read the message okay okay so now we are ready to actually Define how RSA works okay so the basic idea behind RSA is that uh the encryption and decryption algorithm together uh should basically make use of phos little theorem to to make sure that we get back to the same message okay so we're going to try and come up with uh you know some e and d right and some n such that if we you know exponentiate right first raised to the power of of uh e then raise again to the power of D we should get back to to where we started okay so we're going to want uh you know for any m m to the E raised to the power of D should be equivalent mod n to n okay so let let's just start with correctness for now let's let's not worry too much about security just yet but uh how could we achieve this how could we choose uh n and D such that this will at least work even if it's not secure any ideas so what what did FMA tell us so phma tells us right that uh m to the uh you know P minus one is congruent mod P to one okay so how can we kind of massage this into this well first time might we choose n yeah sorry okay so the idea was to you know let e and d uh be factors of n so like e * D sorry equals n okay uh does anybody see a problem with this yeah uh so that's not the problem right so we uh remember the exponent here is p minus one right so you know if you multiply both Ides by m you get m to the p is congruent mod P to M okay so that that is actually what we want what assumption did we have on P yeah P ISE yeah p is prime so we can't do this okay it is close though so maybe I should rewrite this as the suggestion was e * D should be equal to p minus1 + okay does that make it any more clear what how we can uh iterate on this what other things would work here instead of P minus one + one yeah yeah uh yes that's right sorry so the answer was we can multiply this by whatever we want right like any K here it'll still work right as long as e * D is equivalent to 1 mod P minus one so e d equivalent mod P minus one to 1 right as long as we satisfy this right we get this okay or sorry we get this okay yeah uh so the the the question was like what are we multiplying by K we're multiplying this P minus one right uh yeah so the the reason right FLT says that M the P minus one is congruent to one so m to the K * P minus one is going to be 1 to the K right so that's just one okay so no matter what K we put here this will still work now when you multiply by m that's just adding one onto the exponents okay so then you'll have you know m to the uh K * P - 1 + 1 should be congruent to to n okay does this setup make sense to people yeah question uh so the the question was why are we adding one onto the end so the answer was you know FLT tells us that we're going to get one what we really wanted was n okay so you know what what we want is uh you know m to the Ed is congruent to m not congruent to one so that's why okay so as long as we choose Ed congruent mod P minus one to one right we'll get this okay so you know more practically speaking how can we generate e and D like how can I find uh a solution to this uh congruence yeah sorry okay so the answer was TR different values of K uh okay [Music] so we're going to want to be using very large numbers here so that's going to be intractable we want to be able to do more efficiently so recall from uh Tuesday right this is saying that e and D are modular inverses modu P minus one okay how can we compute a modular inverse well one way is to use the pulverizer okay so if we choose e randomly and then pulverize this will give us D Okay Okay so we've got a way to generate Keys we've got a way to encrypt we raise m to the E we've got a way to decrypt we raise C to the D can anybody tell me a security flow why is this insecure so remember for public key crypto system right everybody knows the public key right and we don't want anybody to be able to figure out the private key from that so in this case our public key is going to be you know KP is going to be the pair uh P comma D oh sorry P comma e and our secret key is going to be the P the pair P comma D okay so this is what we need in order to encrypt this is what we need in order to decrypt I claim that this is insecure yeah yes so the answer was can't anybody else do exactly what we did right we started with the public key and then use it to to derive our our secret key if we then share that public key with everybody else everybody else can do exactly the same thing okay so our secret key isn't exactly secret okay so we would like to try and do something similar to this but in a way where other people can't you know repeat our computation can anybody think of how we might do this how can I make sure that nobody else can do the same pulverization yeah okay so the answer was choose a random D and then pulverize to find E I claim that this is exactly the same right it's it's the same process right um so you know like these two are basically symmetric okay so like if I share one of them then anybody else can can then find the other okay so the idea behind RSA right is that this modulus here the the thing that we're trying to pulverize with right and the modulus here the part of the key that we're sharing you know here they're off by one but in some sense they don't have to be okay so we'd like to find a way to share this but like not have this be so easily uh so easily computable okay how could we do that well instead of using a single Prime suppose we have two primes so let's call them p and Q okay and now uh our n is going to be their product P * Q okay so that's going to be what I want to share here okay uh but now this no longer quite works so instead of pulverizing with uh n minus one we're going to pulverize with you know uh sorry P minus1 * Q -1 okay why well suppose like you know suppose we we we have done this already suppose that Ed is congruent mod uh let's call this uh say m no M is for message let's call it n Prime congruent mod n Prime to one okay what happens if we take M and raise it to the Ed power what is this equivalent to mod n y okay so the answer was M yes why don't know fair enough I mean this is kind of you know what we were aiming for so you know very good educated guess uh how could we prove this yeah uh so this is supposed to be an N right so remember that uh you know when we encrypt and decrypt those computations are being done mod n it's only the pulverizing that should be done mod like using uh n Prime okay so we're we're trying to so we're we're assuming that Ed is congruent mod n Prime to one right and so we find that by pulverizing with with the N Prime but you know after that we can forget about NP Prime right we don't need nime anymore we're just going to do all of our computations mod n using you know e and D okay so does anybody have any ideas how we could prove this this statement here what exactly is the statement saying if we go back to the definitions yeah yeah exactly so you've skipped a couple of steps but um yes I will get to that in a moment uh so this is saying that you know uh n divides m to the E D minus uh M okay now at this point we can break apart this n so all we really need to do is you know prove that P and Q separately divide m to the Ed minus M or equivalently that uh m to the Ed is congruent mod P and Q separately to M okay so if we prove these two things then we're done okay so p and Q are symmetric so so you know let's let's only prove it for p the same same exact proof will work for Q okay so how do we prove now that m to the Ed is congruent mod P to n how could we do this any ideas yeah that's right okay so the answer was basically that we've already done it okay so remember that uh Ed is congruent mod n Prime to one okay so this means that n Prime divides Ed minus one okay well what is n Prime n Prime equal pus1 Q minus one so in particular Q minus one no P minus one divides Ed minus one okay so set otherwise e is congruent mod P - one to okay so that's exactly the uh condition we had over here yeah question uh so the question was how do we know P minus1 divides edus one uh P minus1 divides n Prime right we defined n Prime to be the product of Q -1 and P minus one okay so we know that n Prime divides this and one of our rules of divisibility was that you know then any factors of n Prime also divide it okay so we know that P minus one divides Ed minus one so that's just saying that Ed is congruent to one mod P minus one right and that's the condition we add here okay so now by FLT m to the Ed is congruent mod P to M okay so did people follow that so we've got congruence mod P by symmetry we also have congruence mod Q right p and Q are you know they're basically symmetric okay and now because they Prime right we can say that if you know p and Q both independently divide this difference their product must divided as well so that gives us congruence mod PQ okay questions yeah okay so the the question was can we uh you know go into this this step here in more detail okay so remember that's what we were doing over here right so fma's little theorem right says that M the p minus1 is congruent to one mod P okay so if we raise these to any power K right it's still going to be congruent to one okay so m to the K * P minus1 will also be congruent to one right so m to the K * P - 1 + 1 will be congruent to one okay this here is saying that Ed has that form it's some multiple of P minus one + okay so basically we're applying FLT repeatedly just as we did over here okay are people reasonably happy with this yeah okay so why are we using p minus1 and Q minus1 in the first place uh in short I pulled them out of my house so it would work uh so this is um you know it's basically a generalization of of FLT uh called Oilers theorem um it turns out that uh you know this P min-1 * Q -1 is what we call V of n where V is Oiler to function uh this counts the number of of uh you know numbers up to n that are co-prime with n so basically we can we can use the same proof uh as we did you know Tuesday uh to show that you know if we want to get rid of this assumption that P is prime over here uh we can replace this this P minus one with P of n uh and then then we get congruence mod mod n okay uh we just kind of proved the special case where n is the product of of two primes um but uh yeah basically it's it's kind of it's kind of a guess and check right like all we all we really need to know is that this works we don't really need to know how we got there okay Okay so we've proven that uh you know if we encrypt something by you know raising it to the uh eth Power mod n and then we decrypt it by raising it to the D power mod mod n we're going to get back to the same thing we started with Okay so this crypto system is at least you know correct right we can uh encrypt a message and then decrypt it again is it secure oh sorry actually why me just do that okay so uh is RSA secure right we we said before that if we're just using a prime instead of this product of two primes then uh anybody else can can computer secret key okay what are we doing now well one we're choosing random primes large primes so think of these as like having hundreds of digits okay okay uh next we're going to set n equals their product and uh let's just call it f of n nowal p -1 * Q -1 and next we're going to choose a random e co-prime with this and then we want to pulverize it we want to compute an inverse of e so why don't I write it this this compute a multiplicative inverse modulo uh F of n okay now what is the public key public key is going to be oops K sub p is going to be n comma e k sub s is going to be n comma D okay so before when we had uh oh question okay uh how hard is it to choose e that's that's co- Prime uh it's actually not that hard uh so in practice usually you would you know not choose it totally randomly you'd have a fairly small e so that encryption is efficient uh but if you wanted to do it totally randomly right like how many how many things are not co-prime to uh so yeah multiples of the prime factors yes um so let's see have you did we do the carmichel numbers yet no okay so uh well it turns out that if you choose a random a random number it'll actually be co-prime with reasonably good probability okay uh but you know in practice right we're going to just you know choose a fairly small e okay okay so we said that if if we just you know forget about Q use nals P this doesn't work because anybody else can then you know compute our our secret key in the same way as we computed it ourselves why does this not happen here why can nobody else compute the secret key given the public key yeah yeah so the the basic idea is that we're relying on factoring being hard okay uh so the the basic idea right is that if you have n it's it should be hard to to come up with with p and Q okay and I claim that this is actually a much safer assumption than was used with Enigma uh because this is a very well studied problem like people have been trying to factor things more efficiently for you know hundreds of years right and you know mathematicians have not found an efficient way of of doing this so in particular the adversary will will also presumably not be able to do it right it's not just saying like I personally couldn't come up with a with a good factoring algorithm this is you know relying on you know many years of of work by many mathematicians okay it still is possible that that factoring isn't hard like you know and in fact maybe maybe somebody already knows how to do it they've got they've got their algorithm they just haven't published it uh but the assumption is basically like if one could do it then one of these mathematicians would have would have figured it out okay like one of these World experts okay uh so more formally though if we could compute the uh uh ah okay question was isn't this just cryptography by huis okay I claim that I'm not relying solely on you know my own intelligence I'm relying on you know everybody else like the the entire field of mathematics okay like like many mathematicians have spent like their entire careers trying to you know Factor things quickly and nobody's figured out how to do it yet it's not just like you know I was spending half an hour in my basement and you know I I couldn't figure out a good algorithm in that time you know like the the the Enigma engineer right like you know he just came up with something and then couldn't figure out a way how to a way to to break it and so kind of just assumed security from that right so it's it's kind of you know me versus the entire field of of mathematics okay okay so yeah I guess the question is you know given uh so if we had an algorithm that would you know compute the secret key from the public key how would this Factor end right notice that the uh secret key doesn't actually contain p andq so I suppose as described we aren't quite relying on the hardness of factoring we're relying on something slightly different yeah oh sorry uh no how do how do we um so if we could find the uh the private key the secret key given the public key how would this then factor in right we we would like to rely on the the hardness of factorization okay so the the answer was basically that that you have to come up with the prime factors p and Q before you can uh before you can compute uh D from e uh we would like to say that you know no matter how you do it you're still basically going to end up with the factors p and Q right like you will have solved the problem even if you didn't intend to does that make sense okay so suppose I have n e d okay so suppose I've I've used the uh the public key to come up with the secret key so now I have these three pieces of information right does this now allow me to factor in does anybody remember the quadratic formula from uh from grade school it's okay I don't either okay [Music] so if I have end d right Ed minus one should be a multiple of P -1 * Q -1 okay what happens if I reduce that mod in hm I get one uh if I reduce it mod P - 1 * Q -1 I get one yeah get p and Q okay let's let's make it a little bit simpler suppose I actually have p minus1 and Q -1 or P -1 * Q -1 if I had that could I factor in for so if I had that I could oh yeah mhm yeah so if we actually had P min-1 * Q - one we could use that to figure out the sum of p and Q we know their product we can use the quadratic formula okay what happens if we just have Ed uh sorry e and D can we do something similar oh actually I'm running quite short on time okay uh why don't we hold off on that uh let's just take it on faith that we're relying on factoring being hard let's move on to uh the last thing that we wanted to cover today which is a uh slightly different application of uh of number Theory which you may find useful in uh you know throughout computer science um notice where is it uh okay here so here we kind of uh we're trying to work mod n right n is the fact or n is the product of two primes and we said that it's easier instead of working mod n we're going to work mod the two primes individually okay so it turns out that this this is something that you can do in general right uh this is what we call the Chinese remainder theorem right uh if you have uh in fact if you have two co-prime numbers p and Q working modulo their product is equivalent to working modulo each of them individually okay and often working modulo you know the the smaller numbers individually is going to be you know much easier than working modu the the large number okay so as a very simple example uh suppose we have the following uh actually strictly less than 55 okay and we know that X is congruent mod 5 to 4 x congruent mod 11 to okay I claim that we have enough information now to Unique identify X okay can anybody do it how might we do it yeah okay uh so the answer was you know try everything between 0 and 55 uh see what they're con to mod four or Mod Five see what they're conent to mod 11 and see whether it satisfies both of those I claim that we can do it slightly faster than that uh why don't we enumerate everything that satisfies uh this congruence first okay so what is congruent to seven modul 11 in this range right so that tells us that maybe I should write it down here oops X is in the following set 7 18 51 and if we add 11 again we get past okay now we only have to check uh five numbers to see which is congruent to uh uh to four modul 5 and if we look at them 29 is the only one that works okay so it turns out that there's a unique answer modulo okay and we can actually do this in general and in fact even more efficiently so Chinese remainder theorem often abbreviated CRT so suppose p and Q are co-prime okay and a and b are integers okay and we have the following system of congruences okay so if we have this then there is a unique solution there's a unique X that satisfies this modulo PQ okay so how might we prove this what what are the elements that we need to prove yeah sorry oh here fien uh here fien yeah so you don't have to worry about what this is actually called we could call this n Prime but yeah sorry this was just following up on on what one of your classmates asked uh earlier okay so what are the elements that we need to prove in order to prove this this theorem here well we need to prove existence and then we need to prove that there don't exist two solutions okay so let's start with let's start with existence why does there exist a solution maybe we can start thinking about a special case so suppose uh suppose for for a start that a equals Zer okay how could we find a solution uh to X congruent uh to b modul q and x congruent to zero modul P yeah sure yeah so the relation here is that uh you know we've got our p and Q are 5 and 11 right our A and B are 4 and seven and so we're saying that there's a unique solution to to you know this system of congruences modulo 55 which is their product okay or you know you could also phrase that as there is a unique X in this range like a unique integer X in this range okay so we're just kind of we're just kind of G to generalize this kind of to um you know a more General p and Q more General A and B okay question or oh sorry okay well if we look at the special case where a equals z why don't we start by defining uh P minus one p inverse uh to be a modular inverse of p modulo q okay and now let's multiply that by P to get the integer uh e subq okay now what can we say about e subq what is it congruent to modul p yeah yeah so we defined it to be a multiple of P so e subq is going to be congruent mod P to zero okay what about modulo Q what is it congruent to modulo Q yeah one yeah so by definition right P inverse is a multiplicative inverse of p modul q so when you multiply them you get one mod Q okay so how can we use e sub Q to get X remember remember we're thinking of the special case where a equals z so we're trying to find a multiple of P that's congruent to b modu q anybody yeah yeah so the answer was multiply EQ by B okay B * EQ now is congruent to zero modul p and 1 * B which is B modul Q okay does that make sense to everybody so for the more General case we are going to Define uh e subp analogously okay now how how do you think we could solve the more General case instead of just B * zq how do we then you know fold EP into it y yeah so claim X equal a e p + b e q is a solution okay so we can verify each of these two congruences separately right so if we look at the first congruence what happens if we reduce this x modu p well modulo P this EP here is congruent to one so this term becomes a uh we said that EQ is defined to be a multiple of P so the second term just goes away so modulo p X is now congruent to a modulo q it's exactly the opposite right this term goes away because the the EP was defined to be a multiple of Q right and uh sorry yes this is defined to be a multiple of Q and uh I've done it the wrong way around haven't I Q mod q no no we're fine okay so EP is a multiple of Q the a term goes away uh B * EQ is going to be one okay sorry B * EQ is going to be B okay so what about uniqueness how might we prove uniqueness what is the what is the setup going to look like yeah okay so the the idea was show that any candidate solution so let's say x Prime is actually the same solution okay so let X and X Prime be to Solutions okay now what are we trying to show yeah uh not equals so we're not trying to we're not trying to prove there are unique integers right we're trying to prove that it's Unique modul PQ so we want to show that they're congruent modul PQ okay how can we do this well what is the definition of this equivalence we could do this by showing that uh you know PQ divides x - x Prime now in order to do that right we can look at p and Q separately okay so why does p divide the difference well both of them satisfy that first equation or that first congruence okay so both of them are congruent to a modulo p if you subtract them you get zero okay so P divides the difference now because they both satisfy the second congruence right uh you subtract them you get B minus B right so there so the the so Q divides the difference as well okay so p and Q individually okay and by assumption they're co-prime so their product must then also divide the difference okay okay so that means that x and x Prime must be congruent modu of PQ okay so that's all we have time for today um yeah you'll see you'll get more practice with uh RSA and CRT in uh in recitation tomorrow and uh yeah feel free to uh come up if you have questions