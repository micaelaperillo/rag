Good morning. Good morning. Welcome. Welcome to lecture 11 of 6120 61200. I never know how to pronounce it. It's one of them probably. Um we have finished our number theory unit and we're now starting a new unit on graphs. Graph theory. Um this is a a new topic, a new kind of mathematical abstraction that we'll see oops that we'll see um really interesting uses for across this class, across algorithms, across other contexts as well. Um before we dig into what they're good at, let's talk about a bit about what they are, how they're defined. Uh so I've written an example of a graph up here. Totally clear, right? It's easy to read and comprehend. Um but let me define it for you. So a simple graph let's say a simple undirected graph which are the only kind of graphs we'll be talking about for the next couple lectures um is defined as a pair. So G is the graph G is a pair V comma E where V is a non empty set of what we call nodes also known as vertices. Um and E is a set of two element subsets of V. Not all of them but some of them possibly none of them could be all of them as well where um any amount that you want. So a graph is just a set of um a set V um where we call the objects vertices or nodes. Um, sorry. These are edges. So, it's a set V of nodes and a set E of pairs of nodes. And those pairs are called edges. So, in its purest set theoretic form, here is a graph. Here's a set of vertices. Here's a set of some of the two element subsets of V. Of course, I don't really think about the graph in this form. Let me give you an alternative way to uh express this graph up here. One, two, three, four, five, six, 7. Uh these are going to be my nodes. This is A, this is B, C, uh D, E, F, and G. And anytime we have an edge, let's connect them by drawing an arc between them. So we have AB, AC, and BC. We have these, these, these, this, this, and this. This is a visual representation of this graph, but it's conveying the same information. This is a lot easier to look at in my opinion, but they're both conveying the same information. This is the general idea of a graph. It's a set of vertices which are the dots and edges which are the segments connecting them. Does that make sense? Wonderful. Um I want to mention that there there are some subtle differences in the definitions in other sources. Um sometimes uh sometimes uh when people are talking about undirected graphs um some people will allow what are called parallel edges. Oops. which is when you have two different edges connecting the same pair of vertices. Um or uh self loops which is when you have a single edge connecting a vertex back to itself and we are disallowing both of those. So we will never be working with graphs like this that have parallel edges or that have self loops. Uh so that is what what people usually mean by simple. Um and it's why all of the undirected graphs we work with are going to be simple. Um likewise some sources allow the vertex set to be empty. U I stipulated up there that V should be a non-MP set. Um, so we're just disagreeing on a single graph that has zero vertices and then necessarily zero edges because there's nothing to connect. Um, the reason we are not allowing that for our purposes is that often it's going to be a counter example to a lot of the theorems we want to state. We would always have to say for every non-mpy graph, for every graph with a positive number of vertices, something like that. And it just gets cumbersome. Um, so we chose this definition because it makes that more convenient. Not really a big deal, not really something we'll need to think about much. It's just a part of the definition to be vaguely aware of in the back of your mind. Um, we do allow the set of edges to be empty. For example, here is a graph with five vertices and zero edges. Let's call them vertices one, two, three, four, and five. Five vertices, zero edges. That's totally fine. That's a valid graph. Uh so this has an empty set for the set of edges, which is fine. All right. Um so what are graphs good at? Um graphs are great at representing um two-way relationships between pairs of objects. Uh let me give some some real world examples like friendship. Um you can imagine the graph of all the friends in the world. Uh the the vertices here let's see the friend graph the vertices are going to be the set of people each person is a vertex. The set of edges is pairs of friends. Now I'm making an assumption here that friendship always goes both ways. If I'm friends with you then you're friends with me. No unrequited friendships here. Um, for example, Facebook friendships always go both ways. You're either friends on Facebook or you're not. Um, so the graph of Facebook friends is a concrete representation of this kind of thing which is which can be interesting. Um, whoops. Uh, let's see. Another example is the brain. The brain is just a network of neurons. The neurons are the vertices. neurons and connections. Some neurons connect to neighboring neurons and it's those neurons and their connections that somehow creates cognition and memory and intelligence and I wish we understood how but at least it's a graph. Um, also we have the internet. Um most network connections on the internet go both ways network connections. So the servers are the vertices and the which servers can talk to which other servers u are the edges. Uh and most communications have to go both ways because you have to like communicate back and forth and make sure that each of you trusts the other party before you actually send any information over. So you have to go both ways to to make that connection first. Uh and then you can send information in whatever direction you want. Um a non-example is hyperlinks on websites. If site A has a link that takes you to site B, there isn't necessarily a link back. Um so this would not be an example of an undirected graph. That would be a directed relationship which we're going to talk about later after break. Um but that's not an example for today. Similarly, Twitter followers is a directed relationship. If I follow you, you don't necessarily follow me. So that would be a directed graph which will fit into um into lectures after break, not this one. Um all right. And graphs uh I said earlier graphs are a really useful abstraction. And I claim that they're useful because uh they strike a nice balance between simplicity and complexity. On one hand, graphs are simple to define and describe. They're simple conceptually. It's just a set of objects and a set of pair-wise relationships. um easy to define. So, as we just saw, there are lots and lots of real scenarios that can be modeled faithfully as a graph. On the other hand, they're complex in that there's a rich mathematical theory of graphs. There are lots of powerful tools and definitions and theorems that we can bring to bear anytime we're trying to analyze a graph and therefore we can apply all of that to all the real world scenarios that we have been able to model as a graph. So it's a really nice balance between the two. Um so let's dig into this rich mathematical theory and see what what tools and theorems we can develop. So the next definition is vertex degree um sorry the next definition is um adjacency. Let's see. Two vertices U and V are adjacent adjacent if and only if um they're connected by an edge. i.e. UV is one of our edges. So there vertices are adjacent if they're connected by an edge. Um we'll say that uh let's see an edge UV has end points U and V. Just the the two end points of the edge. And we'll say that edge uv is incident to u and v. So a vertex and an edge are incident if that edge has that vertex as one of its end points. Um these words sound a little alike. Adjacent is used for two vertices that have an edge between them. Incident is used for an edge and a vertex where the vertex is an endpoint of the edge. Um but useful terminology. Uh and that lets us define the next thing which is for a vertex V. Uh the degree of V is the number of edges uh incident to V. So the degree of a vertex is the number of edges it has. So what's the degree of E? Just yell it out. Three. Yeah. One, two, three. What's the degree of C? Four. Degree of f two. What's the degree of this vertex two? Zero. It doesn't have any edges. Excellent. Degree is just the number of incident vert uh incident edges. Wonderful. Uh you can understand some not everything but some things about a graph just from the degrees of its vertices. Uh for example uh that graph way over there on the left. The degrees of its vertices are let's go through them all. We've got 2 2 4 3 3 2 in that order. I think I got that right. Sometimes this is called the degree sequence. That's less important than the degree itself um than the concept of degree itself. But we can we can play with this concept a little bit. For example, does there exist a graph with degree sequence 2 2 1? Sorry, that's supposed to be a question mark. There we go. Does there exist a graph with degree sequence 221? So, three vertices, two have degree 2, one has degree 1. Think about that for a second and then we'll try it together. Okay, I see someone violently shaking their head. I think they're cracking their neck. Uh, let's try it. Um, so 221 means we need three vertices. One, two, three. Um, first vertex has degree two. Well, there's really only one way to do that. It has to connect here and here. The next vertex also has to have degree two. Well, that means it also has to connect there. Only way for it to get a second edge. Then the third vertex is supposed to have degree 1, which it doesn't. So we're sad it didn't work. Um, you can think of this, by the way, as a proof by contradiction. Um, if there were a graph that satisfied this, then it would have to look like this. But this graph doesn't work, so nothing works. Sound good? Okay. But what if we asked a more complicated uh version of the question? Does there exist a graph with degree sequence two two two one? This time there would need to be six vertices and now there are lots of ways that we could choose two edges for each of those vertices. Um so there are lots of cases that we would need to try out in our proof by contradiction. Um so maybe a different strategy would work better. Does there exist a graph with this degree sequence? Yes. always. No, because the sum always has to be even. Interesting. Why does the sum have to be even? All right. So, if an edge connects to one vertex, then it also can connects to another vertex. So, each edge is somehow counted twice. Yeah, that's exactly the right intuition for the following theorem. In fact, that's the correct proof for the following theorem. Um, we've got the handshake shake lema. Let's see. For graph G, which is vertices and edges, we have the sum of vertices in the set of vertices of the degree of that vertex equals. So if you take all the degrees and add them all up, um your colleague here claimed that what you're going to get is 2 times the number of edges. And we can see that for this example, if we add this up, 4 8 14 16 18 and there are nine edges, that checks out. Um and the reason this is true is also exactly what your colleague said earlier over here. We're adding the degree of every vertex um which means we're basically counting every end point of all the edges and every edge has two end points. So every edge was counted twice in this count on the left. So that's the handshake lema. It's called handshake lema because if you imagine a room full of people and some pairs of them shake hands, then if each person counts the number of handshakes they had and you add that all up, that equals two times the number of handshakes because each handshake had two hands involved. Um it's exactly the same explanation and proof. It's just with hands uh instead of um pairs instead of half edges. Um all right. So does this help us with that? Can someone tell me why there doesn't exist a graph with this degree sequence? Yes. Yeah, because the sum is odd. Um, this would have to have what? 11 divided by two edges, which isn't great. Uh, I don't know how to draw a half edge in these graphs. So there is no such graph. Awesome. Here's one more application of the handshake lema. Uh let's see. What is the maximum number of edges in an nvertex graph? What is the maximum number of edges in an nvertex graph? Um well each vertex has degree at most n minus one because at most it connects to all the other vertices. There are no other vertices to connect to. You can't connect to yourself. You can't repeat any connections. Uh once again that's what we meant by simple graph and all our graphs are simple. Um so every vertex has degree at most n minus one. So the sum of the degrees uh is at most n * n minus one. But the sum of the degrees is equal to 2 * the number of edges. So the number of edges is at most n * n minus one / 2. Didn't have to do any fancy induction. Didn't have to compute some sum. I wonder if this equals a sum that we've seen before. Um, but so we have an upper bound. The number of edges is at most that. And turns out this is achievable achieved by the complete graph kn which is the graph with n vertices and all possible edges. So this vertex connects to everyone. This vertex connects to everyone. This connects to everyone. Connects to everyone. I think I got them all. So this is a drawing of K6. There are six vertices and everyone connects to everyone. This graph indeed has every vertex with degree N minus one. So it has exactly this many edges. Um the K for KN this is standard. You'll see KN uh everywhere. I think it comes from German. Uh it kind of sounds like complete graph, right? Um, but we'll be using this notation a lot. All right, let me ask another question. Um, so most of us here are MIT students. I know we have some crossregistered students. Welcome. You're um I'm glad you're here. Um, for the MIT students in the room, do you have any friends at Harvard? Yeah. Awesome. Um, okay. So, I got at least one hand. I got more than one hand. But let me ask, how many Harvard friends do you think the typical MIT student has? Don't answer that. It's rhetorical. Uh, what about the reverse question? How many MIT friends does the typical Harvard student have? Which one's bigger? Let's see. So on one hand we've got the average number of Harvard friends for the typical MIT student or the average number of MIT friends for the typical Harvard student. Which one's bigger? And how could we know? How do we how can we decide this? Maybe I could do a big survey. I could sample a bunch of MIT students, sample a bunch of Harvard students, um take the average of whatever is reported and and take that as ground truth. Um that is how a lot of empirical statistics ends up working. Um can anyone suggest a better way? Yes. All right. Uh, so let me let me rephrase that. Um, so we know that every friendship goes both ways. There's one MIAT student and one Harvard student. Again, we're assuming friendship is uh is two-way, no unrequited friendships. Um, can't the two schools just get along? Um, but because there are the same number of friendships on both sides, um, when we're taking the average, we're dividing by the number of Harvard students and dividing by the number of MIT students. But Harvard has more undergrads than MIT, so we've divided by a bigger number. So, the MIT average should be bigger. Woo, that was a lot. Um, thank you for saying all that. Let's unpack it a little more slowly. Um, but you are absolutely correct in every step of your reasoning. Um, so what I'm going to do is let's draw a graph where the vertices are going to equal um the set of MIT undergrads and the set of Harvard undergrads. Um, and I want to emphasize that these are two disjoint sets. No student is enrolled in both schools. Um, we're not counting cross registration. That's why I mentioned that earlier. uh and sometimes to emphasize that these two sets are disjoint sometimes you put a little dot inside the union sign. So our set of vertices is the disjoint union of MIT students and Harvard students. And um our edge set is going to be the set of let's see M comma H where M is an MIT student, H is a Harvard student and M and H are friends. And we can draw an example of what this might look like. So here's all of my Harvard vertices on the left. Here's all of my MIT students on the right. Um here we have like I don't know Bill and Helen and Natalie and Neil and TS on the right. Maybe we have uh Buzz and Kenji and Lisa. And these lists go on. Um, this is just an example. I don't know if they're actually students with these names. Um, and some pairs of them are friends. Maybe these are friends. And these and these are friends. And Buzz is just friends with most people. And TS only likes Lisa among this graph. Some pairs of them are friends. Here's our graph. Again, there are more vertices, more edges, but here's an example of our graph. And this graph has a special property called bipartite. This is a bipartite graph. Um let's see definition um G is bipartite um when it's possible to partition V as the disjoints disjoint union of two sets. I'm going to call them left and right. That's common notation for for bipartite graphs. um such that every edge has one end point in L and one end point in R. So you have some vertices on the left, some vertices on the right, and every edge crosses between them. One end point on the left, one end point on the right. These graphs are called bipartite, and the one we just drew certainly has that property. Sound good with me so far? Awesome. And now um we have a bipartite version of the handshake lema. Let's see. handshake lema bipartite which says that if you add up all the degrees just on the left the vertices in the left side degree of v. Well, every edge has one endpoint on the left and one end point on the right. So this is just equal to the number of edges. And likewise you can do the same thing on the right. So all the degrees on the left add to the number of edges. All the degrees on the right add to the number of edges. But remember we are interested in the averages. The average degree on the left versus the average degree on the right. All right. So, we've got, let's say, average degree on the MIT side divided by the average degree on the Harvard side. Well, this is equal to the total degree on the MIT side. So, just adding up all the degrees um of the MIT students divided by the number of MIT students. And this denominator is the total degree on the Harvard side divided by uh the number of Harvard students. Right? That's what we mean by average. Add them up, divide by the number. Add them up, divide by the number. Okay? But we just said that the total degree on the Mside and the total degree on the H side, both of those are equal to just the number of edges. So this is the number of edges divided by the size of M. divided by the number of edges divided by the size of h. The e cancel. This just becomes the size of h divided by the size of m. All right, we've now caught up to your comment. Thank you so much. Um, and now we can just ask how many students there are in each school. Um, this is about, let's see, I wrote something down. About 7,200 divided by 4600. Those are close anyway. They might be a bit out of date. Um, but this is about 1.6. So, the average MIT student has about 1.6 times more Harvard students, Harvard friends, uh, than the number of MIT friends the average Harvard student has. And that's not um any judgment about behavior on the two sides of the schools. It's just a fact about averages uh after knowing a little bit of graph theory. Um but our number is bigger so we're better. Um, but so already we've just defined a couple things and we've already been able to prove some non-obvious theorems and facts. Um, again, they still look like toy examples, but there are real scientific studies that have studied questions like that and not known the graph theory and then came up with conclusions that were very obviously wrong to anyone who did know the graph theory. Um for example uh there's a very famous study um out of Chicago from 1994 uh called the social organization of sexuality sexual practices in the US. Uh so it was a big sweeping um study about sexual practices and behavior and health across the country. Um they had thousands of participants. They asked lots and lots of questions and came up with lots of statistics and measurements and trends and published all their results in a big 700page writeup, a very famous study. Um, and out of all the questions they asked, I'm going to single out one of one of them uh for the single purpose that their results are obviously wrong because of exactly this argument. So, one question they asked um specifically to their male and female participants um they asked the men um how many female partners they've had. They asked the women how many male partners they've had. Um don't worry, they had lots of other questions about other kinds of relationships. Uh they had lots of other questions for their non-binary participants as well. Like I said, I'm just singling out this one of many questions. Um so, what's the average number of female partners a man has had? what's the average number of male partners a woman has had. Um, and according to their reports and surveys, um, the men reported about 1.74 times as many partners as the women. Um, let's see. So the average degree of the men um was equal to about 1.74 times the average degree of the women. Um, a different study, this time from ABC News in 2004, um, got a similar result, but instead of 1.74, so sorry, this was from Chicago, um, ABC News approximated this number to be about 3.3. Um, yet another study from the National Center of Health, National Center of Health this time from 2007 got this number to be about 1.75 when of course we know the exact answer. This ratio should be the number of women divided by the number of men. Because of the specific question they were asking about this subset of relationships among this subset of the population. They put themselves in a bipartite scenario where this theorem applies and the correct answer is just the number of women divided by the number of men. The uh let's see the number of women divided by the number of men which um according to the 2010 census was about 157 million over 152 million which is about 1.03. 03. The correct answer is 1.03. And it's not a question of behavior. It's a question of just averages. Uh there is nothing to learn from this ratio except this is how many men and women are in the country. Not a very interesting example for a behavioral study if you ask me. Um I'm not going to speculate on why these numbers don't match reality. Um, I don't know. Think about it yourselves if you want. Uh, are there questions about this example or anything else we've talked about so far? All right, let's move on to another topic in graph theory, another common application. [Applause] So instead of measuring affinities or friendships among pairs of objects, let's measure conflicts between them. So here's an example graph. Let's say let's define the vertex set of our graph to be the set of all MIT classes with a final exam and E is going to be pairs of classes. is C1 C2 that have someone enrolled in both. So you're the registar. Your goal is to assign a time for the final exam for every class. And if some student is taking two different classes and those classes are scheduled for the same time slot or overlapping time slots, then that student can't be in the same place at uh can't be in two different places at the same time. So you have a conflict. So this graph here is measuring all of the conflicts among uh final exam times. There's an edge precisely when the two classes can't be scheduled for overlapping times. Does that make sense so far? Cool. So, edges are conflicts in exam scheduling. And let me draw an example. Let's see. So in this example, MIT only has five courses. Um six um 3700, 6,000, 6200, 6 3,000, and 64,100. So this is some fake approximation of what this graph might look like. So, this says that there's someone taking our class and 62000. Um, there's some people there's at least one student taking both of these classes. There's no one taking uh 6 3700 and 63000. Um, so for example, these two are allowed to be scheduled at the same time. Um, so this is listing all of our conflicts. And this brings us to the graph coloring problem. [Applause] Uh, so we say that a proper K coloring a proper K coloring of a graph G uh is defined to be I'll write it down mathematically first and then explain it in words. a function f from the set of vertices to a set c of colors um where there are at most k colors and for all edges uv fu does not equal fv. So in other words, we have some set of colors available and we want to assign a color to every vertex. Um, and we want to assign a color to every vertex so that no two adjacent vertices are ever assigned the same color. In this example, you can think of colors as time slots for final exams. If two vertices are given the same color, that means that they'll be administered at the same time. And this condition that edges have to have two different colors on their endpoints means that anytime there's a scheduling conflict, they will always be given different colors, which means they'll be given different time slots. So this is what we mean by a proper K coloring. It's an assignment of um of a color to every vertex from a possible choice of K different colors where the two end points of every edge are assigned different colors. Uh, and as an example, so let's let's try to color this graph. Um, okay. I'm going to color let's say I'm going to color this red and this green and this blue and this yellow and this purple. Is that a proper coloring? Yeah. Yeah. Every edge has two different colors on its end points because all the colors are distinct. This is a proper five coloring. Can be five colored. All right. But that means we need five different time slots for the final exams and we'd like to be a little more efficient. Uh can we color this with just four colors? Yes, I claim we can. Let's make that red instead of purple. Now, this class and this class are both red, but because there's no edge between them, uh, that's fine. All of the edges have two different colors on their end points, and that's all we need. All right, so this can be fourcolored. Can we do better? Can we get away with just three colors? All right. Interesting. I'm seeing one headshake and and one head nod. Um, so yes, please. How about making the yellow? Make yellow red. Okay, we'll make this blue or green. Yeah. All right. So, we've got red, green, blue, red, blue. So, we've got two reds, but there's no edge between them, so we're fine. And we've got two blues, but there's no edge between them, so we're fine. This is absolutely a valid threec coloring. can be three-colored. Can this be 17 colored? Is there a proper 17 coloring for this graph? This is a bit of a weird edge case, but yes. Um, this set C um says that there have to be at most 17 colors available. We don't have to use all of those colors. Um so if we were if we had a 17 color palette and we found this proper coloring that would be a be considered a valid 17 coloring. So this is a valid uh this is a proper 17 coloring of the graph but more directly it's a proper three coloring because usually we're trying to minimize the number of colors. All right. And we can make that notion concrete definition. Uh the chromatic number of a graph G. The chromatic number is denoted kai of G. That's a lowercase Greek. Kai is the smallest number of colors needed for a proper coloring of G. All right. So, the chromatic number asks, what's the fewest colors you can get away with? Um, in our scheduling problem, what's the fewest number of time slots that we need to cover all of the final exams? Um, for this graph, what is its chromatic number? Have we shown that it's three? First of all, is it five? Is the chromatic number of this graph five? Why not? because we can we can get away with fewer colors. That's right. It's not five because we can do fewer. Uh it's not four because we can do fewer. Is it three? I don't know yet. Can we get away with fewer colors? Well, let's see. Um can it be two-colored? Is there a proper coloring with just two colors for this graph? And in this case, there isn't because this triangle right here shows us that all three of these vertices need different colors. Uh you can think of this as a proof by contradiction as well. Assume it's possible to color with just two colors. Well then, well, these three vertices would have a conflict among them somehow, which is a contradiction. Um so cannot be two-colored and these two statements together can be colored with three colors cannot be colored with two colors. This is what we need to confirm that the chromatic number is three. Three is the smallest because three works and fewer doesn't work. uh and I want to emphasize that in general to show that the chromatic number of G is some value K um usually we need both an upper bound and a lower bound. We need an upper bound which is that K of G is less equal K. And how do we prove that? usually by giving a K coloring. If you know it's possible to color in K colors, then the chromatic number has to be K or smaller. Give a K coloring. But you also need a lower bound that K of G has to be greater than K minus one. And how do you prove that? You prove you have to prove that it can't be kus one colored usually by contradiction. So I just wanted to emphasize that the definition of chromatic number as the smallest thing that works there are two parts to that. It works and nothing smaller works. Make sense? Cool. All right. So, let me Yes. So, graph coloring. We've seen one application which is the registar scheduling final exams. They actually do something exactly like this. By the way, this is why uh final exam schedules don't come out till a couple weeks into the semester because they need to see who's enrolled in which pairs of classes so we can try to schedule those um apart from each other. They're trying to find a coloring with few colors. Um in practice, if they were looking for an actual proper coloring with no conflicts whatsoever, probably wouldn't fit into exam week. So instead they're looking to minimize the number of conflicts which is a slightly different problem but still an interesting one. But there are lots of scenarios where you're trying to avoid conflicts um just like the registar is trying to avoid conflicts. So other coloring applications, um, a really common one and one that's appropriate for this computer science class is register allocation. When designing compilers, um, you have multiple values that you're trying to compute, different operations you need to do with them. Yes, matters, that's a great question. Thank you for asking. Um, do the elements of C matter or just the size of C? C is the set of colors available. Um, so if you change the set C, then you're you're giving a different coloring because your colors mean different things. Um, but you're not going to change how many colors are needed. You're not going to change the chromatic number if you change the set of colors available. Um, and you you said we could have put like green green here instead of here. Yeah. Like we could have made the reds could in could instead be green and this green could be red or this green could be yellow. Now we've got some greens, some blues, and a yellow. Still three colors, different coloring because we're assigning different colors to them, but um still the same number of colors. And often for the applications we're about to talk about, the number of colors is all that matters because the colors just mean these are the different classes that you need to put them in. and then you do something with each class. Um so this application register allocation when you're computing multiple values um the your processor has a small number like 16 or 32 registers which are really really fast memory that it can um that it can do operations on and in fact it has to bring data into a register before it can compute on them usually. Um, and some values you're computing and you need lots of different pieces to go into that computation. Some values, well, you're done with it. You don't need to remember it anymore. So, let's evict that and put something else in that register. And ideally, you can figure out a way to schedule all of your values in the different registers so that everything fits in the registers and everything's fast instead of having to spill them out into RAM. um you don't need to understand compilers or exactly what I'm saying here. The point is um your variables, the values you're computing have different lifetimes. Times when they need to still exist and other times when you're allowed to forget them. Um and compiler writers often draw exactly the conflict graph between these lifetimes. This value has to exist at the same time that this value also has to exist. So they can't be in the same register um because then one would overwrite the other. And if you can write down your conflict graph and find a coloring with a small number of colors um ideally smaller than the number of registers available then everything works in registers and you're really fast. Um another one is radio tower frequencies. Um, if each if each tower in a radio network needs to broadcast with some frequencies, well, if two towers use the same frequency that can reach the same places, then they're going to conflict. You're going to get static in the noise. You're getting noise from two different places at once. Um, so any conflicting towers need to use different frequencies. And this is again a graph coloring problem. Um, draw your your conflict graph, color it with a small number of colors. each color is a different frequency. And since different towers that are assigned the same color don't have an edge in the conflict graph, it means they don't conflict. And so they're allowed to use the same frequency just fine. Um, in general, where did I put this list? Way over here. No, come back. Um, let's see. Map coloring. Uh a while ago, Eric told us about the four color theorem that every planer map uh every map that you draw uh on a sheet of paper, you can color all the regions in different colors so that two neighboring regions never have the same color. Uh and four colors is always enough. Excuse me. Um this is just saying that certain kinds of graphs can always be fourcolored. Not every graph but certain kinds of graphs um the so-called planer graphs can always be fourcolored. Um this is this is the language that that proof is written in. It's it's a theorem about graph theory. It uses graph theory. Um but it's an example we've already seen which is nice in general. Anytime you're trying to avoid pairwise conflicts, graph coloring is a great tool to reach for because it's such a great tool to reach for in many contexts. Wouldn't it be great if there was a really fast, simple algorithm that says, "Here's a graph. Here's a target number of colors. Please give me a coloring, a proper coloring that uses this number of colors. Um so an algorithm to k color any input graph um or decide it's not possible if I'm the registar and I know I have what is it five days of exams two sessions each so I have 10 different exam sessions I really want a 10 coloring of my graph Um and so I want to ask please give me a 10 coloring of this conflict graph and then that's my schedule. Is there an algorithm to do that? Um likewise uh instead of asking give me 10 colors um you can ask algorithm to compute k of g. I don't know in advance how many colors I'm expecting. Just give me the best coloring. Give me a coloring that uses the fewest number of colors. Is there an algorithm to do that? That would be really great in lots of applications. Um, unfortunately, I'm talking in hypotheticals here because these algorithms very very likely don't exist. Uh, these problems are what we call NP well this problem's nplete. This one's possibly even harder. Um, at least this problem is npmplete. Like I said, this one might be even harder than NP. Um, what does this mean? I don't care so much. Uh, I don't really want to dig into what NPMPlete means right now or NP hard or any of those things. What I will say is that there are thousands upon thousands of computational problems like graph coloring um like the traveling salesman problem if you've heard of that one it's pretty famous um like sudoku on n squ by n squared boards instead of just 9 by9 um there are thousands upon thousands of these problems that computer scientists have decided are all equally difficult So if we were able to find an efficient algorithm to solve any one of them like to solve the k coloring problem then that would immediately give us an algorithm to solve all the other ones efficiently as well. Uh and all the problems that are easier than those. Um a notable problem that we've already talked about is factoring large numbers. This is known to be in NP. It's not known whether it's NP complete. It's in fact thought to be even easier than than most of these. So it's thought that factoring numbers is somehow easier than K coloring your graph. Also, by the way, even if we're just asking for three colors, does this graph have a coloring with just three colors? That's already nplete. That's already too hard. and we don't believe there's going to be an efficient algorithm for it. Um, so if you solve this easier problem, factoring large numbers, if you find an efficient algorithm for that, well, you'll be able to break all the public RSA keys, uh, read everyone's encrypted messages, steal all the electronic money, um, including the real currency from electronic banks, um, run from all of the world governments that are trying to hire and/or silence you. Um, but if you solve the even harder problem of threecoloring a graph, you get all that plus a million-doll prize for solving a famous millennium problem. So, you've got choices. Point is graph coloring is a hard computational problem and we strongly believe most computer scientists strongly believe that there is no efficient algorithm um for graph coloring and so we're not it's not realistic at least for very large graphs. It's not realistic to ask for um a coloring with a specific number of colors or the the best possible coloring, which means that our applications are a little bit sad because sometimes we really want optimal colorings. Thankfully, in practice, um optimal colorings aren't really necessary. Sometimes we can get away with good enough. Um, and so for all of these NP complete or NP hard problems, the best you can hope for is an algorithm that's good enough. Um, usually the answer it gives is a little worse, but it runs faster. Uh, and let's let's see an algorithm for that to give us some colorings of graphs, even if they're not always optimal colorings. All right. So we have a greedy coloring algorithm. Um and here is the idea of the algorithm. So first of all, um we're going to order the vertices v1, v2 vn. So we're going to pick some ordering of the vertices. Uh we're going to order the colors. Uh I'm going to use my favorite color palette. One, two, three, and so on. Those are my colors. Um and then for each vi in order so we'll look at v1 then v2 then v3 and so on and we'll assign each of them a color one at a time. Um, assign vi the smallest color that doesn't introduce conflicts. So when we get to vertex I, we're going to ask, does color one work? Does color two work? Does color three work? And this the first time we get to a color that is valid that it doesn't have a neighbor of that same color, we're going to assign it that color and then move on to the next vertex. It's greedy because you're um yeah, it's called greedy because you're always picking the smallest color you can at any one time. It doesn't necessarily mean that you're going to get an optimal coloring. In fact, usually you won't. At least, you know, for big graphs where it's hard to find optimal colorings. Um, let's run through this algorithm. Let's see it happening just to get a more concrete feel for what we mean. Um, here we go. So, here's my graph. Nope. Pause. Thank you. Six vertices. One, two, three, four, five, seven edges. Uh, and this is the vertex order we're going to use. We could choose any vertex order we want. Um, but we're going to look at the vertices in this order and always choose the smallest color that's valid. So the first one, first color is fine because there are no possible conflicts. No one else has colors yet. Uh second vertex, the first color is no good because it already has a color. Sorry, it already has a neighbor that's been assigned that color. So instead of the color triangle, we have to go up to color square. All right. Now, let's go to vertex three. Our first color is valid this time, so it gets color one. Still with me? All right. Vertex four can't use color one, but can use color two. Vertex five, let's take a look. Uh, vertex 5 can't use the first color, can't use the second color, but can use the third color. So, it gets assigned the third color. And finally, vertex 6 gets assigned the first color. And we have our valid coloring, our proper coloring. Does that algorithm make sense? Awesome. Um, one thing I want to mention is that different vertex orderings will often lead to different colorings and often lead to colorings with a different number of colors. So here with this ordering, we got a coloring with three colors. We got a proper three coloring. But if instead we use this coloring, sorry, this ordering where all I've done is change the order of vertices 1, five, and six. This is a different vertex order on the same graph. So let's run the algorithm again in this ordering and let's see what coloring it gives us. So first color is fine here. First color is fine here. This one needs the second color because it already has a neighbor with the first color. Stop me if I'm going too quickly. Um, the next one has neighbors with colors one and two, so it needs the third color. Um, the fifth vertex has a neighbor with color one, so it needs the second color. Uh and then finally, vertex six has a neighbor with color one and a neighbor with color two and a neighbor with color three. So it in fact needs a fourth color. So with this different vertex ordering on the same graph, it gave us a four coloring instead of a three-coloring. All right. So some orderings are better than others. Yeah. All right. Um, does this algorithm actually work? Does it always give a proper coloring? So, yes, in this case it does. Um, and an easy way to see that is that um, the way the algorithm is designed, it never introduces conflicts. um always after we've assigned the next vertex, we never have an edge that has two end points of the same color because that's kind of the point of the algorithm. So we never introduce a conflict on any edge. So when we get to the end, we haven't introduced any conflicts, so there aren't any conflicts. That's kind of a a state machine style proof of of that algorithm. Yes. Good question. If you try all the orderings and then take the best one, the best coloring you get, will that be optimal? Um, so there there are sort of two questions in there. Um, can you get all colorings from this algorithm? And the answer is no. You can't get all colorings from this algorithm. For example, colorings that never use color one, you can't get from this algorithm because you're always going to use color one on the first vertex. Um, but the other question, can you always get some coloring that uses the minimal number of colors? Even if you can't get all different colorings, can you at least get all different numbers of colors? And that answer is yes. Um, it takes a little bit of thought to prove, but the answer is yes. So if you do try all n factorial vertex orderings uh and take the minimum minimal coloring um you will in fact get the chromatic number but n factorial is a runtime that is not considered efficient for things like np and and np hardness. Um so that is absolutely an algorithm to compute chromatic number uh just not an efficient one. Uh yeah great question. Um let me let me prove one thing about this greedy algorithm. Um as we said it's not always going to give the the smallest coloring depending on what order you pick. But we can prove something about the quality of colorings we get. And here is that theorem. Okay. So for all graphs G for all vertex orderings, excuse me. Um if the max degree of our graph is less equal d um by max degree here I mean look at the degrees of all the vertices and take the largest one. So the maximum of the degrees of the vertices. Um so if the max degree is at most d said differently if all vertices in the graph have degree at most d then the greedy algorithm returns a coloring a proper coloring with at most D + one colors. So if all the vertices of the graph have degree at most D, then the greedy algorithm will use at most D + one colors. Does the statement make sense? So in this example, all the degrees are three or less. So we're guaranteed to produce a coloring that uses at most four colors. Uh, and I want to emphasize this depends on the degrees of the vertices, not the number of vertices. If if this graph had thousands and thousands of vertices, but all the degrees were three or less, we would still get a coloring with at most four colors. All right, it's not necessarily optimal. In this graph, it wasn't optimal. Um, we found a three coloring, whereas this only promises a four coloring. Um, but at least it's some measure of quality of the results we get out of this greedy algorithm. Does the claim make sense? Wonderful. Let's prove it. All right, we're going to prove this by induction. But induction on what? Um, we might think, okay, well, there's there's a D in the theorem statement. So, what if we induct on D? Well, that means at some point, um, we know something about all graphs whose degrees are at most eight, and we need to prove something about all graphs whose degrees are at most nine. I don't really see how to get from one to the next. That doesn't seem easy to me, right? Grasp with the degree nine. look with max degree 9 look very different from graphs with with max degree 8. If you have a graph with max degree 9, there might be many many many vertices with degree 9. Um but to get anything useful out of our inductive hypothesis, we would need all degree all degrees to be eight or less. Like there there's a disconnect there. I don't know how to make that proof work. Um so let's see. Induction on what? We just said induction on D maybe not such a good idea. Often when when proving a statement about graphs by induction. Um there are two common strategies to try. You can try inducting on the number of vertices or inducting on the number of edges. I'll explain what that means in just a second. Um but these are going to be your best friends. If you're trying to prove a thing about graphs by induction, first try proving it by induction on the number of vertices. Then try proving it by induction on the number of edges. If both of those don't work, I don't know, cry. That that's what I that's what I would do. Um, but let's try this strategy. Let's induct on the number of vertices in our graph. And here's what that means. So we're going to let P of N be the statement that all graphs with n vertices. So all graphs with exactly n vertices and max degree at most d um result in at most d +1 colors from the greedy algorithm. So this is what we mean by we're inducting on the number of vertices because n the variable we're going to be inducting on is measuring the number of vertices of our graph. So um if we think about induction as proving things one step at a time. We're going to first prove something about all graphs with one vertex, then all graphs with two vertices, then all graphs with three vertices, then all graphs with four vertices. This is fun. It's five, six, seven. We're going to build up one size at a time. Um, and that's how our that's how our induction is going to go. Um, all graphs with n vertices is the key phrase here that makes this inducting on the number of vertices. If you wanted to induct on the number of edges, you would say all graphs with n edges or something like that. All right, does this setup make sense? So, we've defined PN here. Our goal we want to prove for all n greater equal one p of n is true. Yeah. So for any number of vertices, all graphs with that many vertices do the thing. So together all of these PNS starting at P1 and going upward include all finite graphs. Does that make sense? I failed to mention earlier, but most of the graphs we're talking about in this class are going to be finite. So if I don't specify, go ahead and assume it's finite. Um, so this will cover all of the finite graphs. So it'll cover all the graphs we care about and we'll end up proving our theorem. All right. So let's actually prove our theorem. Um, base case P of one. Well, if there's only one vertex, we know what the greedy coloring is going to do. Um, well, let's see. Max degree is zero because there are no edges if there's only one vertex. Greedy coloring uses one color. One is 0 + 1 which is what was promised. So P of 1 is fine. Let's do the inductive step. P of N. So here assume P of N want to show P of N plus one. And I really want to emphasize one point right here. Um, very often in this class, students come away from uh the next couple lectures with the belief that induction on graphs is different. It follows different rules. It's backwards. We're going from n plus1 to n or something like that. Um, and I I really want to emphasize induction on graphs is using regular induction in the way we're used to that. We're not changing the rules here. Um, what changes is that what it means to prove P of N implies P of N plus one is a little different from what we're used to. We're still proving that P of N implies P of N plus one because that's what induction tells us to do. But if we use our proof outlining techniques from the first couple lectures and really unpack what it means to prove that this implies that what it tells you to do is often a little bit different from what your intuition might tell you you're supposed to do. So um it's doubly important when inducting on graphs to lean heavily on our proof outlining skills. to make sure that we're setting up our proof correctly to prove PN implies PN plus one and not something that we just think means PN implies PN plus1. Uh so let's do that. Now we're assuming P of N. In other words, we're assuming all uh let's see, nvertex graphs with min degree at most D produce at most D+1 colors. Right? That's that's P of N. We're assuming P of N. And we want to show we want to show that all n + one vertex graphs with min degree at most d produce at most d plus1 colors. All I've done is write out what pn and pn plus1 mean in context. With me so far? All right. And here's where the the confusing bit happens or at least the non-intuitive bit. Um, our task is we want to prove that all n plus1 vertex graphs do some stuff. So the theorem we're trying to prove is a for all. All n plus1 vertex graphs do something. But we know how to prove a forall. We start with a generic thing in that set and we prove the conclusion for that thing. So this for all immediately tells us that the next line of our proof should probably look something like this. Suppose G is an arbitrary N +1 vertex to graph. Yes. writing out the meanings of PN. Did you mean to say max degree? Absolutely. I meant to say max degree instead of min degree. That is a typo. Thank you so much. I guess it's a rhto because I'm not typing for both. Yes. Thank you. Thank you for catching that. All right. Is everyone okay with the fact that this for all all n plus1 vertex graphs tells us that this next line should start with suppose g is an n plus1 vertex graph because this is the part that many students get wrong. Um they will often say suppose g is an arbitrary nvertex graph and then they go on to try to prove stuff about some n plus1 vertex graphs but they haven't shown that they're really getting all of them. It's this for all that tells us we should start like this and no other way. All right. So what do we do next? Um so vertices v1 vn vn plus one. So we have whatever vertex order we're using. Now the greedy algorithm will color V1 through VN as if VN + one and its edges didn't exist. The algorithm never looks at edges that connect to vertices that haven't been colored yet. So as far as the greedy algorithm is concerned, coloring vertices v1 through vn, so all but one of the vertices in our graph is going to look just like coloring an nvertex graph. Yeah. So this what's called a subgraph um on v1 through vn if we take just the first n vertices make a subgraph of just its um just its vertices as our vertex set and the edges between them as our edge set with all their edges. This subgraph also has max degree D. Uh oh, sorry. We're supposed to prove something about all n plus1 vertex graphs with max degree d. So assume g is some n plus1 vertex graph with max degree d. Then when we look at the subgraph where we're only taking some of the vertices and some of the edges, well degree can't go up when you do that. So this subgraph also has max degree at most d. Okay by p of n because we assumed p of n. These n vertices will use at most D+1 colors. Right? We have an nvertex graph that we're talking about. We know it satisfies the property. So we get the conclusion because of our assumption. So it uses at most D plus1 colors. So now all we need to talk about is the last step of the greedy algorithm. Last step for VN plus one. Well, VN plus one has degree at most D. So it has at most D colors that conflict. So um one of the first D+1 colors will be sufficient. Um uses one through D+1 uses one of these colors because you can only have D conflicts because this has degree at most D. Therefore, the last color also uses one of the first D+1 colors. So, the whole coloring uses that many colors. And we're done with the proof. Did that make sense? If it didn't, come up, talk to me afterward. I'm happy to stay and answer questions. Thank you so much. We'll see you on Thursday.