All right, let's get started. Welcome back to 61200. Uh, today we're going to talk about state machines, which is a very cool tool for thinking about uh processes over time. And in because this is math for computer science in particular, we're thinking about analyzing algorithms that do a bunch of steps and the state of the machine uh changes over time like the state of your memory changes and state machines are a nice way to reason about how it's changing. In particular, we'll talk about an idea called invariance uh which you use to prove algorithms and programs correct and you or you will in the future. And so today we're going to formalize that into uh a kind of induction actually. Uh you haven't seen the end of induction yet. Uh so let me tell you a little bit about what state machines are. Then we'll prove some things and apply them to analyzing puzzles and other fun stuff. So a state machine is going to consist of two things uh three things um a set of states and the idea this is just an arbitrary set but the idea is that the state of your machine represents everything that could possibly be in the machine all the information that lets you that that's inside the machine. uh we're going to start in some state which we call Q0 that's going to be an element of Q and then we are allowed some transitions. uh and we're going to write a transition as Q arrow R uh for some Q and R that are states. Okay. Uh let me draw you an example very simple example of a state machine so we have some idea of what we're talking about. This is going to be an infinite counter. I'm going to draw it visually first and then we can say what it means with all these sets. Just dot dot dot. Maybe I'll do one more. Okay, so this is a machine. You can think of it as a single uh register on your machine, single variable. It starts at zero. This little notation here means start state. Um there's there's an arrow coming from nowhere. So that's where you start. You start in state called zero. So the set of states here is 0 1 2 3 and so on. In other words, the natural numbers Okay. And then when you're in state zero, the only transition you can do, the only arrow that goes out from there is from zero to one. And once you're in state one, the only thing you can do is go from one to two. At some point, you decide to increment, then you go from two to three. Some point you decide to increment and you go from three to four and so on. So this is a very simple state machine. It turns out it will be interesting for certain reasons. But uh in general, you could imagine having all sorts of arrows. Maybe one has a transition to three for example or maybe three has a transition to one. All of these are possible. You can have one state that has many transitions out of it. You can go in loops. You can do all sorts of crazy things. Uh but let me finish precisely specifying the counter. Okay. So we said uh here Q0 equals the state zero. And uh what are the transitions? transitions are all of the um i to i + one transitions where i is a natural number. May recall this set builder notation from lecture one I think uh where we write an element on the left and we write some condition on the right and so the idea is t is the set of all of these transitions i to i + one for every i that's a natural number. Okay, so that's an example. But in general, we can have all sorts of transitions from any state to any state, but you're only allowed to make the transitions that are in t. So let's uh formalize that with the idea of an execution. It's going to be a sequence of states that uh you can reach by a sequence of transitions. So uh let's write it as Q0 arrow Q1 arrow Q2 and so on uh maybe up to QN. And importantly, every transition we make for all I qi to qi plus one should be in t, not just any set of states here. We want to start in Q0, our start state. We want to then make a valid transition from Q0 to Q1. Then a valid transition from Q1 to Q2 and so on. So in this example, the executions are very simple. In the in the regular counter without the red lines, the executions are just 0123, that's one execution. 0 1 2 3 4 5 That's another execution. There's an infinite execution which is zero all the way out to infinity. Uh that's why I put this in parenthesis. Either it stops at some qn or just or the dot dot dot continues off to infinity. So trying to simultaneously define finite executions where you stop at qn and infinite executions where you go forever. When you write an algorithm or a piece of code, you usually don't want your program to go forever. And so distinguishing between infinite and and finite executions is one of the goals of this lecture. It'll come at the end. The other goal is to show that your program is correct in a certain sense that in any execution it does the things that you want it to do. So that's what we're going to formalize in a moment. But let me first talk about reachable states. The idea of reachability. I'm going to call a state R reachable if there is an execution that starts at the start state Q0 and ends at R. Okay, so in the counter example, every state can be reached. If I pick a state I, I can go 0 1 2 3 up to I. But if I drew some other circle over here like uh bad with no arrows coming into it, you can't reach bad. Okay, so usually we're only interested in the reachable states because you can't get anywhere else. I feel like I should make a reacher joke, but I don't can't think of one. Okay. Um I think at this point I want to talk about a more interesting example and then we will come back to uh the theory. So the interesting example is this uh it's called the eight puzzle. You have a 3x3 grid with one hole and one by one pieces in it and you can slide them around. And so this is the solve state. Your goal is to get here. But you start in some random state and you want to move the pieces around to get there. Uh so what we'd like to do is capture uh how to solve this puzzle or actually maybe more interestingly is when it's solvable. So here for example, I'm almost solved 1 2 3 4 65 78. I wanted to get into 1 2 3 4 5 6 7 8. Uh it turns out that puzzle is not solvable. I claim it's impossible to get from here to the goal. So let's talk about the eight puzzle. Uh so I have some examples here. One, three, four, two, five, seven, eight, six. Going to one, two, three, four, five, six, seven, eight. Or this one. One, two, three, four, six, five, seven, eight. Okay, hopefully the rules are clear. We'll formalize them in a second. Um, I claim it is possible to go from this arrangement to this arrangement. It's actually quite easy. You move the three over, you move the two up, you move the five over, you move the six up. Okay, so this is possible. I claim this one is impossible. And one of the goal, our first goal really is to prove that that you cannot swap the five and the six by themselves. Okay, we're going to build up tools to do that. So, let me define let me uh so the counter was a very simple state machine. Let me now define a more interesting state machine which is the eight puzzle. Okay, remember the set of states Q is supposed to encapsulate everything about the puzzle or your system or whatever. Uh, so this is going to be all the different arrangements of the eight pieces plus a blank in a 3x3 grid. So I'm just going to write that in words. All possible arrangements of eight I'm going to call them of uh one two three up to eight and the blank in a 3x3. In later parts of the class we'll be able to count how many of these things there are. It's nine factorial, but uh we don't really care how many there are right now. We just want to think about this as a set of all the possible states of this board. Okay, our start state, well, that's either this one or this one depending on where we want to start. Um we're also going to define a final state Q subf and that is uh sorted uh by reading order. So this is Q subf reading order like in English you read the top row, second row, third row with the X at the end. That's always our goal in this puzzle. That's our definition. Uh and then uh what about the transitions? Okay, transitions are going to look like um some Q to R for two states Q and R. And it's when you can get from Q to R by making one slide. I'm just going to write that in words. Can get from state Q that 3x3 grid to state R in one slide. meaning meaning you exchange the blank the X with one of its neighboring cells. So in particular there is at most four different uh transitions from any state. You could move the thing above the blank into the blank. You move the left, right, or below the blank into the blank. But if it's on the boundary, you have fewer than four moves. Okay, so hopefully now I've said it enough times the rules are clear if you haven't played this game before. 15 puzzle is much more common, but eight puzzle is a little easier to think about. Smaller pictures, easier to draw, and I could actually solve it in a reasonable amount of time. Um, okay. So, uh, this is a claim that we want to prove. You cannot get from this state with five and six flipped into this state. And so now we're going to build some some technology to do that. And that technology is an uh first part of it is called a state predicate. So we've seen predicates before. Predicate is just a uh a proposition that's depends on some variable. And here the variable is a state. So p of q is either true or false depending on which state you are looking at. You can also think of this if you're comfortable with functions. We'll talk more about functions later in the class. This is a function from Q to the booleans, true or false. It's an equivalent way to think about it, whatever you're more comfortable with. For every state, we're going to this predicate assigns true or false. Okay. Now, we're going to define uh two types of predicates that are particularly interesting. A predicate is preserved if whenever there's a transition from Q to R, uh, P of Q implies P of R. What does that mean? It means that if I start in some state where P is true and I do a transition, then P remains true. So it's the truth of P is preserved along transitions. Okay, we'll make this concrete in a second. Second important notion is called an invariant or invariant state predicate. If uh P of Q is true for all reachable states Q. Crucially in this definition definition we're only interested in the reachable states. Uh that's kind of important for the eight puzzle because we claim some states are unreachable. Like if I start here the claim is that this one is unreachable. That's what we'd like to prove actually. Uh so this seems useful. Um in particular, let's write this fun fact. Uh if P of Q is invariant, meaning it's true in all reachable states. uh and p of q is false for maybe I'll write p of r here then r is unreachable okay that's pretty much by definition and maybe the contraositive this is saying for uh invariant means that for all reachable states p of q must be true so if I can find a particular state R where P is false. That means you cannot reach it. And that's what we'd like to show, right? We'd like to show this state is unreachable from this one. So maybe we can use these state predicates to do that. And indeed we can. Okay, let me tell you another tool. Uh you know how do we prove that a state predicate is invariant? Uh this seems a little bit tricky because this is talking about all reachable states. Reachable states is like huge. I don't know. Preserved seems relatively easy to prove. This is just saying for each transition something implies something. So I'd like to prove preservedness and I'd like to use that to get invariant. And we're going to do that using induction. But a particular form of induction called the invariant principle. So this is for a state predicate P of Q. If P of Q0 is true and uh P of Q is invariant. Get it right. Observed. then P of Q is invariant. Okay, this is what I said I wanted. Uh on the one hand, invariant seemed hard to argue. Preserve seemed easy to argue. And this is a theorem that connects them in the way that we want. It says if you can prove preserved and you can prove that P is true in the very initial state, then it must be invariant. I think this is intuitive, right? If you start true and preserve says every time you do a transition you stay true then you're always going to be true in any reachable state anywhere you can get. Okay. Uh in fact this is induction in another form. So if you recall in the past which I happen to have right here induction we have regular induction says uh for predicate p of n over natural numbers instead of states uh if p of zero is true and for every natural number p of n implies p of n is n plus one is true then for every natural number p of n is true. Okay, this is saying uh the same thing actually it's exactly the same thing if you apply this invariant principle to this counter [Applause] right in the counter the states are the natural numbers and the transitions are exactly going from i to i + 1 okay so the invariant principle is actually a generalization of the induction axiom uh the special case here where we plug in the counter as a state machine. This is true for all state machines. And if we plug in the counter for our state machine, we get exactly the induction aim. This is our base case in some sense. We prove that uh P is true in the initial state. This is our induction step. It says that if we start at Q and we transition to some other R that's reachable via transition. uh and in the particular case of counter m counter that is going from Q to Q plus one then we get that P of Q is true for all reachable states and in the counter everything is reachable. Okay, so invariant principle implies induction aom. Uh, conversely, we can prove the invariant principle using induction. Maybe it's useful to see that proof. So let's prove the invariant principle uh by induction. So it's not so obvious how exactly but the idea is to specify a particular induction hypothesis which is uh for all length n executions. uh p of qn is true. There should be a colon out here. Uh I think it's intuitive that this is enough, but we'll justify why this is enough. The idea is if you have some state that's reachable, it's reachable by some finite execution of some length. And we're going to prove for all n that all length n executions p of qn is true. And by by inducting over length, we essentially start with short uh executions and then make them gradually longer. That makes this easy to prove. So let's pro let's do a base case uh iH of zero. Well, that's all length zero executions. There's only one length zero execution. uh that is just Q0. You start at Q0 and you stay there. That's length zero. Uh and we claim that P of Q0 Q0 is clearly a reachable state. You get there via length zero execution. Why is it true? this where it's what we assumed it's by one. So that's the base case. Of course, the more interesting one is the induction step. I'm going to assume we get to choose. We could follow this plan. Assume P of N and prove P of N plus one. I find it slightly more intuitive to assume P of N or sorry instead of P it's IH here for induction hypothesis uh IH of N minus one and we're going to prove uh IH of N. Okay, what does it mean to prove IH of N? It says well for all length N executions P of QN is true. Uh so how do we prove a for all? We just take an arbitrary thing in the quantifier. So take any consider any length n execution and then we need to prove the property we want which is p of qn. So let me uh give some notation for that execution. any length n execution q0 q1 q n minus one qn and what we want to show is that uh p of qn that's our goal right it says for all length executions p of qn is true so we take an arbitrary execution if we can prove p of qn is true then we're Well, somehow we want to use induction here. We've assumed the induction hypothesis for size n minus one. Can you see a length n minus one execution here? That might be interesting. Yeah. Q1 to QN. That's a good idea. Does that work? Is that an execution? Let's go back and check. Uh, execution of a state machine is an infinite or a finite sequence starting with Q0 and maybe ending, but it needs to start with Q0. So there's like two natural choices here. One would be starting at Q1 and going to QN, but Q1 might not equal Q0. And so that might not be a valid execution. So we wouldn't be able to apply induction to that. The other obvious choice is q0 to qn minus one. That is a valid execution of length one smaller length n minus one because it starts with q0. Okay, a lot of terms here so it's easy to lose track but eventually they will become comfortable. Uh so by uh induction hypothesis of n minus one if we apply it to this execution of length n minus one we learn that p of q n minus one is true. Right? That's what the induction hypothesis says. The last state in your execution is true. So now we know p of this is true. We just need to prove p of this is true. Why is that? Because property two P of Q is preserved which we can unroll over here says for every transition in particular the one from QN minus one to QN P of Q minus one implies P of QN. Okay. So uh by 2 uh p of q n minus one uh implies p of qn because this is a transition in t. So p of qn. So that's the end of the induction step. So uh by induction we get for all uh n uh induction hypothesis of n. And the idea is that this uh implies p of q for all reachable states q. Because if you have a reachable state Q, there's by definition of reachable way over on the left, uh there's some execution that gets there and it has some length and so I of that length gives you what you want. So that's how we prove the invariant principle. It's pretty intuitive notion, but maybe nice to see yet another example of an induction proof. Great. So, how do we use this? Let's go over here. Here is a template for proving a theorem which is P of Q is invariant. This is the thing I keep saying is hard to prove or by the definition it seems hard to prove but using this invariant principle it's going to be easy. Here's what a general proof will look like. We can say proof by invariant principle. For the invariant principle to apply we need to prove two things number one and number two. So number one is prove that P of Q0 is true and in a template we just say because reasons which we don't know but we have to fill in. And the second thing is that uh P of Q is preserved. That's the more interesting thing and for this we need to unroll the definition of preserved. says for all Q all transitions Q to R P of Q implies Q of R. So how do we prove that? Uh we just take uh any transition in t q to r and because it's an implication we can assume the left hand if we want to prove an implication we can assume the left part this is a direct proof and prove the right part. So we can assume uh Q P of Q is true and then what we need to do is show that P of R is true. That's the interesting step which we need to fill in. But this is the template we're going to now use to analyze the eight puzzle. Of course I haven't defined what predicate we're analyzing. That's the next step. Uh but once we have a predicate, we'll be able to prove that it's invariant using this simple structure, right? Just check it. It's check that it's initially true and check that if you start from something that's true and you take a transition out of it, it's still true. Great. All right. So let me define a predicate for the a puzzle. I want it closer to these examples actually. Yeah. Let's go here. I think you know definition of a state machine. Okay. So for this uh eight puzzle state machine, I'd like to define a bit of a bizarre predicate. So first I'm going to define the notion of an inverted pair. This is going to depend on what state we're in. Uh so let's do it. Let's look at uh inverted pairs in this example in these three examples. So an inverted pair is a is a two numbers. So not the blank but two numbers between one and eight. And I want I less than J. And yet I want J to appear before I in the reading order. So for example my red chalk uh in in this picture this state two and four are inverted right in reading order four comes before two yet four is greater than two. Uh any others? Eight and six are inverted. Six and seven are inverted. Seven is bigger than six. Eight is bigger than six, but they come earlier than six in the reading order. I think there's one more. Three and two. Thank you. That one's a little trickier because it's on different rows, but in reading order, three comes before two and yet three is greater than two. So there are four inverted pairs in this example. How many inverted pairs are there in this example? Zero. Zero inverted pairs. How about this one? One. Yeah. I thought you were holding up your hand, but you're holding up one finger. Uh, six comes after five. That was the only thing out of order. That's what we we started out with. So if you wanted some, you know, where do you come up with this idea, it just is fundamental. You're supposed to magically uh invent it. But if you fool around with the puzzle enough, it's actually somewhat intuitive and that you can get where it's almost sorted, but there's just one pair that's wrong. So you might think, well, maybe there's something about these inverted pairs. Let's talk about them in general, not just about zero versus one inverted pairs, but let's count them. So over here we had one inverted pair. Here we had zero inverted pairs. Here we had four inverted pairs. And I claim it was possible to go from four inverted pairs to zero but impossible to go from one inverted pair to zero. Why pars par means odd or even. So uh P of Q is going to be uh that the number of inverted pairs in state Q is odd. Turns out to be this proof will work for either one. But if we want to prove this particular impossibility result, odd is what we need. So, uh, P of Q is going to be true for this configuration because it has an odd number of inverted pairs and it's going to be false for these two. Why is that interesting? Because over here we said suppose we can show that P of Q is invariant. I claim that's true. Uh if we start from here where P of Q starts true because the number of inverted pairs starts odd then uh and we find another state where P of R is false because here the number of inverted pairs is even instead of odd then R is unreachable. That means it's impossible to get from this state to this state. That's what we want to prove. Okay. So if we can prove this invariant property, we can plug it into here and get the puzzle impossibility result that we want. Okay, that's where everything's going to come together. So let's prove that uh P of Q is ideally we'd like it to be invariant, but uh to prove invariant, we're going to start with proving that it's preserved. Uh the reason for the eight puzzle that I want to talk about preserved first is to be invariant it depends where you start and that's kind of particular that that's a little arbitrary. There isn't one natural start state for the eight puzzle. You might start here. You might start here. You might start here. That' be a very easy puzzle. Uh and so but preserved is just a general property about the system. So I don't need to assume anything for that. So we want to do this part. We want to prove P of Q is preserved. So we consider any transition Q to R where P of Q is true. We need to prove P of R is true. Okay. So here we plug in the outline of step two there. Um consider any transition Q to R that's valid. It's in T. Uh where P of Q is true. And we want to show P of R is true. Okay. What do transitions look like in this game? Well, relative to reading order, reading order talks about rows. So, um there's really two types of moves we care about. There's horizontal moves left and right, and there's vertical moves up and down. I claim those are the two cases, uh that we need to think about because we're thinking about reading order. So, case one is that this transition Q to R is a horizontal move. horizontal move. So this is like uh we take some number I and next to it there's an X and maybe if we move to the right that would be X I or if we move to the left it would be like that. Okay, it's one of those two transitions. X here means the blank. How does that change reading order? Yeah, nothing. Nothing changes, right? The reading order is the same reading order. When we're talking about reading order, we're only talking about the numbers. We don't care about the x. So, no changes in reading order. or in uh the number of inverted pairs because that's only dependent on reading order. Uh so we have P of R. Case one is easy. Let's prove case two maybe over here. [Applause] Case two is a vertical move here. There's actually something to show more interesting, but not much harder. Okay, I'm going to draw some pictures for intuition. Uh it could be we are moving I down and there's two things to the right of I. Uh it could be uh we're moving I in the middle to here or could be we're moving I on the right down to here. Okay. And uh this is for a down move. Up is going to be symmetric. But maybe let's first think about down moves. So in order to do a down move uh in reading order, there are two items that come after I because we're moving down. There is something after I, right? There's a whole row after I until this X. So if we can move I down, there's two numbers between I and the X in reading order. and I starts before those numbers if we're going down and ends after. So, uh the move here we can think of it as swapping uh we we want to swap I with X. Okay, but this is equivalent to swapping I with uh J first of all and then swapping I with K. Instead of going straight down in another color, I'm going to think of swapping I to first come after J and then come after K. That's the same as the X. And it doesn't matter where we started. could be here and then we go here or could be here we go after J and then we go after K. The point is if we swap if we figure out how to swap two adjacent numbers in reading order and we swap I twice then I gets to where the X is because this is a 3x3 that's why twice. Okay. So, uh, now what we care about is, uh, what happens when we swap two adjacent items in reading order. So not adjacent in the 3x3 grid but adjacent in reading order. That's what we care about. If we can solve this and we do it twice then we will know what happened when we do a vertical move. Okay. So what happens when I swap two numbers I and J? How how does that change the reading order? I mean it swaps I and J. That's all. Everything before I is still before I. Everything after J is still after RJ. The only thing is we're change for if they're adjacent items I and J. We're only flipping whether I J is inverted. Right? If I J was in the correct order before, if I was less than J, then after I do the swap, they're an inverted pair. If they were an inverted pair initially, if I is bigger than J, after I do the swap, they're no longer an inverted pair. So, swapping two adjacent items changes the uh number of inverted pairs. by plus or minus one. If they were inverted before, it decreases the number. If they weren't inverted before, it increases the number, but always by one. Never stays the same. Never changes by seven. Okay? So that when we swap two adjacent pairs, we change by plus or minus one. when we do a vertical move, we do we want to do two of these uh adjacent swaps. So, let's continue over here. So if we do two adjacent swaps, this will change the number of inverted pairs by plus or minus one plus plus or minus one. Okay, where each of these pluses or minuses, we don't know. They could be plus or minus. But uh the point is plus or minus one is an odd number. plus or minus one is an odd number. When I add two odd numbers, this is an even number. Turns out you can draw a little picture. If we start at zero here and we do plus or minus one and then from here we do plus or minus one. From here we do plus or minus one. This is a case analysis of all the things you could do. You either get two or zero or minus two. These three numbers are all even. Okay, but I don't particularly care. It happens to be just these three values. What I care is that this number is even. We started with uh we started with P of Q being true over here. Uh assume that P of Q is true. That means that the number of inverted pairs in state Q is odd. And now we change that number by an even amount. Therefore it will be odd still right? If we take an odd number we add an even number uh it become it stays odd. Therefore uh p of r is true. Question uh so question is why is this two swaps? Uh so the the funny thing here you so it's right if I swap I J then let me maybe draw a picture somewhere here. [Applause] Let's just go here. Scratch space. So if we have I J K X and I swap I and J then I get J I K X and then I swap I and K then I get J K I X. And you're right. I is not quite where I want it. Uh this is funny. I'd really want I to be here which I can do. like this. Uh because that doesn't change reading order. Okay, it's good that we spell this out. And also I can do horizontal moves for free. So J, K uh I this is maybe a way to think about it. The point is these three have the same reading order. So those don't really count. But I'm glad you had me spell it out. are not, right? These are not valid transitions. Uh, indeed, at the end, we get to something that's a valid transition. So, the transition goes from here directly to here, and we're splitting it up into some sub moves that aren't valid moves by themselves, uh, but easier to analyze. First, we think about what happens when we swap i and j. That changes by plus or minus one. Then, we swap, uh, i and k. that changes these by a plus or minus one. Then we do these horizontal moves which doesn't change anything or kind of horizontal moves. Moving the x uh in reading order doesn't change anything. Cool. All right. Great. Feel like I skipped a bit of a step here, but [Applause] So the point is when we swap when we in case two we do a vertical move uh the uh we started with an odd odd number of inverted pairs and then we add an even number uh and even odd plus even equals odd. Therefore p of r is true. That's the point. Okay. So if we start odd, we will stay odd. If you swap odd and even in this proof, you can also show that if you start even, you stay even. But what we really want is uh for this part here, we want to get uh P of Q to be invariant and find a place where P is false and then conclude that R is unreachable. So let's do that quickly. So uh let's define this state to be Q0. Okay. So for this Q0 we have or maybe let's say if P of Q0 is true as in this example because there's an odd number of of inverted pairs then P of Q is invariant and so by this property uh if P of R is false then uh R is unreachable. Oh, so actually what I care about is not P of R but P of the final state QF. Okay, so that's that's exactly the scenario. We start in a state where we have an odd number of transitions. we're trying to get to a state with zero uh inverted pairs and so uh that's not going to be possible because we start with P true and we somehow are trying to reach a state where P is false. Okay, but if we can prove this invariant property and we've basically done all the hard work here. This is just by the invariant principle. So now I'm following the outline over on the left. Step one is or part one is that P of Q0 is true. We assume that. Step two is that P of Q uh is preserved and we just prove that. This is our theorem. So maybe you don't know this word corollary or corollery if you're Canadian. Corlary means something that follows. So theorem means something that's true. Both of these are supposed to be true. Uh but these are words to say that okay theorem was sort of the main thing we wanted to prove and then corlary is something that follows immediately from it. It's like almost a oneline proof here. Once we have the theorem, the corollary is immediate. There's some terminology. Okay. So hopefully you now believe this is impossible. Any questions about the eight puzzle for fun? Let's solve it one more time. Uh, I actually didn't have time this morning to implement the only generate solvable puzzles. So, I have no idea whether this will be solvable. It's kind of exciting. If you can count the inversions, uh, you'll figure it out, but I keep moving it, so it's pretty hard. And I'm following a particular slow algorithm for solving this puzzle which I won't describe but it's on wikihow if you're interested. Oh, I solved it. Great. So I must have started with an even number of inverted pairs. Uh in a future version I will add that number. But there we go. Cool. Uh question. Uh so your question is in if in this state we move six down how many inverted pairs do we get? Let's draw it. So that is one two three four five x it should be two uh 7 8 how many inverted pairs are there? Seven is inverted with six. Eight is inverted with six. And that's it. Okay. So there's an example in action. Vertical move changing by two. Sometimes it changes by zero. Uh if I is sandwiched in between J and K numerically. Sometimes it changes by plus or minus two. Of course if we do the up move, we subtract two. That was another question. Yeah. Okay, question is explain preserved and invariant and where are we using different parts? If if I can make an induction analogy for a second. Uh preserved means uh is like your induction step. It says every time you do a transition, if P started true, it remains true. And invariant is what you get out of the induction. Let's go over to the invariant principle here. [Applause] The invariant principle basically says preserved implies invariant except you also need to check that you start true. If P starts true and whenever you do a transition it remains true uh then it's always true for every reachable state. Okay. So crucially in this setup we're ignoring all the unreachable states. just talking invariant only talks about reachable states. It says that every reachable state P is true. That's what we're concluding from. We start true and every time we start in a true state and we make a transition, we remain true. Hopefully that's clear. Takes a little while to get comfortable with these definitions, but very important the difference between preserved and variant. So if you forget, read the definition. Uh or just follow this template. This makes it pretty clear. Usually we just want a proven variant. And there's a clear start state. So in fact, the next example will have a well no that's not true. But uh if there's a clear start state, you can just follow this template. Uh and all you care about is proving invariant. Okay, let's do the next topic, which is termination. And maybe I want to start with an example which is a simple sorder machine. This is another state machine and it sorts and numbers. This is a problem you study a lot in the follow on to this class, the algorithms classes. So suppose we're given a bunch of real numbers or integers, whatever. uh want to sort them in increasing order. Okay, here is so they're given in some particular order a1 through a n and I want to rearrange them so it has exactly the same set of numbers or exactly the same numbers but in a different order and this time increasing order. So I want a1 to be less than or equal to a2 less than equal to a3 and so on. Here is a very simple algorithm to do that which is while there's some index I where I AI is bigger than AI + one swap AI with AI + one. Okay, so I'm just looking at consecutive pairs AI to AI plus one. And if there's some that's out of order, I is less than I plus one, but AI is greater than AI plus one, then I want to swap them in the right order. We can see this algorithm in action for fun. Uh, and then we're going to convert this algorithm into a state machine. Okay, so just pretend you understand algorithms for the second. Uh, here we have the numbers in a particular order. Uh the height corresponds to the value that's written 362541. And uh we're just going to do uh an example. U but then we do a swap a swap. We're always swapping adjacent pairs. And then Pac-Man comes over to the left and we get them in sorted order. Okay. So that is the algorithm. Let's now analyze it as a state machine. So first question is what are the states Q? Well throughout this algorithm so this is sort of in our head what we're thinking about doing. Uh and now uh and we choose I I arbitrarily now we're going to model as a state machine. This will make precise what's actually going on. Uh as we do this we're we're taking the original items in some order. We're always swapping items. So at any moment in time what we have is some reordering of the AIS. Okay, those are our states. Let's define Q to be all possible orderings. These may not all be reachable, but this is the thing that's easy to define. All possible orderings of A1 to A. Okay. Uh this template. Okay. What are the transitions? transitions are going to take some ai ai plus one pair and swap them. So if we start with them in this order, they're going to end up in the opposite order. And we are only allowed to do this when ai is bigger than ai plus one. So that's the transitions. uh implicitly this specifies exactly the algorithm. The algorithm says take some i where a i is bigger than i ai plus one and swap them. That's exactly what the transitions specify because uh we can take any transition that's valid from any state. So with a if we can find any i where ai is greater than a i plus one then swapping that pair is a valid transition. We don't know which one we'll do. state machine will follow some execution which will do one of these until it can't anymore. Okay, great. Can't anymore. Let's define a tool which is final states. Let's call a state Q final if there's no transition uh Q to R in T. If there's no transition that starts at Q and goes somewhere. Okay. So, uh in the eight puzzle there are no final states. You can always make moves. You never are done. You're done only when you happen to reach the final state. But there's nothing in the move definition that prevents you from continuing. Uh in this problem, there are final states. I claim it's exactly a z to a n where a1 is less or equal to a2 is less than or equal to a3 and so on is less than equal to a n. Namely the sorted order why well first of all I claim this state is final because if you look at any pair a i ai plus one we have ai is less than or equal to ai plus one. So we don't have a transition out of there. So these states are definitely final. I also claim that it's all the final states because if I had some some state where this is not true, that means one of these inequalities is not true. So that means there's some AI that's greater than AI plus one and then there's a transition. Okay, so that was a an argument spoken argument for why the final states are exactly this. Uh technically we're proving uh all of these states are final and that all final states are of this form and therefore these are all the final states. Okay, cool. Um so this implies this gives us something we call uh partially correct. I'm not going to define this formally. partially correct machine is a machine where if it terminates oh which I haven't defined uh then uh gives a correct answer. What does terminate mean? Okay. Terminate means uh a state we're going to say a state machine terminates or uh really what we're meaning is it always terminates. No matter how you execute this machine, it stops. And the only way it can stop uh is that it reaches a final state. If you think about it for a second, the definition of execution was a sequence of transitions. And so terminate says there's no infinite execution. For an infinite execution, that means every state qi there's some transition out of it to qi plus one. Uh so if that's not possible, that means at some point you reach a state that's final and from there there's no uh transition. Okay? So you could either say it terminates means there's no infinite execution or every execution reaches a final state. These are turn out to be equivalent. Okay. So now I claim what we've shown is that for the simple sorter machine it actually sorts in this partially correct sense that if the machine terminates then it will give the correct answer because if it reaches a final state it's sorted. That's what we just argued. Now that's not enough. We also want to show that it terminates. And so really the main thing to do the main thing to do is to prove termination. uh and in particular uh let's say a machine is correct uh if it terminates and produces the right answer which was partially correct okay I haven't formally defined right answer but for the sorting problem it's clear we want to get them in order so that this holds A1 is less than equal to A2 is less than equal to dot dot dot. Okay, so we've proved partially correct but we need to prove correct and uh in particular we need to show that it terminates. So we need some tools for proving termination for this machine. Let's go to another board. We want to make sure that this algorithm doesn't take forever. It doesn't go in an infinite loop. Never reaches the sorted state. Let me define a general tool for this. This is how we will always prove termination in this class. It's called a derived variable. Uh this is sort of a reference to random variables which we will see when we get to the probability section of the class. Lots of forward references today. Um it's very simple. It's just uh for every state we define a real number x of q however you want. Okay. In other words, this is a function uh from the set of states to the real numbers. Okay, in our applications, we're only going to think of the natural numbers here, but in general, this could be a real number. Okay. And we're going to call it a derived variable strictly decreasing. If uh whenever we have a transition from Q to R in T, it's a valid transition. Uh we have x of q is strictly greater than x of r. The new value is strictly less than the old value. That's strictly decreasing. This is a very strange looking colon. Okay. So again this is about a state machine. So we talk about transitions and every transition strictly decreases the derived variable. Okay. This is going to be our analog to state predicates and preserved invariant. State predicates we map to true and false or zero and one. Now we're generalizing to allow it to map to any number, any real number. Okay, but very similar notion just we're outside the boolean realm. Now, uh it's very odd to talk about strictly decreasing for booleans. And that's we want we need this. Okay, here is a wonderful theorem. It's kind of it'll be obvious once I state it, but it's very useful for proving termination. It's how most termination arguments go. So it says suppose you have a derived variable x of q uh and suppose it satisfies two properties. Property one is it's actually over the natural numbers not reals. And property two is that uh strictly decreasing. Then uh state machine terminates. Okay. So, uh the then is of course what we want. We want to show that our state machine terminates. So, a claim this is all you need to show. You need to construct some derived variable where the value is always a natural number. So, crucially, it's always non- negative and it's always an integer. That's I I highlight this instead of putting it in the definition because this is something we really need to prove. This theorem is is false if you allow real numbers. It's false if you allow negative numbers. Very important that they're non- negative integers. So that's something we need to check. And it's strictly decreasing. That's all we need. Then we're guaranteed the machine will terminate. Why? Any guesses why? Why is this guaranteed that our machine terminates? Yeah. Well, when we reach zero, if x is strictly decreasing, there's nowhere to decrease. So, there must be no more transitions. That sounds good. So, when when x of q reaches zero, I don't know if it does, but if it reaches zero, you definitely can't go any farther because there's no transitions out of zero. You can't strictly decrease from zero if you're non- negative. Why do we get to zero? Yeah. reach a minimum. Okay, we don't necessarily reach zero, but we get to some minimum. Yeah, I think these are all in the right direction. I I'll write down what I would call a sketch. Uh that's thinking about it kind of the other way around. Instead of focusing on X of Q decreasing, um I want to think about executions of this machine, right? We want to prove that the machine terminates. That means that there are no infinite sequences. In other words, all all executions have finite length. I claim all executions have length at most x of q0 because every time I take a step, every time I do a transition, x decreases by at least one. If it starts at x of q0, it can only decrease by one that many times. At that point it will have to have reached zero and then it has to stop. Maybe it stopped earlier. But this guarantees that it stops. Right? Every step I make I strictly decrease x of q by at least one. We start here. We can't go below zero. So the number of moves is at most that you can prove this by induction. Uh but it's kind of straightforward. Okay. So you're in the right idea, but this is a little more precise. Great. So now let's apply our termination theorem to the simple sorder machine. Uh but we need to do that we need to define one of these derived variables [Applause] and it's actually this one. I'll be mean and just erase this. There's our derived variable. I I'll rewrite it. So there's a reason these two examples are in the same lecture. Use the same idea which is inverted pairs. Oh, perhaps I shouldn't have erased the definition of inverted pairs. Sorry. Uh so back to the simple sorting machine. Uh we're going to define P of Q to be the number of inverted pairs in state Q. Okay, that's some number. It's a natural number, right? It's always greater than equal to zero. It's always an integer because inverted pairs were this discrete object. It was a set I J. Oh, maybe I need to redefine this a little bit. Is no longer reading order. So, what is an inverted pair? This is uh I J where uh I is less than J. uh sorry but a i is greater than a j so it's a i i i and j here are indices into this sequence so in this example uh let's say uh 62 is inverted because six is to the left of two but six is greater than two and that's the opposite of what we want but also 61 is inverted it's not just adjacent pairs all the pairs so there's a bunch of pairs here how many it's exactly the number of dots in this diagram. Each dot which we construct by taking each of these numbers of the particular height and drawing a leftward ray a line to the left and every time we hit another number that means that number was taller than I was. So one for example is is wrong with everybody because it's supposed to be all the way on the left. Okay. So with this funny height diagram you just draw these lines. Those are the inverted pairs. A nice visualization. Thanks Zachmore. and Bmore. Um, so now we think about what happens when we do a swap. So, for example, here I swap these two items. Oh, great. Before six and two were inverted. Now they're not. And that's all that changed because we're all in the algorithm in the transitions, we're only swapping adjacent pairs. Okay. If I swap it back, the number uh increases. Okay. And now if we watch this algorithm, each time it swaps an adjacent pair, it decreases uh by one the number of inverted pairs. Watch it one more time for fun. Love this animation. Okay. So, I claim this P of Q is strictly decreasing. Why? because every time I do a transition from Q to R, uh, P of R is one smaller than P of Q. Let's look at the definition of transition over here. [Applause] When I do a transition in this algorithm, I only swap two adjacent elements. So the inverted pairs with everything else doesn't change. And these guys were guaranteed inverted. I told you that AI was bigger than AI plus one whenever I did a transition. So I decreased by one the number of inverted pairs here. So uh I strictly decrease by exactly one every single time. So in fact the running time of this algorithm the number of swaps that we do is exactly the number of inverted pairs. But in particular it terminates in finite time. And that's what we get out of this termination theorem because we checked uh this function, this derived variable is non- negative. It's an integer and it's strictly decreasing. Therefore, our sorting algorithm actually terminates. Yay. Uh I supposed to do an announcement about problem sets. Yes, which was the Oh, yes. We're about to release solutions to a problem set. Uh problem set one. And you may recall you can submit your problem set one anytime between now and the end of semester. So what do you do? Are you allowed to look at those solutions? Yes, you're allowed to look at the solutions. But you cannot copy those solutions. You can look at them, then put them aside, remember the solution, think about the solution, write it in your own words how that solution works, and put at the top of your document. It says in the collaboration policy, I looked at the solutions, but I'm not copying them. If you copy them, you will be penalized. Okay? Just understand how the proof works and then write down how the proof works in your own words. See you next time.