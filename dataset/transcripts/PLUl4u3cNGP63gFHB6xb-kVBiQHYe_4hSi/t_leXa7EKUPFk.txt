ladies and gentlemen the engineers drinking song back in the day I've drunk quite a lot to that song and as drinking songs go it's not bad I caution you however before playing this song If in the presence of small children audition at first some of the some of the verses are sufficiently gross as to make a sailor go beyond blushing it's an interesting song because there are an infinite number of verses here's the mathematical proof Suppose there were a finite number of verses then there would be a last verse and if there were a last verse then some drunk alumni would compose a new one therefore there is no last verse the size is not finite and there are an infinite number of verses I play it for you today because uh I'm an engineer I I like to build stuff I build stuff out of wood I build stuff out of metal I build stuff out of rocks and I especially like to write programs I don't know sometimes uh people come to me and say I'm majoring in computer science but I don't like to write programs I've always been mistified by that I mean if you want to show how tough you are you can go bungee jumping or driving nail through your hand or something like that instead but I've written quite a few programs uh for demonstrating uh stuff in um in this subject uh they're all written in Java principally because um I can therefore make them available to you and to the rest of the World by way of webart a few weeks ago I was monkeying around with the system and broke the version on the server and within 15 minutes I got an email from somebody and the depths of Anatolia complaining about it and asking me to bring it back up this particular program is patterned after an early AI classic and it was the uh business end of a program written by Terry winegrad who became and is a professor uh of um computer science at Stanford University uh which is on the west coast for these uh on the on on the strength of uh his his work on the natural language front end of this program but uh the natural language part is not what uh makes it of interest to it to interest for us today it's more the um other kinds of stuff let's pile these things up now I'm going to ask to do something maybe put um put B2 on top of B7 not bad how about B6 on B3 this program's kind of clever um let me do it one more let's put U B7 on B2 okay now let's see maybe uh B5 on B2 well B4 on B3 first maybe no I must have click the wrong button oh there it goes okay let's put it let's put B4 on B1 ah my mouse keeps getting out of control now let's put B1 on B2 this is an example I'm actually going to work out on the board so oh I see my touchpad accidentally got activated B1 on B2 now let's ask a question okay well okay stop had enough of that let's see uh why did you put why did you want to get rid of before okay want to clear the T than than you so what happens when you use software you write yourself why did you want to clear the top of B2 did I do that uh why did you clear the top of B1 okay well it's haunting me yeah so it's the drinking song is e easily offended I guess but I won't I won't develop that scenario again uh what I wanted to show you is that this program looks like it's kind of smart and it somehow can answer questions about its own behavior you ever written a program that's answered questions about its own behavior probably not would would you like to learn how to do that okay so by the end of the hour you'll be able to write this program and many more like it that know how to answer questions about their own behavior there have been tens of thousands of such programs written but only by people who know the stuff I'm going to tell you about right now okay so what I want to do is I want to start by taking this program apart on the board and talking to you about the modules the subroutines that it contains so here it is the first thing we need to think about here are some blocks what Happ what has to happen if I'm going to put the bottom block on the larger block well first of all I have to find space for it then I have to grasp the lower block then I have to move it then I have to the block that has been commanded to move then it has to move and then it has to UNG grasp but taking uh hints from some of the questions that it did answer before I got haunted by the music taking our Q from that we know that in order to grasp something in this particular world you can't have anything on top of it so grasp therefore may call clear top in order to get stuff off uh from the target object and that U may happen in iterative Loop because there may be several things on top and how do you get rid of stuff well by calling get rid of and that may go around the loop several times and then the way you get rid of stuff is by calling put on so that gives us recursion and it's from the recursion that we get a lot of the apparent complexity of the program's behavior when it solves a problem now in order to find Space you also have to call get rid of so that's where I meant to put this other iterative loop not down here clear top is got the iterative loop inside of it so that's the structure of the program it's extremely simple and you might say to me well how can you get such apparently complex looking Behavior out of such a simple program or a legitimate question but before we tackle that one head on I'd like to do a simulation of this program on a very simple blocks problem and it's the one I almost showed you but it goes like this here's B1 we'll call this BX because I forgot its name here's B Y and here's B2 and the task is to put B1 on B2 and according to our system diagram that results in four calls to sub routines we have to find Space we have to grasp B1 we have to move and then we UNG grasp now the way we grasp something is the first thing we have to do is clear off its top so graphs calls clear top and clear top in turn calls get rid of and let me see let me keep track of these this is clearing the top of B2 of B1 and this is getting rid of BX and the way we get rid of BX is by putting the X on the table and then that in turn call causes calls to another fine space another grasp another move and another ungraspables it must do that by using this Trace okay so how for example does it answer the question why did you get rid of BX manasa what do you think how can I answer that question so it goes up one level and reports what it sees so it says and said in the demonstration I got rid of BX because I was trying to clear the top of B1 so if I were to say why did you clear the top of B1 it would say because I was trying to grasp it if I were to say why did you grasp B1 it would say because I was putting B1 on B2 if I say why did you put B1 on B2 it would say slavishly because you told me to okay so that's how it deals with with why questions how about how questions Timothy what do you think about that one how would it go about answering a question about how you did something do you have a thought um yeah I would think about what I was trying to accomplish yeah but how would it do that how would the program do that we know that answering y question makes it go up one level how does it answer how question Sebastian you go down one level so you start start off all the way up here with a put on it will say oh well I did these four things if you say why did you grasp E1 it will say because I was trying to clear its top why did you clear its top because I was trying to get rid of it why were you trying to get rid of it because I was trying to put it on the table so that's how it answers how questions by going down in this tree in this Trace of program action so as to see how things are put together what are these things that are being put together what's the word I've been avoiding so as to bring it this to a crescendo what what are these objectives these things it wants to do they're goals so this thing is leaving a trace which is a gold tree does that sound familiar uh three days ago we talked about gold trees in connection with uh integration so this thing is building a gold tree also known as an Andor tree so this must be an an tree and if this is an an tree are there any an nodes sure there's one right there so do you think then that you can answer questions about your own behavior as long as you build an ort tree sure does this mean that the integration program could answer questions about its own behavior sure because they both build gold trees and whenever you got a gold tree you can answer certain kinds of questions about your own behavior so let me see uh if in fact that's if it really does build itself a u a gold tree as it solves problems so this time we'll put B6 on E3 this time we'll watch it develop its go tree so in contrast to the simple example I was working on the board this gets to be a pretty complicated goal tree but I can still answer questions about behavior for example I could say why did you put B6 on B3 because you told me to all right so the complexity of the behavior is largely a consequence not of the complexity of the program in this particular case but the building of this giant gold tree is a consequence of the complexity of the problem and this brings us to one of our uh brings us rather early on to one of the Goldstar ideas of today and this Goldstar idea goes back to a lecture given in the late 60s by herb Simon who was the first Nobel laurate in the pseudo Nobel Prize for economics is that right Bob we see the first yeah he's the first winner of the Nobel Prize pseudo Nobel prize in economics and in this lecture which was titled science as the artificial he said imagine that you're looking on a beach at the path of an ant and he said well you know the path of the ant looks extremely complicated and you're temp to think the ant is some kind of uh of Genius or or Monster brain ant but in fact when you take a closer look what you discover is that there are a bunch of Pebbles on the beach and all the ant is doing is avoiding those Pebbles on its way home so the complexity of the behavior said Simon is a consequence of the complexity of the environment not the complexity of the program so that's the metaphor of Simon's ant and what what it says is that the complexity of the behavior is the max of the complexity of the program and the complexity of the environment so so that's something we'll see over many times during the rest of the semester complex Behavior simple program you think it's going to be complicated turns out to be simple because the problem is the has the complexity not the not the program so that brings us to uh checkbox 3 in today's talk and there's a little bit of a seam here because now I want to stop talking about goal- centered programming and start talking about rule-based expert systems Ro based expert systems were developed in a burst of um enthusiasm about the prospects for commercial applications of artificial intelligence uh in the mid 1980s and at that time it was supposed lengthy articles or written that you could account for useful aspects of human intelligence by writing all the knowledge in the form of simple rules so if this is true then that's true if you want to achieve this then do that but all the knowledge had to be encapsulated in the form of simple rules so what might you want to do with this all sorts of things thousands of these systems were written as I indicated before but here's an example I'm going to work out an example having to do with identification and this this example is patterned off of a classic program strangely Al written at Stanford called M it was developed to diagnose bacterial infections of the blood so you come in you got some horrible disease and the doctor gets curious about what antibiotic would be perfect for your disease and starts asking you a lot of questions so I'm going to deal with that because that world has all kinds of un unpronouncable terms like bacterioides and and Anor robic and stuff like that so it's completely analogous to talk about identifying animals in a little Zoo sort of a small town type of zoo so I'm going to suggest that we write down on a piece of paper all the things we can observe about an animal and then we'll try to figure out what what the animal is so I don't know what what can we start with um has hair then there are some characteristics uh of the following form has Clause sharp teeth and forward pointing eyes and these are all characteristics of carnivores uh we happen to have forward pointing eyes too but that's more because we used to swing around at trees a lot and we needed the stereo vision and we don't have the the claws and the sharp teeth to go with it but anyhow those are typically characteristics of carnivores as is eating meat and this particular little animal we're looking at uh is also got spots and it's very fast what is it oh well everybody says it's a cheetah let's see how program would figure that out well program might say uh let's see if it has hair then rule one says that that means it must be a mammal we can imagine another rule that says if you have sharp claws uh sharp teeth and forward pointing eyes then you're a carnivore and I'm using sort of Hardware notation here that's an andate right so that means that we have to have all of these characteristics before we will conclude that the animal is a carnivore now this animal has been also observed to eat meat so that means we've got extra evidence that the animal is carnivorous and now because the animal is a mammal and a carnivore and has spots and it's very fast that the animal is a cheetah and I hope all of our African students agree that that must be a cheetah it's a small zoo I mean if a big Zoo who knows what it is it's probably got some unpronouncable name there other possibilities but for our small zoo that will do so we have now written down in the form of these and Gates several rules R1 R2 and there needs to be an endgate here that's R3 and an R4 all of which are indicated all of what indicate that this animal is a cheetah so we built oursel a little role based expert system can recognize exactly one animal but you can imagine filling out filling out the system with other rules so you could recognize giraffes and Penguins and all the other sorts of things find a small Zoo so when you have a system like this that works as I've indicated then what we're going to call that we're going to give that a special name and we're going to call that a forward chaining rule based because it uses rules expert system and we're going to put expert in parenthesis because when these things were developed for marketing reasons they call them expert systems instead of novice systems but are they really experts in a human sense not really because they have these knee-jerk rules they're not equipped with anything you might want to call Common Sense they don't have an ability to deal with previous cases like we do when we go to medical school so they really ought to be called rule-based novice systems because they reason like novices on the basis of rules but the tradition is to call them rule-based expert systems and this one works forward from the facts we give it to the conclusion off on the right that's why it's a forward chaining system okay can this system answer questions about its own behavior W what do you think why because it looks like a gold tree all right this is in fact building a gold tree because each of these rules that require several things to be true is creating an an note and each of these situations here where you have multiple reasons for believing the thing is a carnivore that's creating an or node and we already know that you can answer questions about your own behavior if you leave behind a trace of a gold train so look at this if I say to it why were you interested in the animals Clause because I was trying to see if it was a carnivore how did you know that the animal is a mammal because it has hair why did you think it was a cheetah because it's a mammal a carnivore has spots and very fast so by working forward and backward in this this gold tree this too can answer questions about its own behavior so now you know how going forward you can write programs that answer questions about their behavior either you write the sub rutine so that each one is wrapped around a goal so you got goal centered programming or you build a so called expert system using rules in which case it's easy to make it leave behind a trace of a gold tree which makes it possible to answer questions about its own behavior just as this block world program did but now a little more vocabulary uh I'm going to save time by erasing all of these things that I previously Drew by way of connections and I'm going to approach this zoo in a little different way I'm going to not ask any questions about the animal instead I'm going to say mommy is this thing I'm looking at a cheetah and how would mommy go about figuring it out in her head she would say well I don't know if it's going to be a cheetah then it must be the case that it's a carnivore and it must be the case that it has spots and it must be the case that it's very fast so so far what we've established is that if it's going to be a cheetah it has to have the four characteristics that mommy finds behind this rule are four so instead of working forward from Facts what I'm going to do is work backward from a hypothesis so here the hypothesis is this thing is a cheetah uh how do I go about showing whether that's true or not well I haven't done anything so far because all I know is is it cheetah if all of these things are true but are they true well to find out if it's a mammal I can use rule one and if I know or can determine that the animal has hair then that part of it is taken care of and I can and similarly work my my way back through carnivore by saying well it's a carnivore if it has claws sharp teeth and forward pointing eyes and in as much as the animal in question does then I'm through I know it's a carnivore I don't have to go through and show that it's a carnivore another way so I'll never actually ask questions about whether it eats meat finally the final two conditions are met by just an inspect ction of the animal that is to say it's in the database I don't have to use any rules to determine that the animal has spots and it's very fast so now I've got everything in place to say that it's a cheetah because it's a carnivore because it has claw sharp teeth and forward pointing eyes and all the rest of the stuff is similarly determined by going backwards backwards from the hypothesis toward the facts instead of from the facts forward to the conclusions so going Building A system that works like that I have a backward a backward chaining rule-based expert system but there's a very important characteristic of this system in both backward and forward mode and that is that this thing is a deduction system that's because it's working with facts to produce new facts and when you have a deduction system you can never take anything away but these rule-based systems are also used in another mode where it's possible to take something away see in in fact World in deduction world you're talking about proving things and once you prove something is true you can't it can't be false if it is you've got a contradiction in your system but if you think of this as a programming language if you think of using rules as a program language then you can think of arranging it so that these rules add or subtract from a database let me show you an example of um a couple of systems first of all since I've talked about the M system let me show you um an example of uh a m dialogue that's a m dialogue and you can see the appearance of words you have to go to medical school to learn and here's a typical M rule just like the rules for doing Zoo analysis only a more complicated domain but here's another example of a system that was written not in the 80s but just a couple of years ago by a student in the um architecture uh Department uh PhD thesis he was interested in the architecture of a Portuguese architect named cesa and cesa has done a lot of Mass housing stuff and cesa has the idea that you ought to be able to design your own house and so Jose dwarte a Portuguese student in this PhD student in architecture wrote A rule-based system that was capable of Designing caesa Like Houses in response to the requirements and and recommendations and desires of the people who are going to occupy the houses so the most compelling part of this thing of this exercise was that DTE took some of the designs of the program mix them up with some of the designs of Caesar and put them in front of Caesar and said which ones did you do and cesa couldn't tell so somehow the world based system that was built using this kind of Technology was sufficient to confuse even the expert that they were patterned after but this program is a little complicated it too has its own specialized lingo so uh I'm not going to talk about it in detail but rather talk instead about an analogous problem and that is a problem that U everyone has faced at one point or another and that is the problem of putting groceries in a bag at a grocery store it's the same thing right instead of putting rooms in a house you're putting groceries in a bag and there must be some rules about how to do that in fact maybe some of you have been professional grocery store Baggers aeriel is a grocery professional bagger you're which one I used to Market yeah what is your name Lisa Lisa okay well we got two two professional grocery store Baggers and I'm going to be now simulating a highly paid knowledge engineer desirous of building a program that knows how to bag groceries so I'm going to visit your site Market Basket and I'm going to ask Lisa now fearful of losing her job if she would tell me about how she bags groceries so could you suggest a a rule sure large item the B large items in the bottom you see that's why I'm a highly paid knowledge engineer because I translate what she said into into an if thenal so if large then bottom so now so how about you Ariel you got a suggestion about how to bag groceries I mean small things up if small then on top Lisa have you got anything else you can tell me to many heavy things in the same bag don't put too many heavy things in the same bag so if heavy greater than three then new bag or something like that okay is that all we're going to be able to do is anybody else want to volunteer Sila have you bag they bag groceries in Turkey so they don't have uh grocery Baggers so we have yeah everybody's a professional bagger it's outsourced to the custom so no squishies on the no squishies on the bot you have tomatoes that's good tomatoes you don't want them to get squish now there's a very different thing about squishies and tomatoes because tomato is specific and Squishy isn't uh one tendency of MIT students of course is that we all tend to generalize I once knew a professor in a Sloan school who seemed real smart and uh then I figured out what he did if I were to say I'm uh thinking about a red apple he' sit back up and say oh I see you're contemplating colored fruit today just a taking it up one level of abstraction man of Genius he also was able to talk for an hour after he drew a triangle on the board amazing people anyhow where were we oh yes uh bagging groceries so uh we're making some progress uh but not as much as I would like and so in order to really make progress on tasks like this you have to exercise you have to know about uh some principles of knowledge engineering so principle number one which I've uh listed over here as a part of a gold star idea is deal with specific cases so while you're at the site if all you do is talk to The Experts like Lisa and aerial all you're going to get is vague generalities because they won't think of everything so what you do is you say well let me watch you on the line and then you'll see that they have to have some way of dealing with the milk then they will see that they have to have some way of dealing with the potato chips nobody mentioned potato chips except in so far as they might be squishy squishy we don't have a definition for squishy no one talked about the macaroni uh and no one talked about the motor oil this is a convenience store probably don't want that in the same bag with the meat and then uh no one talked about canned stuff here's a can of Olives so by looking at specific cases you will elicit from people uh knowledge that they otherwise would not have thought to give you okay that's rule that's knowledge engineering rule number one and within a very few minutes you'll have all three know engineering rules and be prepared to be a highly paid knowledge engineer rule urtic let's call these urtic theistic number one specific cases urtic number two is ask questions about things that appear to be the same but are actually handled differently so there's some Bird's eyee frozen peas and here some um fresh cut sweet peas and to me uh a person who's never touched a grocery bag in my life maybe I'm from Mars I can't tell the difference they're both peas but I observe that the experts are handling these objects differently so I say why did you handle those peas differently from those peas and what do they say one's canned and one's Frozen so what happens fingo I've got some new words in my vocabulary and those new vocabulary words are going to give me power over the domain because I can now use those words in my rules and I can write rules like if frozen then put them all together in a little plastic bag actually that's too complicated but that's what we end up doing right why do we put them all together in a little plastic bag what's that well there are two explanations the ah there's the MIT explanation uh we know that that uh that temperature flow is equal to the fourth power the temperature difference and the surface area and all that kind of stuff we want to get them all together in a ball sphere uh the normal explanation is that they're going to melt anyway so they might as well not get everything else wet all right so that's eristic number two and actually there's aristic number three um that uh I just want to relate to you for the first time because I have been dealing with it a lot over this past summer risting number three is you build a system and you see when it cracks and when it cracks is when you don't have one of the rules you need in order to execute uh in in order in order to get the program to execute as you want it to execute so if I were to write a grocery store bagging program and have it bag some groceries again eventually it would either make a mistake or come to a grinding Hall in bingo I know that there's a rising rule uh isn't that what happens when you do a problem set and you hit an impass you're performing an experiment on yourself and you're discovering that you don't have the whole program in fact I've listed this as a goalstar idea having to do with engineering yourself because all of these things that you can do for knowledge engineering are things you can do when you learn a new subject yourself because essentially you're making yourself into an expert system when you're learning circuit Theory or Electro magnetism or something of that sort you're saying to yourself well let's look at some specific cases well what are the vocabulary items here that tell me why this problem is different from that problem Oh this is a cylinder instead of a sphere or you're working the problem set and discovering you can't work the problem and you need to get another another chunk of knowledge that makes it possible for you to do it so this sort of thing which you think of in primarily as a mechanism ristics for doing knowledge engineering are also uh mechanisms uh for for making yourself uh making yourself smarter so that uh concludes what I want to talk with you uh about today but the bottom line is that if you build a rule-based expert system it can answer questions about its own behavior if you build a program that's centered on goals it can answer questions about its own behavior if you build an integration program it can answer questions about its own behavior and if you want to build one of these systems and you need to extract Knowledge from an expert you need to approach it with these kinds of tics because the expert won't think what to tell you unless you elicit that information by specific cases by asking questions about differences and by ultimately doing some experiments to see where your program is cracked so that really concludes what I had to say except um I want to ask the question is this all we need to know about human intelligence can these things be are these things really smart and the traditional answer is no they're not really smart because their intelligence is a sort of thin veneer and once when you try to get underneath it they tend to they tend to as written they tend to crack for example we talked about a a rule we could talk about a rule that knows that you should put the potato chps on the top of the bag but a program that knows that would have no idea why you would want to put in potato chips on top of the bag they wouldn't know that if you put them on the bottom of the bag they'll get crushed and it wouldn't know that if they get crushed the customer will get angry because people don't like to eat crushed potato chips so that's what I mean when I say the knowledge of these things tends to be a veneer so the M program during debugging once prescribed a barrel of penicillin to to be administered to a patient for his disease they don't know they don't have any common sense so the question then becomes well I don't know um does rule based do rules have anything to do uh with um with common sense and I'm becoming a little bit agnostic on that subject because there are certain indications there are certain situations in which rules could be said uh to play a a role in our ordinary understanding of things would you like to see a demonstration what I'm going to show you uh when a clip spoots up well before I make any promises let me see if I'm actually connected to the web MIT good M might guest yeah that's me sounds good okay I just tested the system and I've seen that it is actually connected to the web now I'm going to adjust um some uh systems options here we'll get rid of the text box and we'll get rid of uh this change its scale a little bit and then what I'm going to do is I'm going to read a little synopsis of the MC Beth plot now you're MIT students I'm sure you're all classically educated and very familiar with Shakespearean plots so I'm going to read one and read a version of a MC Beth flot and it's going to go along like this it's basically reading a rule base so far and pretty soon it's going to get beyond the rule base and start reading the MC Beth story and there it is it's read the MC Beth story let me show you what the MC Beth story looks like as it's actually retained by the system that's it you can read that okay you run out of time because the machine's already finished takes about 5 Seconds to read the story now as you look at this little synopsis of McBeth there are a couple of things to note for one thing it says that Duncan is murdered Duncan I hope this doesn't bother you Duncan is murdered by MC Beth but at no time does it say that Duncan is dead but you know Duncan's dead because he was murdered if murdered then dead so if you look a little further down what you see is that um McDuff kills MC Beth fourth line up from the bottom why did MC Beth why did McDuff kill mcdeth doesn't say why in the story but you have no trouble figuring out that it's because he got angry and when you get angry you don't necessarily kill somebody but it's possible so now that you see what's in the story let me take you back back to this display it's what we call an elaboration graph and when I blow it up you can see that there's some familiar looking things in there for example up here in the leftand corner MC Beth murders Duncan right over there and over here MC Beth kills McDuff kills MC Beth if you look at what is a consequence of that it looks like there must be a rule that says if you murder somebody you harm them and if you murder somebody then they're dead dead and one reason why you might kill somebody is because they angered you and if you go the other way one con consequence of killing somebody is that you harm them and that they get and they die too and if you harm somebody they get angry and their state goes negative so that suggests that there are some things that we have in our heads that are very compiled and very a strangely enough very rule like in um in their character now to close I'm just going to read Hamlet the Hamlet demonstration is much like the MC Beth one in fact Hamlet and MC Beth are very alike in their plot but there's one thing that's well illustrated by our particular capturing of of Hamlet here and that is that you'll note that the ratio of gray stuff to white stuff is considerable the gray stuff is stuff that has been deduced by rules and the reason there's so much great stuff in this Hamlet story is because everybody's related to everybody else so when you kill anybody you you you irritate everybody else so look at that a few white things those are the things that are explicit in the story and lots of gray stuff so what this is suggesting is that when we tell a story it's mostly a matter of controlled hallucination I know what rules are in Europe head so I can take advantage of that in telling the story and not have to tell you anything you I'm sure you're going to know and so that's why we've discovered that storytelling is largely a matter of just controlling how you're going along a kind of controlled hallucination