welcome to exploring computing today's video is computer security mechanisms so in this video we're going to look at the different mechanisms that we use to keep computers secure on the network and you'll recall from the last lecture uh we talked about four different network security concerns confidentiality making sure that our communications are confidential and nobody is able to eavesdrop authentication being able to determine that the person who we're talking to is who they say they are integrity making sure that our messages aren't tampered with and non-repudiation being able to determine whether or not somebody actually carried out a particular action in a way such that they can't repudiate it the mechanisms we're going to be talking about now are going to take care of these different problems these all fit under the general umbrella cryptography which is a study of how to send secure messages they're going to depend on encryption techniques encryption means to take a plain text message and convert it to an encrypted ciphertext message and decryption which is the reverse process taking the ciphertext message and converting it back to the original plain text now we've been doing encryption for thousands of years and so i'm going to start off by showing you how the caesar cipher works this is a pretty simple cipher that you'll all be able to understand quite easily and it was used by julius caesar so you can see we've been encrypting for quite some time okay the way the caesar cipher works is we shift letters in the message by three letters so uh if i've got a message and i've got the letter a in the original text i'm going to go ahead and shift that a b c d and instead of writing the a i'm going to write a d instead of writing a b i'm going to say b c d e okay if i shift b over by three characters i get an e and so i'm going to write an e instead of a b i'm going to write it f instead of a c and so on all right so let's take a look at the caesar cipher in action so suppose the tas are unhappy with how i'm running the class and they decide that they are going to meet for lunch and plot a coup d'etat so they're concerned because they know i'm a tyrannical guy so they don't want me to know that they're meeting and so they're going to take their uh message here meet for lunch and they're going to encrypt it using the caesar cipher so the m if we shift it over by 3 mnop the e becomes efgh the t becomes t u v w and so on and so you can see that meat for lunch becomes phhw iru 0xqfk and just again as a reminder we refer to the original text as plain text and the converted text as ciphertext now i play the role of mallory here i'm the bad guy and so i intercept the tas texts and i see phhw iru 0x qfk i think huh i seem to recall ireu stands for something this must be some new newfangled kids internet speak i guess they're just having fun i have nothing to worry about uh everything's going great and um so the tas are able to meet for lunch and replace me and they will be teaching lecture shortly this is actually a true story because ivy who is one of our tas will be teaching the lectures on artificial intelligence because she is far more of an expert on modern artificial intelligence than i am i actually have a master screen artificial intelligence but it's from 1986 so i think things have changed a bit since then all right anyway back to the caesar cipher all right so just as a reminder um we have encryption and decryption so alice is going to start with a plain text meet for lunch she's going to generate the ciphertext p-h-h-w-i-r-u-0x qfk and then when bob receives that ciphertext he's going to have to pass it back to the decryption algorithm in order to understand what the heck alice is actually trying to tell him all right there's actually if you think about it there's actually two components to the caesar cipher there's the general shifting algorithm and then the z-mount to shift so apparently augustus caesar actually used the same shifting algorithm as julius caesar did but he changed the amount to shift it's still shocking to me that uh their opponents could not figure out the cipher but they didn't um which brings us to the next question why am i shocked that this cipher actually worked because there's a lot of problems with the caesar cipher the main one being the key size is way too small if we're using english letters you can only shift up to 26 characters and in fact the 26th character actually rolls around to the original character so arguably you only have 25 characters because the 26 is useless um and so this is susceptible to what's called a brute force attack and so the idea behind a brute force attack is i just try all the different combinations of characters until i use one of them and it results in something that looks like normal english text i'm like oh that must be the meaning of the message but it turns out that the caesar cipher is not just bad because there's only a very limited number of keys it's also bad because it's susceptible to cryptanalysis and so a cryptanalysis means is that we take a look at the ciphertext and we're able to discern information about uh the message and the key just by looking at the the text and so if we look at this text i p-h-h-w u 0 x q f k the thing that immediately stands out to me is that pair of h's next to each other now how many letters are there in the english language that you can get two of them right next to each other i mean there are there's more than just two of them but there aren't that many of them offhand you could have two o's next to each other like look you can obviously have two e's next to each other i think you can have two l's next to each other but you know there aren't that many letters which you can have two of next to each other and it'd still be a word in the english language and moreover this particular message doesn't have uh this particular weakness but um if we have a message that has a word with a single character in it there's also a very limited number of messages that can only have a single character in it like i or a and so if we're caesar's opponents and we're intercepting a bunch of these messages over time we're going to see messages with these pairs of duplicate letters we're going to see messages with single letter words and over time we're going to be able to reduce the amount of possible keys far below the original 26 and so the caesar ciphers just seem super super weak and it's a little scary to believe that uh and apparently this is true this was used by julie caesar um shocking i like using it though because it's it's something that you know people students can look at and they're like okay i kind of get that and so the same general process is going to be used with real ciphers uh real modern ciphers although the conversion to the ciphertext is going to be much more complex and mathematically based if we look at the caesar cipher there's actually two different things that are keeping these messages safe the first one is the number of keys and as we saw that's really weak with the caesar cipher although in a modern cipher that's that is really the thing that's keeping you safe you just need a really big key and the second thing is what the algorithm is and presumably what was keeping the caesar cipher safe was the algorithm people didn't realize that this was a shifting algorithm and so they just looked at the message and they just thought it was gibberish and didn't know how to break the code but it might surprise you to learn that modern encryption algorithms are all public so if you want to know the algorithm being used to send encrypted traffic on the internet well it's publicly available and you can take a look at it why do we tell everybody what algorithm we're using well the hope here is that um you know we're concerned that the black hat hackers the bad guys are going to be trying to break these algorithms and steal all of our information um and the hope is that the white hat hackers or security experts the good guys are going to analyze our encryption algorithm and determine if they're susceptible to cryptanalysis and actually stanford's been involved in several of these efforts and there are encryption outcomes that were formally used that are not being used anymore because of work by a stanford computer scientist so there you go white hat hackers in action um one thing i should mention is that a lot of the things that i say about keys are actually also true passwords so keys and passwords aren't the same but there definitely are strong similarities so passwords like keys are susceptible for to brute force attack so with the key you try all the different combinations with passwords you just try all the different combinations of letters or letters to numbers um until you hit the one that matches uh the original the person's original password and as with the keys where you know the problem with the caesar cipher is there are only 25 or 26 keys um with passwords longer passwords are much better but also passwords are susceptible to analysis and there are certain passwords that are nice and long but that are used by a lot of other people and so that would be a really bad idea to use those hackers have list of the most common passwords so um you know you really want a long password that it's completely random we'll talk more about passwords in another lecture but uh i just know what usually when i'm talking on this subject the students get a little confused because some of the things that we say about these keys seems to be related to passwords and yes there are strong similarities between the two all right so the caesar cipher is what we refer to as a symmetric encryption technique in symmetric encryption the same key is used for encrypting and decrypting so with the traditional caesar cipher is used by julius caesar the key is three so both the person who's encoding needs to know that they're shifting it by three and whoever receives the message knows that they need to decrypt it by shifting back by three so uh the same key is used for encrypting and decrypting there's another encryption technique called asymmetric encryption where we have two keys one key is used for encrypting and the other key is used for decrypting and it turns out having two different keys is super super useful now the two keys have to be mathematically related to each other and they are going to be generated as pairs and if we have one of the keys in the pair we can't be able to determine the other key in the pair easily because if i can get from one key to the other key uh this these keys are gonna be useless for asymmetric encryption so they're generated together at the same time um and but if somebody gets a hold of one of the keys but doesn't have the other key they can't be able to reverse engineer it to figure out what the matching key is that would be bad and if they are able to do it then we're uh we're completely vulnerable so symmetric encryption has been around for pretty much forever as as we've seen from our example the caesar cipher asymmetric encryption on the other hand is quite recent it was first published by diffie hellman in 1976 and the hellman in diffie hellman is actually martin hellman who's a professor in stanford's ee department and is the winner of the turing award which you'll recall is the equivalent of a nobel prize in computer science uh i guess when alfred noble was creating the nobel prizes there was no computer science at the time so we didn't get one of them so we made up our own which is a turing award and professor helmut is the winner of the touring award it turns out it was also discovered by the british intelligence government communications headquarters in 1973 but they didn't publish the work asymmetric encryption is sometimes referred to as public key private key encryption or sometimes just simply as public key and as these names apply making one of the keys public is often very useful and it will allow us to solve a bunch of the problems that we looked at um when we were talking about network security issues so one of the problems with symmetric encryption is the problem of how somebody gets a key so suppose i am communicating with amazon and i want to communicate with them in a secure manner i'm going to provide them with information like my credit card how can we make sure we're shopping securely on amazon if we've got symmetric encryption we know we need to have a shared key we're both using the same key for encrypting and decrypting we both have that key and it needs to be very long because remember longer is better longer is more secure and so the big question that comes up is how do i get the key well think about that for a minute how am i going to get the key from amazon um well one obvious thing is they could email to me that turns out to work because email is not secure and in fact i can't think of a good way for amazon to get that key to me other than through snail mail uh but you know snail mail is you know sending to the u.s postal service that's a really bad idea from their standpoint i mean it will work but that means i would put a bunch of stuff in my shopping cart the first time i went to amazon and i'd be like okay i'm ready to check out and they'd be like oh well we're going to mail you this key um through the u.s postal service and it will probably take three days but it might take longer and when you get it you can enter the key into the web browser and then you can send us a credit card like yeah i'm pretty sure they would lose a lot of people just at the shopping cart right at that point the other problem is take a look at what the key looks like so this is the actual key that amazon has you can see it doesn't actually fit you can see the little scroll bar there on the right if amazon were to mail this to me it would be on the printed page and i would have to enter in all these hexadecimal digits and not get any of them wrong in order to communicate securely with amazon using symmetric encryption okay this is totally not happening all right so how does asymmetric encryption solve our problem very easily amazon takes one of their keys says this key is going to be the public key and they just put it up on their website in fact we just saw it a minute ago that's their public key um and then when i want to talk to amazon i take their public key and i encrypt whatever i want to send to amazon with that public key and anyone intercepting our traffic can see that i'm sending information amazon they know it was encrypted with the public key they also have access to that public key but that public key doesn't decrypt messages that were encrypted with it we need the private key in order to decrypt the message we don't have the private key and as long as amazon keeps their private key private i can encrypt messages and send it to amazon and nobody else can read it so we are now able to uh communicate with amazon and secure manner now usually what's going to happen with websites like amazon all the other websites work the same way um i'm going to start off with an asymmetric encryption because that's you know they're going to provide me with their public key and i'm going to encrypt something and send it to them uh and they're the only ones that are going to be able to read it because they're the ones with the private key but as soon as we can we're going to generate a symmetric key that only the two of us use the only the two of us know and that's what we're actually going to use for regular communication because it turns out symmetric encryption is computationally cheaper than asymmetric encryption and since their web server is decrypting all these messages anything they can do to register is the load on the server it's going to be better for them it's going to be cheaper for them okay i mentioned that email is not secure generally not secure it is certainly possible to create a secure email system using public key private key and in fact there is a system out there it's just not very widely used uh okay so how do we create a secure email system using public keys well basically everybody just publishes their public key and then if somebody wants to send them a message they just take that public key they encrypt the message with that public key they send it through the internet everybody can see all the traffic sent through the internet but uh you know if somebody sees that message on the internet it's encrypted with the public key they also have access to the public key but they don't have access to the key that they need to decrypt it that's the private key and so the email is secure um public key private key can also be used for non-repudiation so here's you'll recall this is our non-repudiation example from last uh last video so suppose i send out a message i say no final exam maybe i'm drunk or something and on a lark uh i decided to send out this no final exam message and then later the next day i'm like oh god did i actually send a message there was no final exam oh crap i didn't mean to do that i'm going to take it back i'm going to tell them that wasn't me must have been somebody else must been maddie uh that actually is not a very good example because if maddie actually has access to my computer she could totally send it uh in a way that would violate our little example here so anyway so i'll talk about that in a minute when i tell you how this all works all right so uh the way we have non-repudiation is if my system is set up so that when i send that message no final exam i actually encrypt no final exam with my private key and you guys all receive it and you decrypt it with my public key now you can be like patrick you must have sent that message because only you have the private key that could be used to encrypt the message in such a way that we can decrypt it with your public key so therefore you can't repudiate you must have sent this okay going back to our example maddie and maddie actually has access to my computer um she's sleeping under the coffee table right now uh if if maddie actually has access to my computer and uh you know my private key sitting there on my computer and probably my whole email system set up to use the private key um you know she could totally send the message so basically this whole system is only as secure as your private key is secure asymmetric encryption is also used to identify websites uh the way this works is that there are a number what are referred to as certification authorities that are responsible for certifying websites the most common certification authorities have public keys which are built into your web browser it's also possible to add additional certification authorities by explicitly adding their public keys to the web browser i don't recommend doing this in general so if you go visit certain websites you may get a message that oh this website is certified by such and such a certification authority which the web browser doesn't know about should i add this certification authority to your list of certification authorities and in general i don't think there are good reasons for a website to not use one of the standard certification authorities at this point so just be aware if you say yes that means other websites certified by this potentially sketchy certification authority are also going to be assumed to be legitimate by your web browser and that may not be something that you want to do so be cautious adding additional certification authorities to your web browser so the way this is going to work is a website that wants a certificate is going to contact the certification authority and they will provide sufficient identification to the certification authority to convince the certification authority that they are who they say they are and then the certification authority is going to take their information and generate a certificate using the certification authority's private key and so uh you have the public key built into the web browser and the certification authority has the private key used to generate the certificate the certificate is going to be placed on the website and when we visit the website we will download the certificate to the web browser the web browser will attempt to decrypt it and if it can be decrypted with the public key built into the web browser than we know was actually issued by the certification authority the certificate includes the website's public key and we use the public key to initiate communication with the website notice that this system does depend upon the certification authorities correctly vetting those who ask for certificates and also keeping their private key safe and secure and it turns out that sadly both of these have failed at various points with this certification authorities there's been at least one case that i'm aware of where a certificate was authorized and given to somebody claiming to be microsoft and it turned out they weren't microsoft and there's also been a case where the certification authority itself was hacked and uh their private key was stolen so great job guys when you are communicating with a website that has a certificate and is you you're going to be communicating using https instead of http so standard non-secure communications on the web uses http secure communications uses https which is a secure variant of http and when we are using https that means that all of our traffic to and from that website is being encrypted okay let's go back to our list of uh network concerns that we had before so confidentiality um being able to communicate in a secure manner such that if somebody's trying to eavesdrop they can't read our communication well we've seen that both symmetric and asymmetric encryption takes care of that authentication we've just seen that with the certification authorities the certification authorities use public key private key in order to provide certificates that guarantee that a website is who they say they are non-repudiation we saw that public key private key could be used to set up a system where people could not repudiate actions that they had taken and then that leaves integrity which we haven't talked about yet so let's take a quick look at integrity the simplest way to generate integrity is to use a checksum and check some there's a variety of different ways to check some but the simplest way to do it that i think students understand intuitively is you just take all the different values of that are contained in the file you treat all those bits as numbers and add all the bits together um now it's going to come up with a really big number so you probably want to chop off a whole bunch of the high-end bits and you basically do a modulus if you're familiar with the modulus it's a sort of a remainder integer remainder and then you go ahead and take the remaining value and use it as your checksum all right so the way this is going to work is if you transfer say a file over the internet um originally the person that created the file is going to create that checksum they're going to either include it with the file or they will send it separately from the file your computer will receive the file it will go back through and add everything up to to see what checksum it gets and if the two checksums match then you know that there's a good chance that the file was not in fact corrupted now um it's possible for the file to be get corrupted in just such a way that the checksum is still the same so that is a possibility but it's unlikely the problem with checksums though is since it's pretty easy to understand how the checksum is generated it's also pretty easy to reverse engineer things so that you manipulate the file in just such a way that the checksum remains the same so this is actually kind of a problem i should also mention that you may run into checksum if you download a zip file you'll you will occasionally run into zip files where it says there's a checksum error and so that's what's going on with those it's saying hey we calculated the checksum when we generated the zip file and now uh when we're unzipping it we're double checking to check some and they don't match so something went wrong here you know either it was uh you downloaded over the internet and some of the bits got twiddled or you know maybe somehow got corrupted on one end or the other end but somehow we know that the checksum is not the original checksum for the files when we originally generated the zip file so something is wrong here so that's probably the most likely place you're going to run into checksum all right um so as i mentioned uh a malicious attacker can manipulate the file in just such a way to maintain the checksum so uh there's another technique we can use called a hash or a cryptographic hash these work similar to the check sound but they work in such a way that it's it's much more difficult for somebody to try and manipulate the file in such a way that we end up with the exact same hash so these are going to guarantee but from both accidental changes which is what our checksum did but they will also guarantee against deliberate corruption of the data you will occasionally run into these when you download things from websites particularly software that's open source so here um i used a program called audacity much earlier in the quarter actually the first week of the quarter when we were talking about computer music it was a program where i was playing music to the computer and it was showing us what the waveform looked like if you go to the audacity website they don't actually host the audacity files themselves because it costs a lot of money to serve up copies of the audacity files to everybody that asks for them so instead they have a bunch of other people you can download the files from and they want to make sure that whoever gives you a copy the audacity source files has not somehow corrupted it and added in some sort of malicious thing in their code we'll talk about the different malicious things you could put in the code actually next lecture so what they've done is they've provided the different checksums and so you can see they have a whole bunch of checksums because there's a copy of audacity for windows there's a copy for mac there's a copy for unix and so on and so forth and so each of these is a different file and it has different code involved and therefore it has its own checksum and so the idea here is that you would download the file from a third party um you would get a hold that file and you would run something to generate the cryptographic hash so it turns out it is marked as checksums but these are actually using a cryptographic hash technique and that sah256 that you see in front of each of these checksums that is actually the specific cryptographic hash function that you need to run in order to get that number back so you would go ahead and download one of these files from from either from audacity itself which i think redirects to other people's websites or maybe you get it from a friend or somebody you want to just double check to make sure that this file is in fact what it says it is and so what you would do is you would take that file you would run the sha-256 algorithm on it that would generate this big long number and you would compare the big long number that the sha256 generated from the file that you have with the number published on the audacity website as the correct checksum and if the two match that tells us that uh this is in fact the original file that audacity came up with and if it doesn't match that's pretty bad it could just mean that um the file was just corrupted in network transit or it could mean somebody has deliberately inserted something at the file like maybe they've added some adware to it some spyware or something else even nastier to it and again we'll be talking about different nasty things people can do with files in effect in the very next lecture so i will talk to you then