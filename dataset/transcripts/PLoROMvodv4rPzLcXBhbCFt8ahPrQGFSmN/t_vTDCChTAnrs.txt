welcome to exploring computing today's video is bits bytes and binary part 3 or how to destroy a rocket with only 16 bits so in this video we're going to take a look at what happens when things go wrong i'm going to start off with a story about a rather expensive error where the source of the error was the programmers chose the wrong number of bits we're going to go back to the year 1996 the european space agency has a new rocket the ariane 5 which is as you might guess a follow-on to the aryan 4. on board this new aryan 5 rocket are four satellites worth 370 million dollars the rocket launches three two one fire things look like they're going well and then 37 seconds into the flight the rocket starts veering wildly off course it starts breaking apart and ultimately it has to be destroyed what went wrong what went wrong was in one place the program controlling the rockets tried to store information in 16 bits as you might recall in 16 bits we can store numbers as large as 2 to the 16 which means we can store numbers between 0 and 65 535 and while this number was large enough for the aryan 4 the predecessor to the air and 5 the aryan 5 had performance characteristics that caused it to run much faster and the value that it tried to stick in this to the 16-bit storage location did not fit and when it tried to put the value into 16 bits what ended up happening is we had a condition called overflow and what can happen in overflow is we can have a really large number and add one to it and end up with zero or we can have a large positive number add one to it and actually end up with a large negative number so we're going to take a look at this phenomenon in a minute this phenomenon is also related to another famous problem which is the y2k problem i know this is a little bit before some of your time so you may be thinking yeah my parents might be interested in this lecture but um what happened with the y2k problem is that programmers starting in the 50s were trying to save space in their computer programs and so when they tried to store the year they didn't store the full year with all four digits instead they would store just two digits so here's a little table for example so let's say the programmer was interested in storing the year 1952 they would just start 52 and then when that 52 got red from computer memory the computer would just know oh i need to add a 1 9 to it and so this would go on 1984 distort 84 95 star 95 but the problem is you can see here is when we start getting closer and closer to the year 2000 the programmers realize they have a bit of a problem if they just store zero zero and they do not fix their program the program is going to think that the year 0 0 represents the year 1900 not the year 2000 and so this was the y2k problem and what ended up happening was we had to spend millions and millions of dollars rewriting computer programs so that when the year 2000 hit the computers didn't think we were back in the 1900s all right so let's take a look at how overflow actually works i'm going to show you two different versions of overflow in the first version of this we're going to take a look at what happens when we're storing positive integers so i'm going to stick with 8 bits although typically these numbers will be much larger but it'll be easier to understand we only use 8 bits so in 8 bits if i'm only storing positive numbers we can store the numbers from zero to 255 and so suppose we have the number 255 stored in a particular storage location so here you can see you know i've got all my bits on this is the largest possible number i can store in eight bits and then i try and add one to it what happens well the natural thing if you recall our last video on how to how to add uh in binary and who can forget that video um what happened was uh when we added one we had that carryover and we had to carry over and we had to carry over and we had a carryover and it finally carried over to the far left and you can see what happens is the ninth bit gets flipped to one but guess what we don't have nine bits we only have eight bits because this particular value is only being started eight bits so what happens is that that ninth bit gets discarded there's no space for it and what has happened is our very large value consisting of all ones has flipped to a very low value consisting of all zeros so in terms of what's happening for decimal we have a 255 which is the equivalent of having all the bits in a particular byte switched to one we have 255 we've added one to 255 and we've actually ended up with zero so this is overflow so for our next example we're going to take a look at what happens when we have a large positive number but we're storing in a space that is allowed to store both positive and negative numbers so in this particular case again i'm just going to store all of our data in a single byte which allows us to store numbers between positive 127 and negative 128. now there are a number of different ways to store negative numbers on the computer the simplest way to store a negative number on the computer is something called sine magnitude representation inside and magnitude representation what we're going to do is we're going to take the high end bit and we're going to go ahead and say if it's a 0 we have a positive number and if it's a 1 we have a negative number so in the case of our single byte the way this would work is the seven low end bits would go ahead and represent our number and then the eighth bit would represent whether we had a positive number or a negative number it turns out that this has a number of problems though most notably it gives us both a positive zero and a negative zero so if all the bits are zero that's a regular zero and if all the bits are zero except for the leftmost bit is one that's a negative zero so that's kind of a problem so there are several other schemes used but the most common one is something called two's complement i'm not going to go into detail and two's complement i think we spend enough time on math for today but the key point on all of these schemes is that left most bit is going to represent whether or not we have a positive or negative number so what we're going to do now is we're going to go ahead and take our largest positive number which again leftmost bit is zero that represents we have a positive number and all the other seven bits are one this represents a positive 127. we're going to go ahead and add one to it and you can see what happens here is that most bit flips to a one this means we have a negative number and in fact using this standard two's complement representation this is actually a negative 128 so what has happened is we've had a very large positive number 127 we've added one to it we've got 128. so this is again an example of overflow so when you're working with a computer program or you're working with some sort of application and you think everything's going great and suddenly your bank account gets reset to zero or your bank account which was at a million dollars gets set to negative a million what's probably happening here is overflow this probably means whoever wrote the program did not do a very good job okay i've got one more type of error i want to introduce you and this is i suppose it's not actually technically an error what we're going to see here is that when we're working with binary numbers our intuition on what results should come up is not necessarily correct and so what i mean by that is we're going to add some numbers together and the results should be very very obvious to us when working with decimal but we'll see that the computer has some different ideas on what the answer should be so what i'm running here is this is the python interpreter this is a way in which i can interactively enter commands in the python programming language this is the programming language that cs105 students will be using a little bit later on this quarter and so what i'm going to do is i'm going to add some numbers here so let's let's ask the python interpreter to take 0.1 and add it to 0.2 and what is 0.1 plus 0.2 well naturally it's 0.3 let's see if the python interpreter agrees with us whoa what is this okay let's try another one let's ask the python interpreter to add 0.7 to 0.1 see it's pretty clear this should be 0.8 right okay python interpreter let's see what you got what okay so what what is going on here is is this computer just completely messed up now what's actually going on here is that numbers that we can represent in decimal in a set number of decimal places is not the same base 10 and base 2. so you may recall that there are certain numbers that we cannot represent in a fixed number of decimal places so let's say i tell you to write the decimal equivalent of two-thirds well what is the decimal number equivalent of two-thirds well you might say it's 0.67 but that's not actually accurate i could say no 0.66667 is a more accurate representation and in fact the correct representation would be this 0.6 repeating where this bar above the 6 represents a repeating decimal where that 6 is repeated forever ever and ever and ever so the problem we're running into here is it turns out that the binary number has different repeating numbers than the decimal number system and in particular the number 0.1 and base 10 you know obviously it's very finite 0.1 there you go that's the answer it does not have a finite value in binary in binary it's 0.0 and then zero zero one one repeating so for example zero point zero zero zero one one zero zero one one zero zero one one zero zero one one and so on and there's no set number of there's no finite number of places after the decimal point so what's happening here is we're taking these numbers where we are sure that there's a set number of decimal places like 0.7 plus 1.1 and we're getting a number that does not have a natural endpoint and so that's why these numbers are slightly off as a result of this programmers are cautioned not to use floating point numbers when representing money because you will get these slight variations that will cause your customer to be like wait what what is going on here all right so there's obviously a lot more that can go wrong with computing and in fact we'll see some of it later in the quarter but for now that's it for a little exploration of what can go wrong when we're working with binary numbers you