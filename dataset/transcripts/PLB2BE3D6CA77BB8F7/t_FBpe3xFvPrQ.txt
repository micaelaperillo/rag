the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu good morning everybody let's go back to where we were we were talking about abstract data type and the notion of objectoriented programming um and in particular the role of classes in in all of that a lot of people think this notion of objectoriented programming is a new notion in fact it's not it's been around for probably at least 35 years maybe even longer um but it's only been widely practiced for maybe 15 years even that to most of you will seem like a long time um started in the mid 1970s when people began to write articles explaining this advantage of the approach to programming and at about the same time uh the language Small Talk was developed at Xerox Park and clue developed at MIT uh and they were the first languages that in an elegant way provided linguistic support for this style of programming but it didn't really take off in the public until the introduction of java considerably later and Java was the first popular language to support object-oriented programming after that there was C++ which supports it in not a very elegant but a usable way and today probably python is the fastest growing language supporting object oriented programming it's used widely and that's one of the reasons we we teach it here as I said at the bottom of it all the most fundamental notion is that of an abstract data type and the idea is that we can extend our programming language by adding userdefined types and we'll shortly see why that's such a useful thing and that these types can be used just as easily as any of the built-in types why do we call them abstract data types rather than just data types and that we do that because we are essentially going to Define for each type an interface and essentially what the interface does is it explains what the method do what do I mean by what they do what they do at the level of the user not how they do it that of course is the way the built-in types work it wasn't until Tuesday that you understood how python made dicks do what they do before then I just explained that you could put in a key in a value and you could look it up and do an associative retrieval it was maybe not magic but it was wonderful that you could do this and not have to bother your heads with how it was made to work and that was because we provided or the designers of python provided an interface that let you use it we'll do the same thing with the abstract data types the key idea here is one we've talked about before and that's a specification it is the specification of a type or of a function or of a method that tells us what that thing does and we'll now till the end of the term try and maintain a very clear distinction between specifications and implementations all right let's look at an example so the example should be familiar to you uh you will remember that on Tuesday at the start of the lecture we looked at how we could use hashing to implement a set of integers and I explained to you that I wasn't very happy with the implementation because of the way it used This Global variable now we're going to see a much more elegant approach so I'm going to define a new abstract type called inet I do that by writing the name the word class followed by the name of the class and then there's this funny thing saying that it is a subass of objects ignore that for now and I'm going to come back to it later but fundamentally what it's saying is that every instance of interet is an object that's not very interesting because everything in Python is an object so from an information theoretic point of view there's no information here later we'll see that we can use this mechanism in a more interesting way all right now let's look at the methods so first I tell you a comment it's a set of integers then I've got this funny method called underbar underbar init whenever you see something with an underbar underbar in its name it has a special status in Python that lets us do elegant things with the syntax what will happen every time I create a new object of type inet the underbar underbar AIT method or function of the class will be executed on that object what it will do in this case is introduce two attributes of the object the attributes are numb buckets which is now replacing the global variable we looked at last time and I've arbitrarily chosen 47 and valve this will be the hash table itself containing the values and then exactly as we did on Tuesday I'm going to initiate and initialize excuse me the values so that each element of this list is now the an empty list now what's going on with this funny notion of self let's look at an example here I'm going to say s equals inset open close this will create create a new inset object execute the underbar underbar and knit so if for example I print self. num buckets whoops can't do that because self is not defined in this environment self was a local variable to underbar underbar and knit in fact the formal parameter but I can write self or s dot numb buckets and I'll see it's 47 num buckets and Val are now attributes of s attributes of the instance s of the class interet and I canally what we would expect yes s set you didn't put any object in between the parenthesis yes so that the question is well it looks like underbar underbar inset our underbar underbar in knit has a formal parameter and I've given it no corresponding actual parameter yes let me finish so that's what it looks like and that's the magic of the syntax it automatically passes it an implicit object or it creates one it's a very special role for underbar underbar and it self is used to refer to the object being created I'm going to come back in a minute to discuss more fully the concept of self and how it's used here so just give me a minute to to get there the next thing we see is Hash e this is something we looked at again on Tuesday um it's a private function in this case that I don't intend to be used outside the class so if we think of the specifications here the interface of the class it does not include hash e that's what private means here this is a convention it's not enforced by the language and unfortunately as we'll see a lot of useful things are not enforced by the language but nevertheless good programmers follow the conventions and we expect you guys to do so as well because of course you're good programmers so this doesn't do anything very exciting it's just what we saw insert is more interesting let's look at what that does it apparently takes two arguments the formals named self an e and inserts e into self. vows however if we go look at the code that uses it in say test one what you'll note is I'm saying for I in range 40 this is just like the test one we looked at yesterday or Tuesday I'm going to say s. insert of I it looks like I'm calling insert with only one argument but as we discussed last time this s before the dot is actually the first argument to the method insert and so it's getting two arguments really and by convention that imp explicit first argument is always called self in Python it's not in force you could call it George if you preferred or Alice or whatever you like um but if you do you will confuse the heck out of anybody who ever reads your code including any TA you ask for help so please do use self it's just a name it has nothing to do with what a philosopher or a psychologist or a ethicist might think of the concept of self this wonderful elevated concept it's none of those it's just a name but stick to using that name so if we go back I can insert a bunch of things I can then I'm going to then print s that's kind of interesting underbar underbar Str underbar underbar is one of those special names as well the code is pretty simple all it is is returning a string representation of the set and it could be anything you want I chose a sort of conventional way of denoting sets what's interesting is that it gets automatically called by print so when I write the command print s in test one the python interpreter is smart enough to know oh I better take s convert it to a string and then print it how does it know to convert it to a string it automatically invokes the underbar underbar Str method and then the other operation is member which again is exactly what we looked at before but you'll notice in this code that uses insets I make no reference to the data attributes of the class directly or I shouldn't you'll notice that I wrote evil next to s. vows python will let me do it but I shouldn't why shouldn't I do it why why am I saying this is evil well would you be Happ happy if you got a message saying Idol has changed please download a new version and the new version happen to have a different implementation of lists or dicks and it caused all of your programs to stop working you would be pretty unhappy now why won't that happen because your programs don't depend in any way on the way in which people chose to implement those built-in types because you program to the specification of the types not to the implementation the specification of inet did not mention vows or num buckets therefore as the implementor of that class I'm entitled to go back and change it oh I'm not going to use a hash table at all I'm going to do something else I'm going to use a red black tree or some other fancy implementation I'm allowed to do that and if I make that change and vals disappears and numb buckets disappears your program should continue to work so long as I still meet the specification the minute you go in and directly access the variables of the class those attributes you have used things that do not appear in the specification and if I change the implementation your program might break so you shouldn't do that does that make sense to everybody it's a very important concept the concept is known as data hiding it is really the most important development of that makes abstract data types useful that makes them gives them the same status as the built-in types the minute you choose to ignore this you do so at your own peril some programming languages like Java provide a mechanism to enforce data hiding the designers of python for reasons I do not understand chose not to I think it is is a flaw in the language the things we're hiding are the instance variable those are the variables associated with each instance of the class we should also hide class variables we haven't seen those yet and we will see them later the instance variables we get a new copy of each time we create a new instance of the Class A new inset in this case the class variables are associated with the class itself and you get only one copy of them later on we'll see an example where class variables are useful all right so let's run this just to make sure it works does what we would expect true false and then you'll see this nice uh string representation of the set and then just to show you what happens when you do the evil thing I printed as we did last time the actual uh list that came out all right let's now look at a more interesting example and the idea I want to convey here is how we use classes and Abstract data types to design programs so imagine that you're writing a program to keep track of all the students faculty and maybe staff at MIT it's certainly possible to write that program without using any classes for each student you might give them a family name a given name a home address years grades Etc and you could do this with some complicated combination of lists and dictionaries um but it wouldn't be very elegant so what I want to do before writing that program and I won't actually write that program I'll just write some of the classes we can use I want to pull back and think about what abstractions would be useful so this style of programming in which you organize your programs around abstract data types says before we write the code in detail we think about the types that would make it easy to write the code so for example if you were uh a finance student and you wanted to write some code dealing with uh markets you might want to have an abstraction of a Government Bond and another extraction of an equity and an extraction of a call option whatever you wanted but you'd say I want to think at that level of abstraction I don't want to think about lists and dicks and floats I just want to think about options which have a strike price and a date and things like that similarly as I'm working on this database for MIT I want to think about abstractions of students and faculty and staff I'm also going to use what's called inheritance to set up a hierarchy of these and the reason I'm going to do that is I want to be able to share code I know that there will be certain similarities between students and faculty some differences too uh but I want to begin by saying what's not different what's similar what's the same so that I only have to implement it once and get to reuse it so if I pull back and say is there an abstraction that covers the shared attributes of students and faculty and staff um I might say it's a person they're all people and it's arguable whether every faculty member is a human being but for now let's pretend all right and so I'm going to start with this abstraction person uh I'm going to import something called date time I'll show you what we're doing when we get there but it's like we've imported math before this is a class somebody else wrote that deals with dates and time in a in a fairly reasonable way all right so I'm going to import that here into person probably didn't need to import it twice maybe I'll just simplify it by getting rid of this one um underbar underbar in knit here will create a person with name name and uh you'll notice what I'm doing here is introducing an extra attribute last name self. last name and that's because I just want to make life easy for myself I figure I'll want to find the last name frequently let's once and for all get it and put it in something and I'm going to initialize Birthday To None the next attribute or the next method is get last name I have that here because I don't want users of this abstraction to even know that I have an attribute self. last name that's part of the implementation and so I have this method that's a fetches it and you'll see as you build classes that you often have things called get and those are typically methods that return some information about an instance of the class uh you'll also frequently have set methods for example set birthday that gives values to instances of the class more interestingly I have get age and that's using some of the built-in operations on date time conveniently it allows me to uh subtract one date from another and get a number of days so this will allow me to uh return somebody's age and days um then I've got another underbar underbar method we haven't seen yet LT stands for less than not a big surprise and I'm going to use this to order names or order people why am I using a special operator rather than just putting in the method Lees s a n n uh I'm doing that because I want to be able to write things like P1 less than P2 in my code and python will take that and turn it into the underbar underbar LT better yet if I have a list say of persons I can use the built-in sort operator on that list and it will be smart enough to know when it's comparing to people to do the sort to use the underbar underbar LT very convenient kind of thing okay let's look at an example let's look at some code so I'm going to set me to John gag and him to Barack Hussein Obama heard of Madonna and we'll print some things okay so I printed him and I printed him. getet last name I can now set some birthdays um let's look at this line how do you feel about him. birthday equals 8461 we'll come back to it but I want you to think about it and we see that uh Obama is well we see their ages here right actually we see that Madonna is older she looks really old when you look at that number of days doesn't it maybe she is all right now what's going to happen here I messed up and I messed up because I went in and directly accessed the instant variable and assigned it what I thought was a reasonable representation of a birth date but I shouldn't have because that's not even the appropriate type right it's a string rather than something from date time so again we see the impact of my having done this evil thing of violating the abstraction boundary and stuck in there try to directly access an instance variable we can do some comparisons and what we see is that uh I'm not less than madana I guess that's okay um okay you with me so far I can make a list of these things and print the list so it does a fairly nice job call calling the underbar underbar St Str operator and you'll note I had no trouble throwing objects of type person into the list no different than putting inss or Floats or any of the built-ins it all works nicely and then I can sort it and print that and now the lists come out in a different order because it's using the underbar underbar LT operator to sort the elements all of this is just by way of showing you how convenient it is to write code that uses a data abstraction if we go back and look at the code we'll see that once again person was a subass of object that's why we can do all these things we've been doing with it but now I'm going to start using the hierarchy now MIT people are special I I hate to say that because I know we have non-m people in the room but MIT people are special well here's at least one of the special attributes of MIT people they all have an ID so I'm now going to say an MIT person is a special subclass of person so it has all of the properties of a person and the way we describe that is it inherits the properties of the super class and it adds a property we can now assign an ID number and now we're going to see the thing I promised to show you which is a class variable next ID num is not associated with an instance of MIT person but it's associated with the class itself it's a class variable I can do that because objects are or classes are themselves objects and the advantage of this is every time I get a new instance of this class I can assign a unique ID similar to the way we were using Global variables earlier in the term typically once we have classes we stop using Global variables because we have these class variables which can serve very much the same purpose in many cases and so now every time I get a new MIT person I give them an ID and then increment the ID number so that the next person will get a different one so I've added a property this ID number property which I find by get ID num I've also overridden an existing property you'll note that I've changed the definition of underbar underbar LT so it's now saying we're going to compare two people not on the basis of their names but on the basis of their ID numbers so let's look at some code that uses this I'll get rid of the other code so it doesn't clutter up the screen so we'll look at some things here we'll uh get some MIT people called P1 P2 and P3 and we'll print their ID nums by calling get ID num and you can see that Barbara beaver gets zero and the first suan gets one and the second suan has D2 I can create even a third such person and now let's think about what happens here I'm going to print whether or not P1 is less than P2 and whether or not P3 is less than P2 what should we get when we do this somebody pardon true false I heard a true false and indeed that's right because there comparing IDs now suppose I want to compare names I could if I chose do this I could call person underbar underbar LT and what this says is don't use the less than of the super class of the subass go up and use the super class one to do the comparison all right so it's going up and doing that I can do other things I can compare things for equality let me just rip through all of these and see what we get whoops surprise well before we get to that surprise and it's not actually a surprise I shouldn't have uncommented it let's look at the other ones we can say is P1 equals equal to P4 and we discover it's not that's it's good uh and we can say is P4 less than P3 that all works it's not but I can't say P3 less than P4 and why can't I do that why did I get an error message when I did that yes someone wanted to answer that yeah because you not an can you say that more loudly she's a person not an MIT so you didn't her an ID number exactly right the answer I hit somebody right on the head now there's going to be a traumatic brain injury I'm going to get SU D it's going to be messy time to leave the country um all right um because it looks at P3 less than P4 looks at the first argument which is P3 and says okay what's the underbar underbar LT associated with P3 it's the one associated with MIT person let's go execute that and then it tries to retrieve the ID number of P4 which is not an MIT person and it gets an error message all right nothing subtle it's the same kind of thing we've seen all along when we've used type errors in this case it's called an attribute error because we've attempted to access an attribute of an instance that doesn't exist and so we could catch it we could it's raised an exception we could catch it as we looked at Tuesday but we're not going to do that because it's really a programming bug when that happens okay let's continue we were interested in students so we're going to continue our hierarchy here and now I'm going to introduce a subass of an MIT person called an Ugg short for undergraduate um underbar underbar andit is going to call MIT person underbar underbar andit which will give the Ugg an ID number and a name and it's going introduce yet another instance attribute or field called the year and say the year initially is none then I can set the year um though if I try and set it as something greater than five I'm going to raise an overflow error called too many no student no undergraduate should be a year greater than five and I can get the year well let's let's look at what happens when we do that so I'll have two ugs both happen to be named Jane Doe and then the same MIT person as before let's run this code and see well what's going to happen what am I going to what's going to happen when I say print ug one the first thing it's going to do is it's going to say is there an underbar underbar st associated with Uggs and the answer is no say that's okay because I know an Ugg is also an MIT person if I don't find it at the lowest level class I'll bounce up and say all right is there an underbar underbar st associated with an MIT person no that's okay I'll go up another level and say well I know an MIT person happens to be a person and then I'll say oh good there is an underbar underbar st associated with person so I'll use that one so it looks at the class if it doesn't find it it goes to the super class doesn't find it it goes to the super class and it does that all the way up till the end where at worst it will use the built-in thing for printing objects because remember everything is a subass of objects you don't want to do that right you want to have something more elegant than object at location XE 345 or whatever it would have printed then it will do some cap comparisons it will First Look for the most local and then work its way up as needed okay let's keep going we're going to introduce another kind of person called a graduate student and I'm going to write pass what that means is a g is an MIT person with no special properties all the usual properties of an MIT person does not have a year because graduate students could be here more or less forever which goes like this when I say that um why did I introduce the type in the first place because it lets me do type checking I can now check whether or not a person is a graduate student because they will an instance of G will have all of the properties of an MIT person but it will have a different type it will be type G and so I can now ask the question is the type of this object a g or is it an MIT person and get a different answer so I can do this and if I go type of G1 well that's interesting it says class m.g okay it's going to a said it's a class and the class is defined at the outermost level which is called Main and the class's name is G which is what we expect and so I could write something like that well type of G1 equals equals g and I get true okay so it's a handy thing to be able to do and in fact I'm now going to bounce back to MIT person and add another method to it and this happens all the time when I'm programming that I go to find a class think I'm done and then sometime later decide it would be convenient to add something new another method in this case I'm now adding the method is student which returns type of self equal equal ug or type of self equal equal G so this will let me distinguish an MIT student or student from another kind of MIT person so for example if I want to have a course list another class this is a subclass of object you'll note I have an add student method which takes self and who maybe it should be whom and it says if not who do is student raise type error not a student so I'm getting some leverage now out of this now I wouldn't need to necess necessarily do this I could have said if not um type of who equals g or type of who equals ug but I chose not to the reason I chose not to is looking ahead I might want to add some other students I might want to add special student for example or I might want to add cross registering student as separate types now the nice thing is I don't have to make a lot of changes I know there's exactly one place in my code that defines what it means to be an MIT student I go back and I change that method and even if I asked whether somebody's a student in a hundred different places I only have to make one change to fix my code so I'm getting some modularity by associating the method with with the class MIT person rather than every time I need to use it