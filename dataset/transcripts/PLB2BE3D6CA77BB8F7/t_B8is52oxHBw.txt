the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit mitop courseware at ocw.mit.edu Happy Valentine's Day 11 actually maybe it's a little smiley face combined with an El did any of you leave this here for for me or am I just stroking my ego and this was left for someone yesterday stroking my ego all right okay uh last lecture we looked at a program for finding roots and put in a little debugging statement that along the way printed various approximations to the root well now suppose that instead of printing things we actually wanted to SCT the approximations for example to be able to go back and look at them later and analyze them do various kinds of things to do this and this is the sort of thing we do a lot we need some data structures that can be used for massing collections of items there were three data structures in Python that are used to collect items I'm going to try and cover all of them today today tupal lists and dictionaries we'll start with tupal and lists and what they have in common is they are ordered sequences of objects so the key notion here is they're ordered it makes sense to talk about the first object the second object the last object Etc when we get to dictionaries or dicts as they're spelled in Python we'll see that they're not ordered all right let's look look at tupal first they're the simplest so if we look at it is a very simple example at the top I have this tupal called test and I'm just said that's the sequence of in 1 2 3 45 I can then index into it for example look at the fr first element which is the zeroth element or I can look at the next element and we can print them so let's just do that and you can see it prints one and two not surprisingly I can print the whole thing if I want that lets me look at the entire tupal I could also look at this and that gives me the last element without my having to know what the last element is I can ask about the length of a tupal and it tells me it's five similarly I could write something like this print test why was that out of range yeah Zer because I'm indexing from zero so that's why I have this sort of more convenient way of writing minus one otherwise I'd have have to do Len minus one good grab okay um let's look at a little example of how we might use this sort of thing so here I've just written a little piece of code that finds divisors going to find all the divisors of 100 collect them into a tuple notice this kind of funny piece of syntax here I comma I need to do that to say it's a tuple of length one why can't I just write open parent I comma open parent because that would just take the expression I and parenthesize it as we often use parentheses for grouping when we write things so by inserting this comma I say I don't just mean the in this case say the number I I mean the tupal of length one so it's a sort of special case piece of syntax that you need for tupal of length one then I can print the devisers so let's run that and it now prints the tupal for me so I've run through I've computed all the devisers and I've collected them nothing very interesting but kind of useful we can also I've shown you how to select elements of tupal I can also if I choose get what are called slices of tupal so a slice gives me a range of values or a in this case a subsequence of the tupal as we'll see we can also slice lists so let's see we have a tupal called divisors here yeah okay I'll save the source oh come on so if I wanted to do uh what did I call I called it divisors so I can do something like divisor one comma 3 one colon 3 rather and you'll note that gives me those two elements at the appropriate places and so it's a very convenient way to take pieces of it all right any questions about tupal not very deep lists are I think more useful than tupal uh and also alas more complicated and they're complicated because the big difference is that tupal are immutable and by that I mean once you've created a tuple you cannot change its value you can create a new tupal but you can't change the value the old tupal in contrast lists are mutable once you've created a list you can actually change it it's the first mutable type we've looked at because you'll recall assignment didn't actually changed the value of an object it just changed the object to which an identifier was bound mutability is the first time we've seen a way to actually change the value of an object itself and that's as we'll see both a powerful concept and an opportunity to mess yourself up by committing serious programming blunders all right so let's look at an example here first of many we'll be looking at so first we won't worry too much about the mutability so here I'm creating a list called text which happens to be in this case a list of strings lists need not be homogeneous as we'll see you can mix strings and floats and ins and most interestingly you can have lists of lists uh then another list called ivys then I'm going to say I'm going to have the these unev yet another list this list empty containing no elements then I'm going to append text to ivys notice this syntax un. append what that means here is that append is what python calls a method as we'll see when we get to classes methods play a very important role in Python but to a first approximation it's quite safe to think of a method as an alternative Syntax for writing a function so instead of writing something like append a list and an element I write L do append the element and just think of this L over here as a fancy way of denoting the first argument to the function append the first actual parameter when we get to classes in a few weeks we'll see why it's highly useful to have this specialized syntax but for now just think of it as a as a piece of syntactic sugar if you will the thing I want you to think about though is this is not equivalent to assigning something to L this actually mutates the list and we say it has a side effect up till now since we've only been dealing with immutable types every function we've looked at its job was to take in a bunch of values do some computation and return a value it didn't change anything and then if we wanted to take advantage of what the function did we had to assign the value it returned to some variable and then we could manipulate it or we could print the value it returned we had to do something with the value it returned here we invoke a pend and rather than worrying about it what it returns we're invoking it for the purpose of its side effect the modification it performs on the list so let's look at what we get when we run this so you'll notice what unes is now it's a list of length one and the one element in it is itself a list because I have appended a list to the end of the empty list not the elements of the list but the list itself okay so it's important to notice the difference between a list that contained the elements MIT and Caltech and a list that contained a list which contains the elements MIT and Caltech okay yes add two t together and that's not saying that's not like a bending right it's because when I concatenated two tupal in order to do something useful with that value I had to assign it to something it did not modify anything it produced a new tupal which was the value of appending them and then it assigned it to a new Tuple so that's quite different from a pend which is actually having a side effect on the list does not produce a new list it modifies the old list so we can look at this draw a little picture here so we had text and that pointed to a list with two elements in it which I'll abbreviate as MIT and Caltech both of these elements were strings then I created a new list called unives and that was initially bound to the empty list a list with no elements in it I then did an append and the effect of the append was to modify unev so that it pointed now had one element and the element it was was this list notice it didn't copy this list it actually included the list itself so let's look at the ramification of doing it that way whoops so what I'm going to do now is append another element called ivys I'm going to then print it and then for e in unev so here's a kind of a nice thing you can do with lists you can iterate over the elements in the list so you might think and that the way to do that is well I'll go for I index in range zero to length of list that would be equivalent but it's in fact much easier to just write this way for e in unev that will do something to every element of the list I'm going to print what the element is so let's look at that so now I have a list as we see here of length two contains two lists and if I print the elements I print each of those lists nothing very magical there now suppose I wanted it flattened you asked the question about the tupal where I did concatenation well I can do the same thing here I'll let flat equal Tex plus I and then I'll print flat and you'll note here what concatenation does is it just takes the elements of the list and creates a new list and appends it that's the doesn't append it in this case it assigns it to Flat excuse me so that's kind of convenient poor old plus is overloaded with yet another meaning all right let's keep on trucking I have course can do this myself so here I've got another list called art schools includes Ry and Harvard for you two and art schools if you two in flat I'm going to remove it all right so again I'm going to iterate over everything in art schools what's this going to do do you think what will I get when I print it here no new Concepts here this is all stuff we've seen somebody out there yeah yes the answer the correct answer was flat without Harvard in it wow almost a good catch just just almost there all right so let's confirm yes we'll save it thank you all right so we've now removed the art school all right look at one more thing actually we'll look at far more than one more thing but we'll look at one more thing for the moment so I'm going to invoke another method this is a built-in method of python that works on sequence types and it's called sort so you can do this will have a side effect on flat and it will as you might guess put them in order so let's run that actually comment this out for the moment so you'll now note that it's put them in alphabetical order this is something again that you will find Convenient throughout the term the ability to have the side effect of sorting a list now I'm going to assign something to Flat sub one so let's think about what this is going to be doing it's going to replace the first element of flat by a new value so it's having again a side effect on flat so you have to be a little bit careful as you think about this that I've written something that looks like an conventional assignment statement but in fact flat sub one is not an identifier so this is not binding the name Flats of one to uass it's actually modifying the object that is the first element of flat pardon flat for example well I think the way to question is would the identifier just be flat uh no don't think of this as an assignment at all because remember what an assignment does is Swing one of these pointers to point to a different object we'll see an example of that whereas here I'm actually modifying a piece of the object that the identifier points to so it's not an assignment in the sense of a rebinding it's actually having an side effect of modifying the object let's just run it and then I'll be happy with the question so here you'll see I've changed flat sub one to now be UMass Yeah question if you as you as youve drawn on the Blackboard here yeah you've drawn an arrow to the actual object that's text right so if we change text Will we change unives yes the question was if we change text Will we change units now in some sense that's a philosophical question from the philosophical point of view maybe you could say no univ is still the same object so The Binding has not been changed but the object to which it has been bound is now different same object but it has a new value all right so this is a key thing to keep in mind assignment has to do with The Binding of names to objects mutation has to do with changing the value of objects we'll see that pretty graphically in in the next example that I wanted to work my way through so I'm going to work through a kind of a dull example but I think it illustrates the points and I Do by the way very much appreciate the questions even if I forget to throw you candy in return for asking uh but it's good if you have questions please do ask them and I'll try and remember to feed you so let's work through what this code is going to do so first I'm going to have the list L1 so the first thing I'm going to create an object which is a list of length one containing integer two so L1 will be bound to the list of length one containing the in two I'm then going to create another lit or not create L2 which is going to be of length two and the first element will be L1 and the second element will be L1 so what will happen if I print L2 what will I get I'll get list two comma list two right we can look at it if I print L2 excuse me all right just what we would have expected now I'm going to change the zeroth value of L1 to be three so I'm going to mutate L1 now if I print L2 I will get a different value three not surprising it's something to keep in mind that will can be useful but can also be confusing because if I'm looking at my code it doesn't look like I changed L2 when I have a side effect on L1 and so it can be kind of mystifying when you're trying to debug you print L2 you do a bunch of execute a bunch of statements none of which apparently deals with L2 then you print L2 again and get a different value this is both the Beauty and the Peril of mutation now let's see what this does so here I've now mutated L2 so that its first element is no longer the list L1 but is now the string a now we'll just do a bunch of these all at once here now I'm going to change L1 to be two length one so what do you think will happen by the way if after this I print L2 oops what do you think is going to get printed here all right this is important you need to figure this out what's going to get printed here a volunteer please yes well a then a and then two is one conjecture let's find out a and then three why because what happened here is when I did the assignment to L1 what that effectively did was swing this pointer to point to the new list containing the element two but had no effect on this object right I was changing The Binding of the identifier I was not mutating this object and so this element still points to the same list which was not mutated does that make sense now so you have to get your head around the way all this this stuff works that does that anybody have a question about why this is what it did all right if not we'll just roar right along so now we can do various things and we'll get some stuff okay all right moving right along here's a kind of an interesting little program not in your handout let me get rid of all this CR so here's a function copy List It Takes a source list in a destination list and for e in the source list it appends it to whatever the destination list used to be and then I'm just putting in a little print statement so you will be able to see as it runs what it's doing so I'm going to say L1 is equal to the empty list L2 is one two 3 and I'm going to copy list L2 to L1 print L1 and L2 so what am I going to get when I print those things this is the easy question don't tell me I have you so intimidated that you think I'm playing this is not a trick question pardon two of them one two three for both of them who said that raise your hand someone back ah oh good grief all the way in the back all right oh no not even close off by a row in about four people too okay so let's try it 1 123123 so exactly as predicted now comes the trick question what is this going to do pardon well we'll print L1 here what do you think it'll do when it gets to that print statement will it get to that print statement let me ask question will it ever get there no Bingo let's run it and you'll see eles just gets longer and longer and longer why is that happening because what it's attempting to do is look at L source and copy the remaining elements of L source to l d but every time I go through the loop what we have is a situation where the formal L source and l d are now pointing to the same object so every time I modify L I'm modifying the object to which L Source points to and I keep finding yet another thing to copy this is an example of what's called an alias one object with two names or in general multiple names when you have immutable objects aliasing is perfectly har Harless if you have 58 different names for the object three it doesn't matter because you can never change what three means here where you have multiple names for the same mutable object you can get massive confusion when you modify it through one name and then forget that it's being accessed through another so it's something to worry about okay as with tupal you can slice lists you can index into lists you can concatenate lists you can do all the usual things I'm not going to list all of the operators and there are a lot of very nice operators but we'll post readings where you can find what operators are available I now want to move on to the third built-in type that collects values and that's a dictionary a dictionary differs from a list in two ways one the elements are not ordered and two more profoundly the indices need not be integers and they're not called indices they're called keys they can be any immutable type so we'll look at a simple example first so here I'm creating a new dict we use set braces rather than Square braces to remind ourselves that the elements are not ordered and I'm saying the first key is the number one and that's bound to the object the string object one quote one one and then the second key is the string object du which is bound to the string object two and the third one is the string object Pi which is bound to the float 3.14159 now I can then index into it so for example if I choose to I can write something like print d sub Pi I'll just stop it here with my old trick of asserting false and you'll see it will print the value with which the key is bound to which the key is bound so what we have here is a dict is a set of key value Pairs and I can access it by looking at the keys I can do an assignment D1 equals D just as I can with lists and now I remember this is a real assignment so now I have an alias two objects pointing two identifiers pointing to the same dict I can then print D1 sub one I print it or I could assign to it so let's do that first we'll print it just to show what we get then I'm going to do an assignment saying okay I want to now change the binding in D of the key one to be Uno rather than one and we'll get something different let's just run this so you'll note as we would have guessed with mutability we see it showing up so so far just like lists the difference being we have key value pairs rather than you could think of a list as being int value pairs the indices of a list are always inss associated with each of those ins we have a value let's look at a kind of a more fun example showing what we can do with dictionaries so here I have a very simple dictionary called e to F or English to French and we can do some things with it so I can print it and that's be kind of interesting let's see what we get when we print it so it's printing it and you'll notice the order in which it's printed the key value pairs is is not the order in which I type them that's okay the order in which it prints them is not defined by python so there's no way to predict the order and that makes sense because by specification dictionaries are unordered they're sets not sequences I can print keys ef. keys open close Keys is a method on dicks that Returns the keys and then just for fun I'm going to try to print e to f. keys without the open close so you'll see when I first printed it with the open closed I got all of the keys in an order that was not necessarily predictable certainly not the order in which I type them but that's nice I now have this sequence of keys that I could do things with when I typed it without the open close and I wanted you to see this it just says it's a method a built-in method it does not execute the method right that's fine but again you have to be careful that you'll find this happening when you write code you'll forget to write the open close and you'll wonder why your program isn't doing what you expect it to do remember it's not saying that the method Keys had has no argument it has one argument in this case e to F and the open close is basically saying all right call the method rather than the method itself again this will be very important when we get to um classes all right let's get rid of some of these print statements now suppose I want to delete something I can delete something so delete e to F sub one dell is a command much like print that says remove something from E to F so I can do that and now something is disappeared the key value pair where the key is one is gone so that's how I remove things yesable the keys have to be immutable you cannot use a mutable type for a key uh we'll see the reason for that uh in a couple of lectures when I talk about how dictionaries are implemented in Python they use a very clever technique called hashing which would not work if the keys were mutable so in order to get an efficient implementation of Dictionary lookup we need to have immutable keys and so that's required let's look at another example so here I'm again setting a dictionary and now what I'm going to show you is that I can iterate through the keys and print the values for key and D1 dokeys nothing very fancy here okay one equals Uno pi equal 3.1459 and D equals 2 all right right so nothing very dramatic happening here finally just to illustrate why this sort of thing is particularly useful and in fact you'll find it quite useful in the upcoming problem set I'm going to do some translations this by the way is not the way Google translate works it's a bit more sophisticated so I'm going to have two functions translate word which if it finds the word in the dictionary Returns the value associated with the key so note if word in dictionary says is there a key whose value is word if so return the value associated with that key otherwise don't even try and translate it just leave it the way it was and then translate sentence will set the translation equal to the empty string and word equals to the empty string then it will just collect all the characters until it finds a blank translate the word using translate word and append it and when it's done it will print it so we can now do these translations quite simply what could be easier you never again have to learn a foreign language just use Python to do the translations for you all right that's it for today um remember there is a problem set that you should be working on and another one that will'll be posted take care