The following content is provided under a creative common license. Your support will help MIT Open Courseware continue to offer high-quality educational resources for free. To make a donation or view additional materials from hundreds of MIT courses, visit MIT Open Courseware at ocw.mmit.edu. I want to finish up our little excursion into uh searching and sorting. A very important topic in computing. How do you sort lists or databases? How do you search them? Um and I want to finish it up with hashing. Hashing is how dictionaries are implemented in Python. And this leads to a very efficient at least most of the time search uh but it comes at the cost of space. So this is an example where one can trade space for time. So I want to start with a simple example to explain hashing and I'm going to begin by assuming that what we're hashing is a set of integers. So we want to build a set of integers and detect whether or not a particular integer is in that set and we want to do that quickly. So the basic idea is we're going to take an integer, call it I, and we're going to hash it. And I'll show you what that means in a minute. And what a hash function does is it converts I to a different integer perhaps in some range. So it say converts I to some integer in the range try that again some integer in the range zero to K for some constant K. We're gonna then use this integer to index into a list of lists. So each list each of these is called a bucket and a bucket will itself be a list. So this together is called a bucket. We've already seen that we can find the e element of a list in constant time. So when we ask whether some integer is in this set, we'll hash it. We'll go immediately to the correct bucket, the bucket associated with that integer, and then we'll search the list at that bucket to see if the integer is there. If this list is short enough, it will be very efficient. All right, I realize that's very abstract, but let's look at the code which will make it much less abstract. So, the code starts with something very ugly that I'll apologize for, but very soon we'll see how to get rid of that. I'm using a global variable here to say how many buckets there are going to be, and I've very arbitrarily chosen 47. I then have a function called create which uses this global variable and creates a list of lists each element of which is empty because initially we have no elements in the set. When I want to insert an element in the set, I'll call the function insert, which will hash the element. Doesn't actually even need to use the global num buckets in this case in fact, and then append it to the correct list. So it calls this function hash elem which could hardly be simpler. It just takes the remainder the modulus of the element and the number of buckets. So that will give me a value between zero and num buckets minus one. Gives me one of the list and I'll just insert it at the end. When I want to check for membership, you'll see it's quite simple. All I do is ask the question, is I in the list associated with the correct bucket. Remove is a little bit more complicated, but in fact, we don't need to spend much time looking at it now. It's just some code. And the only reason it's complicated is insert doesn't look whether or not the element is already there. So it may occur multiple times in the list. So I would have to remove each one of them. Okay, people see the basic structure of this. Why a list of lists? Why don't I just say have a list of booleans where I hash the the integer and It's true or false whether or not I've seen it depending upon the value of that bucket. Why can't I do that? Somebody well what's the property of this hash function? The key issue here is the hash function is many to one. That is to say, an infinite number of different integers will hash to the same value. Since after all, I have a set in which I can store any integer or any positive integer at least. And there are only 47 buckets. So it's pretty obvious that many integers will hash to the same bucket. When two different elements hash the same bucket, we have what is called a collision. There are lots of different ways to handle collisions. What I've shown you here is probably the simplest way which is called linear rehashing. I'm not actually rehashing. I'm just keeping a list. Does that make sense? Yes. Thank you for I'm glad somebody has a question. You have to ask loudly when you take the modulus 47 what does that return? Uh zero. So hashm well sorry it depends what I'm hashing right sorry I thought you were saying that if I ask 47 mod 47 if I take 48 mod 47 I get one I take 49 mod 47 I it's the remainder maybe I should have called it just the remainder look up I'm about to throw something at Oh, I threw a curveball. Okay. What's the complexity here of the membership test? Kind of hard to analyze. roughly speaking or exactly it will be the length of the bucket right the size of the bucket now I don't know how many elements will be in the bucket but what will this depend on it will depend upon the number of buckets if I have a million buckets I'll get a lot fewer collisions than if If I have two buckets, right? So let's look at an example here. There's a small program called test. I set num buckets to 47 in this case. And then I'm going to create it. Create a set. And then I'm going to put a bunch of integers in it. Then a few more just for fun, including one very big integer just to show that it works. Then I'm going to show you what the set looks like. And in fact, what we'll do is we'll stop it here and see what we get. So what we'll see here is as you would expect with that number of buckets each of the small numbers hashes to a separate thing. That's just the way remainder works. Uh, not surprisingly, in fact, it would be disappointing if 325 didn't hash the same value both times I inserted it. So, we see we happen to have one bucket that's got two elements in it. Happen to be the same. But this very big number happened to hash the same value of 30 as 34. So here we have two elements in it. A good hash function has the property that it will widely disperse the values you hash. So they end up in different buckets rather than some stupid hash function that tends to put everything in the same bucket. Now let's see what happens if I change the number of buckets to say three. Well, not surprisingly, we get some very big buckets. because there's relatively few choices. So what we see here is we have a genuine tradeoff between time and space. If the number of buckets is large relative to the number of elements that we insert in it in the table, then looking whether or not an element in it is roughly order one because these lists will be very short. So we can actually look up something in constant time if we dedicate enough space to the hash table. If the hash table is very small, you know, the reductio at absurdium case of one bucket, then it's order n. It's not it's not constant time. It's linear in the number of elements, right? Typically, when people use hashts, they make the hashts big enough that for all intents and purposes, you can assume that looking something up is constant time, order one. And that in fact is what Python does with dictionaries. It hashes the keys and chooses a big enough table so that looking up whether or not something is in a dictionary can be done in constant time. If it then notices that the table is too small because you've ended up putting a lot of elements in it, it just redo it and gets a bigger table. So hashing is an extremely powerful technique and it's used all the time for quite complicated things. Now is it useful here only when we want to store ins? No. I mean it would be kind of bad if that were the case. In fact any kind of immutable object can be hashed. Now you may have wondered why the keys in Dicks have to be immutable and that's so that they can be hashed. Why does it have to be immutable? Well, imagine that you used a list as a key. You'd hash it when you put the list in the hash table, but then you might mutate it and the next time you hashed it, you'd get a different value and so you wouldn't be able to find it again. So you need it to be a kind of object where every time you apply the hash function you get the same value. Okay. Um I don't need to show you that this works. You'll just believe me, I'm sure. Let's look at a slightly more complicated hash function. Here I want to hash something that could be either an int or a string. So I first check and see if it's an int. If so, I'll set the value to be e. Then down at the bottom, I'll do the modulus operator again. But if it's a string, I'm going to first convert E to an int. And this is basically the trick that people typically use when they're doing hashing is they convert whatever thing they have to some integer. People do this with all sorts of things. For example, this is the way airport security systems today do face recognition. They hash every face to every picture of a face to an integer and then look it up. So we can see it here. The way I'm doing it and the details don't very much matter is I'm going to do it a digit a character at a time. Do a shift or C takes the ASI the internal representation bits of each character. And again, I don't care if you understand how the code works here. What I just want you to see is that it's not very long. And in fact, it's typically fairly simple to hash almost any kind of an object because deep down we know that every object is represented by some string of bits in the computer's memory. And we can always convert a string of bits to to an integer. All right. So that's hashing. A very powerful and extremely useful technique. All right. Yeah. There are many different ways of doing hash. All the hash element has to do is function has to do is convert its argument into an integer in some way or another within a fixed range. It happens to be that remainder is a very simple way to do that. Uh and is often used. There's a whole theory about hash functions. Uh you can read about them in gory detail in Wikipedia. uh the math can actually be quite complicated and there's no real need to understand it. I typically do something like dividing by a prime number which is known to have good properties. But again, you can get carried away with this uh and it's usually not worth the trouble unless you're very deeply involved in something. Okay. And then I've got another program that that does this, but again, I don't think much would be served by running it for you. Any questions about hashing? Yes. So, does this only work because you said like in a previous lecture that Python treats lists in a certain way, you said other languages, you can't have this constant time list search. So, how would hashing work? So, the question is that because Python gives us constant time look up for lists is the key to making this work. Every programming language I know has some concept that's similar. In say C, it's not a list, but it's an array. And so in C, you would use the array for this purpose. Java, you would use the arrays for this purpose. But yes, you can do this in any programming language because every reasonable programming language has some way to create the equivalent of a list in which you can get a particular index in constant time. So it's it's a universally useful technique. Good question. Anything else? If not, we're about to abandon searching and sorting and in fact abandon algorithms in general for a while. Bounced right off his hands. Um, I will not sign you to a baseball contract. Um, pardon? I threw him a Yes, I threw him a butter finger. Oh, it's terrible. Boy, your jokes are worse than mine. All right, I now want to move on to the last go back to Python, away from algorithms, away from computer science in general and talk about the last three major linguistic concepts in Python. Exceptions, classes, and then later iterators. Um, let's start with exceptions because we've already seen them and they're pretty simple. Um, exceptions are everywhere in Python. Um, you know, and we've certainly seen plenty of them all semester already. You know we we get them if we uh set some array to uh some list to say one two and then I ask for test of 12 I get an index error. This is an exception. Um, we've got exceptions when we've tried to convert things to incorrect types. So, if I go int of test, I'll get a type error. Anything that ends in the word error is a built-in kind of exception in Python. We've got them when we access non-existent variables, a name error. So, there are a whole bunch of these things. In each of these cases here, I was just kind of playing around in Python and it had printed an error message and it stopped. These kind of exceptions are called unhandled exceptions where they cause the program to effectively crash. the program just stops running. And I suspect that some of you have written programs in which this has happened. In fact, is there anybody here who has not written a program that crashed because of an unhandled exception? Good. For those of you watching on TV, no hands went up. Uh, and I almost every day I write a program, it crashes because of an unhandled exception. Uh, on the other hand, once my program is debugged, once your program is debugged, this should never happened because there are mechanisms in Python for handling exceptions. And in fact, as we'll see, it's a perfectly valid flow of control concept. You will sometimes write programs that are intended to raise exceptions and then you'll catch the exception and do something useful with it. The way we use exceptions is in something called a try except block. So you write the word try and then you have some code and then accept and then some more code. It what the program the interpreter does is it starts executing this code. If it gets through this code without raising any kind of an exception, it jumps to the code following the accept block. On the other hand, if an exception gets raised here, it immediately stops executing this code and jumps to the start of this code, the code associated with the accept, and executes that. And then when it finishes this, it again goes to the code following the accept. Just like an if, you can nest these things. It's just a control concept. It's nothing more. Let's look at an example. So here's readv val. This is a function. It's a polymorphic function. Its first argument is of type type. Remember, and you'll hear me say this a thousand more times at least, in Python, everything is an object and can be manipulated by the program. It's one of the beauties of Python. It's something that's not true in many programming languages. So types are objects just like ints or floats. So the first argument to read val is a type and then there are two strings, the request message and the error message. It then sets a local variable num tries to zero. And while num tries is less than four, it sets val equal to raw input printing the request message and then it tries to convert val to val type whatever that happens to be and if it succeeds it returns it. On the other hand, if during this attempt to convert it, an exception is raised, for example, the user is asked to input a an integer and they type in the letter B which can't be converted to an int, then a type error exception will be raised or a value error exception. And if a value error exception is raised, it prints the error message set increases num tries by one and goes back to the top of the while loop. If it goes through this while loop too many times, it leaves raising the type error with the message the argument numbum tries exceeded. All right, let's run this and see what happens. Now, every once in a while Funny things happen when that happens. Somehow clicking in this window and then clicking back in that window tends to make it work again. This is a bug in Python. So it's now asked me to enter an int. If I enter an int, everything is good. It just prints it. On the other hand, if I run it and I enter the letter A, it will give me another chance. And now I can enter an int and it's happy. All right. Now suppose I'm unhappy with the fact that if four times in a row I fail to enter an int, something bad happens. It comes back and it raises an exception. Well, I can catch that in the code that calls read val. So here at the top level I'm going to try read val and then I'm going to say except if a type error is raised print the argument returned by that exception. So this is what's called the handler for the exception. And so I don't have to crash when the exception is raised, but I can actually deal with it and do something sensible. If following the word except, as you see over there, I have not listed any exception names, then I'll go to the except clause for all exceptions. Doesn't matter what the exception is, I will go there. So I can write code that captures any exception. Okay, usually that's not as good a thing because it shows that I did not anticipate what the exception might be. But you can see that this is a pretty powerful programming paradigm. I can write this fairly compact read val function that's pretty robust. It's polymorphic. It can take in what the error messages are and it can try as many times as I want. Yeah. after type error. You'll note that when I raised the exception type error after it, I had an open PN and then a string. So what this basically says is that an exception can have associated with it a set of arguments, a sequence of arguments. And I've just chosen to call the first of the arguments s so that I could then print it. So this is a fairly common paradigm that you associate a message with an exception explaining the exception since after all type error doesn't is not all that meaningful and this tells me why it was raised that I tried too many times. Okay, does it make sense? Anything else? Yeah. Well, what we'll see when I type something like assert when I execute something like assert false. It's actually raising an exception. it's raising an assertion error exception and so I can actually catch that and do something with it. I've been using these asserts just basically to stop the program. But we've also seen that sometimes with functions we use assertions to check the types of the arguments. But if you don't catch that exception, then the program crashes with the wrong arguments without doing anything useful. because it's just an exception. I can catch it and then do something useful. So, it's again just an example of that. All right, we're going to try your hands once more. I'll throw you a different kind of candy. And this time he caught it. Two for two. Okay. Very powerful. Um a very useful mechanism. Um you can use them for sort of catching errors as we've done here. Uh they're frequently used for in situations where you are getting input from a user. So, for example, if you were writing a text editor and you wanted to open up a file and you typed in the file name and it didn't exist, you would in Python get an error message when you tried to open that file. It would raise an exception uh file not found basically which you could then catch and then print to the user a useful error message saying file not found. Similarly, if you try and write to a file that already exists, you can get an exception saying, do you really want to overwrite this file and ask the user? So, it's very commonly used in a lot of programs as a mechanism. And now, as we go on and see more and more code, you'll see that I'm going to start using exceptions fairly frequently as a uh flow of control mechanism. it makes uh certain kinds of code easier to write. All right, that's all I have to say about exceptions. Um, simple but useful mechanism. Now, on to something that's even more useful but not so simple. Um, it is probably the distinguishing thing not only in Python but in a whole class of modern programming languages and that's the notion of a class. I'm not going to finish it today. I'm barely going to scratch the surface of it today. Uh but we're going to start leading up and I will pretty much finish it on Thursday. We've already seen the notion of a module which has been a collection of related functions. So for example, we've seen code that includes something like import math. And that provided me with access to functions like math.log. What the module mechanism does in the import mechanism, it makes it convenient to import a lot of related things at once. And then we use this dot notation to disambiguate to tell us well which log. Typically, there's probably only one log function, but certainly you might imagine that set dotmember and table dot member would be different and that both might exist. And as we've said before, the dot notation avoids conflicts by disambiguating. Okay, that's a module. What a class is, it is like a module, but it's not just a collection of functions. A class is a collection of data and functions functions that operate on that data. They are bound together so that you can pass an object from one part of a program to another. And the part of the program to which you pass it automatically gets access to the functions associated with that type of object. And this is really the key to what people call objectoriented programming. A very popular buzzword. So we've already seen that kind of thing where if we pass a list from one function to another we can write something like l.append some value. The data and functions associated with an object are called that's that object's attributes. So you can think of this as a way to associate attributes with objects. Now, I've been talking about data and functions as if they're different kinds of things. Uh, in fact, they're not really because they're just objects. In Python, everything is an object, including, as we'll see on Thursday, the class itself is an object. When people talk about objects in object-oriented programming, they often use a message passing metaphor. And I want to emphasize it's nothing more than a metaphor. And I almost hesitate to bring it up because it makes it all sound more complicated than it is. But you will see this phrase in the literature. People will use it. So you need to know what it is. The basic metaphor is that when I write something like L.append, I am passing the message append E to the object L. And then there's a mechanism for looking up what that object means, what that message means. and then the object L executes that message and does something. So for example, if I had a class called circle, I might pass the object C the message area, which would cause this object to return the area of its its own area, the area of the circle that is that object. Again, nothing dramatic going on here. If you just think of this as a fancy way of writing functions, you'll be absolutely correct. And but I did think you should hear about this metaphor. So I have by the way should have I've been using the word method is a is a function associated with an object. So in this case the method area is associated with the object C and purists would say always refer to append as a method rather than a function because we use the dot notation to get to it and it's always associated with some object of type list. Okay. Now, just as data can have types, objects, as we know, have types. What a class is is it's a collection of objects with identical characteristics that are that form a type. So we can use classes to introduce new types into the programming environment. So as you think about existing things, now I won't put that up because it will disappear behind the screen. We've looked at things like lists and dict what these are are built-in classes. They happen to be classes that are so useful that somebody decided they should be part of the language. They should have efficient implementations. They should be built in. People shouldn't have to reimplement them themselves. And in fact, there are a whole bunch of interesting built-in classes in Python. And there are a whole bunch of libraries of classes you can bring in. And we'll look at many of those that extend it. And that's the beauty of the class mechanism. It lets you add new types to the language that are every bit as easy to use as the built-in types. So in effect, the language can be extended to add new and useful types. And we'll look at several examples of that starting on Thursday.