The following content is provided under a Creative Common License. Your support will help MIT Open Courseware continue to offer high-quality educational resources for free. To make a donation or view additional materials from hundreds of MIT courses, visit MIT Open Courseware at ocw.mmit.edu. So, by way of review, we're going to start off with loops. So what are two loops that we've covered in lecture or two types of loops? Wow. Okay. Yeah. So for and while. So I'm going to start with while loops because that's what I have first. Um can someone walk me through the syntax of a while loop? So while condition while condition and what type is this condition? Okay. And then I have and then a block of code right indicated by indentation. Okay. So next question is what does this code do? Right. That's a little bit too high level, but um kind of specifically what does this loop do? The even numbers from 2 to 10. Perfect. So, so that's exactly the kind of comment we're looking for when you're doing your problem sets or you're just coding in general. You want to have a comment that describes in an abstract way what's going on in chunks of code. You don't want to have a comment that says like I don't know assigns two to a continues looping until a is comments like that aren't really helpful because you can get that from reading the code. So that's exactly right. It's perfect. I don't have candy to pass out though. Um so the next question is what's the decrementing function? So the way to think of a decimating function is that it's uh a statement that moves uh the loop closer to termination. So in this case well in this case I would yeah 10 - a or a plus equal 2. Right? So we're moving you know as we're incrementing a we're getting closer and closer to 10 and that's going to cause us to kick out of the loop. Uh, do I have anything else to cover? Okay, next thing is a a good variable name. So, the answer is no. Otherwise, we wouldn't have asked him. But a better variable name might be even number, right? because instead of just a being an integer, now we know what it's supposed to represent in the code and it becomes clearer when we go to execute it or run it. Right? So for loops, same thing. Can someone walk me through the syntax for a for loop? And first question, does this loop do the same thing as a while loop? So if this is our while loop, does this loop do the same thing? Yes. Okay, let's see. So the while loop printed out 4 6 8 10 and 12. So this is going to print out 8 and 10. So the reason is where we have the increment right? If we had done this, then they would print out both the same. But little aside, that was a bug I just caught. All right, so someone walk me through the syntax for a for loop. Okay, so four keyword and then what do we have here? A variable of some sort and then we have in keyword and then we have this thing here. So we're going to get to tupils in a second, but this is a tupole literal, right? And for for loops, a for loop requires something that's innumerable, which means that we can take one element after the other and assign it to the variable I. All right. So, four loops iterate over innumerable. Four loops enumerate over or iterate over enumeral items. Thank you. That's exactly what I was talking about. If I'm speaking too low, just jack your thumbs up. All right. So, this construction though is kind of inconvenient though because if we wanted to list all the numbers that we wanted to print like so 2 to 10 is not too hard. But let's say we wanted all the even numbers between two and 100. I don't want to have to write out all you know 50 of those. So, we get to the range function. And you've seen this before. We just haven't ever explained it. Right? So all the range function does is it takes between one and three parameters and returns a list of integers. So let's say that I pass it one parameter. So I'm going to give it the integer 100. This is going to give me nothing because I didn't print it out. This is going to give me integers 0 to 99. Right? If I give it two parameters, what it's going to do is give me the numbers or integers between one and 100. Right? So in this case, it starts off at one and it gets to 99. So the uh one important point is that when you give it two parameters the first one is inclusive and the second parameter is exclusive. Did everyone follow that? All right. And finally the third form is with three parameters and I have a start an end start inclusive end exclusive and then a step. All right. This will give me all the odd numbers between one and 100 right here. And we can also go in reverse. So if I wanted to go count down from 100 to one, I can give it a negative step. And if you want help on using the range function, there's a handy command called help which you can type in the interactive prompt. And this gives you the syntax for using range. You can do this for any function in Python and it's going to tell you here's what here's the name here's a parameter start here's a parameter stop and here's a parameter step and then this little arrow here means this is what it returns a list of integers when you see when you you type help and you see one of these square brackets that means the parameter is optional. So a start is optional, step is optional, stop, we always have a stop. So we always know when we're stopping a range and that's why we can pass one, two, or three parameters. Is everyone is anyone confused on that? If you only put it start, right? If you only put uh one parameter, then it will start from zero. So the zero, the start is implicit. We good on this? So, we can code our for loop like that, which for 10, like I said, five numbers is not too inconvenient or or convenient, but if we have like, you know, 500 numbers, makes it a lot easier to just change one end point than it is to type in 500 numbers, right? Okay. Yeah. It's a good question. We should try it. So, why don't we give it a shot? So let's say so the question was can we make a range of floats? So let's try 1.0 to 10.0. Well, it'll give us an answer, right? But it also give us gives us a warning says that an integer argument is expected. And so let's say I do this. Will this work? Well, what it's going to do is it's going to truncate the floats. So it's going to truncate the start to one and it's going to truncate the ends to 10 and then it'll just return the integers as required. So you can, but it doesn't work the way you think it would. All right. So, moving on. You guys hit tupils in lecture this week. So, we're kind of done with the with the big with the old review stuff. So, can anyone tell me what a tupole is? It's a nonscalar data type [Music] that can hold many items. Okay. What does non-scaler mean? Multiple elements. So well that can hold only one value at a time. A sca. So you're both right. So a scalar can hold only one element at a time. So a non-scaler can hold more than one element at a time, right? Tupils are actually the second scalar data type that we've seen, right? A string is the first. A string can have multiple characters. Right? So tupils are flexible. We can have duples of numbers which we can spec. This is this uh syntax the parenthesis with a set of elements separated by commas. This is the literal syntax for a tupil. And all we're saying is that my tupil of numbers has you know the approximation to pi 2 1gative 100 you know etc. We can have tupils of strings. We can have actually tupils of anything but we'll you know get to that in a second. So yes, we're going to get to that. So we can So the question was, can you mix data types? And the answer is yes. We'll get to that in a second. So to access individual elements of a tupil, we do something called indexing. And we specify an index by uh if I have tuple of numbers my variable name I have a left square bracket and a right square bracket and then I have an integer in between and this will give me the item in the tupil that exists at index zero. Now tupils are indexed at uh starting at zero and in increments of one. So when I say tuple of numbers zero, what should this print out? Right? So it'll print out 3.14159. Now if I change this to one, what will this print out? Exactly. So and it doesn't matter what data type is contained in the tupole. If it's string, it'll just print out whatever's here. Right? Which is what now you can also use negative indices. Negative indices tell Python that I want to go to the very one past the end of the tupil. So in this case tupil of strings I'm like out here somewhere and then walk back one or walk back however many the integer is. So I have here a tupil of strings minus one. So, Python's going to go to somewhere around here and then walk back one and give me name. Right now, what if I do minus3? What's that going to print out? Is all right. Now, let's see who's paying attention. What's this going to do? My name or name rather. Well, remember we index tupils at zero, right? So, that's going to give an error. Exactly. So, it's going to tell us index out of range, right? We have four elements in tupole strings. 0 1 2 3 Whoops, we're off. So you can get outside of a tupole and get an error. To avoid that, sorry. Well, the thing is like when you said print tuple of numbers, you said one, it printed the 3.141 number, which would technically be zero in this case, wouldn't it? No, I I switched it. Oh, you switched it. Yeah. So, so just to make you uh make you feel better. I see an error. You got it. Okay, it's always possible that I made an error. So, okay. So, in or in your code in order to avoid that you can check yourself by getting the length of tuple of numbers. So there's a function len right all right and it's going to tell us that tupole of numbers has six elements we can count them one 2 3 four five six so what's the last index of this tupil five right now back to your question two pools can hold different data types or this is they can hold different uh data types that are different from each other and I'm wording that improperly but so here we have a float and three strings. Okay, this is a heterogeneous data structure. A homogeneous data structure would be one that you would say only holds ins or only holds floats. But tupils are very flexible. So we have a float here and some strings. And then you can also have tupils that contain other tupils. So in this case, how many elements does tupil of tupils have? Three. Right? You have the first element is a tupil. The second element is got and the third element is real. So what should this print out? Yeah. Okay. I had to sanitize that quote. Why does it print out? Well, Python's behavior when it sees a a a tupal data type and you call it with the print uh statement is it represents as a string um a tupil the way you would literally see a or literally write out a tupil. So stuff just is a tupole with the two strings stuff and just so Python is going to print out the literal representation of that tupil. So if I were So another way I'm going try and explain it. Let's say that I print out the entire tupole. What should this look like? Well, it's going to be just the literal representation of the tupole. You see? All right. What does it mean for a data type to be immutable? can't change. You can't add another element. You can't change it. So, if I try to change the first element of tupole of numbers, it's going to tell me it doesn't support or Python's going to tell me it doesn't support item assignment. And you'll see this error. All right. Tupils support something called slicing. Which means that if I have a tupil of numbers and I give it a where I normally put just a single integer for an index, if I give it a start index and an end index separated by this colon, Python's going to get the item at index one to whatever this end element is minus one. So, it helps if I just print it out and to make it a little bit easier to follow. Right? So, I've said I've told Python that I want to slice out of this tupole of one of from one to three. And what Python's going to go do is look in tupil of numbers. This is element zero. This is index one. And so it's going to pull in two. This is index two. So it's going to pull in one. And then three. Well, pyth you know in Python we go one past the end of the range that we want. So it's going to return a tupil of 21. This is slicing a tupil. Anyone confused by that? Well, wow. Right. So there are many different ways that we can slice a tupil. So we can have an implicit start. So if you see this uh where there's no number before the colon and that tells Python start at index zero and then in complimentary fashion if you see this where you have an integer on the left side and nothing on the right side it tells Python go from index one all the way to the end of the tupil. All right. What happens if I do this? What's that telling Python to do? Yeah, it looks kind of redundant, but it will become important to us when we get to lists and something called aliasing. But what this does is it tells Python to take a slice that is the entire tupil. And then when we do these uh slices, we can also use negative indices. So this is going to tell Python to go from zero to the last element minus one. So it'll look like that. Everyone following? You good? Oh, so it minuses. It always minuses from the end. Yeah. Okay. So, I wonder if this would work actually. Actually, I don't know. No, it has unexpected behavior. So, I don't know why. I'll have to look that up. So, tupless are also, you know, we already said earlier that they're innumerable items, right? So we can use a for loop with them. So if I want to print out all the numbers in tupole of numbers, I have my for loop, my variable in and then my innumerable object. Okay, so I have a question now. Who thinks this will work? We know that tupils are immutable, right? So, it's going to work. I still have print up here. So what I'm doing is I'm taking tupil of numbers and I'm printing before and then what I'm doing here is I'm telling Python to take this tupil and this tupil and add them together and assign reassign it back to tupil of numbers. So it looks sort of like I'm modifying the tupil but in reality what's happening is I'm modifying or I'm creating a new tupil. So let's say I have ton here. Ton is short for tupil of numbers. Originally it's telling Python that some chunk of memory has a tupil of you know 1 2 3 4. Okay. When I say a statement like ton equal ton plus another tupil, what it's telling Python to do is create another chunk of memory that includes ton whatever is in ton and the other tupil. All right. And then this assignment statement tells Python that ton now points to this new object. You had a question. It's a advanced question, but the question was um does Python have a garbage collector to discard this memory that's no longer being used? And the answer is yes. And if you don't know what a garbage collector is, don't worry about it. You don't need to. But, you know, to answer your question, yes, it does. Um, I don't want to get too far into it. Does everyone follow that? That also is going to be important when we get to lists and aliasing. Um, that type of object creation, modification. So, but we won't get to that for a while. So, everyone's good with this. I can move on. All right. Python has what some would be considered a wart when it comes to tupils and that is when you want to create a tupil with a single element in it. So just people just starting out with Python would sometimes mistake a tupil the tupal literal of a single element to be this. So parenthesis with a single integer. The problem is is that parentheses are the grouping operator in Python but they're also used for making tupils. They serve a double dual purpose. And what Python will say is, "Oh, I've got a number between two parentheses. Well, this person really wants this integer to have high precedence. So, we're going to make an integer 50 and assign it to oopsie." But it's not what we want. We want a tupole with 50 as one element. And the way you do that is you have a lone comma at the after the first element. All right? So if we print out what or if we run this and we look at what it prints out, you see that oopsie has the integer 50 which is not what we want. We want what's in onesie. Oh onzie anyone confused by that? Okay, we're zooming along here. So, strings, they're actually a lot like tupils. They're immutable, so you can't change them. They're uh non-scaler. They have multiple characters within them. So, if I print it out, everyone's seen this. I can get to individual characters. So if I want to get to the first character in name, I use zero. If I want to get to the second character, I can use one. And then of course they're immutable. So that's going to tell me that I can't do that. All right. And they also support iteration. So if I want to print out all the letters in name, one on each line, I can do this. Not too useful, but it works. You look confused. How did that happen? So name is a string right follow that string is just a bunch of characters and it is innumerable meaning that we can go one character at a time through the string and that's what the for loop does count as Okay, the question was do spaces count as characters? And the answer is yes, they do. So if I write spaces there and I run this again, as I iterate through the string, I get a space where I'm supposed to. Okay. Is everyone good with this? Okay. And like tupils, you can take slices. That's going to give me it. Strings also have a lot of or many functions, right? So this is an incomplete list of functions that you can uh use on string objects. So I can make everything uppercase lowerase. I can also find characters. Oops. What do I do? Go. All right. So what find does is it finds the index of the leftmost character. So if I want to find I says it returns one because I is at index one in the string. And I can also do something like this. I can find an entire string and tch the substring starts at index two. Ah, if it doesn't find it. So, let's put in garbage negative one. All right, we can also call a replace function. So if I want to replace M with P, doesn't make sense anymore. Um, I can do that. Now the question is, how would I use this to change the string? So think back to how we modified the tupil. We did we created a new object and we assigned it to a variable the same name. Right? So if I know that replace is going to return a string with m replaced can do that. Does everyone follow that? version of that character you're searching for. It's a good question. And that also gives me a perfect opportunity to demonstrate to another command that you'll find helpful. So, if you're working with an object like string, you can use a command in the interactive editor called dur. If you type dur str, it's going to return all of the symbols that exist within the str object. You can also type help str and it'll give you a nicer version of this. So So in this case, the first character indicates what you're trying to replace and the second is what you're replacing it with. Right? So we can do help.st str replace and it'll tell us. Okay. So and then the count in this case would be if you had multiple instances. Yes. Okay. So like if you had your name a couple times three times, right? You know, if I were particularly narcissistic that day, right? I could replace it multiple times. So let's demonstrate that because, you know, some people might confuse. Let's say I want to replace uh T and I'm going to replace it with R. Whoops. Well, why didn't it replace these two T's here? one, right? So P in strings you differentiate between lowerase and uppercase. All right. So if I wanted to get the behavior that I was hoping for this way. So now I have something that's not even remotely looking like English. Or I could do something like this. I'm going to make everything lowercase and then replace the T. Yeah. Well, remember what I said first recitation that you know computers will do exactly what you tell them to do and nothing more or less. So there we go. good though at fig Python is a very nice language. It's one of my favorite languages right now because it's not as fussy as some other languages like mat lab. Yeah. Or C or C++ or tickle any one of those. So is everyone good on strings? I can move on. Just remember, if anything, if you need help on any of these commands, just remember you have the help command at your disposal. It'll automatically default to do everything unless you tell it to only do like two of the letters basically. What happens? Okay. Oh, yeah. We didn't demonstrate that. And demonstrations are worth a thousand words. So, if I only wanted to, for whatever reason, only replace the first two T's, I could tell it to only replace two T's within the string, and it leaves the other T alone. How would you pick out the last T? It's a good question. I don't have a ready answer for you. Usually you see these uh functions with R in front of them. uh the string uh object often has functions that will start from the right side as opposed to left side. So like the find command I showed you, it has an rfind command as well. This guy right here. So, I'm, you know, I'm blanking on if there's the analog to replace, but can I get back to you because I, you know, I don't want to spend all time searching for this and then fail spectacularly. So, I'll get back to you on that. Is it possible? Yeah. I Is there like a oneliner function? I can't tell you at the moment. So, but again, that's why you have dur help, right? You can find this out on your own. So, all right. So, next thing break. So, we're done with strings, we're done with tupils, and we're still working on loops. So, everyone's seen this function before, right? This is our find a find the uh cube of a perfect or find the cube root of a perfect cube function. So if I give it 27 and I tell Python to stop printing my name. All right, that's what this does. And as a toy example to illustrate the break statement, first of all, can someone tell me kind of in English what the break statement does? Just stop the loop. Well, it doesn't stop the program, but it it kicks you out of the loop. So, we can rewrite the the uh cube root program to work like this. So instead of our stopping criteria being answer cubed less than the absolute value of the number, we're just going to uh tell the for loop to go from a range zero to the absolute value of the input plus one. Why do we have the plus one there? Yeah, because otherwise it would go to one before the absolute value of x. And then we break out of this loop if answer cubed is equal to absolute value of x. So as soon as we see that it's equal to to x, we're going to call break and that's going to immediately kick us out to here without executing any more of the for loop. Right? Do people understand that? Are people good with that? the innermost loop and if you have multiple loops yes good question the qu you know does it break you out of the innermost loop or all the loops and the answer is the innermost loop so when he says innermost what he's talking about are nested loops so let's say I have something like this and I'm creating on the fly now so [Music] excuse my inability to So what is this going to do? This this is an example of a nested loop, right? We have an outer loop here and then we have an inner loop here. And all the outer loop is doing is it's going from the integers 0 1 2 3 to 9, right? And then we have an inner loop which looks like it should go from the integers 10 to 100. But we have the statement in here if J mod 2 right that's what the percent sign is modulus is equal to zero. So what we're saying is if J is evenly divisible by two we're going to break. Now the question is this is obviously uh going to break when you know J is 10. So I mean this loop is going to execute once. The question is, does it print out only one set of J values or does it print out 10? And so the I'm getting to the answer to this question is if break statement breaks out of all the loops then we would only see one print out of I and J. But if it only breaks out of this inner loop then we should see 10 right followed by here. So it breaks out of the inner loop. So long answer but demonstration. Okay. Is anyone confused by that? All right. Is anyone too shy to admit it? Okay. There's office hours. or you can talk to me afterwards. Okay. All right. So, now we're going to get to functions which are uh triple underlined and circled over here because they're extraordinarily important for you to understand. What can someone you know kind of wing it and tell me what they think a function is? You want to try? It's a code that takes some input, does something to it, returns out. Perfect. It's it's a bit of code. It's named so you can refer to it that takes input, does something with it, and returns something, some value, right? And the way that we do it or define a function in Python is like so. Let's say I have a function cube. It consists of a few parts. We've got the defaf keyword. We've got a name cube. Name should be meaningful for functions like variables. You know, name should mean something like this would be a bad name for this function. We want it to be meaningful. Has a set of parameters. In this case, it only has one parameter. This is this is what we pass to the function when we call it. We'll talk about that in a second. It has this string. This is called a a doc string. Uh it's the specification for this function. And when you write functions, it's good to have this string here because what it allows you to do is describe what the function does, what it expects for input and what it gives you as output. All right? And in this case, it's very simple. This is the body of the function. Again, you know, we denote the block by indenting. And all it does is it takes a number which is passed into it and raises it to the third power. And then this return statement tells Python to send that back to whoever called the function. So as an example of this working, let's look at this line of code. What it's doing is it's, you know, we've seen the print statement, so we know what it does. It's going to take it's going to name cube and it's going to call it. And Python knows it's calling it because it's got the name of the function with the input parameters. So three is being passed to cube to be well cubed. And what's going on here is that Python is breaking out of its normal flow of execution sending three and you know calling it number in the function and then raising it to the third power. So if we run this we see 27 right and we can pass it any number that we want. So is anyone confused on this? Those are like comments, right? They don't they don't do anything. So the question was, you know, these this string here between the quotation marks, this doesn't do anything. No, this is a comment. This is so that you can tell yourself, you know, six months down the road what you were thinking or so that you can tell another programmer what what this function does. You know, it's a way of documenting your code. But yeah, like cube in this case is something that's built into the program. Yeah, this is just a toy example. I, you know, I wanted to keep it simple. So, you know, just I'm illustrating concepts. So, yeah, I mean, it wouldn't be too hard just to do, you know, this, right? All right. So, I'm going to move on. Everyone's good with functions. Um instead of return the number and you just make it into a variable without the return, right? If you do have to use the return function that actually I was just getting to that. So the the question is do you have to use the return function? And the answer is well it depends on what you want to do. So let's take a look at a new function now. Can someone tell me what this does? Well, first what does the function do or what is it supposed to do? Right? And you got that by reading the writing on the wall, right? Really, it's too easy. And in the body of the function, all it does is it assigns it creates a new variable answer and it assigns number times two to it. Okay. Now, what's going to print out here? Oh, why don't we run it and see? Uh, that's not doing what we wanted. So when you don't have a return statement, Python uh returns implicitly none to whoever calls the function. Okay, so in this case, this function obviously doesn't have a return statement. So Python says, okay, well, I'm just going to return none. And whatever it whatever work it did in the function is is lost in this case. So to get the right functionality, we have to add a return statement. Okay. And it works. Did Was that what you were getting at? Okay. Anyone confused? Can I move on? All right. All right. So, we're going to functions have something called variable scope. And I apologize for the punning. I was getting tired when I wrote this. So this chunk of code, I define a global variable all hope. All right. I also define a function that takes a parameter variables and it says it steals all the variables, but I don't know how it does that in the computer. And it doesn't return anything. In the body of the function, I create another variable called my variable, right? And I assign it, you know, a string. And then I'm not actually returning anything, right? Because I've said I'm not returning anything. All this is doing is just printing stuff out. So it's printing out what the parameter passed into it was. It's printing out. So it's printing out variables. It's printing out all hope, which is a global variable that we define up here. And it's printing out my variable which is a local variable in the function. All right. Down here defining you know a variable old meme is old and then I'm calling the function. So it does what we expect it to do. What I want to illustrate though is what happens if I do this? Well, as you might expect, it's going to give me an error, right? The reason is is that my variable has local scope to this function. All vari belong to us. Is anyone confused by this? No one's confused by this. Okay. [Music] So, let's try something else. Actually, let's not do that. All right. So, if I run this code, we can tell from the function that it's taking one parameter. It's incrementing that parameter. It's incrementing this global int that we've defined up here. And it's returning the parameter that it's just incremented. Erase my corny humor. Now the question now is Let's say that I have a variable y and it's I give it a value of 10 and I'm being completely arbitrary. If I call the variable inkit on y, first of all, what's going to print? And then if I print out the value of y, what's going to print? Now, why do we run it? Uhoh, I'm failing. Hey, so I'm stepping on myself here. This is why you don't debug code on the fly. So if I have a global variable and I need to reference it, we use a global keyword. You should never have to do this though, right? So incit is going to return 11, right? Because it's taken y, which is 10, and it's called x= x + one, and then it's returned this x, right? But if I look at what y is after I've run this, y is still 10. This is, you know, because when we've passed in x here and we've called x= x + one, it's actually shadowing itself. It's overwriting what's in the local parameter, but it's not overwriting the actual variable y. We'll get we'll get more into this later on, but uh the important thing to understand in this case is that the changes that you make to this parameter stay within the function. We good? All right. So, I need to move pretty quickly now. Gotchas. Guarantee you someone's going to make this mistake. Print is not returned. All right. When you run when you call print is not returned, it's going to call this function and it will print out this string. But it's not actually returning the string. What it's returning is none because there's no return statement, right? And that's where this none comes from. Return is not print. So if I you know say print this return value it will print this will return a string. But if I just call this this not going to print it again. It's going to print nothing. You'll just have to make a mistake. All right. One thing to be careful of in Python is functions every remember I said everything is an object. Functions are no different. Functions are objects. So if you just uh reference the function's name cube which is not defined now it's going to print something out that looks like that. All right. This is the object of or the what the object looks like to Python. In order to actually call it, you have to have the parenthesis with the parameters. All right? Python's not going to complain. Some programming languages will complain. Python won't. So, it's possible when you're running your code, if you're trying to call a function and you forget those par that you forgot the parenthesis and Python's just not complaining, it will merily do what you tell it to do. What's that? Yeah. I'm sorry. Can you speak up? Yeah. Okay. So, is X defined? Okay. Yeah. Just Yeah.