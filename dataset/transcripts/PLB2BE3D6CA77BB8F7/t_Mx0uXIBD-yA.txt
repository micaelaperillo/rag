the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu for those of you who are unaccustomed to seeing it that blue stuff through the window is called Sky um okay I left you last time uh with a question I'd shown you a bsection search implementation or I should say putative implementation of the square root and told you that it was flawed and asked you to think about what was wrong with it so first I just like to take a poll how many of you know what what the problem is or at least what a problem is okay that's a good start and I won't ask how many of you don't know because I presume that's the rest of you so let's look at it now I'm not going to ask you the answer because I want to show people how to find it so here's a slightly simplified version of it just get rid of this stuff here so it doesn't confuse the picture so this is roughly the one we looked at on Tuesday but I just took out some print statements and things and simplified it and let's just run it and we'll run it with trying to find the square root of 0.5 see what happens when we run it uh well not much happens when we run it actually quite a lot is happening we just can't see it so this program is running longer than I expected it to so if you go to the keyboard and you hit controll and C it will interrupt the program it generates what's called a keyboard interrupt and it stops it and it tells us where it happened to stop it it happen to stop it in line seven uh the test to the while loop and the problem is the program just seemed to be running forever so despite my perhaps persuasive argument last time about the decending function there's clearly a flaw in my logic and in fact it does not always terminate so what do we do about it well this is the main trick and one of the things I I I sort of need you to understand this semester is perhaps the most important thing you'll learn is how to debug programs too many people sort of think the hard part is done when they write the code the first time now that's actually the easy part the hard part is actually getting it to work um so the thing you need to learn is how to debug code and the nice thing is it's a transferable skill it's also fine for debugging lab experiences or family members or anything else that can be seriously arai so the way I do it when I program is typically with print statements so the fact that the program was running forever suggests that I'm not exiting the while loop so clearly I need to print something in the while loop and the only three variables it seems to be using or answer low and high those are the three that change so let's see what the value is notice by the way that I actually went to the trouble to type you know ants equals ants low equals low Etc a lot of people would just say okay I'm going to print and they'll ants comma low comma high and then when they run the code they'll forget which is which the most common problem that people have in debugging programs is that they are lazy you know they try think they're saving themselves work and in fact they're creating work so my first piece of advice to you as debuggers is don't be lazy you know maybe you heard this from your your mother some point in life or your father but now you're hearing it from me try and just do it right the first time so let's run it and see what happens now well at least it's printing some output and it's chugging away and chug uh oh so now we see we have a real problem we've reached a fix point where every time through the loop nothing is changing well the first time we go through the loop and nothing changes we know we're in trouble because nothing's going to ever change and therefore we're going to be in the loop forever so we see I've gotten to a stage where everything equals 0.5 and now if I go back and look at the code and I I asked myself the question well what happens when everything is 0.5 and I can see the problem it's this statement here yep turn it around maybe but that's never going to change now because it's 0.5 +0.5 ided two is .5 and it'll just stay there forever so that's my problem I have to somehow change my code now so that this doesn't happen so what is the problem now somebody can tell me simply what is the problem here what was the flaw in my reasoning when I first set this program up yeah louder please so the comment was I don't have a high minus low is less than or equal to Epsilon uh true but that's not sort of the real flaw yeah iser than the original fraction so the solution it's not in the Sur exactly so the answer is the problem was that I did a search in a region and the answer wasn't in that region because the square root of 0.5 does not lie between 0 and 0.5 silly me when I thought about it I didn't think of finding the square root of numbers less than one so what's a simple fix well what I can do is the following I'll go back and say hi is going to be the max of X and one so now I'm going to ensure that the square root actually does lie in the region I'm searching I hope let's run it ah all right well I got to some stuff at the end which you shouldn't worry about but it found something that I guess is a good enough answer we'll get rid of that code I put in this morning which is we'll get to this later okay so I've now fixed the program everyone with me on that any questions and the thing to understand is conceptually what was wrong wrong with my reasoning that I'm doing a search in a region where the answer doesn't lie so I'm not going to find it and the other thing to sort of understand is my systematic way of finding the bug now I confess I knew the bug was there when I wrote the code so I kind of cheated with the debugging but even if I hadn't known this is what I would have done I would have put in that print statement all right so now we have actually a pretty good piece of code for for finding square roots and as we looked at on Tuesday I can use the same piece of code I can modify it to get cube roots or fourth roots or fifth roots and so I have sort of a general framework for doing things but it's pretty unsatisfying in that sense because let's look at it if I wanted to find the square root of some number other than 0.5 I to go and edit the code replace X by the assignment to X by whatever I'm trying to do um if I want to do cube roots I have to cut and paste and edit and do things um there's no very good way to now embed this piece of code inside a larger computation imagine that I've got some 10,000 line program that needs to find the square root six or seven times well now I'm going to have six or seven copies of this code in my program for every time I need the square root um clearly not what you want to do um in general having more code is a bad thing so it's not like you're giving an essay to write and someone tells you it's got to be 5,000 words and you're just sweat blood trying to figure out how to stretch it to be that long um in code it's the other way around most of the time we want to make it shorter not longer and the reason we want to do that is the difficulty of getting code to work is grows maybe even grows quadratically or worse with the size of the code so the more code you have the harder it is to get it to work so one of the things good programmers learn to do is write less code and so we don't measure productivity of a programmer by the number of lines of code they produce each day but we measure it by the amount of functionality they produce each day and we give them bonus points if they achieve the desired functionality with less code so let's talk about how we can write less code and accomplish more well to do that we're going to look at a new language mechanism actually not new but new to this class called the function but before we do that I want to pull back and talk about what it is we hope to accomplish by introducing functions into our programming language we want to provide a mechanism that provides for two things decomposition and abstraction what decomposition does is it creates structure it allows us to break our program up into to something called modules and the module we'll focus on today is function but later we'll see there's another important kind of module in Python called the class and the advantage of a module is it should be self-contained and reusable so it's a self-contained unit of functionality that can be used in multiple contexts abstraction suppresses details it allows us to use a piece of code as if it were a black box that is something whose interior details we can't see don't need to see and shouldn't even want to see we only need to understand what it does not how it does it and that lets us use code that other people have written easily and in fact use code that we have written easily You Know It uh it's one of those few occasions where I think Thomas R was right when he said ignorance is bliss sometimes knowing less is better um all right so let's look at the way functions work the functions let us break code into reusable coherent pieces now we've already looked at similar kinds of things when we looked at say floating Point numbers and we wrote operations like Plus or divide whatever we didn't worry about how they were actually implemented in the machine we said okay they do something they're kind of like dividing real numbers let's not worry about the details we do that with a lot of things we looked at strings we concatenated strings well we didn't worry about how did python go about doing that we just assumed it did it and it had the meaning we wanted it to what functions led us to do is extend the language in some sense by adding New Primitives that we can use just the way we use the built-in Primitives so let's look at an example here I've written a very simple function does something that we actually did or did already when we looked at square roots I've called it's a function called within Epsilon and let me comment this out while I'm thinking about it so we don't have to live with it later and I now want to sort of walk you slowly through what this function does so at the start it uses the keyword deaf short for Define following that is a name I chose the name within Epsilon you can choose any name you want for a function um I'm strongly encourage you to choose nimonic names that is to say ne names that have a meaning so in some sense you see it says within Epsilon you know what it does already following that it has three things called formal parameters I'll come back to in a minute in what that means and then after that it's got something called the function body so we see that a function has a name it has parameters and it has a body the body is the code that's part of the function in the body if you can write any code you want plus there's something you can't write outside of a function called return that's a special command that says whoever calls me has called me to have me compute a value I'm going to return the value that this person would want and then here we see something that's very important this is where we get abstraction and that's the specification of the function and it says here there are two pieces to it one that its parameters x y and Epsilon are all floats and furthermore Epsilon is greater than zero you can imagine this is important um and it returns true if x is within Epsilon of Y otherwise it will return false if I want to use within Epsilon I don't need to look at the code I look Instead at the specification now here where the code is one line maybe I haven't gained a lot by looking at the specification and instead of the code but you can imagine if the code were a thousand lines I'd much rather read the specification than the code we'll also see for other reasons later why it's in fact dangerous to look at the code how do I use it I use it by invoking it so I could for example write something like print within Epsilon of uh one what's it going to print pardon error why is it going to print an error do you think you ah I typed it wrong thank you you're correct it would have printed an error now what will it print sure enough I could also if I chose write something like uh Val equals that and then if I want I could print vow now it's going to print false So within Epsilon is just like Plus or something else does some computation returns a value I can use that value any place I could have used an expression now one more thing to look at with this suppose I don't return anything anyone want to guess what it's going to do now I point this out because this is a very common error people write lots of code calculate some wonderful value and then forget to return it what's it going to do now well let's run it see that by the way is a good habit to get into it's going to return the Special Value none remember we looked at that earlier meaning I don't have a value so if you see in your code some nun popping up where you don't expect it to it's probably because you forgot to return a value so just keep that in mind all right now there's a big advantage of this once I've written this code I can now anywhere I want call within Epsilon and I don't have to duplicate the code I only do it once um as I said earlier maybe I'm not gaining much because the body is so short on the other hand I'm still gaining something notice that when I look at the code down here it's easy to read I'm printing within Epsilon 2 three and one and I don't have to decode this and tell me that that's what that's doing so if I have a function and I choose the names properly code that uses the function is much easier to read and that can be a big value all right let's look at another example so here I've got this function f I chose a non- neonic name because there is much meaning to this function um what F does it is a formal parameter X it sets X to x + one then it prints X and returns X pretty boring so let's see what it does here so now I'm going to set X to three set Z or Zed if you happen to be Canadian to F ofx and then print the values of Z and X also in F before I return X I'm going to print it so let's see what happens when I run this one it prints four four and then three all right what's going on why did it do that well it's pretty easy to see why it printed four here because I called x with called f ofx with an x equal to 3 then I incremented it by one and then I printed it it's probably also sort of easy to understand why Z was four because I returned the value of x here which was four and it printed it but why is this X3 and the answer is this X and that X have nothing to do with each other right I could just as easily have chosen some other value for the formal parameter say George and say George is equal to George plus one print George return George right there is no relation between the name of the formal and in this case X defined in the calling environment so now let's think about that by working slowly and carefully through what happens when we call a function so the first thing that happens at the call and I'll just work it through this one is the formal parameter X in this case is bound and I'll come back to the what binding means that's a critical concept here to the value of the actual parameter so these are important terms actual and formal which in this case also happens to be called X but what's Happening Here is when you enter a function upon entry of a function a new scope is created what's a scope a scope is a mapping from names to objects so if we look at what's going on over here we can draw a little picture well before I draw a picture I'm going to look at a slightly more complicated example well yeah let's do that this one is not in your handout but it is illustrative of I think the what's really going on here here I've got another beautifully named function in this case F1 and inside it I've defined another function called G which takes no arguments uh I've set X to ABC then I haven't shown you these assert statements yet yet or haven't talked about them assert is a command in which the keyword assert is followed by an expression that evaluates to either true or false if it evaluates to true it does nothing it just continues if it evaluates to false it stops your program dead in its tracks so I've just used it here as a trick to make my program stop when I run it in general you'll find that I use asserts quite a lot uh so for example in the next piece of code which is called find root it takes the root is it square or cube whatever the value an Epsilon it assumes that power is an INT and Val and Epsilon float in the specification and then then you'll notice I start by putting in an assertion here and what I'm asserting is that the actuals to which these formals are bound have the properties the specification says they do this is what's called Defensive programming in principle I shouldn't have to do that because in principle nobody should call this with incorrect values but in fact can happen programmers occasionally make mistakes and so I'm protecting Myself by checking that the assumptions are met and if they're not my program will just stop then I can go hunt down the fool that called it with the wrong parameters probably myself so asserts are good for that and I'll use them a lot for these kinds of things I'll also use them when I think I know what value something should be in a program at some point and I'm not sure it really is I'll assert that it has the value I think it is I'll assert that X is six if I think it's should be six and then my program will conveniently stop for me if it's not true all right so that's assert other than that I think there's nothing here you haven't seen before so what's going to happen we're going to step through this piece by piece so initially as we look at it we enter the main body of the program which is not wrapped in a function so what Idol will do or The Interpreter will do is it will start by executing each deaf by executing a def doesn't do anything but puts some names in the environment then it will go and start actually running and interpreting the code that's not nested inside a function so the first thing that will happen is The Interpreter will build for me what's called the scope I've already mentioned that that's a mapping from names to objects so in the outermost scope it will first find the name F1 and it will tell me that F1 maps to an object that happens to be a function so it will come over here and it will map and I'm just going to draw some picture we'll assume that's kind of the memory of the computer and it will map to something that happens to be a bunch of code if you will all right it will then stop it will then notice that it's got at the outermost level a variable called X and that will map to an integer which will initially have no value in it and then after the assignment it will now be bound to the object three it will then create another object Z but before it canbin a value to it it will invoke the function F1 Now The Interpreter starts to execute F1 when it does that it will create another scope so this is the main scope it will next create a scope called the F1 scope in that it will have another name g which will be bound to some code it will have a name X which will be initially bound to the actual so in this case it will be bound to the object three it will then eventually do a print it will invoke G which will now create the G scope and the g scope will create a name X which in this case will be bound to the string ABC it will then start executing G and it will stop so let's see what that looks like sure enough it got an assert false gave an assertion error what I can do now is go up to this debug here and go to What's called the stack viewer each of these Scopes is what's called a stack frame now why is it called a why are they called stack frames because when we do it we begin with the main scope we call F and we get the F scope F calls G and we get the G Scope when G completes which alas it doesn't because of the error it pops the stack and gets rid of the G scope and now the stack is the F and the main and then when F completes it will have just the main so it's last in first out which is typically called a stack in Computing or lifo if you're a course 15 major and do accounting so let's look at the stack viewer and I apologize for the small type font but I was unable to make it look bigger so it says at the top we've got an assertion error and then you'll note it's got three stacks the main the F1 stack and the g stack I forgot I called it F1 not not F then I can inspect them further so the G stack has local and Global variables the local variables include x which is equal to ABC globals we'll get to later if I look at F1 it also has a local called X but its value is now four not ABC and it has a value called G which is a function as we discussed and if I look at Main it has a bunch of things but it has everything that's available in The Interpreter which because we've looked at when a thin Epsilon it's there but you'll notice its X is three all right so this stack viewer can be very handy to sort of look at what you've got when you've got a bunch of calls now if we go back to our code here and we'll take this out and suppose what we do is we assert false here now if we look at the stack viewer we see that we have F1 in main but G is no longer there it's gone all those variables don't exist anymore because I'm no longer in G this is a nice thing because it means if you call something a thousand times it doesn't use up all your memory every time it's finished it gets rid of what it no longer needs all right does that make sense this is an important thing to get yeah thank you question ass where did I where did you put this other assertion when you just changed ah all right where did I put the other assertion if you look at the code you'll see I put it after I called G and G is by now returned but before I left F1 which is why the F1 stack is still present that make sense to you which Stacks exist which stack frames exist depends upon which functions are still active yeah how you don't need a return under the G function oh because I'm not doing anything interesting and it's useless right why don't I need to return under G well if I wanted it to do something useful I would need to return something but I'd probably also want to pass it some arguments rather than have it take no argument as well so it's here just to be the simplest thing I could put that created a stack frame but don't try and interpret it as being anything meaningful yeah would you run into problems assuming that g did something to X and then returned it would you want problems that you name the varibles the same in other words to use x twice would you want it no if an X exists or any variable exists within a function body when you leave that that function that variable is gone forever these are just names they have no intrinsic meaning so one of the ways to think about it and we'll see this later when we get to classes a lot later you could if you wanted think about this as really the name g.x and you could really think of this as a name of f1x and you could think of this is the name of main dox indicating that they're really not the same but it would be kind of a pain to write them all that way okay so different Scopes have different names available to them you can use the names in the scope and you have to keep track of what they mean okay any other questions these are great questions and I really do appreciate them yeah does this also happen with four Loops like if you sayx in range something use x later or X you can use x later X will be available outside the loop this was if you said forx in something is X available outside the loop yes and in fact you'll often want to test what the final value of x is when you leave the loop um okay the next thing on your handout and I'm not going to go over it is uh using functions to implement something that finds Roots uh there's no real point in my walking you through this code in class I did include it in the handout and by the way the handouts are all available after lecture online um is that I think you should work through it on your own and make sure you understand it to get a sense of how functions work and it's certainly related to the current problem set which would be another good reason to work through it the problem set that will be posted today the new problem set PS2 note again how careful I am about the specifications and I should point out that this something interesting whoops excuse me if I type find root open par well let's let's let's do this here o let's clear things up let's get rid of things that will cause the program to halt notice that when I type find root open pen it's given me the values the names of the formal parameters which I've chosen in such a way that'll remind me what their values should be and it's also given me part of the specification the piece in the triple quotation marks to tell me the rules I'm supposed to be following here on these things so it's a very handy thing and as you use idle you'll get used to the fact that uh this is a a convenience all right work your way through that code make sure you know what it does finally today I want to switch gears and talk about something else up till now all of the programs we've you looked at have been new iic they've played with numbers and I've done that because I assumed you guys all had some intuition about numbers um I've used strings as a primitive data element to sort of print things but we haven't done anything very interesting with things however strings are indeed quite interesting in that they're the first nonscalar value we've looked at and you we call non-scalar values or values that can be decomposed so if we now look at the code again I've got this little piece of code called some digits so before the four statement we looked at was 4X in range well you can apply it to a four statement to any type that has a way to enumerate its elements so for C in Str Str actually of 1952 so I've taken the number 1952 and converted it to a string so it will now be quote 1952 I can now do something to every character in that string and what I'm doing is converting it back to an INT and then adding it so this will give me the sum of the digits 17 this is a very convenient mechanism and you'll use for a lot this way you'll use it in fact more for this sort of thing than you will for for inss now I can also select values so if I look at what's going on here every once in a while when you go back and forth between the editor and the shell the shell hangs and you have to go try it again if I go to S equals ABC I can look at individual elements of s for example S Sub Z which will be a I can also look at slices of s so for example s from 0 to one that's interesting why is what is it doing now try and infer I'll give you another example so you'll remember when we did range from X to Y it went to Yus one same kind of thing is happening here so that's why s from 0 to one gives me only one character but s from 0 to two gives me the character string AB this is what's called slicing and it's very common what a slice does is it makes a new copy makes a new object in this case which is a substring of the original string there are many other things I can do on strings I can do something like s.find and it will tell me that b is at position number one in s so use Google whatever you use to find the python web page that describes strings and it will give you all of the operations you can do and they're quite convenient one other scaler type that you're going to need for the problem set is tupal and that will be discussed in recitation tomorrow okay thanks a lot