the following content is provided under a Creative Commons license your support will help MIT OpenCourseWare continue to offer high quality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu good morning I want to start today's lecture with I guess one could call it a confession this isn't a real 600 lecture I'm standing here on June 30th in an empty classroom dressed for some bizarre reasons if it as if it's the winter I guess it's what the video folks would call continuity what happened is professor let Grimson gave a beautiful lecture 13 for which we have a lovely picture and no sound we decided that probably those of you watching us in OpenCourseWare would be unhappy just to watch professor Grimson and not hear him so we're now retaping the lecture this is actually one of two lectures we're going to be retaping because we had video problems so when I say something hilariously funny and there's no laughter in the room it's because the room is empty do me a favor and laugh out there and in video land so maybe at least someone will respond ok the last lecture closed with the slight mystery not a great mystery but a little mystery we ran our simulation of the drunkards walk and got a result that wasn't credible how did we know it wasn't credible well we had worked out some details on the blackboard of what we thought would happen with a small number of steps and the results we got didn't match that at tolis we had something wrong we asked you to go think about it and come back today prepared to tell us what was wrong well since there's no one here to ask I'm not going to ask the class to fix it but instead I've had the laborious task of fixing it myself so let's look at it the problem was in sim wok and what we had is we had the wrong argument here we had num trials instead of number steps and so it didn't make any sense I've now fixed it and now I want to run it well clearly what I should do to begin with is run it on some examples for which we already know the answer so I'll change drunk tests to instead of running it on large numbers of steps run it on just a few and let's see what we get and run a lot of trials here since it's a short trial and what we see is for a hundred trials of zero steps the mean was zero the max was zero the min was zero well that's exactly what we saw when we looked at it on the board should happen and the same thing with one everything worked the way it was supposed to work doesn't tell us the program is perfect it does tell us that works in at least two examples which was better than we had last time all right now let's look at it on a larger set of examples I think I won't run a hundred trials here because it'll take a little longer than we want so let's run maybe twenty see what we get well it's running through here now we're getting examples that seem much more credible when we take ten steps the mean is two point eight five and the max is between six and one or the max is six the min is one it's what we would hope for that there's some dispersion there and as we get up higher we see that for a hundred thousand steps the mean is 248 and there's quite a spread between the max and the min finally we get to look at the question that had us writing this code in the first place how far should we expect this drunk to be given a particular amount of time well we can look at these numbers and try and think about them in there in our heads but in fact it's a lot easier to look at a picture and this will get us to a theme that we'll be getting to shortly in the course of how do we visualize data so here we have a visualization what I'm plotting here is the mean number of the mean distance against the number of steps for this random walk and what we can see is as we knew at 0 at 0 and then it sort of goes up and I've taken only up to a thousand at a thousand or somewhere it looks like around 25 steps so we can learn something well what can we learn from this how fast is it growing well it seems to grow pretty fast and then it flattens out it looks to me we're like roughly speaking the distance is growing as sort of close to the square root of the number of steps well I could look at it more closely we actually know this is not exactly the square root right the square root of a thousand is not gonna be 25 but I'm not gonna delve into the details of that it's actually a little bit complicated we could derive it but but we won't because I want to get to what I think is it is a more important message how much should we infer from this or from the numbers are displayed before and I want to say not too much because what we saw if we go look at what we had before his quite a dispersion between the the max and the min and furthermore if we run it again with 20 trials we're getting different answers so what you can see here is for 10,000 steps here my mean was 78 and here for 10,000 steps from I mean is 90 here the mean was 279 Nero it was 248 the maxes and the mins are different so I don't want to read too much into that graph now one of the issues we should have asked is well it's the mean of how many trials I didn't tell you and to be honest I don't quite remember I think it was 20 but I don't have enough information to interpret it I need a lot more and that's gonna be what this whole next unit of the course is about is how do we think about the results of programs when the programs themselves are stochastic and this is important because as you will see not only in this course but as you progress in your careers if you're involved in engineering or science is that almost everything in the real world is stochastic and in order to think about it we have to really think pretty hard about what those things mean so I want to now pull back and talk a little bit sort of philosophically about that about the role of randomness and computation something you probably haven't seen a lot if at all in the other courses you've taken if you're say a freshman or a sophomore and that's because there's something really comforting about Newtonian mechanics when I first learned physics it was really comforting I learned the physics of Isaac Newton you push down in one end of the lever the other end of the lever goes up you throw a ball up in the air travels a parabolic path and lands F equals MA that wonderful rule of physics everything happened for a reason it was predictable it was a great comfort to some of us about about it and for centuries that's the way the world thought from almost the beginning of the time to science to really if you look at the history of science to today people believed the world was deterministic and they liked it then along came the so-called Copenhagen doctrine and quantum physics in the 20th century and the comforting world of Newtonian physics disappeared the doctrine the Copenhagen doctrine led by the physicist Bohr's and Heisenberg argued that at its most predictable and most fundamental level the behavior of the physical world cannot be predicted one can make probabilistic statements of the form X is highly likely to occur but not statements of the form X is certain to occur period I can make the probabilistic statement that if I take this laser pointer and put it on the table it won't fall through the molecules won't separate in such a nice way that it just drops through but I can't promise it won't happen truth is I'm gonna make that promise anyway because I believe in probability and it's highly highly probable but they tried to say that in fact the world is all stochastic everything is probabilistic other distinguished fittest physicists of the time most notably Einstein and Schrodinger vehemently disagreed this debate it's hard to believe actually roiled the world of physics philosophy and rich religion the heart of the debate was the validity of something called causal non determinism the idea here causal means caused by previous events so causal non determinism was the belief that not every event is caused by previous events Einstein and Schrodinger found this view philosophically unacceptable as exemplified by Einsteins often quoted comment God does not play dice what they argued is for something called predictive non determinism the concept here was that our inability to make accurate measurements about the physical world makes it impossible to make precise predictions about the future so this distinction was nicely thumbed up again by Einstein who said and I quote the essentially statistical character of contemporary theory is solely to be ascribed to the fact that this theory operates with an incomplete description of physical systems ie things are not unpredictable they just look unpredictable because we don't know enough about the initial States this question is still unsettled in science the good news is it probably doesn't matter at all what the truth is however you want to look at it we have to assume that the world is non-deterministic because we can't actually predict it so there's a little experiment I sometimes do I'll pretend to do it even though there are no students here I take three coins if their students in the class I ask the students to give me coins and then I try and steal them but since there are no students I'm gonna have to use my own coins and I'm gonna ask is at least one of them heads well the truth is it's completely predictable I know the answer but you don't know the answer because you can't see these coins and so you - well assume it's probabilistic and guess well he put three coins down at random the odds of each one being a head is half so probably one of the three is ahead and you're relying the probability because you don't know what's going on non predictive non determinism okay and that's the way we're gonna deal with a lot of things going on for the rest of the semester we'll look at a lot of examples where we have to act as if things are non-deterministic and that gets us to this notion of what mathematicians call stochastic processes a process is stochastic if it's next state depends on both the previous states in some random element so now what I'm gonna do is pick up one of these coins flip it in the air put it down and ask again about the state of these three coins it depends upon the previous state because these two coins have the same value they had in the previous state plus a sarcastic element a probabilistic element a random element the value of that coin which I just flipped okay most programming languages including Python include simple ways to write programs that use randomness as we'll see as we've already seen in Python when our drunkards walk we use the function random dot choice which given a set of values at random chose one of those values that function and almost all of the other functions in Python that involve randomness are implemented using something called random dot random this function generates a random float that's greater than zero and no greater than one point zero so you get one of the infinite or seemingly infinite number of floating-point values but that are greater than zero and no greater than one so let's go look at another example of a stochastic process we're gonna look at throwing dice so I've got something called roll die which chooses a value between 1 and 6 for those of you who have never gambled with dice it's a cube you roll it and it has a value between 1 and 6 that shows up at random and then I've got this little program called test roll that rolls a bunch of dice and comes up with an answer all right so let's see what happens all right before we do that let me ask you we can look at a question imagine I roll it and I roll I run it some large number of times 10 would you expect to see the value more likely see that value or might more likely see a value that looks like this which of these values is more likely to come up from my random rolls of the die well when I take a vote if I take a vote historically in this class this strikes people is more likely to happen in this but it's a trick question because as it happens they're equally likely and the reason they're equally likely is each role is independent of the previous roles and as we'll see in our excursion in probability in randomness independence is a very important assumption in a stochastic process two events are independent if the outcome of one event has no influence on the outcome of the other the events are independent if the outcome of one event has no influence on the outcome of the other so it's a bit easier to think about this maybe if we simplify the situation for the moment to think about flipping coins which have either heads or tails and I'll look at the value is 0 or 1 as the examples there that means I can use I have a binary die for some reason so have we seen before if I flip a coin 10 times how many different possibilities sequences of 0 & 1 are there well we've seen this kind of thing a lot of times already this semester there are two to the 10 binary numbers of 10 digits so we know that there are two to the 10 possibilities each of these two to the 10 possibilities are equally likely so the number in which I have all zeros is no more likely than the number of all ones it's no more likely than some seemingly random combinations of 0 and 1 so it's a very small probability so what's the probability of getting all ones it's 1 out of 2 to the 10 what's the probability of getting all zeroes 1 out of 2 to the 10 what's the probability of any combination you would happen to pick of zeroes and ones one of over two to the 10 I know I'm belaboring this point but the point I want to make is that when we talk about the sum result having a particular probability we are asking essentially the question what fraction of the possible results have the property we're testing for so I ask what property are all ones I'm saying what fraction were all ones if I say well property there are exactly four ones what fraction of these numbers have exactly four ones in them whatever I want so probabilities will always be fractions that's important because it means that when we talk about the probability of some event occurring we know it has to be somewhere between 0 and 1 probabilities are never less than zero they're never more than one cannot happen guaranteed to happen usually somewhere in between all right that's the key thing to remember when thinking about probabilities suppose I want to ask what's the probability of getting some sequence of coin flips other than all ones well I know the probability of getting all ones is 1 out of 2 to the 10 I know the probability of getting some sequence of flips is 1 it's a certain I'll get one of those numbers so the answer is probability of not getting all ones as 1 minus 1 over 2 to the 10th this is an important trick to remember typically we have two ways of computing probabilities we can either compute it directly as I did when I computed the probability of getting all ones or we can compute the probability of something not happening or by subtracting one probability from another this - 1 - trick and so you'll see me using this formulation a lot of times and we'll talk as we go forward about when you do it which way all right so let's go back finally to our six-sided die how many sequences are there of length 10 for that 2 to the 10th no 6 to the 10th because unlike the coin where we only had two possibilities we now have 6 possibilities so there are 6 to the 10th different sequences of rolls I could get quite a few so the probability of getting 10 consecutive ones is 1 over 6 to the 10th and of course the probability of getting this sequence here is also 1 over 6 to the 10th so we see that they they are equal okay we're gonna spend a lot more time on probability and randomized stochastic algorithms before I do that I want to take a brief digression and return to the topic we looked at a little earlier this morning we was data visualization plotting I want to do this for two reasons one it's really important it's something that all of us do a lot of in the course of our work but it also will just make it a lot easier for me to talk about probability and stochastics when I can draw some pretty pictures to illustrate what's going on now many people most of us probably when we're writing code to do something focus on writing programs that perform some complicated analysis of the data and then print something we don't spend enough time I think worrying about how the results of our analyses are presented so that somebody else can make sense of them or in fact we can understand them better ourselves sometimes text is the best way but sometimes there's a lot of truth to the Chinese proverb that a picture's meaning can express ten thousand words now most of us sort of believe this why don't we do it well because in most programming languages it's hard to draw pretty pictures one of the reasons we use Python in this class is because in Python it's easy to draw pretty pictures or at least to make plots why is that it's because somebody not me went to the trouble of building something called pylab pylab is a python library that provides many of the facilities of something called MATLAB if you're an MIT student the probability of your graduating without using MATLAB is very low it is something people use a lot it's not my favorite programming language it has its utility I like Python because it brings a lot of the features of MATLAB or easy to use in a programming language that I find much more convivial than MATLAB alright I'm not going to give you a complete tutorial for pie rod here it would take a long time and it would be boring instead I'm gonna give you a few examples in fact focus primarily on the plotting capabilities and the good news is the plotting capabilities in pylab are almost identical to those of MATLAB so if you learn it how to do it here you already know how to do it here for details you should take a look at make sure I write this correctly this website matplotlib doc sourceforge.net and it's very nicely put together website that will give you all of the the capabilities of plotting also you'll find in the class website I've wrote written a little chapter of a book about how to do this sort of thing and you may also find that helpful I should point out that pylab is not part of the standard Python distribution it has to be installed on your computer and again there are instructions about how to do this post it on the class website alright let's start with something very simple look at that here I'm beginning by importing I'll import pylab you have to import it to use it and then I'm going to plot two things so what I want you to observe here is I'm going to plot two vectors the vector 1 2 3 4 and the vector 1 2 3 4 these are the x coordinates these are the Y coordinates so I'll get a two-dimensional plot X versus Y and it's very important that these two vectors be of the same length doubtless when you're using this in your problem sets you will screw up and you'll get an error message which you will have a hard time interpreting but what it probably is gonna boil down to is you've done something wrong and you're plotting things that are not the same length after I plot these two things I'm going to type pylab dot show which will put the plots up for us to look at so let's do that now so it first plotted our straight line 1 versus 1 2 versus 2 3 versus 3 4 versus 4 got that then it plotted this rather funny-looking zigzag we saw kind of just randomly chosen in the other one I mean the plots will always look something like this I should mention if we go look at the code pylab dot show if I hadn't said that the plot would not have appeared in my screen pylab would have produced it but not displayed it you may think that's silly but in fact it's useful because most of the time when I'm writing a programs that do plotting I don't want to see them on my screen I'm producing a whole bunch of plots and I'm gonna write them the files that I'll then look at later or include in a paper or a lecture or something so it makes me say that I want to see it I should point out depending upon your operating system it can be pretty annoying because if you try and do this twice in your code something bad can happen the code can hang there for you should only execute pylab dot show once for program and it should always be the last thing you execute it because once you execute pylab that show the program will stop running essentially it's annoying I wish it weren't that way but it is so live with it all right let's go look back at our graph or plot at the top is a title this is the default title it says figure 1 later we'll see that I could have given it a much better title than that then it's got the values of the X and y axes and a bunch of things down at the bottom that we could point out you can zoom in on the plots are using that or zoom out you can use this funny icon happens to be a floppy disk icon something that probably most of you have never seen congratulations if you've never seen a floppy disk your life is better than it would be had you had to deal with them but that's used for saving them to a file you can move around in it you can get back to what the original figure was a whole bunch of useful things I suggest you just bring this up and play with it one of the things I should mention here is you'll note that when I produce this I only used 4 points 1 2 3 & 4 say for this one yet it looks as if I have a continuous plot you know it claims that one point five and one point five match this can be very deceptive as we'll see later on and probably it might have been better for me to plot not lines here but points indicating there are only four points in this graph it's more apparent here where we see this funny-looking zigzag implying some complicated relationship amongst the points which actually probably doesn't exist and again later on we'll see ways to to avoid that okay it is of course possible to produce more than one figure so let's look at this will comment this piece out for now and we'll run this code so this says I want to plot something on a figure I'm calling figure one as before then I'm gonna go to figure two so now in plot instead of plotting both of these on the same figure I'm gonna put them on separate figures and then pile of dots pylab dot save figure will actually create a file in the directory in which I'm running the program and save it and called first save and then this will be second save and now I can run it and now I have two figures figure 1 as before so I'm not quite as before a different figure and figure 2 again nothing very magical there and if we look in my directory we should see I hope first saved and second save so if we look at second saved we'll see there it is and just to show that I'm not cheating you can notice that the time stamp is today at 10:30 4 a.m. which happens to be when I'm giving this particular lecture all right put that away now continue now what I want you to notice that's is the last one I just gave it one argument five six seven and ten and if we look at what it plotted actually I think I put that in Figure one didn't I you'll see here it is and it's made up some values for the x-axis if you only give it one set of values it it zoom it's the y-axis and it finds values all right now what values is it going to choose for the x-axis well this is Python so surprise surprise the first value is zero one two and three how I get the four values now we could let's look at another example slightly more interesting one comment this out so we don't look at the boring stuff over and over again I've written a little program to calculate interest so I'm gonna start with an initial principle here of a thousand an interest rate of five percent 20 years and just do compound interest this you all would know how to write this and then I'm gonna plot it and see what we get all right so what we have a something here which sort of shows the kind of beautiful growth you get with compound interest with the finance people called the magic of compounding which will make us all rich in principle until we see what the markets really do but any rate for now we can look at it and it looks very pretty but I don't know what it means I look at it so it's figure 1 well that's not very informative and X goes from 0 to 20 but if I hadn't told you you wouldn't know what that meant and why from 10 thousand up to 28,000 but again you wouldn't know what that means we see this all the time it's not a good thing it's a bad thing in fact all plots should have informative titles and all axes should be labelled you know I can't tell you the number of times I've had a graduate student show up in my office having worked for weeks producing some data put a plot on my desk and say look at this isn't it great and I say I have no idea what it means and sometimes I say well what is the y-axis and they end up scratching your head they're not quite sure you got to label your axes you got to put a title you've got to give the person a break well how do we do that well it's pretty simple so here's this code so yeah we just just want to get rid of the old graphs because sometimes if you look at them it causes you problems because it's now hung it won't continue until I get rid of it now my shell is back so pylab the title just says okay I'm gonna call it five percent growth compounded annually notice that I've put in that it's five percent interest rate and then I'm compounding it annually not semi-annually or quarterly the x-axis is going to be the years of compounding and the Y out exists the value of the principal in dollars so now it's the same curve but a far more informative picture all right here's where I want to stop today we're gonna come back to this topic in probably more detail than you want and spend quite a lot of time talking about how do we produce beautiful plots and more importantly how do we produce plots that are actually meaningful to those reading them thanks a lot see you in the next lecture