the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit mitop courseware at ocw.mit.edu good morning thank you okay so we're about to Launch unch into uh learning some basic elements of python today the elements I'm going to talk about are common to every programming language that I know at least in concept and of course slightly different in detail but as I said last time everything you're going to learn about python should be readily transferable I'll be using for all of the examples I present something called an integrated development environment and in particular one that's built for python called idle usually we talk about these things as uh IDE I'm told I don't know if it's true that the IDE for python is called Idol after Eric Idol of Monty Python uh which was also I'm told the inspiration for the name of the programming language um so what is an integrated program pring environment in this case it includes a specialized text editor that provides highlighting autoc completion smart indent and you'll see shortly while that's very important and a few other amenities that make it easier to use this to type python than typing it into a generic text editor it includes something called the shell which is the environment that actually interprets the python code and the nice thing about it is it includes syntax highlighting so the shell gives you some information about the syntax as does the text editor of course and finally it includes an integrated debugger this could be useful in the unlikely event that your programs have errors when you write them um though truth be told I've been programming in Python for years and I don't know that I've ever used a debugger it's not that I don't make mistakes it's just that I'm kind of a lite and I typically use print statements for debugging and in fact almost every programmer that I know when push comes to shove ends up using print statements but the debugger is there should you care to take a try all right so you'll see on the screen here an idle shell in the Shell we can type things what are we going to type well the first thing to understand is that at the core of python and probably the most important thing to understand are something called objects everything in Python is an object so every kind of entity that you can create in Python is an object and in fact python code itself is an object you remember we talked about stored program computers last time and the concept that a program is data just like a number is data each object has a type that tells us the kind of object it is and in particular what we can do with it and then there's a built-in function called type that can be used to find out the type of an object as we'll see there are two fundamental kinds of types scalar and non-scalar we'll start with talking about scalar types and the key thing to think about there is that they are indivisible think of them as the atoms of the programming language now I know that some of you have studied physics and know that atoms are in principle divisible but of course only at Great expense and with serious consequences and we've seen the same thing here you can if you're desperate chop up these scaler types but it almost always leads to uh something bad all right well let's look at some well the first one you'll see is used to represent integers and that's called int for every type or every buil-in type there's a notion of a literal which is how we type it so for example we can type three and that will now tell us it is the value three you'll note it's typed it in blue and can ask what the type of three is so you'll notice as I type things into the shell it's using colors to give me a hint so it's uh this fuchsia color for the word type telling me that's a built-in function and now if I ask it it will tell me that the type of the literal three is quote int quote so it's an integer and I can you know use other sorts of things all right there's also a type float so those correspond to the real numbers so I can do something like that and we'll talk about this in a second but you'll notice if I do typo 3.2 it tells me it's a float and for that matter I can do type of 3.0 and it will tell me it's a float so there's a difference between three and 3.0 one is an INT and one is a float now you'll notice something kind of weird here when The Interpreter printed back the value of the literal 3.2 it gave me 3.2 and a bunch of zeros and then this funny two standing at the end in a few lectures I'll explain why it does this but for now you should just take this as a warning that floats are not the same thing as real numbers right you learned about reals presumably in middle school or High School uh floats are a computer scientists approximation to reals but they're not quite the same the good new news is almost all the time you can pretend that a floating Point number is a real but as we'll see in a few lectures every once in a while it can really sit up and bite you if you believe that but for now we'll just pretend that they're reals um there's booleans a nice scalar type of which there are only two values one of them is true and what do you think the other Boolean value is thank you so somebody said false I have no idea who but whoever it is there's probably some candy to be at oh I managed to find one place in the room where there was an empty I'm hoping that people will now scramble and fight for it like a a foul ball at a baseball game now people were too polite thus far all right so we have true false is the type booleans and then we can do operations on them so for example true and false is false as you might guess finally there's this funny value nun which doesn't print anything when I type it and if I look at the type of none we'll see it's the nun type not very interesting fundamentally as we'll see that gets used when you want to put in something temporary when you don't yet know what its value is going to be you know it's going to eventually have one so maybe you start out calling it none and then you can check and we'll see how we might do that so those are the fundamental scalar types the indivisible ones interestingly enough python does not have what is a common scaler type in every other language called Char short for character instead what it has is strings that can be used to represent strings of characters so for example I can write the string quote a quote and if I ask for the type of it it tells me it's an Str Str short for string happens to be a string of length one which we might usually think of as a character but there is no type CH so it's not a problem we just have to remember it literals of typ string can be written with single quotes or with double quotes there's no difference just a convenience that you can do it either way and we can build strings of things it's worth noting that the type of say the string one two three three is Str whereas the type of one two three without the quotes is int so we have to be a little bit careful sometimes as to whether we're dealing with strings or ints when we look at these literals you can only get so far with literals things you can type so of course python has in it something called an expression again this shouldn't surprise anybody and an expression is a sequence of operand and operators the operands are objects so for example we can write the expression 3 + 2 and when we type an expression into idle it automatically evaluates it and prints the value of the expression in this case of course it's five one thing to be a little careful about is if I type the expression 3 slash2 slash is the Divide operator I get one whereas if I type the expression 3.0 / 2.0 I get 1.5 so dividing two integers in Python 2.x gives you essentially a floor operator uh in 3.0 by the way integer division is not allowed it always converts it to floats and does a floating Point division but for many of you this will be something that will trip you up as a bug if you want to get real division write floating Point numbers otherwise unpleasant things may happen some other interesting things I can type just as I could type 3 + 2 I can type a plus b what do you think I'll get there it does concatenation so what we see here is that the operator plus is overloaded so overloaded operators have a meaning that depends upon the type of the operand and of course we've already seen that with the slash operator which means one thing for ins and another things for floats and of course we see the same thing with plus what do you think will happen here three Blank Three any guesses I get a syntax error remember we talked about that on Tuesday it's not a valid python expression so we get an error how about this one that is synt syntactically valid it's got operand operator operand what do you think it'll do when I uh hit return here somebody is that a semantics ER pardon was that a semantics error a static semantics error and because of the light I can't see who said that raise your hand man oh come on all the way back there all right I have the most chance of carrying with one of these I'm going to lie those of you who are watching an open course Weare it was a perfect throw okay so indeed we get a static semantic error of a particular kind called the type error saying you cannot catenate an Str Str and an INT type errors are actually good things the language does type checking in order to reduce the probability that a programmer will write a program with a meaning that will surprise its author so it looks at it and says somebody might have a weird guess what this means but just to be safe we're going to disallow it rather than it could of course make up some funny meaning if it wanted to but it doesn't and I think you'll find type checking saves you from a lot of careless programming errors as as you go on all right let's continue let's look at some other things uh I can write this because that's just two strings and it just concatenates them the string a and the string three more interestingly I can do this so now what we're seeing is that you can take any type name use it as a conversion function to attempt to convert one type to another so this has now converted the int3 to the Str Str quote 3 quote similarly I can do something like this and here it's converted the string quote 3 quote to the int three on the other hand I could do this and it will tell me it's not it's a static semantic error it can't conver convert 0.0 into an INT similarly it can't con convert 2.1 or can it so now I've given it the float 2.1 and I've tried to convert it to int not the string 2.1 but the float and it succeeds and it's succeeded by essentially truncating it is this a good thing or a bad thing um to me it's a kind of a bad thing if I've typed something like that or I've evaluated some expression that happened to work that way more that likely than not I'm confused and I would probably have preferred to get a type error rather than it deciding how to do it it's one of the things I don't like about python it's too generous it lets me get away with stuff it shouldn't let me get away with other languages for example Java or much stricter this is a designed decision and it is the way it is and we have to live with it yes turn into one up top yeah exactly um it is the same reason that that happens this will never go that far butay yeah exactly it's the same reason the question was is it the same reason that 3 ided two doesn't give you the answer you would get with floating point and it's because python has tried to help you uh again python 3.0 is a little stricter about these things we'll talk much more about this during the term this is close to the last time you'll see me typing things directly into idle for the most part as you write programs you'll use the text to produce them and then go to the Shell to run them but you'll want to obviously if I had a 100 line program I wouldn't want to sit here and retype it every time I needed to change it so instead I use the editor and idle to produce the programs and then I can run them and that's what I wanted to start doing I should probably mention that what most people call a program some python programmers call a script think of those two things as synonyms but you will see people use both of them uh I will typically call them a program all right let's look at an example so first thing to say is that things look a little bit different when they're executed Ed from a script than when you execute them directly in The Interpreter so I happen to have a script here if a line in a script starts with a sharp sign or a number sign that makes it a comment so it's not executed so I've started here just by commenting out everything but now whoops what happens if I just put the number three here we saw when I typed it into idle it echoed it in some sense and gave me what it was or just to be clear I'm going to put in the expression type of three I'll save it and then I'll hit F5 to run it and it does nothing right you saw it move it didn't print anything so when you type an expression into the shell it prints the value but when it executes a script with an expression it evaluates the expression but does not display it on the screen well so what do we do about that there is something called a print command so I can do this print type of three and now if I run it it will actually appear so whenever you want to get something to appear you have to use the print command um not a very complicated concept a program or a script is a sequence of commands each one tells The Interpreter to do something so a command is print for example okay so that's there that's kind of boring I'll get rid of that the next command is a really interesting one it's an assignment statement a key Concept in every or almost every programming language is that of a variable different languages have different Notions of what a variable means in Python a variable is simply a name for an object and what an assignment statement does in Python is it binds a name to an object so these assignment statement you see here binds the name x to the object three the next statement rebinds the name x to the value of the expression x x x so it takes the old value of x a evaluates the expression and then binds the name x to the new value so at the end of the second statement X will be bound to nine by the way these are really stupid comments I've written here uh I put them in just to show you what these statements are doing for goodness sake when you write comments in your programs assume that the reader can read Python and you don't have to explain the programming language in your comments that's not to say you shouldn't write any comments the purpose of a comment is to make the program easier to read and so typically comments are there to explain things not to explain the language or its semantics but to explain your thinking when you wrote the program what is the algorithm you've used and we'll see some useful examples of comments probably not today but but later all right so let's execute this script sure enough it printed nine just what we would have hoped all right now let's try some other things print lets us output things raw input lets us input things get things from the keyboard essentially so the statement here is making a request to the whoever is using the program to enter a number there are two kinds of input statements in Python 2.x there's raw input which is the only one you will see me use an input raw input by the way is the only one that exists in 3.0 so please just use raw input the difference is raw input always expects interprets what the user types as a string so you'll see here it says y equals float of raw input enter a number so let's run it so it's taken the argument to Raw input the string enter a number ask me to enter a number I'll enter a number and then it's converted it to a float suppose I get rid of that suppose I do this that should work so now something has happened it's printed both of them as 3.0 it looks like they're the same but in fact they're not and this is something to be aware of what we've seen here is when it prints a string it does not print the quotation marks so even though if I were to put this in here I'll put in two print types of Y and I'll comment this out because I'm getting kind of tired of seeing nine you'll note that one is a string and the other is a float again I point this out because this is something that can confuse people when they're debugging programs because you think it's a float when in fact it's a string okay nothing deep but these are the things that sort of get people in trouble now the kinds of programs we've been looking at so far are what are called straight line programs what distinguishes a straight line program is it's a sequence of commands you execute one after another you execute every command without making any deviations without going back with any Loops to execute a command more than once so in a straight line program every command gets executed exactly once there is a a very elegant and even useful theory that talks about different layers of levels of complexity of programs and says for example what kind of functions can you compute with straight line programs we'll talk more about that field which is called complexity Theory later in the semester but for now the thing to realize is that straight line programs are just dead boring you can't compute anything interesting with one last time we talked about a recipe as an analogy for uh a program imagine a recipe with no tests so every recipe or almost every recipe I know has some decisions you know if it taste it and adds salt if you need it or poke it the meat and see if it's done or cook it until the thermometer says some degree on it those are the kinds of tests we need to make interesting programs the most primitive kind of test we see is what's called a conditional statement and those are written using the word if and optionally as we'll see the words else or L if standing for else if so let's look at an example here where' my mouse there it is yes someone has a question shout that sorry I was wondering when the user was prompted to put in input instead of putting in a Flo puts in like a string because you define it as like a floating integer how does it interpreted that I I didn't get the question is the argument to ro input or or the response to Raw input so yeah for for the raw input where you define it as a float yeah the user puts in a string how does python interpret that uh it will interpret as a string containing quotation marks okay so typically you don't type A String because everything it it interprets everything you type as if it were a string so don't bother typing strings good question thank you all right so let's look at this so here I'm going to get an INT or at least a string I'll convert it to an INT then I'll say if x remainder two that's what the percent sign is it's a remainder or a mod operator is equal equal zero that's important you'll notice that we used an equal sign to do assignments if we want to do a comparison of to whether two objects have the same value we don't write a single equal we write a double equal so whenever you're testing for equality of objects you use double equal so it says if the object xod 2 has the same value as the object zero print even else print odd and then just for fun I'm going to see whether or not it's divisible by three why did I do that just to show you that I can Nest conditionals inside conditionals so in one of the branches of the conditionals I'm now doing a test so what this does is it if comes down it does the test if the value of the test is true it executes the block of code following the if in this case just print and then it skips the else it does not execute the else so it executes one or the other if the test is false it skips the block of code following the if and executes the block of code following the else so it does a or b but not both the indentation is important pyth on is very unusual in that the way you indent things actually affects the meaning of them and you can tell that if if I were to type this in the editor you'll note here it's on that line but if I hit return it automatically indents it that's the autoindent feature I mentioned earlier in the editor of idle and this tells me how these things line up so the fact that this is here tells me I execute it only as part of the else Clause the program would mean something quite different if I wrote this then it would mean if x mod 2 is zero print even otherwise print odd and whether or not it was even or odd do this test in the if statement so the indentation actually affects the meaning of the program now a lot of other languages almost all other languages don't do that they have some punctuation for example C uses set braces to designate what's called a block of code if you look however at a well-written piece of C code or Java code or any other language that I know programmers are trained to use indentation to show the structure of the program even though you don't need it you could line up everything right at the left Edge and just use the punctuation people don't do that and the reason they don't do that is is programs are intended to be read not just executed why are they intended to be read be because the only reason the only way you can debug a program is reading the code in it typically you want to write your program so that if you look at it from a distance the visual structure of the program reflects the semantics of the program and that's why people use indentation when they don't need to so that you can see the structure of the program by looking at it on your screen and not having to parse each symbol the authors of python made what I think is a very good design decision they said well if that's the way you ought to write your programs let's force people to write their programs that way and guarantee that the visual structure of the program actually matches the semantic structure the problem with languages like C and Java is that you can indent things and fool the reader of the program by making it look like something is under something else when in fact it really isn't because of the punctuation so here we have a guarantee that the visual structure matches the semantic structure and I think that was one of the really good design decisions in Python okay people see that so we could execute this program let me get back to where it was before control Z is the go back and now we can enter an integer say 14 and it will tell us it's even I can run it again and now I'll put five 15 in and it'll tell me it's odd we'll try it once more we'll put in 17 it was odd and it's not divisible by three these kinds of programs are called branching programs and that's because the structure of them as you go down you execute some statements and then there's a branch which says execute these statements or execute those statements and then typically it comes back together and continues of course branches can have sub branches we could do this and then join further down as we've seen here now branching programs are much more interesting than straight line programs we can do a lot of things with them but fundamentally nothing really interesting and we can think about that by thinking about how long it takes a branching program to run so let's first ask the question how long does it take a straight line program to run 14 seconds no it's not the way to think about it how would we think about how long it takes it to run what governs the length of time a straight line program can take exactly the number of statements or commands in the program since it executes every command exactly once if you have a 100 commands it will have a 100 steps in it now there's some variation in how long each step will be some commands might take longer than others but the length of time it can take to run has nothing to do with its input it has to do only with the number of lines of code and that tells us it's not very useful because well we can only type so many lines In Our Lifetime well branching programs have the same problem in a branching program each command is executed at most once so again the length of time it takes to execute the program is governed strictly by the size of the program why isn't that good enough well think about a program say to compute the uh the GPA of all the students at MIT well how long is that going to take think instead about a program to compute the GPA of all the students at the University of Michigan which is probably 10 times Bigg than MIT well you would expect that to take longer right because you have to look at more students and in fact it's true most programs that are interesting the amount of time they take to run should depend not on the length of the program but on the size of the data that you want to evaluate using the program so you would argue that the amount of time taken to compute the GPA of the students at MIT should be proportional to the number of students not proportional to the length of the program used to do it we'll talk a lot more about that later in the term in a much more uh thorough way but it's important to get that as something you think about so the fact that branching programs are not proportional in time to the input means that they're Limited in what they can do so that gets us to the final concept we need to write every program that could ever be written or at least to compute every function that could ever be computed and that's some sort of a looping construct once we add Loops we get to a class of programming languages or programming constructs that's called touring complete and I mentioned this last time any program that can be written or any function that can be computed rather can be computed in a touring complete language so let's look at an example here this concept by the way is called called iteration and if we look at languages with iteration what we'll see is a more complicated flow of control you execute some statements maybe you do some branching if you want but then you're allowed to go back and execute statements you've already executed typically what you have is another Branch One Branch goes back and one continues so now we see we can execute a statement more than once suddenly we have enormous power at our disposal so let's look at an example example of that I by the way am skipping some of the code in your handout but that's probably fine because you it's there for you to be able to read and what I would recommend by the way is is that we will post the handouts on the web but at the end of every lecture within a few hours or a few days at least go through the handouts and make sure you understand everything in them because if you don't you're probably missing something you'll need to understand to do the problem sets so here's a little program that finds the cube root of a perfect Cube this by the way is a useful concept here right tells you what the program is intended to do so we get an integer we set the variable ANS to zero and then while ants time ants time ANS is less than the absolute value of x we're going to set ants to ants plus one we could print where we are I put those sort of things in as debugging statements if ants time ants time ask an is not equal to the absolute value of x when I finish the loop then I'll print X is not a perfect Cube otherwise I have to do something to deal with positive and negative values now I know that this was fast and that most of you probably don't fully assimilate this program do not worry uh it will be discussed in rep in uh recitations tomorrow so tomorrow the recitations will review the python Concepts we've dis we've discussed today but we'll start by emphasizing how these loops work okay thanks for coming uh enjoy recitation tomorrow