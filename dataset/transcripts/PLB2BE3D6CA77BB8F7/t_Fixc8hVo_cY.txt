the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu so let's start I mean for the first question you can answer what is tle you can go through the L can a tuple contain a list what do you think can a tuple container list yes yes it can so we'll go through the examples later and let's see the uh this first example we have two tupes the Tuple B contains Tuple a as well as a list okay so it can prob let's see let's print the resource to okay so for the first example we try to access the elements zero and two of the Tuple a and later we use minus one to access which element okay and zero is the first element of course and remember now we are using like 01 it's like we are accessing the it's it's now okay what is Tuple B it's a two-dimensional tup yeah exactly it has a list and a tuple inside so the first element has a first element is a tuper and the last element is a list so now it's sort of like two dimensional but if you look at the second sorry or first element of it the MIT word is that doesn't have any Dimension does it it's a string so you can again access but not this way but still you can access and we have we are using this notation to access a portion of the list a part of the part of the T actually here it's called slicing so here 0 to one gives you which element just one element right it's the first element 0 to two gives you one and two okay this is an interesting uh usage of the slicing this is used to access the whole tuper now you might wonder why why we need that we could just uh the handouts are here so why we need to like copy or why why we need to access the list through the colon operator like this we'll we'll look at that later it's it's very essential when we when we have list for the time being it's okay when ts are like immutable so it's it doesn't have a like a special usage but later on we'll be using it then if you look at this part this is the most interesting part how do you iterate through a tuper you use a full loop and you call like item in tup the element in tup the element is initialized with every element when it goes through the iteration at every iteration it will be in instantiated with the the corresponding element in the T but you're using the same name anyway it's item this is equivalent to accessing the Tuple like this going one by one in the range and accessing the corresponding element in the T so this is a simpler way to access that do you have any questions in that part yeah um for that part okay that's correct so the thing is okay suppose a tuple has three elements so for example example in this case tlea how many elements are in the tlea three elements so what will be the length of tlea three but the what would be the range 0 1 2 right so you have to type 0 to three so that's why I put length Okay that is three okay so you just say like mle it assumes that the first one first is zero if you don't specify zero okay now let's go through the list so if you go through the questions what is the difference between a list and a t what is the difference between a list and a T anyone yeah um are mutable okay L mutable and because it's mutable it has like special functions to like access the elements add elements and like modify the list itself how would you add an element to a list suppose you have list a how would you add three to this list okay let's start hand okay let's go okay how would you remove the element from the like top of the list or the last element how would you remove this three from the list this one let's see we know how to check the uh specification of a function right sorry so it's not the right function right because it says it removes the first occurrence of a particular value you pass in to that function okay there's another function which is called list. poop that removes the last inserted value so it pops from the top okay so remove can be used to remove a particular element so here suppose we want to remove one so we could say list remove y okay so in this example actually I have uh committed out this line this would be an error if I execute why why it like Q an error doesn't exist it doesn't exist great so the problem here is we can't access an element in the list unless we explicitly assign something or create something but suppose we want to pass a list of 10 elements to a program so that it can assign values on the Fly and it can modify okay so how would you pass an empty list of 10 elements okay the problem is if you're passing something like this you need to know how this list should be initi like instantiated so you should know what are the initial values of these elements okay suppose you want to create a list of 10 zeros then the easiest way to create the list is this so it will create a list with 10 elements but if you don't want to waste memory or if you don't want to like keep anything particular you could do something like this now this will create a list of empty list and there will be 10 such empty lists okay and you could pass this list to a program so that you will assign the elements okay you can iterate through the list the same way but lists are interesting why they are mutable so they can be actually used to create interesting mathematical objects for example like Matrix so how would you create a matrix using list any ideas how would you create say 2x two Matrix if you consider this example this creates a matrix 4X two right so there will be like four rows and two colums but how can you go and access access the inner element or inner Matrix so if you suppose you want to access 2 three that is the third row then how would you access how would you call M M3 M3 gives you 2 three suppose you want to access the three in the 2 three then wait sorry yeah M3 you two before I'm sorry my bad yeah okay this is like computer science not maths you got it right why it's not three it's two because I talking about yeah that's fine so like I'm asking now like how would you access the three in the two three box to another parth another bracket okay very is small so you can access like uh you can access matrices like this okay great we are on time okay so this actually gives you a summary of functions I mean essential functions for example the pop I explained earlier remove removes a particular element extend that's interesting can you tell me what it does here the measured extent on list okay what does that method take it takes another list so which means it's going to merge the list you are passing with the list you are calling the method on that is LA right so it's going to comine the let's see so this corresponds to this so two list are comined okay so these methods actually useful right because you don't have to write yourself most of the things you can easily do now the question is why T didn't have these methods why why why we didn't have these methods for ters they are immutable so you can't extend you can't happen so when you extend what would happen it's going to create a new tuper actually you can do that but like this for example you have tle a which is 1 comma 2 and suppose you have Tuple B 3A 4 if you want to combine them how would you do tle a plus tle b okay that concatenates this operator is overloaded for T PS okay so list are mutable so you can do all all of these things let's look at few other examples too okay okay there's an interesting part here Lisa mutable that that that we understand but how how this lists are actually stored in the memory for example suppose you have a list LST sorry Apple how do you think it's stored in the memory so you have three elements but these elements are actually not stored in the list itself they actually in the memory 0 one apple uh but do you have the pointers to those lists to sorry to those elements so actually you can modify these values without changing changing the list itself because the list actually points to this part the container so in this example you have list A and B but the list B actually contains list a okay since list a is IM mutable you can go and change it so here first you print list list A and B but you're going to change list A's zero element okay after changing the element the list a becomes PR with its first element changed to okay fine what do you think the list B would be okay let's print it contains the 88 right the modified value why because list B actually had a pointer to list a which again had pointers to other elements and we modified this value to 88 so you are still accessing list B okay the pointers are not changed that we can see here in the second example the problem of aliasing so we have list X and we call it by list y as well and we are now changing the list y sorry we are changing the list X but it's going to affect list X as well as list y see because it's just a reference the actual object is this you can call it by two different names it doesn't matter but the actual object is here that's where we need this operator so if you just point okay for example we had list X if you just assign list y to list X it's not going to copy the elements just going to copy the reference which means list X and list y both will be pointing to the same object if you want to copy these elements and put it in a new one say list Z then we need to copy one by one every element for that we can use this operator it's called Full slicing it's not it's not going to modify elements it's going to copy the whole list of element great the same line this another small example that tells you how to cost a list into Tuple and a Tuple into list so you had a tuple one for Apple zigger and you cast into list now the type is list it's very simple operation can you do that yourself how would you do it like if you want to write a function to cost how would you do that you go through element by element and add it to a tuper and concatenate two ters right so I guess you can write probably as a homework try that like try how to convert a list to a tuper without like explicitly calling the casting function okay similarly you can convert a tuple back into list so it's pretty straightforward and suppose you are getting a input from the user as a tuper then suppose you want to make it a list you don't have to write your function you can just call the this casting operator right so it'll be like uh it will save some time okay great let's go through the dictionaries now so we so we have the third data type dictionaries oh you didn't get the second one so we have another data type dictionaries and why do we need dictionaries in the first place do we need another data type can we like just get away with tup list yes because you can actually make a list sorry make a dictionary out of list and R Grimson Professor Grimson went through that in the lecture uh if you want you can come and ask in the office of us but first try whether you can do that yourself but the problem is actually not not just the dictionaries but other high level data structures are actually available in python as like buil-in data structures or as classes just because like they will have these methods on these data structures implemented so it would save some time for us plus those methods are guaranteed to be like state of art for example if you want to go through all the list then the search function or the lookup function that you write may may not be like that efficient right but they might use those efficient algorithms in the standard implementation so it's why you should always like look for the standard data types if you can't you can like uh write usf1 but it's good to use the available data types so that like they will have these efficient methods implemented okay so in this list uh sorry dictionary we have like two elements one is key one is value okay so these Keys actually have a special property what is that the keys should be an immutable object you can't so you can actually have a tle as a key you can have a string as a key but not a list as a key so you need an immutable object for the case what about the values they can be in values can be even a dictionary it can be a list but the keys must be mutable do these Keys need to be like uh unique yes no okay the problem is this dictionaries have the same uh type type I mean same structure this is a key and this key points to a place in the memory suppose you call it key a okay if you assign another value to key a that will actually replace the content in the memory right so that's why keys are going to be unique it's by Construction by by the construction of the dictionary the keys are going to be unique because you have to if you want to assign something different You Have To Call It by a different key Call It by a different name say [Applause] keyb what about the values they do they need to be unique no of course otherwise no use of key no use of dictionaries right what is the order of the item stored in the dictionary can you give a guarantee like in list in list items are stored from zero to the length right length minus one actually what about dictionaries actually you can't Guaranty the order but you can modify the order okay so thing is first if you look at this example first we have the staff uh dictionary and and when I print the length it gives me three fine then I'm I'm like doing few things first I uh I changed the address by calling its key and dictionary is are mutable so you can change the values then also we are adding a new element fine if you want add a new element you call it by the key that you want to assign if the key already exist it will just modify the value otherwise it will create a new key and add the value you can also check whether this particular element is in the dictionary but this must be the key whatever you are calling here should be the key not the value it won't search for the value we'll search only for the key presence of a particular key because you access the values through Keys again here if it is not in the list actually I'm adding an element okay in a okay to compare in the list suppose I have a list 0 comma 1 comma 2 if I want to check whether one is in the list how would I check do we have to go through element by Element no that's a shortcut if one and list right if I want to check whether one is not in the list if I want to negate this I would write if one not in list we just ignore the verbs it's pretty much like English okay we just remove the verbs okay in the dictionary we do the same thing through keys if ta a in okay I'll call it say D1 okay and you actually call or you search for the keys not the values okay there's an interesting part here if you want to modify the order actually I told you that the order C earlier we couldn't guarantee the order right it was not the order we typed because it starts with hamian because we added at the end actually right so actually you can't guarantee the order but we can sort it but how do we sort it we call the keys and we sort the keys because remember every values if you want to access a particular value you access it through key actually if you call the dictionary it doesn't know where these values are T to go to the key to access the value so if you want to do something on the dictionary itself you can do that only on keys so if you want to S the dictionary you sld it by keys so you call the keys function sorry it's method for the dictionary so it Returns the list of uh methods list of sorry keys and you s them okay this is called chaining method so I I have chained the methods I have read like two methods right I call Keys this first part actually returns you list of keys then you sort them yes it doesn't look like they oh on this let's see oops okay let's see okay oops okay now they sort it okay what was the problem what was the problem there why it wasn't sorted do it in two lines sorry you have to like call up the keys and then sort it in a separate line um okay it's bit the problem is B uh in the logic you actually when you call this function method you're actually sorting the keys return by this method you not actually going to sort the dictionary itself you're sorting only the list that was returned right the list of keys although the dictionary is mutable it wasn't sorted do you see the problem so that's why when I called keys equal to staff. keys I'm getting a list of keys then I'm sorting the that list and I'm printing that list but if you want to go through if you want to like go in a particular order or if you want to access the dictionary in a particular order what could you do is you could do something like ke is equal to st. keys then you can start Keys then for K in Keys you can go and iterate now right so you can say print K and St K okay so you can do this but actually the python provides a way through iterate both keys and value pairs that you do by calling both both elements over the methed items the items return a list of key value pairs if you call D1 do items you get a list of key value pairs you see that and we are going to iterate through individual elements so first we start with this second this okay so there's a simpler way to access every elements in the dictionary great okay now we are the interesting part [Applause] recursion okay what's the principle behind recursion anyone oh what's the idea of precaution yes cause itself basees a lot Mone yes uh the the idea of retion is if you have a problem try to express the problem in a simpler version of the same problem so if you want to find say factorial n try to express it in terms of factorial n minus one so you could keep that keep on doing this till you come to say factorial one for which you know the explicit answer right so you try to express the problem in in its simpler form it'll be useful like in in many uh cases actually in your next p you'll have the problem but be mindful what's what like makes it U possible for you to use the equation only if you can express in terms of the simpler version otherwise you can't this is probably quite like the induction you might have studied mathematical induction ction I don't know whether you stud in high school but it's quite right okay so there are two parts in recursion the first one is the base case so for a factorial problem we can express the factorial say n factorial as n to n -1 factorial okay so this will be our recursive case so what is our recursive case suppose we want to define a function factorial n okay so what will be our recursive case no I'm I'm I'm asking the recursive function what will be that n into factorial n minus one right and you just return this what be a base case if a n is equal 0 we know factorial of 0 is 1 right what is factorial of why okay but why in this program we didn't have that particular line why we didn't have n = 1 why we didn't have that it will always go zero right because you can express one in terms of zero as well right so you don't need to actually write this explicitly why because your recursive function only depends on it previous value so you need only one value in advance which means you need only one value for your base case but so you I mean you can understand this program right I'm not going to go through that but anyway like when you write a program always check its base case so you have to start with factorial zero for this case okay and check one by one then you would know whether the program is running correctly or not so always start with the simp case but remember in Fibonacci series okay for Fibonacci series can you give me the uh can you give me the recursive function yes what is Fibonacci series okay yeah that's good so return say F of nus 1 + f of nus 2 what is the Fibonacci series you start from zero add you add these elements so one you add last two elements two you add last two elements three you add last two elements right okay so you add last two elements so for if you want to find F of n you return F of n minus one and plus F of n minus 2 but here since you have like two elements or you need to access two two previous elements you need to Define your base case accordingly so for your base case f of0 is what actually that depends on whether you start here or here okay you could do this I'll go through an interesting uh recursive example okay it's called recursive exponentiation so actually you can do an exponentiation through recursive multiplication suppose you want to find 3 to the power say 10 then how would you do that you start by like expressing it in terms of its simpler version right so it'll be 3 into 10 ^ 9 sorry 3^ 9 okay so if you want to find the N power of number M you would say m into m the^ n minus1 okay so now you have your recursive case what is the base case yes if n is equal to Z in Python you would test this by okay two equal signs if n is equal to Z then what return one okay why we have only one base case here sorry yes and because you're accessing only one previous El right unlike Fibonacci series similarly if you want to multiply something okay here what we did is like we replace this operator by recursively using this operator okay can you do the multiplication by recursive addition so can you do can you replace this operator by this operator yes so how would you do this for example say 3 into five so how would you do it here tell what be this 3 + * 4 3 * 4 here come on okay simple right I'm insulting you okay what's the base case that is interest interesting what is the base case if n is equal to zero okay if n is equal to Z there I mean that is zero but that's fine but there's another problem the problem is you don't know whether these values are positive or negative so you can't just keep on adding like this this will work if it's positive but if it's negative actually you to check which is sort of tricky it's just if you want to use the same recursive function otherwise you could have like had a if condition here if say n is less than greater than zero do this okay else if you multiply n by minus one you negate that so it be it becomes positive and do it the same way way and then like reverse the answer right so you could do that but if you want to do it in the same recursive case then you have to follow this if you have any questions come to the office of us okay on that the final question is final example is the Hanoi example okay this very interesting so here we have three towers Source Target and buffer suppose you have like three discs you want to move them from source to Target and you can always have a smaller disc on top of a bigger disc then how would you move okay so can you express this problem in its simpler version so now you have three diss you want want to move them to Target so can you express it in a simpler version come on just in plain English how would you do that without looking at the program because python is very verbal so if you read the program you get it in English so any ideas okay we have to anyway move the last disc to taret right but that's the hardest part so before doing that you have to like move this somewhere else so let's move it to buffer done how would you move this now you can move it to Target okay now what you do okay sorry yeah okay okay now what would you do you can only move this to the buffer right not the target okay so we made some mistake earlier remember the problem is because we didn't think recursively okay let's think recursively Source Target buffer so suppose we have only one dis then you can simply move to Target okay so our condition is if there's only one dis just move it to the Target so if n is equal to 1 we always move from move source to Target okay suppose you have two then what would you do you move the top one to buffer okay so move source to B offer then you move the next disc from source to Target so now it's source to Target and finally you move it from the buffer right now we have a very nice recursive case if you have two we move from source to buffer then source to Target then from buffer DET tet so if you look at this example I'm checking if n is equal to one if it is one just I'm moving the s from source to Target if it is greater than n what would I do and the first assert statement is just there to make sure n is greater than zero otherwise like it's meaningless right you you need to have this you can't have like negative discs okay so what would be the next step if you don't have uh if you have more than one dis suppose you have two disc then what what would you do you move the top disc or whatever on the top to the buffer for this simple example it was just one dis but suppose you had more disc on on top of the last disc so you would have moved all of them to buffer you don't have to worry how you move it but you had to move it anyway okay after moving that you can leisurely move this big disc to the top to the Target sorry okay finally you you bring back all of them here right okay for your first operation for your first operation from source to Target you had to move all of them right the bulk you could have used Target as your buffer okay so that's why in the in this line I'm using source as Source but the second argument which should have been the target is now buffer because my current Target is buffer for the top n minus one disc but my buffer is not the target okay because I can use the target as buffer for that movement then I moved from source to Target the last big disc okay for that I can use buffer as my buffer okay then finally I bring back from buffer to Target using source as my buffer okay so the thing is if you want to handle a recursive problem you can do it in two ways one thing you can start like start thinking like how to express this problem in it simpler version like how we thought about the Fibonacci series for instance or as you can start from its base case the most fundamental situation so here it's n equal to 1 but this doesn't give you enough context so you go to the next level n is equal two and you have the answer right