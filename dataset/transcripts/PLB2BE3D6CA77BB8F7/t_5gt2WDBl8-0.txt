the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu okay I want to remind you that there's a quiz one week from today um yeah I know it's soon uh open book open Notes no Comm no Computing or communication devices allowed um between now and then uh probably uh tomorrow in fact or at least over the weekend I'll send out a summary of what I think we've covered so far and what you'll be responsible for in the quiz roughly speaking it's anything covered in lectures problem sets or recitations uh I'll also post some practice questions that you can work on and I I'll tell you now that we will not be posting answers to the practice questions uh instead we'll be holding some quiz reviews okay um couple of I wanted to cover two different topics today the first topic is just a tiny bit on floating Point numbers uh in Python but in fact what I'm going to tell you is true about all programming languages uh in fact all computers really and then after that we'll spend most of the lecture on the topic of uh debugging so let me start with a quick review of binary numbers because you have to understand binary numbers to understand floating point so when you first learned learned about numbers you learned about base 10 and you learned that a decimal number is represented by some combination of the digits 0 through 9 the rightmost place is the 10 to the zero place and then it's the 10 to the one place the 10 to the two Place Etc um so for example the number 302 or the digits 302 represent 3 * 100 plus 0 * 10 plus 2 * 1 the all right binary numbers are exactly the same except we only have two digits to choose from typically written as zero and one and everything is represented by a sequence of those digits the rightmost place is 2 to the 0o the next place is two to the 1 2 to the 2 2 to the 3 2 to the 4 Etc so for example example if we look at the binary number 101 we see that's equal to 1 * 4 + 0 * 2 + 1 * 1 or five so one of the first things we'll notice is binary numbers take a lot more digits to represent them or take more digits than decimal numbers in fact if I give you n digits n binary digits how many different binary numbers can I represent with those n digits well if I gave you in decimal digits how many different numbers can I represent how many different values can I represent n pardon 10 the n so for a binary number it's going to be 2 n 2 to the N that's important because we'll see as we get to talking about the complexity of various algorithms how long they take to run or how much space they use we'll frequently be resorting to arguments of this sort to understand them now the reason floating Point numbers cause problems for programmers is that people have learned to think in base 10 computers do everything in base two and that causes a cognitive diss dissonance sometimes where people are thinking one thing and the computer is doing something slightly different so why do people work in base 10 I don't know maybe because we have 10 fingers but we also have 10 toes so why didn't we work in base 20 um you know we have one head I don't know why but we do it we work in base 10 I do know why computers work in base 2 and that's because it's easy to build switches in electronic Hardware a switch is some physical device that has only two possible positions on or off we can build very efficient switches in hardware and so it's easy to represent a number as a sequence of on and off bits switches either on or off originally they were relay then they became transistors now they're something alog together different but all what they all had in common was they were stable in the off position they were stable in the on position and they never had to get in between hence we represent everything in computers in binary so now let's think about why that causes some confusion and it does only for fractional numbers so for whole numbers binary and decimal it doesn't matter inths are never confusing they sort of do what you know God told us integers should do or whoever toess integers all right but now let's look at other things so I want to start by looking at the decimal number 0.125 what's that is a fraction by the way happens to be one what 1 18 okay we'll see why that actually matters in a minute so what does it mean in some sense in decimal it's equal to 1 time 10-1 + 2 * 10- 2 plus 5 * 10us 3 so it works exactly the same way that things work on the other side of in this case the decimal point suppose we want to represent it in binary so instead of a decimal point we have a binary Point what does it look like then well it's equal to what one times if it's 1/8 what's it going to be 1 * what 10us 3 or [Music] 0.01 right so so far so good not much difference between the two now let's take a different decimal number what about the decimal 0.1 I have to tell you that it's a decimal because could also be a binary with just zeros and ones well we know how to represent that in decimal how about in binary what's the equivalent you know that's one10 of course what does on10th look like in binary any tapers well I'll give you a hint it's so long that I don't want to write it on the board in fact it's worse than long it's infinite I guess that's kind of long it's this repeating binary fraction there is no finite combination of binary digits that represent the decimal fraction 1110th there's no way to do it and that's why things get a little hairy so we can stop at some finite number of bits and in fact that's what happens in the internal representation in Python it ends up representing 1/10th as something equivalent to this decimal fraction if I take the number of binary bits that are inside the computer and then I translate it back to decimal it turns out that it's using this approximation for the decimal fraction 1110th so for example some of you in your problem set where you were Computing how much you had to pay on a credit card would get answers that were eventually off by a penny or something from what we expected in some and that has to do with the fact that you were thinking in decimal and in fact you were writing your program in decimal yet internally things were happening in binary and when you thought you were writing on10th for example you were actually getting something like this inside the computer pretty close to 1110th but not exactly on10th now when we print it we get yet something else because the print statement uses an internal function that by default rounds these things to 17 digits and so you end up getting something like that or you might depending how you do it so let's look at an example here so I can do something like this and it prints that because it's doing some rounding for me but if I really look at what's under there and look at the representation the re function is Con venient to get a sense of what's really going on in inside it tells me that well that's its best 17 digigit approximation and now so that's what's really lurking there so a hint if you think something is going funny because of the way arithmetic is working uh instead of just using print you can use print of re to see to get a better idea aidea about what's really going on all right now does this matter usually it doesn't most of the time it's safe just to pretend that floating points work the way you learned about arithmetic when you were in third grade or probably in kindergarten if you were educated in Europe or Asia but now let's look at an example um where you can get in trouble so I've got a little program here I initialize X to Zero then I'm going to go through a loop a lot of times where I increment X by a tenth and then I'm going to print X and because it's going to do automatic rounding it's going to print uh 10,000 or actually it should print 100,000 right no 10,000 because I'm only incrementing it by a tenth excuse me but then I'm going to print rpr of X and then I'm going to do a comparison now if floating Point arithmetic work the way reals work we would think that 10.0 * X should equal the number of iterations because I'm starting at zero each time I'm incrementing it by a tenth and so if I multiply the result by 10 at the end I should get the same as the number of iterations does that make sense to everybody that that's what you would normally get if you did this with pencil and paper of course it would take you a really long time to do 100,000 increments let's give it a shot and what we'll see is that if I print it it looks okay it's a th000 but if I print rapr of it I see it's it's not sorry it's 10,000 a bunch of zeros and then 18848 and of course consequently when I compare it I get something that says false and that's because if I look at re of 10.0 times X well that's interesting what's going on here it kind of looks like the same thing doesn't it but it's not because way out there at some other digits we're not seeing something different is happening okay what's the moral of this it's not complicated it's not okay write your programs thinking deeply about what's going on and those bits sway out there at the end it's don't ever test whether two floating numbers are equal to each other instead do something like this to find a a function called cloth or whatever you want that takes two floats and some Epsilon and I've given here Epsilon a default value and then just return whether the absolute value of xus y is less than Epsilon so whenever you're comparing two floating numbers the question is shouldn't be are they identical but are they close enough for your purposes and if you do that then you don't get tripped up by this kind of rounding and things like that not a complicated story but keeping this in mind will get you out of trouble when you're doing floating Point arithmetic let's run this and see what happens and indeed they're not equal but they're good enough close enough if you will okay one of the dangers the reason this went wrong is these little differences can accumulate if you go through a lot of iterations sometimes they balance out sometimes it rounds up sometimes it rounds down but not always so very simple answer just don't get caught up in this problem of uh floating Point numbers all right any questions about that all right yes you know the must have been changed or 5 2.7 it's only returning 0.1 and not 0.1 2.7 yeah don't know sorry um but the moral Remains the Same whatever is going on don't test floating Point numbers for equality because you'll have a high probability of getting false when you should get true okay you almost never get true when you should get get false all right I now want to move on if there no more questions to debugging um I never know when to give this lecture in the term so what I usually do is I wait until the volume of email and complaints and office hours bills and I realized people are ready to learn more about debugging if I do it too early people don't pay any attention because they don't realize it's a problem and if I do it too late they get irritated with me because they say well why didn't you tell me this earlier in the semester when it would have done me some good so I pick a time and right now it looks like the uh the need has built up enough that it's worth doing there's a very Charming Ur urban legend about how the process of fixing flaws in software came to be known as debugging it's one of those stories that's so nice that you just want it to be true so let's look at the the story cuz it's fun all right what you see on the screen now is a photo of a book now at this Smithsonian Museum of the lab book from the group working in the mark 2 aen relay computer at Harvard University pardon oh I see it on my screen now you see it on your screen thank you so there it is uh it was September the 9th um yeah 1947 even before I was born that was that long ago uh and so you can see that they're running their computer and they've started to do an arct tan computation and it's kind of interesting that they started it at 10:00 or 8:00 in the morning and it ran for 2 hours and then it stopped wow to do an arc tan tells you something about how fast this computer was then it went on then they started the coign tape and uh started to do a multiple adder and then something bad happened um it stopped working whoops all right hold on a second and they spent a long time trying to find out why it stopped working and then they found out the problem they found a moth stuck between two one of the relays so it had mechan electromechanical relays for their switches the on and off and they were debugging maybe they didn't call it debugging and they found the software had failed because the hardware had failed and the hardware had failed because a bug had been stuck in one of the real life they debugged it as in removed the the moth and the program ran to successful completion and as you can see the comment was written in this book first actual case of a bug being found hence we call it debugging um this was by the way Grace Murray Hopper lab book um she is often described as the first programmer uh that's unclear if that's true what is true is she was the first female Admiral in the US Navy she was a Navy programmer who eventually Rose to the rank of Admiral um so it's a Charming story that this is why we call it debugging turns out it's not at all true that the phrase debugging had been used for a long time um and could easily be traced back to the 1800s when people were writing books about electronics and talking about debugging even in those days uh and in fact you can go back to Shakespeare who talks about a bug bear meaning something causing needless exercise or needless excessive fear or anxiety well that's a good description of a bug all right and he actually called it a bug when he had Hamlet Ketch about bugs and goblins in my life all right so I want to start now oh by the way just for fun this is what the mark 2 looked like this was the computer that took an hour or so to do an arc tan uh you can see it filled maybe it's a little hard to see in this light but you can see it filled an entire room uh quite quite amazing and uh here's a picture of Admiral Hopper and some some unidentified male all right if anyone knows who this is it would be good to know so I can update my archives all right so now on on to some practical aspects of debugging the first thing I want to do is dispel some myth about debugging there is this myth that bugs crawl unbidden into our programs that we write perfect programs and somehow be a bug just sneaks in and and and ruins Perfection that's not true in fact if there's a bug in your program you put it there so it would be almost better not to call it a bug which sort of sounds like it's not our fault but it's a mistake it's a grew up so get that through your head similarly bugs do not breed in programs if there are multiple bugs in your program it's not because a couple of them got together and procreated it's because you made a lot of mistakes um keep that in mind with that in mind we should think about what the goal of debugging and it's not to eliminate one bug quickly it is to move towards a bug-free program and I say this because they're not always the same strategy that you would follow for these different goals and I also carefully say to move towards a bug-free program because in truth be told we are hardly ever sure that we have no bugs left debugging is a learn skill don't despair Nobody Does It Well instinctively right Evolution did not train us to be debuggers uh so a large part probably the largest part in many ways of learning to be a good programmer is learning to debug and what that has to do is thinking systematically and efficiently about how to move towards a bug free program the good news is it's not hard to learn uh and it is a largely transferable skill the same skills you use to debug software can be used to debug laboratory experiments uh I actually give lectures sometimes to Physicians about how to debug patients how to use debugging techniques to find out what's wrong with people when they're sick it it's a very good and useful life skill now for four decades maybe five decades people have been building tools called debuggers and you'll find that built into Idol there is a debugger that are designed to help people find out why their programs don't work and fix them um personally I almost never use it one um the tools are not that important what's important is the skill of the Craftsman in this case and in fact most of the experienced programmers I know rely on print statements so it's okay to use the debugger but I think the best debugging tool is print and I have to say I've been surprised that's a mild word here at how few print statements you guys seem to use I I get these emails or the staff gets these emails kind of plaintiff why doesn't my program work you know and then there's a little piece of code and the answer I send back when I reply before one of the Tas do and they usually get there first is usually put in a print statement here and see what happens and I'm just amazed that when the code arrives it doesn't have these statements in it um my favorite response was I sent an email to a student who shall go nameless and he or maybe it was a she and I said insert a print statement here and see what happens and I got back a reply saying no I don't don't need a print statement here I know what the value of this variable is well you know my reply was that if all the values were what you thought they were you wouldn't be sending an email saying why doesn't my program work put the darn print statement in and see what happens and then I got a gracious email back saying more or less whoops I see uh but please you know when you send us some code and you want some help send us code with some print statements already in it to at least show us that you've tried to find the bug yourself all right so what we're essentially doing when we insert print statements in a code is searching for the place in our program where things have gone arai and the key to being a good debugger is to be systematic in this search so you saw that when we looked at algorithms for things like exhaustive enumeration we said well if we're so searching for an answer we have to search the space carefully one at a time then we said if we want to search it efficiently maybe instead of starting at the beginning and just going to the end we should use something like binary search the same techniques can be used when you're searching for a bugs so I recommend searching for bugs using some approximation to binary search and we'll see an example of this as we go forward but as we look at the example what I want you to think about is what are we searching for but we know our program doesn't work so the question that I like to ask is not Why didn't it produce the answer I wanted it to but how could it have done what it have done this is a subtly different question and it's an usually a much easier question to answer not Why didn't it do the right thing but here it did something so I already know what it did and I say I didn't expect it to do that so why did it do that once I know why it did what it did it's usually pretty easy to think how to fix it so that's the first question I ask I then go about it using something akin to the scientific method which we all learned about many years ago and basically the scientific method is based upon studying available data the data you have is of course the program text itself the test results you ran some test and got the wrong answer which is why you knew you had a bug and then you can probe it you can change the test results by using print statements so that you have more data to study keep in mind that you don't understand this program because if you did it would work once I study this I form a hypothesis that at least I think is consistent with the data and then I go and design and run a repeatable experiment and I want to emphasiz the word repeatable here and again the key thing as with the scientific method the experiment to be useful must have the potential to refute the hypothesis why might repeatability be an issue well as we'll see pretty soon a lot of programs involve randomness where you're doing something equivalent to flipping a coin somewhere in the program which might come up heads or tails and the program would do different things we'll see why that's an important programming technique soon and once you do that you can get different results with different runs um more subtly uh there can be various kinds of timing errors deep down in the operating system where you have multiple activ activities going on at the same time this is usually the reason that you'll see say windows crash or word or PowerPoint or something else because there's some timing error that occurs sometimes and probably most commonly because there's human input somebody types something and they might type something different so one of the things you want to do when you're systematic is make sure that you can replay things and we'll talk more about this when we get to Randomness about how we go about doing that all right now let's try and put this all together in a little program um if you've been studying your handout as at least one of the Tas did uh you've been kind of mystified by the fact that there's a pretty crummy looking program in it and unlike sometimes when I make mistakes I don't know I've made here I intentionally made some mistakes so let's look at the program I wrote a function called is palindrome that takes in a list and is intended to R return true if the list is a palindrome and false otherwise then I've wrote this little program called silly that uses his pal takes in a number requests that the user repeat that many or in make that many inputs then calls isal to find out whether or not the resultant list is a palindrome not too complicated but now let's run it we'll do silly of five and it tells me ABCDE is a palindrome all right I have a bug now I need to go try and find that bug so the first thing I need to think about when I'm looking for it is to try and find a smaller piece of input that will produce the bug so I want to find small input on which program fails why do I want to find a smaller input well a in this case it's less typing B if it's a real program it's probably less execution time to make it run but C it'll be easier to debug cuz those fewer kinds of problems so let me try it on a small piece of input say silly of one oh doesn't gets that right so that's no good let me try something else let's try silly of two I'm sort of sneaking up gets that one wrong all right so I know I can test it on a small input so that's a good thing I now have a simple test now in this case the code is so short and so stupid that you could probably look at it with your eyes and just find the bug instantly but the point of this exercise is not to find the bug but to kind of show the process so now I want to go through this process of binary search to try and find the bug so we'll start was silly the top level program and I'll look for something about halfway through maybe here and try and now answer the question that I've got a lot of code and I'm going to find a point halfway through it and try and ask is the bug above this or below this so I need to find some intermediate value I can check and at this point in the program the only thing I have done is accumulate the input right so there's no nothing else to ask so my hypothesis is that everything is good and that the input will be AB so let's try it let's print result here and well actually yeah print result here every time through and see if we get what we wanted to get huh all right that's not what I expected so something is wrong what's wrong why is result always the empty list I can out wait you yeah because um whenever it goes through and keeps com back right so every time through the for for loop it's re reinitializing got for those of you who are watching on TV I just hit a person who was heads down with a can piece of candy fortunately it was not a hard candy all right so you're right let's get that out of there put it where it belongs run it again uh okay are we happy with that result yeah because I've done that before the append right and now just to be sure we'll take this print statement out here and let's put it here we're now searching elsewhere well the good news is I now have the right result for the value of the variable but the wrong result for the program it's still telling me it's a Pome so the moral here is there is no such thing as the bug never use the definitive article there is a buug I I there's a story that uh I've heard related to this you know as far as finding a bug you can imagine that you're at someone's house for dinner you're sitting at the dining room table you can't see the kitchen and suddenly you hear from the kitchen what the heck's that well your Hostess walks out and says don't worry I just killed the Cockroach on the turkey well your immediate reaction is the Cockroach on the turkey where there's one there's likely to be more every time you find a bug the more bugs you find the probably the more bugs you are still left because you've shown that you make a lot of mistakes all right onward we go so what do we do next well we now know at least that things look okay to this point which suggests that the problem must come below this in the program well the only only thing that's going on below this is the call to is pal so now we'll say okay we've now isolated the bug to is pal that's a good thing let's try and ask where things are going on there so we'll take a point halfway through is pal and we'll print some things here so let's print uh see what we have here but before I do that I've gotten really tired of typing A and B so I'm going to use something called a test driver or a test harness and I recommend that you do this kind of thing whenever you're testing a program write some code that has nothing to do with the program itself but makes it easier to test and debug the program the pretentious word for this is a test harness all this is is code that helps testing one of the things that you see in industry is about half the code that gets written is not intended to be delivered as part of the final product but is there merely for the purpose of testing and debugging it's a big deal so don't feel bad that you're writing code that's not part of the solution to the problem set that is there only to help you make your code work it seems like it's extra work but in fact it will save you work so let's call it we'll call is pal and it's going to print some things that I think it should do in fact we'll look at what it does first before we look at the print statements in is pal so for the moment let me just comment these out and what we see here is it should print false and it prints true well print should it print false the second time no right so it should have printed true and it did so this is an important lesson make sure that when you put in these debugging statements you write down as part of the print statement what you expected to print so that when you look at your output you can quickly scan it and see whether the program is behaving as you thought it would so now Works once doesn't work the other time so we'll go back and turn on the print statements up here and see what we get so it's printed temp is 121 and X is 121 so kind of okay that print and X are the same we expected that but we thought we reversed it right we've entered one two one and it is this what's going on what's wrong well now what we can do is let's see where it went wrong we'll put in another print statement here see what value is there there well it was one 12 one before reverse and it's one 121 after reverse how come why isn't reverse reversing temp yeah parentheses after reverse exactly I need parentheses after reverse whoa close because without the parenthesis all all reverse is doing is nothing that's just the name of the method not an invocation of the method right all right now let's run it um good news and bad news what's the good news it has indeed reversed one two right to make it but it's also reversed X so naturally since it's reversed X temp and X will be the same and I get the wrong answer what's wrong now yeah so it's I think your aliasing I'm aliasing and it's reversing because now remember how M mutation works now temp and X both point to the same object if I reverse the object doesn't matter whether I get to it through X or I get through it through temp it will still have been reversed so in this case what I need to do is this clone it and now when I run my code it works no applause all right uh couple more things about debugging next Tuesday and then we'll move on to uh some pretty interesting topics in the next phase of the course