the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu so um you guys have been talking about graphs in lecture right so so what are graphs wow boring all right so graphs are a kind of formalism they have they have vertices and edges all right a set of vertices is you can think of it it's like a set of things and then the edges are the relationships between those things so like the set of all your friendships and your friends friendships could be considered a graph so like if this is me and this is all two of my friends then an edge between us would indicate a relationship of of friendship but there's no edge here so there's no friendship between these two so yeah so you have vertices which are also called nodes and then you have edges and they could also be called arcs so if you see either uh any of these names they're all you know these two are the same and these two are the same okay so what kind kind of graphs do we have so there's a direct directive graph and there's an undirected graph so up on the screen here is a directed graph right and so I'm not a sports fan I think that's those are the Bruins and I don't know what the other team is you know okay yeah it's I think it's a hockey team somewhere up in Montreal so this is a representation or a graph representation of cities which are the nodes and vertices and then the roads that connect the cities and obviously it's not to scale or accurate but uh it's an abstraction so we're okay with that and the question here is like what's the path to get from Boston to Montreal right so in this case it's a directive graph so that means that we can only go this direction from node to node in the direction of the arrow so really there's only one way to go right two hops so for so that's a directed graph and then an undirected graph is basically the same thing except we can go either direction on the edges right so on the directed graph on the previous in the previous uh slide you could only go in this direction so you had to make two hops in order to get to Montreal in this uh undirected graph you can just make one hop to get to Montreal so really conceptually very easy can you have yeah so and actually we'll we we can we'll see that in the code so the question was is can I have like New York here and then Boston here can I have this sort of relationship right and the the answer is yeah this is actually just equivalent to an undirected graph right you can have a directed where some cases have that yeah so you could have like and we actually have actually I think this might have an example of that so yeah so in this case you have Hartford has a path to Albany and back and a path to New York City but there's no path directly back to Hartford that that work for you what's that um well then I won't insult Harford then um I didn't do these SL these these these graphs so uh I don't I'm not I if I had done them I certainly would have wouldn't have used sports teams because I know next to nothing about sports um so I don't know the rationale behind picking the names other than I'm I'm supposed to say that the reason why the Bruins want to go to Montreal is because they want to kick Canada's butt they did did they already oh well then this is a very Appo slide then um so what we have up here is a is a weighted graph right so we we the the undirected and directed graphs have been really easy so far because they're just defining you know the fact that there is a relationship that exists between two vertices right so what a weighted graph does though is it says that not only is there a relationship between these these two entities these vertices but it also has maybe a cost associated with it so if these represent the no Road networks then these represent kind of the toll costs the the the weights on these edges so it's saying that in order to get the Heartford it I need to pay a dollar and then to get the Albany I need to pay $3 and then they get to Montreal to pay $6 so a common question you know uh on you know weighted grass in general is what's the least cost path from here to here so can anyone tell me yeah what the least cost is from Boston to Montreal it's Harford is your only choice right then New York then right so and the cost for that is nine right CU you got one 7 one some nine um there are actually two paths to get from Boston to Montreal the other path is from Boston Hartford Albany Montreal but the cost of that path is 10 so the the question is um you know how do you figure out which path is shortest right so did he talk about breadth first search and depth first search at all he's only talked about depth first he only talked about depth first okay so we need to do bread first so before we do breadth first can someone Define depth first for me and maybe walk me through it a little bit so let's take this off the screen and let's assume that I have a very simple graph I'm going to start here I want to end here and I have and so I'm starting at v0 and I want to get to V8 I have it's a let's call this as a directed graph so it can only go One Direction it also doesn't have any Cycles so that makes it a little easier so if I'm starting here in depth first search what what do I do pick a daughter pick a daughter so you pick pick one of your children so you're going to pick V1 or V4 now you go to this this node what do you do now pick a daughter same thing again so you pick another daughter and because this is a really trivial example we just walk down the line until you get until you find the node that you're looking for or if you don't find it and you have no more there's no more there are no more children to to to look at then you you know there's no path that exists but we can get to our goal node here right so what do we do once we find this node we save it off somewhere like it it becomes a path with just itself and then we return that to who or and then we say okay well where did I come from while I came from V7 so now my shortest I know that my shortest path from uh V7 to V8 is going to be V7 V8 and then I'm back here I'm going to add wherever I came from here so the idea is that I I grow my shortest paths backwards right um and actually the shortest is the top one here so is if you had a branch on V7 when you go back to V7 would you check the next Branch so yeah so if I had something like this and the answer would be let's say that it loops around right so now we have a cycle so it becomes interesting so let's say that I've reached my goal here and I've I know that if I'm at my goal then my shortest path is just my goal right so now I return here and I say well what would be my shortest path in this case um Can does this child have a shortest path so what when I'm standing when I get here first to V7 I I asked the question what's the shortest path to V8 from either of my two children so I'm going to look at all the children of V7 and I'm going to find what's the shortest path from V8 or from this node to the end node and then from this node to the end node and obviously this one's the shortest because it is the end node so now I know that my shortest path is the This plus myself all right and so that means that the shortest path from V6 to the end node is going to be this path plus this right and I don't know if that's getting getting any clear so really if we start out at the beginning here we're looking at this first known we ask the question what's the shortest path from V1 to the end and what's the shortest path from V4 to the end and we choose the shortest shortest of those two paths as our answer and we just add ourselves to the beginning and that's all we do for each of these nodes we ask of it of the children at each of these nodes what's the shortest path and then we add ourselves to the beginning of that path and return that as our answer so if we were to look at that in code so you guys have all seen the graph object in class with the node and edges yes or no okay so here is shortest path depth first right so there's a lot of debugging code here but and some administrative stuff so all this is doing is just making sure that the nodes we're looking for are in the in the graph and actually let me backtrack so when we first call shortest path we're going to call it with a graph object and a start and an end node right and we're also going to have this parameter visited which keeps track of the nodes that we've already seen and we'll get to that in a second so the one of the first things that we do that's of any importance is we check to make sure that the start and end nodes are actually in the graph because you can't get from one to the other if they don't exist right and then we're going to construct a path or a list that just contains the start node as its element and then we're going to check to see if start is equal to end so if we're already at our goal then the shortest path is just us right we don't have to go anywhere what's that uh for comparison purposes I mean you you if you look at the definition of node it's pretty it's pretty sparse or pretty Spartan like if we wanted to make it so that you know we just added the node object itself we'd have to add like an underbar underbar equal method stuff like that and in this case we're we we don't want to bother with kind of complicating what like that so if we're not at the end though now we need to figure out what the shortest path is from each of our children to the gold mode right so we have a variable that we call shortest and that's going to keep track of what our shortest path so far is and then we're going to iterate through all the children in this node and if the node is not inv visited and that's where this parameter comes in um we're we're going to say okay well let's take a look at it and then we're going to say we're going to add it to visited so we know that we visited this known kind of sounds kind of cyclic but which is funny because we have visited so that we avoid Cycles right um because so if we've if we've already visited a node and we figured out what its shortest path is why would we want to visit it again like say you know this if we're on a path and we're saying let's say I have I'm trying to figure out the shortest path from V1 to V4 and I'm using depth first and so I decide I'm depth first first goes to V2 then to V3 now it's got two choices on which nodes to get the shortest path for for let's say for some reason it you know it when it gets the list of children it's going to get V1 and V4 and if it's looking at V1 before it looks at V4 then if we didn't have that check in there just make sure that we are not visiting or looking at other notes that we've already visited then the algorithm would just go here and it would repeat itself in a cycle like that so that's what that visit par is doing this it's preventing that cyclic check or cyclic checking so now we ask the question or we make a recursive call to shortest path right and the only parameter that changes is no is the start node we're going to say and we're going to ask it what's the shortest path from this node to the end and it's going to do you know call itself again and return an answer and if it doesn't return anything then we're just going to kind of ignore it and continue but if it returns something and either we haven't found a shortest path yet or the length of this new path that it's found is shorter than the shortest path that we've already found then we're going to record it and say that this is our new shortest path here and then we're just going to keep iterating through all the children of the know until we've exhausted all possibilities and then once we break once we finish going through all the children we're going to say if we found a shortest path that means that there exists a path from one of its children to the goal node then we're going to add it to our existing path which is just ourself so we're adding ourselves to the beginning of the shortest path that it found then we return it so it's kind of growing the shortest path from the back to the front right breath for search works in the opposite direction so the way that well first is anyone confused by depth first search I kind of hit it what that so this line here this is well this if statement first is checking to see that we've got that one of our children has a shortest path it's like if it's possible that none of our none of our possible children lead to the goal known so like let's say that I have another kind of subgraph on here all right when I when V2 is my start node I'm still going to check these two children but and let's say that my goal node is to get to V8 right well I'm still going to check the short to see what the shortest path is from both of these children well once I use this as my start node there's obviously no path to the actual goal node so the depth for search call or the the call the shortest path is going to return none in this case and we need to check that so that's what that bit of code is doing there is that if we it's saying if there is a shortest path then we're going to just add ourselves to the front of that shortest path and return that as our answer but if there is no shortest path from us from one of our children from any of our any of the children on the start node to the gold node then we're just going to return none as our answer because we can't get to the gold node from where we are right did that work for you okay so want we take a look at how this is working so we're going to try DFS on an undirected graph and the code that does this is called test two here and all it does is it creates a graph with 10 notes and and in this case it's going to be an undirected graph and we're going to create a bunch of edges so is the that that diagram you sent out the is yeah so is that the representation the code from lecture okay so it only uses five so we have this graph and what we're going to do is use depth first search to compute shortest path from here to here so this is showing kind of the recur the depth of the recursion right so we start off on node zero and then we then it starts looking for the shortest path from 1 to 4 and at the same depth it's going to try and find the shortest path from two to four so it starts out here and then it try it asks what's the shortest path from 1 to four and then what's the shortest path from two to four and so when it's looking at one now it's going to ask what's the shortest path from I want to do that hey sorry okay is there a bug in your cone is there so this is this is all is this the lecture code okay none of this is mine I didn't bre first search this is this is the first yeah because it seems like it's checking node zero twice it didn't do that on M so it's going from oh no because there's a directed Edge from one2 Z right yeah so what it's doing what the code does is it says um it say it does a depth first so first it looks at node zero and then it goes for child in right for all the children nodes what's the first child of node zero it's node one oh because zero hasn't been added to the visited list right and then and then it asks what are all the children of of well no the print statement comes before it discovers that checking node zero is a invalid path I didn't add I I forgot to add another print statement if you go to the code okay so where we at yeah so see how I have the very first at the top of the function see how there's the if to print I say that but then there's this check here if it's not inv visited if it is inv visited there's no print statement that says that says that you know it's that yeah so basically What's happen is we when we do that second check where we end up finding the second path from0 to four right it ends up hitting that test that says we've already visited node zero so we don't continue that I got it okay that was just a little there was no print statements in the code before and I was having a really hard time figuring it out and I did this and this made it a lot more clear I thought to try and figure out how the depth search was working no I think so too it's just maybe we should add a couple extra yeah no I agree I didn't I didn't I sorry I was just I was perplexed because I like uh oh um so it's working correctly but is there anyone is there any confusion on depth first search in spite of that okay so let's start on bre first search so you guys cover you guys covered depth for search in lecture so we need to do breath resarch okay so the idea behind breath first search is that instead of asking the question what's the shortest path from V1 to V4 and adding ourselves to the front of that to get the shortest path we're going to build the path from the start outward or from the start forward so in this case we're building the path from the goal backward in this case we're going to say we're going to say I'm at v0 so my current partial path is V 0 right then I'm going to ask I'm going to look at V1 and V4 and so I'm going to have and I'm going to say now this is my list of partial paths to the goal and then for V1 I'm going to say I'm going to ask what its neighbors are and we have V2 and then for V4 we're going to ask the same question so now we're building our partial paths all right so conceptually what we're doing is we're just you know we're we're maintaining a list of all the all the paths that we' or all the history of nodes or paths that we've uh been looking at and just kind of growing that one by one by one so if we look at this in code shortest path BFS has a slightly different call Signature than the DFS um method so we still get a graph and then we get this variable called paths and what path contains is the partial path or a list of the partial Paths of tupal so the format of this is each element has a list of the nodes in the path and then the length of that uh particular um path so we also have the goal known and what we do the first thing that happens is this pass gets shorted or sorted so so it's sorted by the length of the path so is anyone puzzled by this lampda here yeah okay so when you call the sorted function and you pass it a list you can also pass it this key parameter this key parameter is a function that takes um it takes a uh an object and it'll return kind of the the value of associated with that object so in this case each of these paths contain each of the elements in paths contains a tuple and what this key function does is it says each element in this path is has got a value that is equal to the length of that path and this length perimeter that's just the uh that's the second element in the Tuple right so when sorted does its work it's going to call this key function on each element in path and what this function has to do is return you know the the value associated with that particular element I don't that Mak is lamb just a keyword that oh Lambda is what's known as an anonymous function and he covered that in lecture at one point yeah so he did he just use Lambda he sort of blew past it and said this is something called Lambda oh okay well since I'm your ta and I'm here so real briefly Lambda is a way of kind of doing really simple F not really simple functions but it's a way of creating Anonymous functions so let's say that I want to create a function that squares a number right this is exactly well not exactly but it's equivalent to this right I can use G as a function just as easily as I can use H so that's all and it's useful for situations where you have you have elements that aren't EXA that aren't def don't have a order defined so like sorted needs to know a value of an element in order to put it in order in order to do the Sorting right so that's what this function does is it gives each element in that list of value so that the Sorting can do its its job so so the the key that we want to sort on or the the item that we want to sort on is the length of the path and the reason why we want to do that is we're going to take the first partial path that exists in our PA in our in our paths and for every node in the shortest or for every node in the um for every child of the last node in this path we're going we want to check to see if it's the goal and if it's not then we're going to append it we're going to append a new partial path which is the path that we're looking at plus it one of the children nodes and then the length of the path to this value called New Paths so it's it's it's saying this node that I'm looking at so I guess let's say that this is my partial path what it's doing is it's looking at this last node in this path and it's saying what are all the children of this node and if none of the CH none of the children are the goal node then it's going to create a new set of path that in that are uh composed of this path plus all the children so if2 also went like right would it the new no um so we should probably get rid of this the reason why Breet first search has its name is that it doesn't try to it doesn't keep go toward try to go towards the end immediately it it grows gradually so if you can kind of Envision a graph like this death first works by going by proceeding down until it finds the goal node for each of the possible paths right what breath first search does is it starts at a node and then it builds all the paths from that node and then for each of these it builds the paths so that's what I'm saying when they there when I say partial paths so it just a new parti path yeah it's a it's a new partial path so so it would be V V1 V2 the next MH so let's so let's say this is v0 V1 V2 let's say that I have this partial path already all right when I build a new partial when I'm looking at this path which is what I'm doing when I pop it off the front of the list of pass that I already have I'm going to look at all its children so I'm going to look at these two nodes right here and then I'm going to say let's say that my goal node is here and then I'm going to say that you know these aren't my goal nodes so I'm going to create new partial paths and one of them is going to be v z v0 V1 V2 and V4 so I already have that and the other partial path is going to be v0 V1 V2 and V5 just find every single um what's that every single possible path until you reach the goal node so with depth for a search you do have to uh well no not even with death bir search um there's some interesting properties about the different searches but we just want you to be familiar with kind of how they go about doing their task so the idea is the idea is that you know we start off with a partial path of just this guy and then we find all the other partial paths so it'll start off with just this guy as its list of paths so one element and then it's going to then it's going to pop this off the front it's going to say okay I'm looking at this partial path what are the additional paths that I can build off of this and I can build four additional paths off of this so now I have set of four paths that I want to look at and then it takes a look at say this you know this partial path of v0 V1 and says what are the paths that I can build off of this and then it adds it to the end and then it says what are the paths that I can build off of this guy adds those to the end what are the paths that I can add get from this guy adds those to the end and so on and so forth yeah so you you you keep track of all the pths right yeah oh okay is that what you meant okay yeah you hit a node and there's another possible thing but if you don't no if there's some path somewhere else in the gra and it doesn't ever like reach a that goes to that yeah just doesn't well for yeah know I mean there it is possible for breath res search to go find nodes that don't have that don't reach the goal but what's going to happen in those cases is they're they're going to they're just like so let's say that there's such a path at the front of this paths list and it doesn't you know if you it doesn't have any children so it's like the it's a you can't go anywhere after you've gotten to this node then what's going to happen is this for Loop's not going to execute right because it has no children and so it's just going to be discarded as a possibility so I mean the the the the the key thing is that you're you're generating these new partial paths for every node that you're looking at and you're adding those to a list or a cue of thing of partial paths that you need to examine in the future if you don't find your goal if you do find a partial path that has a child that is the goal then you can just immediately return that path cuz you know it's going going to be the shortest path in this case so I don't know unless you find H what if you find so what happens when you find two pars that um well then it it depends on which one appears first in your list so you you're you're asking like if I have let's do something really simple if I have so at some point you're going to have a partial path right here that cons or list of partial path that consists of v0 V1 and then v0 and V2 whichever path you ultimately wind up returning is going to be you know dependent on whether or not this one comes first in your list of P partial pass to check or this one comes first and you list a partial pass to check so that kind of answer it yeah okay so is everyone good on breath first search conceptually say code kind of fxing anyone you know if you reach if you if when you're building uh yeah if you're building your partial path and one of your CH one and you so you've popped off this path that you're examining and you look at all this children and one of the children is the goal known then you know that you found the shortest path right because um you've been building this incrementally you know one by one by one and then if you've found this the gold node then you know that you know you already built up the shortest path possible because if you had found the gold if the gold node had been on a shorter path before you would have found it already SC well that if the paths are weighted them it's a little different because then you're not because here we're just doing shortest path what you're talking about is doing like a least cost path in which case you would you know the the main difference would be this how it sorts it's list of candidate pass right it would say when it yeah I mean what yeah so in this case our our Lambda function is saying that we're going to sort these lists based on their length but if I wanted to say sort them based on the sum of their weights then I would have a function that you know sums up the weights on that path and uh uses that in the storting in order to select the next partial path that's to Surge although in that case you'd actually have toate every single possible path sure you find the lowest cost path um no because doesn't I might understand this is that you you you you find you find all the paths of length one from the starting point you find all the paths of length two right and so if you're worried about cost it's possible in principle that your longest path your longest path is your lowest cost path but you not sorting It by L then right although but but what he's saying is that because you're growing it by one each time then it's possible that let's say that I have a you know I have partial pass of length to but my my least cost path is actually of length five then even if one of these nodes reaches like say that V2 reaches the goal before the the actual leaste cost path then you can't stop you can't stop you do have to enumerate through all well you just sort it by cost I think that it's a better example to say that if you have one partial path that has cost seven well actually wait no you're actually right because if you sort it by cost then your least cost path is going to be in front all in front of your Q not true I don't think that's true because imagine this imagine you had a graph that was like this is your start node this is your end node and you go like this this this this and so you make a breath first where you go to this Noe and this note and the cost of this is one and the cost of this is eight right the cost of this is 20 and the cost of this is one mhm this is your shortest path or this is your cheapest path but when you add them they're both of length one so you explore this one first because it's the cheapest right at at a cost of one but the total cost is 21 to continue from this node the total cost from that node right but so I think he's right right you I I thought you had to expand all nodes when you're doing breath first that's why you do like DTR yeah so but yeah for weights you have to expand all of them right so yeah possibly Poss okay I you know I'm blanking on this on the answer so but in this case we're not we don't have to enumerate all path so with the with the you're just looking for the shortest path you can just find the shortest path right but if you if you incorporate cost and you do have you would use a different algorithm so it would be like actually shortest path or something like that all right so why don't we just run this so is like one better than the other or um they have different running characteristics it really depends on your application um the nice thing about death first search is that you it's fairly memory efficient because with Brett first search you're storing all the possible paths all the possible um uh partial paths with depth for search you only have one path in memory at any given point right you have the path you have the path that you've already found from one of your children to the end node plus one but with the uh bre first search you're going to have a list of all the partial paths that you have to search through so so let's see this does not make sense I don't think it matches the picture yeah 04 is a path right yeah no it's not matching the picture what's that that that you undirected is what was undirected yeah it was an undirected graph that's why so so let's you know if we run it direct let's see what happens 0 to four is still yeah you are absolutely right oh you know what's going on it's running both it's running the depth for search no it's running both the directed and the undirected well it's also running the depth first search as well that's that that was my question because I was looking at this and I was like that's not breath first search that's step first search this on the other hand is breath first sech so there there we go so if we have a graph and let's see so it start it starts off with node zero and then it's a it builds a a new list of partial paths with 0 one 02 so it's got in this case this partial path and then this partial path and then it expands one of them so in this case I guess 01 was the the uh path that was first and the list right so it's going to expand the children of one which is just two and itself but it's going to avoid Cycles what's thator oh yeah and then expand and then it's going to expand this partial path the 02 because it's the shortest one and it's going to add that new partial path to the end and then it's going to expand this guy and add the expansion here and then it's going to expand this guy and it turns out that there is that the you know one of the children of three is four so it's found the path the shortest path from 0 to four make sense so so why does it say 0 2 that's the representation in the in the path list so each element in the path is represent each element in the paths list uh is represented as a tupal the first element is the list of nodes on that path and then the second element is the length of that path so and that's why we had that Lambda function in the first place right so if you read the specification here you have path length and then you have the nodes that are on that path and when we sort this PA the path list because we need to you know make sure that we're looking at the shortest path then we use this uh this Lambda function in order to get that length for each Tuple