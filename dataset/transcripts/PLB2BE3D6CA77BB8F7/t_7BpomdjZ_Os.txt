the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu so we're going to pick up where we left off last Friday on recursion and we're going to well first of all uh can anyone tell me what recursion is or what a recursive function is no one knows okay okay it's it's a divide and conquer technique um how does it do it like it's recursive function return function value right so it's a it's a function that calls itself and it works by one identifying a base case which is the smallest sub problem that it uh possible and then uh in the other case the recursive case it tries to chunk the problem down into a smaller uh into smaller sub problem that it then solves by calling itself so um so we went over a few examples and uh one of the things that we wanted to uh talk about is that uh for many problems a recursive function can be written iteratively and or actually for most problems um so there usually is some sort of a subjective choice in how to write a function and it really comes down to ease of understanding in so what we've done is we've uh taken a couple of the algorithms that we showed last week and we've written them iteratively and we also have the recursive version and we'll kind of compare uh and contrast and kind of see where we would want to use a recursive function so on the screen on the left here we have the uh multiplication version the recursive multiplication that we uh showed last week it's a little different because um turns out there's a couple of simplifications you can make but um did anyone well can someone walk me through how this works so what's my base case first zero right and so obviously when n is zero we're going to you know if we multiply by zero then our result is zero now there are two recursive cases and not really sure how to explain this intuitively but let's say that my n is positive right so I'm multiplying by positive n well then all I'm going to do is take M and just add it to a recurs the recursive version of itself n minus one times it's kind of how to read that right and then analogously if n is less than or equal to one then I'm going to take negative M and add the recursive result of n +1 * m it is not too intuitive right so if we implement it iteratively though I think it's a little easier to understand now this is also a subjective judgment so you might disagree you're free to um here's our base case again n is equal to Z or M is equal to Z return zero in this case though if we don't have the base case then we're going to initialize a result variable and then for n is uh greater than or equal to one we're just going to enter a while loop and keep adding M to result n times a little bit easier to understand I think than the recursive version and then same thing for well I have a bug here same thing for n is less than equal toga 1 all right so I'm going to run the two versions of this function all right so here's a recursive version and here the version they both return the same exact thing they both work in generally the same manner it's just that in one case we're using recursion to solve it which I don't I don't find too intuitive and the other case we're using while Loops all right so in this case in my opinion writing this iteratively it makes a little bit more intuitive sense but in other cases let's say go to Old Fibonacci we can write the recursive version and then the iterative version all right so here's recursive Fibonacci we have our base case or cases and then we have recursive case right you can almost rewrite the mathematical formula from this directly all right now why is it so here's the iterative version of Fibonacci what we still have our base case all right but when we get to what was the recursive case we have to do a lot of bookkeeping we have to save off of the previous Fibonacci what we're currently computing and then we have to iterate you know get the next Fibonacci and then save off the prior versions of it this is all stuff that in the recursive version gets done for us by virtue of just calling another function so this is an example of a case where your recursive version is actually um a little bit easier to understand doesn't mean that it's more efficient and later on in the class we'll you actually use this to talk about uh uh complexity but the left version I think is easier to understand than the right version are there any disagreements if you disagree I'm not going to bite you um so anyway we can run this and we can see that the output's identical all right xange X range um probably something I shouldn't have put in there X range xrange is like range um except that it returns what's known as an a generator object that you can iterate over so so that I don't have to explain that right now we'll actually we'll probably talk about it later uh in the semester the difference is efficiency um Range will return an entire list to you um whereas X range is a little bit more conservative in how it uh manages its memory for uh these purposes but it you know changing it doesn't won't make a difference in the program and for this for program as simple as this range is perfectly fine um I just use x- range out of habit um so we do one last example and then we'll move on to a different topic um if I didn't mention it before uh in problem set 4 recursion is highly recommended for the final portion of it so it's kind of important you understand what's going on anyway so remember we had uh we looked at bsection early on in the semester and we showed you an iterative version of bsection right this shouldn't really be unfamiliar to anyone at this point so all this is doing is is finding the square root of a number using bisection search right and we set our low and our high get our midpoint and we just keep looping until we get uh a value that when we Square it is close enough to X and on each iteration we set our low and our highs right depending on how good our guess was now the recursive version looks like this it has a few more lines of code um and before I launch into it um did we explain default parameters to you for functions so all right python has this uh feature where if you have a function such as Rec bicep section search you can specify that certain parameters are optional or you can give default uh values to them so let's just show a simple example so I can get past this so so if I Define this function this one's really easy all it's going to do is print out X I can call it like this in which case it's going to pass 150 in and X will be 150 when the function is executing see I'm not lying or I can call it like this and it'll give it'll be 100 right so that's in a nutshell what default parameters do for you they're useful in some instances as in this example so in this recursive version of bisection sort or square root sorry we have a low and a high parameter that we specify it's exactly equivalent to the low and a high parameter in the cative version all right and all we're saying is that if we're calling it for the first time this is a common idiom for recursive functions in Python um if we're calling it for the first time we're not going to specify in a low and a high so low and high will be none coming into this function and then we just set them as we did in this iterative version and then we set the midpoint and then we have slightly different structure here if the midpoint that we guess is close enough to uh the square root of x then we just return the midpoint on the other hand if it's too low of a guess then we're going to recursively call ourselves with with the same X same Epsilon but we're going to use midpoint for the low parameter so midpoint in this Cas is here and the same high parameter all right and then if we've guessed too high then our low parameter is low and then our high parameter is the midpoint so it's doing the exact same thing as the iterative version we have recursive iterative recursive iterative same just different forms all right before I leave recursion does anyone have any questions or want to ask anything or complain no all right you use a lot of recursion in your work like do you normally go use iter or recursion is it just Case by case it's Case by case it it depends on the problem um and what we were trying to show here is that um there are some problems that are better expressed recursively and others that are better expressed iteratively um and by better it's a very subjective term it's uh in my mind it means more intuitive easier to understand uh it allows you to focus on solving the problem rather than filling with code um on the other hand sometimes efficiency comes into play and we'll talk about we're going to be talking about that pretty shortly and in that case you might want to do a recursive version because it's easier to understand but it takes too long to run so you write an intive version so it's a computer programming in a lot of cases actually in all cases is is a bunch of tradeoffs you know oftentimes you'll trade off speed for memory um Elegance for efficiency uh that sort of thing and uh part of the skill of becoming a good computer programmer is figuring out where those Balance points are so and it's it's something that I think only comes with experience all right so we've talked about floating point I think to death but we just want to really emphasize it because it's something that even for experienc programers still trips us up um so the thing that we want you to understand is that floating point is inexact so you can't you shouldn't compare for exact equality so looking at the code here I have to find a variable 10 hunds which which is just 10 over 100 and 100 which is just 1 over 100 and then 900s which it's 9 over 100 and so in real math this condition would be true I add 100 one 100th and 9 hunds I should get 10 hundreds so if we were not dealing in computer land this would print out but because we are dealing in computer land we get that all right and the reason is is because of Python's representation now when you write print x if x is a float variable python does a little bit of nice formatting for you it kind of saves you from its internal representation and but you can look at so here is 101 100s as you would just print it out it's just it it's what you would expect it to be but this is what python sees when it does its math all right and it's not just python this applies for anything on a on a b computer it's an inherent limitation and you know we can get we we can get arbitrarily close but never exact um and then again if we have one 100 and 900s python will show us 0.1 so when you print these out they look fine you know if you were doing de if you writing debugging code and you were wondering why if you compared X to Y it wasn't exactly equal you know you would naturally print out X and then print out y but it would look equal to you but you know the code wouldn't be working properly right well the reason is is that the internal representation that python is using to compare them is that so what's the solution it's an actual question I don't know the answer close right so we're going to do we're going to we're going to say good enough right and the traditional way of representing that is Epsilon Epsilon we've we've you know you've seen it in your problem sets and you've seen it in code before and if you've come to office hours someone's probably explained it to you um Epsilon is the amount of error we're willing to tolerate in our calculations so uh in Python land you can I think have arbitrary Precision um don't quote me on that though but for purposes of this class if you're using an Epsilon that's like 0.01 it's we're not going to get too upset um all this function does and this is a handy function to keep around is it just tests to see if the distance between X and Y are less than Epsilon if it is then we say they're close enough to each other to be considered equal so I don't like the function name compare I don't think it's intuitive close enough is probably better but it's also going to break my code so uhoh this is an actual bug l23 what do I do to myself I commented out my definitions that's what I did all right so if we compare the two values 10 hundreds and 100 plus 900s and we use our close enough our compare function then yeah it's within Epsilon um again notice here that we're using a default parameter so if we don't pass in something explicitly so I can say something like this um let's make Epsilon really tiny so if I make epon really really tiny then it's going to say no so um how you determine Epsilon really determines uh really depends on your specific application um if you're doing High Precision mathematics or you're you're modeling like faults on a on a bridge or something probably want to be pretty precise um because if you have the wrong Epsilon then you know you might have cars falling off the bridge or the bridge collapsing and it would just be a bad day um so is there any are there any questions so far about floating point no go as close as the ER what's it you can't get as close as you want um how can you make the error that that small how can I is not going to get that close well yeah that's what I mean so there is a limit to how how close you can get um and it depends it depends on the language and it also depends on the hardware uh there are and this is getting a little bit more technical than I want but um you can Define pretty precisely the smallest value that Epsilon can be um in a language like uh C it's defined as the minimum difference between uh or the minimum difference between uh two floating Point variables um that's representable on the post machines Hardware so yeah there is a limit uh there's some math packages though and we'll be using uh something called numpy uh later on in the semester that allow you to do pretty high Precision mathematics so just you know keep that in the back of your mind but yeah you're right you do you do eventually hit a limit okay so the last thing that I wanted to cover on floating point is um that even though it's uh inexact it's consistent so uh let's say I Define a variable 900s plus 100th and it's exactly what it says 900s plus 100th now we know that this is not going to equal you know 10 hunds right we' we've just demonstrated that at nauseum also yeah I'm still Define the question though is If I subtract 100th from this variable that I've defined this 900s plus 100th can I compare will uh 900s now be equal to 900s plus 100 so in other words will this be true and the answer is yes and the reason is that if I'm just if I'm adding or I'm subtracting even though 100th we know is an inexact representation it's still the same and so when we do the subtraction we're subtracting the same inexact value so um this appeared as a quiz question at one point probably won this semester but you know it's something to keep in mind so any questions on floating point if you want to if you're if you're mathy type and you want to look up i e 754 and this will give you all the Gory details about representation and mathematical operations on floating point and if you don't then don't worry about it it's not required for the class okay so the next topic we want to cover is pseudo code so can someone take a stab at defining pseudo code for me um from what I gathered uh it's basically like you're just kind of writing out what you're planing on doing in like just normal English uh I wouldn't say just normal English but it's an English of sorts so the idea is that um and a lot of the difficulty that uh programmers have with writing programs or new programs as that um we don't naturally think in computer languages uh you you think in English and or well you think in a human language so what pseudo code allows us to do is to kind of be in in the in immediate right we we still want to develop kind of a step-by-step process for solving a problem but we want to be able to describe it in words uh and not variables and and and you know syntax which uh sometimes what'll happen is programmers will get so wrapped around kind of getting the syntax right that they'll forget what they're actually the problem that they're actually trying to solve so let's kind of walk through an example um let's let's talk about pseudo code for hangman and because you've all done this on the problem set um I don't have to explain the rules right so what would be a good kind of English first step for hangman choose choose right so let's not be too specific we'll just say select random word okay now what would be another good step Next Step um uh display um display the amount of letter like the amount of spaces maybe like so display like a masked version of the word yeah exactly like hide the word could display it hide the word but display it yeah like dis you probably want to State how many letters are in the word something oh that's a good point where should that go that should probably be before the display okay so uh tell how many letters all right now what would come after this after display um how many letters you have to choose from okay first time first time you don't but you know the nice thing about pseudo code is that we can kind of barf things onto paper and then rearrange them as we it's sort of like brainstorming in a sense right you know you you're you're trying to derive the structure easier to do like this than to um try and do it in code so but yeah you're right you don't have to so I guess you would ask the person to input a letter okay for letter and then what would come after that um so you want to check if it's yeah check check if it's in the word all right and if it is if it is add it to the word add let's say two correct letters guess yeah okay and if it isn't if it isn't um project it say like you know um oh let's say you want to remove it from the um so the options so if it's not then we're going to remove from options so letters remaining probably want to tell the user they're wrong too yeah and use up what's that you want to use up sorry oh yeah yeah if you have like a set amount of turns okay so we're actually going to get to that I I set really high I actually played all of your hangman games that's was quite fun so so again yeah you're right so we have a number of guesses that are remaining and the thing is is that we know that the user has a certain number of terms so we're probably going to repeat repat a lot of this right so at some point we probably want to have a while and we'll just say while you know we have guesses left remaining by the way the reason why I program computers is because my handwriting is horrible so while we have guesses remaining we're going to keep doing all this all right and then we're going to remove what is this the only stopping criteria what if they win so while they have guesses remaining and the word is not guessed so this is an Essence your hangman program it's English language it's not easy to read because that's my handwriting but it's kind of easy to understand it an intuitive level all right so and the thing the reason why we're talking about this is because we're going to get to some more complicated programs as we uh move through the semester um and a good starting off point for a lot of you when you're trying to do your problem sets is you know instead of trying to jump right into the the coding portion of it to sit down with a piece of paper index cards or a whiteboard and kind of sketch out a highle view of the algorithm all right and so that we can see this in kind of code form so let's say that I want to write a function that tests number to see if it's Prime first question is what is a prime number factors are one right so yeah a number that is uh only divisible by itself in one um are even numbers prime can they ever be prime really what about two right so two is one of our special cases all right so what would be maybe a good starting off point for pseudo code to test primality knowing those facts all right so can I erase this or should I leave it up because I can go over there all right it's not like I'm erasing any deep dark secrets there's no magic here all right so test number uh if what equal to equal to say what two yeah why not and maybe three um now what do I do if it is are they Prime so I'm done right so I'm going to return true now what do I do if it's not if the number given is not two or three you're talking about the module operator right so yeah we we will use that that um will tell us whether or not a an integer divides evenly into another integer or the remainder after an integer is divided into another integer but um well let me ask another question what is the maximum value of an integer divisor for a non-prime number so for a composite number what's that okay excluding the number itself um well let's say that I have n is the number I'm testing square root of n because I'm not going to have a factor that's larger than that right so and I asked that because there's a loop involved so how would I do about go about this systematically well i' probably start at let's say five right okay and then test if n modulo let's say five is equal to zero now if n is evenly divisible by five then that must mean that n is composite right because five is a factor so if it is then return false okay now what if it isn't that means that n is not evenly divisible by five does that mean that the number is automatically Prime so what's it after five what would be a good number to test to move to all right six no yeah that wouldn't be it right because if it's divisible or if it's uh if six is a factor then obviously it's not well yeah whatever um so we're going to move on to seven right so basically we're going to test all the OD numbers and this is going to be the same as that so this repetition indicates here that I probably need a loop right so instead of doing this I'm going to say I'm going to say x is equal to while X is less than we're going to test if x evenly divides n and if it does return false and if it doesn't then we just increment X and repeat all right and what happens when X becomes greater than TK of n well the while Loop's going to stop and that also means that if I've made it to that point then I've not found any numbers between you know five andun of n that will evenly divide n so that means that and S Prime so if I translate this into code it would look something like this now I see so first we're going to check if n is less than or equal to three if it's two or three then we'll return true if it's not two or three then that means it's one or zero right so return false so we've got those cases and then we're going to iterate or if n is greater than three we're going to iterate now why would you go from two I don't know we're going to iterate through all the possible divisors and check for uh divisibility and if we evenly divide it return false and if we make it through the loop we return true it yes because well think about what return is doing you're in this function test primality right and as soon as python sees return it that's telling python to kick out of the function and return whatever is after the return statement so this false here you know it says return false that means that doesn't matter where you are it's just going to kick out of the innermost function or the function that encloses that return and return that value any questions all right so so testing primality one is false two is true three is true four is false false and five is true so it looks like the program works and if no one has any questions I'm G to move on to the last major topic all right everyone's good on pseudo code all right want expl folks pronounce words when they're speaking foreign languages a lot easier for people to digest with debugging what are bugs mistakes mistakes and if you have many if you see one bug there are probably many more right all right so when you're debugging your goal is not to move quickly this is uh an instance where where the maximum fastest slow and slowest fast comes into play um you want to be very deliberate and systematic when you're trying to debug code uh you want to ask the question why your code is doing what it does and remember the first recitation I said um that your program or your computer is not going to do anything that you do not tell it to do uh it's not something that people uh do naturally like if you watch some of the Tas and you know sometimes a student will say how do you how do you find the bug so quickly well it's because I've been programming for 18 years um Professor guog has been programming for longer than that so a lot of it is experience and it's just you know when we've debugged our own programs and when we were learning to program it was a it was as painful for us as it was for you so that's said um you want to start with asking how could your code have produced the co the output that it did and then you want to figure out some experiments that are repeatable uh that and that you have an idea of what the output should be so after you do that then you want to kind of test your code one by one on these different uh test cas basis and see what it does and in order to see what it does you can use a print statement so when you think you found a bug and you think you have a solution in your code you want to make as few changes as possible at a time because as you're making Corrections you can still introduce bugs right um let's see a useful so a useful way to do this is to use a test harness so when we actually grade your problem sets a lot of the time the Tas will put together uh a set of uh test cases for your code um so one of the things is a lot of the times when you get a one of the problems or when you look at the problems it'll have some example input and output but that doesn't necessarily mean that we only test on that there's additional test cases that we use and it's not to trip you up it's just because there's a lot of different variations um and it's also if you read the specification and you follow the specification then you'll be fine but moving on so let's look at an example I have a function here is palindrome all right I think you've seen this before right yes yeah okay so it's supposed to return true if string s is a palindrome and so I've written this function and I've also written a test harness now there's a lot more code in the test harness but it's pretty simple code um I'm going to uh think of when when you're writing functions you want to think of uh the type of input you could receive and you want to think of what are kind of the boundary cases so the extremes of that you can get we call these boundary cases edge cases uh for the is paland drum function it would be like the empty string would be one or just a single character right these you know these are U kind of the minimum we could have or we could think of on the opposite of the spectrum we can have an in well theoretically we could have an infinitely long string so we're not going to actually test for an infinitely long long string so anyway all we're going to do is in our test harness we're just going to run the function on these inputs and we know that an empty string should be true we know that A Single Character string should be true we know that you know if I have a string that's two characters long and they're the same character that should be true if they're two characters and it should be false and what I'm going to do now now is I'm looking at kind of expected what we call expected input so after I've hit my edge cases I'm going to look at all the strings of an even length and make sure that the function works properly and then I'm going to look at strings with an odd length and then once I get to this point where I've tested uh you know a number of different lengths and in this case it's just 2 through five or uh 0 through five if you want to include the edge cases then I'm going to say well it looks like all tests are passed and I think that this function works pretty good for anything we can expect it to encounter reasonably so what the way that you kind of use test harnesses is you want to every time you make a change to your program you want to run the test harness because that'll catch any bugs you may have introduced and so I'm going to finish up with this really quickly because I know uh it's my time's up um so I got a bug right it's telling me that one of my test cases failed so line 299 which is this test case so what we can do is now that we know that fails we can say maybe print out our input and see what we have and instead of just running I'm just going to run that one test case that failed okay so obviously this should be true and what we're seeing is that on the first call to is palindrome SS Abba and then on the recursive call to it we only get BBA right that means that we've only chopped off the front character right so you see the bug well here right so here we go