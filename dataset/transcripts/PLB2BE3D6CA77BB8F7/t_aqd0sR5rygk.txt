the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit mitop courseware at ocw.mit.edu good morning everybody um we're on the home stretch here only two more lectures no more recitation in a small matter of a final exam um I should remind you the final exam is on Monday of finals week and it will be a two-hour exam not a three-hour exam um same kind of format as on the first two quizzes open book open Notes the difference is we'll be giving you some code which we'll be posting today uh which we're going to ask you to study in preparation for the exam and then uh we'll ask you some questions about that code for example ask you to make a small modification to it on the exam and in fact today's lecture just as a special incentive to pay attention will be about things related to the code we'll be posting for you to study for the exam um it covers one final class of simulation we haven't looked at at all this term but I think is important to at least know a little bit about it and those are queuing network stimulations from the time of conception until death human beings find themselves all too often waiting for things waiting for events waiting for conditions waiting for TAS Etc uh queuing networks give us a formal way to study systems in which waiting plays a fundamental role some typical examples might be uh in a supermarket waiting to check out you get in a queue wait your turn uh computers all the time uh um you may wonder sometimes why when you hit your computer and ask it to do something sometimes it's fast sometimes it's slow well it's because there are task running in the background that are ahead of your task and a queue and you're waiting for them to finish uh computer networks uh waiting for arrivals and things like that if you look at the internal structure of the internet as say an email hops from hither to Yan between two sites along the way way it enters cues and waits for its turn to get forwarded to the next top um a few of you have experience this when you go to office hours where there's a wait for ta and you get in a queue um public transit uh analysis of Highway systems all of these things depend upon understanding cues to understand how they work um you might wonder why we have cues uh the answer is pretty simple in that it typically makes economic sense as we'll see in our analysis uh when resources are limited particularly say servers it makes economic sense to have jobs line up for service so if you think about a supermarket I ideally when you go to check out you'd like there to be no line but think about how many cash registers they would need to ensure that all the time when someone was ready there was no line uh and the problem is if they did that they would have idle servers and so they would not get very good resource utilization of the people they would be hiring to do the checkout in designing a system with cues and that's what the simulations help us do uh we're aiming for a balance between essentially customer service and resource utilization the organization paying for the resources would like them to be working a 100% of the time at full capacity so there's no wasted expense on the other hand it's easy to show in any reasonable system that if you have 100% resource utilization you're going to be providing terrible customer service there is a always a need for excess capacity in a complex system in order to provide adequate service most of the time and that's because as we'll see the demand for service is probabilistic and unpredictable uh and in order to observe absorb bursts of activity you need excess capacity because a lot of the time you don't see those bursts all right all that by way of introduction if we think about how to model a system with q's they're all modeled essentially the same way you start with some jobs work to be done those jobs enter a queue they wait around for a while they leave the que one at a time and enter a server and then they depart all right so that's what it looks like and of course it can be much more complicated than this uh you can have multiple streams of jobs you can have multiple cues you can have multiple servers but when we build an analysis of it when we build a simulation we typically break it down into components that look exactly like this and use that as the key as we do this we have to look at a number of different things we start with the arrival process how do the jobs appear and there are lots of questions we can ask do they arrive singly or in groups if they arrive in groups we say that it's a batch process so if you think about a service for say processing students at MIT into the database they typically arrive in a big batch in September rather than straggling in one at a time um we have to ask related to that is how arrivals are distrib distributed in time assume for the moment that arrivals are one at a time for example automobiles entering a highway um do they come uniformly at evenly space intervals uh do they come at random times if if random is there a time of day when we see most of them we typically model all of that and what's called an inter arrival time distribution the simplest process is where these things do arrive at regular intervals constant intervals we hardly ever see this in in the real world most of the time we see something that looks much like our old friend of the Pome process the things arrive at a random interval but they are typically exponentially distributed we've seen this before okay it is as you will recall memory lists it is as you will recall described by a single parameter the average arrival rate we can look at it just briefly to see what it looks like just a find ourselves really so have just a small piece of code where I've given the mean arrival and then I'm going to just have 2,000 things arrive uh at poso intervals all right why is it not running I cleverly rebooted before I got here so it shouldn't have had any problem there it is all right so that's really should be anyone remember what this calls right and so we'll see that we have exponential arrival times a rapid Decay only a small tail out at the the right in this picture and a big cluster near the mean we can look at this in a different way if you look at the scatter plot and you'll notice that we've given a mean of 60 the dark blue line but we seem to have an awful lot of points below the mean compared to a very much smaller number of points above the mean why is that in fact inevitable in this situation yeah space because there's just less space for them they can go from six to well there's less space and the reason that there's less space is we don't allow things to arrive yesterday in negative time so the smallest inter arrival time is just Epsilon more than zero so the time between jobs can never be less than zero and so if we want and we're going to have a few way out here that take a lot longer because that's the nature nature of an exponential so we're going to have to have a bunch down here to counterbalance the few way up here we can only get 60 below the mean in this case and you can see we here have over 500 above the mean so it's going to always look like that which is why the histogram looks something like this so you'll observe that as you look at these things all right that's the arrival process we also have to look at the service mechanism how does the server work again we can ask some question like um how long will it take to provide service and this is called the service time distribution this depends on two things the amount of work the job to be served entails and the speed of the server so again you've experienced this no doubt at the supermarket where if you get in the wrong line where there's a very slow person running the cash register even though the jobs are small it takes forever because there's a slow server or alternatively you've gotten behind the line not noticing that the person in front of you has two shopping carts full of junk and so even though the server is fast it will take a long time to service that job uh the number of servers certainly matters an important question is the number of cues in particular does each server have its own que which is what you see at the supermarket or is there a single que for many servers typically what you see if you are checking in say in coach class at the airport or lining up for security at the airport which of those is better do you think which provides on average better service multiple cues or a single que single Q right is much better uh in fact it's easy to construct to proof why it's better um which is why we now see them typically at places like Banks and airports didn't used to be initially people didn't understand this was better and they would have multiple cues um why don't we always have a single Q because we may not have enough space so you can again imagine at the supermarket there'd be no place to put the single Q for all of the cash registers maybe and another question we have to ask is whether or not we allow preemption in some queuing systems a server can stop processing a customer to deal with another emergency customer in others once a job is started it has to run to completion and again you get very different performance depending upon whether you allow preemption or not an important part of the architecture is of course the characteristics of the Q itself the fundamental question is the policy how from the set of customers waiting for service do we choose the customer to be served next so a very common policy is fifo stands for first in first out that's the one we see most of the time in a lot of physical situations whoever gets in line first gets served first uh there are some situations where you do last in first out who's ever arrived most recently gets served first a very popular one in many Computing applications is what's called srpt which is short for shortest remaining processing time take whichever job you can complete fastest so these are the three most popular policies you can also Imagine a random policy where you just chose some random member of the que um then there are lots of other kinds of issues which I I won't go into in detail the choice of queuing discipline as we'll see when we look at the code can have a major effect on performance in particular it can be used to reduce congestion we'll often see in practice this one now why might that be a very useful practical method well it's got one obvious feature if the available space for the Q is small by taking the ones you can finish fastest you reduce the average number of elements in the queue because you get to process more customers by taking the customers that you can process quickly and so on average there will be fewer customers in the queue and so it reduces congestion as we'll see it also improves expected service time so it's it is an excellent method when we talk about queuing networks what what we're going to see and I hope I've implied this already is that probability has to play a fundamental role in understanding them because there's Randomness there's Randomness in the inter arrival time and there's typically Randomness and how long each job will take to process what are the questions we might want to ask about a queuing system to see whether we've designed it properly an important question is the average waiting time on average how long does a job wait between the time it enters the queue and the time it leaves the queue you know imagine that you're waiting for the MIT shuttle bus how long do you wait before you get on the bus on average you can also ask once the job starts how long to complete we can also ask is the waiting time bounded so this is a different question than how long you should expect to wait on average it's what's the probability of you're not having to wait longer than some upper bound so you can imagine that if you were working for uh some company that for example sold products over the telephone you might want to put a bound on how long a customer would wait before their call got picked up and you do some analysis saying if people have to wait longer than three minutes they hang up the phone and so we'll have enough servers that on rare it's only rare that someone has to wait more than three minutes it's a different question than how long people have to wait on average we've already talked about the average Q length and by analogy we can also ask about the bound bound on Q length you can imagine if you're designing a router for the internet you need to know how much memory to allocate for the cues of jobs so that you don't run out it's not infinite so there's an upper bound on how long you'll let the the cues grow and finally along a different dimension is something we've already already talked about server utilization what is the expected utilization of each server in sense of what is the expected amount of time it will be fully occupied remember servers cost money so keeping them busy is important if we can assign relative cost values to each of these things we can then build a system that will let us do an analysis and build an optimal system decide how big the cues should be how many servers how fast they should be do the analysis and design a system that meets some optimization Criterion so now we need to investigate these things two basic methods as we've discussed before are analytic and indeed you can get books on analytic queuing Theory really thick hard to read books I might add that give you complicated formulas for deriving these kinds of things in practice they're hardly ever used because most systems are too complex to actually model analytically so in fact today most queuing Network systems are analyzed using simulations the kind of event discrete event simulations we've looked at earlier in the term all right now I want to look at a particular example and see how we can build a simulation that will let us answer these kinds of questions about a particular example the example is a and again this is the one that you'll be asked to look at is a simplification of the MIT shuttle bus system so as I'm sure you all know know it runs in a loop uh dropping picking up students and dropping them off at some number of stops for legal reasons each bus has a maximum capacity often exceeded I'm in practice but there is officially a maximum number of people allowed on a bus and it takes a certain amount of time to go around the loop um the obvious question to ask is how long should a student expect to have to wait for a bus at a particular stop to get picked up and what should MIT do to depending upon whether it's feeling benevolent or not minimize or maximize the waiting time for the bus all right most of the code we're going to look at now is on your handout um I should say I've deleted the obvious part so I I could fit it on the handout however we'll be posting the code uh on the web today a piy file that you'll be able to study and more importantly probably run it all right let's start so as usual in designing a piece of code I began with some useful classes you won't be surprised that the first class I looked at was class job uh so what is a job a job is depending upon the mean arrival and the mean work involved and I've chosen to model arrivals as exponential and I've chosen to model work as a gaussian nothing magic about this and in fact I played with various other models what would happen if the work were uniformly distributed or exponentially distributed and of course you get different answers um I said next two attributes there is actually only one attribute here and this is going to keep track of when a job enters a queue so that we can tell how long it had to wait and then there's the inter arrival the work the queue the queed time Etc all right and then I'm going to model a passenger as a job you'll note this is kind of a boring class all I've done is say pass because I'm not adding anything new uh I am giving it a different type and it gave me a place to put the comment here that the arrival rate corresponds to passengers to arriving at a bus stop and work is the time that takes a passenger to board the bus there are many other things I could have done for work I could have made it multi-dimensional having to do with how long to get on the bus how many stops etc for Simplicity I'm just assuming that there are some agile people who just get on the bus quickly and there's some people who are a little bit slower who might take a longer time to get on the bus and that's it for jobs pretty simple but pretty typical of the kinds of things we see then we come to the cu's themselves uh the root class is just the job Q uh jobs can arrive and the queue can have a length you'll note that I don't have any way for jobs to leave the queue in the base class and that's because I'm the subass that in each subass will be distinguished by the queuing discipline it's using and the queuing discipline typically has to do with how jobs leave the queue so there's a fifo discipline uh pretty simplistic it just removes the first item from the queue and returns it um raises an exception if you try and uh remove something from the queue when there's nothing there and srpt is a little bit more involved but not much I've not tried to be clever you could imagine a much more efficient implementation than the one I've got but here each time a job needs to leave the queue I just search the queue to find one of the jobs with the least amount of work and I remove that that's why I'm searching with the index here because pop lets me remove a something from a list at a particular index and then finally I have another simple class bus stop and the key thing here is what it's a subass of initially I'm choosing it to be a subclass of fifo later we'll see I could make it a subass of srpt or in fact anything else I chose but this gives me a convenient way to decide what queuing discipline I'm going to use at the bus stops so I mentioned earlier that srpt is nice because it allows us to reduce the size of the Q I also mentioned that it's typically optimal in the sense of producing the shortest average waiting time so let's think about why imagine that we do the opposite this is a good intellectual tool just think of the opposite suppose we always took the longest job first what would that do to the average waiting time if say we had a job that took 10 minutes and a queue with 10 people in it well while we were waiting for that one 10-minute job to get on the bus the other nine people would each have to wait 10 minutes nine time 10 90 minutes of waiting time not very good right now suppose each of those nine jobs only took one minute well the first job would wait zero the next job would wait 1 minute the next job would wait 2 minutes and even the longest job would only have to wait nine minutes before it started so the total amount of time spent waiting would be much less so we can see that by using shortest remaining processing time the waiting times are reduced now with the bus example it's a little bit strange in that yes you'd get on the bus but maybe the bus wouldn't move at all while it was waiting for that last person to get on but most queuing disciplines imagine you're in the supermarket uh you don't care how long the guys behind you take as soon as you get to the front you get processed you get to leave the store so in fact a supermarket would on average have happier customers if it followed shortest remaining processing time and always took whoever had the smallest the fewest number of items first why don't they do that or why is not srpt always used in practice it's got one glaring problem what's that problem it doesn't seem fair to everyone else it's not fair and this is actually a technical word people talk about fairness of aing discipline and in particular it's so unfair that it allows starvation another technical term imagine that you're the person with the 10-minute job and there's a continuing stream of people arriving with one minute jobs you never get to get your job processed at all you just sit there and you wait and you wait and you wait and in fact you wait forever in the bus situation imagine you're the person who's in a wheelchair and takes 10 minutes to get on the bus um and people keep arriving at the bus stop well before before it gets to be your turn the bus is full and it leaves you have to wait for the next bus but people arrive while you're waiting it arrives again you don't get on and you never get on this is technically called starvation and it's a problem that srpt has so typically if you're using that as your scheduling algorithm you've got to put in some sort of a priority on top of it that gives uh the the long jobs a chance to at least run once in a while and there are lots of different disciplines for doing that all right let's continue looking at the code so now we've got B bus stops which are cues we've got jobs well we're going to have our server and in this case our server is a bus uh every bus has got a capacity the number of people it's allowed to hold and a speed the speed has to do with how fast it goes from stop to stop and for Simplicity we're going to assume that this depends only on the bus itself not on the traffic not true in Cambridge and Boston of course but we can't get everything in a code that we can get through in one lecture uh so it's got a capacity it's got a speed and then we can keep track of how many people are are on the bus it's got an enter which has to do with people getting on it and it does that until it's full then it raises an exception and things can leave the bus and there's here's the interesting method unload takes a self and the number of to be unloaded from the bus and it just calls self leave over and over again all right those are our basic classes nothing too sophisticated as is often the case with classes the code is straightforward and now Comes The Not So quite straightforward code which is the actual simulation itself probably the most important thing to understand in looking at this code is the arguments this will sort of tell us what the simulation depends on so there's going to be a bus so notice we have only one bus so again I simplified the simulation instead of having a multiple buses running around the loop where you going to assume you just got to wait for that first bus to get back uh later we can talk about what would be involved in having multiple buses the number of stops in the loop the loop length and for Simplicity I'm going to assume that the stops are equally spaced along the length uh the mean arrival rate of jobs the mean work per job and then how long we're going to run the simulation roughly speaking I'm using the same units for the simulation time and the loop length so this would would tell us if we simulate for 30,000 times and the loop is this 1,200 time units long how many times around the loop we could get and how many stops the bus would make all right and then comes the body of the simulation uh so the first thing actually let me write up some pseudo code here to basically show you the way way it's structured um yeah I think we'll put it over here so the first thing we do is we create the stops and we initialize some variables that we're going to use to keep track of performance we then enter the main Loop which is essentially while time not expired that has to do with how long we're going to run this simulation we move the bus so the loop will go through one time unit each iteration at least it looks that way initially so we'll move the bus that amount of time so then while we're doing it passengers will arrive at the stops then we'll see when a bus is at a stop has it driven long enough to get to the next stop and when it's there we'll unload some passengers first and then we'll load some passengers and then when we're done at the very end we'll compute some statistics so that's the overall structure of the simulation then we can put that in something outside it that tells us how many simulations to run and get yet more statistics about aggregate all right now working our way through the code the initialization while time less than in Time advance the bus Advance time move the bus now how far we move it depends upon how fast it is so we'll just add to the Bus location however F far it's allowed to move in one time unit I don't care whether the time unit is seconds minutes hours days whatever just it has to be all consistent uh then I'll see if there's a pth passenger waiting to enter the queue by checking the arrival time and passengers can arrive simultaneously at each stop I apologize for leaving the comments out of your handouts but I couldn't squeeze it onto the page with the comments whoops then here's the interesting piece so we we do this we're just having passengers arrive based upon the characteristics of jobs see if the bus is at a stop if the Bus location divided by the inter stop distance is equal to zero so it's actually at a stop um I'll do my unloading Etc now down here you'll notice that I up here I had this assumption that the speed of the bus is small relative to the inter stop distance this assumption is important because of this statement if the bus were moving too fast it might skip over the stops now this is kind of a clumsy trick I've used here um it has to do with it being small it has to be doing with each movement of the bus being in fact an integral of the inter stop distance so that you don't skip over the stops uh in a real simulation I would have done something much more careful to deal with the not missing stops but again I wanted to make this relatively simple so I'm going to things so that the speed of the bus is evenly divides the inter stop distance so when I Advance the bus it never skips over a stop okay it's just a trick not a very elegant trick but it keeps things working all right then I'm going to unload some fraction of the passengers now again in a more realistic simulation I'd be keeping track of what's the average distance of a passenger wants to travel and I would have in fact made work two dimensionals the amount of time to get on the bus plus how far the passenger wanted to travel again here I've done something simple I've just assumed that a fraction of all the passengers get off at each stop and the fraction depends upon how many total stops there are we can still understand most of the interesting aspects of the problem even with all all these simplifications and that's an important lesson every simulation is a simplification of reality no simulation is ever a perfect model of reality no model is ever a perfect model of reality what we typically do in build a simulation is simplify it enough that we can get it to work but not so much that we can't answer the questions we want to answer and so I've made a lot of these simplifications but they will still allow us while maybe not to get precise answers about the impact of various things to understand how things relate to each other the relative impact of various design decisions all right if the bus is at a stop as I said some passengers will get on get off um passengers that are already at the stop will try and get on the bus um we'll have to advance time because time starts to run out as people are getting on the bus even though the bus is moving but of course even though time is advancing the bus is not so we have to model that that the impact of loading times and in fact in mass transit systems it turns out that loading time is a very important parameter in many Urban systems uh Subways will spend more time at stations getting loaded than between stations moving to the next one if the stations are dense you may have noticed this on the green line um so we have to make sure we model that and then of course since the bus could be at the stop for a while passengers might arrive while it's at the stop then we can keep track of the number of people left waiting when the simulation ends uh and do things like that all right finally there's this program test which I won't go over in detail it's exactly like the drivers we've written for other simulations for at least half the semester uh in which I run simbots multiple times accumulate results from trials and then plot them nicely all right let's run it so I'm going to run it with uh I've actually written it so that I can look at combinations of speeds and capacities but first I'll just look at small combinations I.E each list will be one so we'll test it with a capacity of 30 in a speed of 10 do 40 trials then we'll test it with a capacity of 15 in a speed of 10 and a capacity of 15 and a speed of 20 all right we have some results so what we can tell looking at the green line is that I have I have a speed of 10 and a capacity of 15 the uh aggregate average weight time is long and apparently growing the longer I run the simulation I've only plotted here up to the first 500 times that the bus stops at a stop but we can imagine that if I went further it would just get worse for a while uh then it will eventually Plateau but it will take it quite a while to do that um and here we can see the interesting thing in that the blue and the red lines are not very different so what this tells us is there's a tradeoff I can afford to have smaller buses if I make them faster or conversely if I want slow buses I have to make them bigger and I get more or less the same average weight time and not much difference in in how many people are left behind at the end clearly here I have a big number these are smallest numbers um again we'd have to run it longer to see whether these are stable and with different seeds or different random numbers to see whether or not the fact that this is 80 and This is 40 is statistically significant or just an accident of this run because we do have Randomness but we did do 40 trials so maybe there's a reason to believe that in fact this is slightly worse you'll notice also the Blue Line doesn't quite get all the way to 500 which means that slow bus didn't get to make enough stops took a long time to load up because it had big capacity and didn't really get to all of the stops all right let's try another experiment and let's go change the queuing discipline go way back up here and let's make it srpt and see what we get well we get something pretty different uh in particular you'll note that the average weight time has dropped rather significantly it really has as the theory predicted led to improved weit time we'll also notice that it's got some interesting shapes here where it uh jumps around goes up almost a knee here and we might try and understand you might try and understand why it's doing that as you look at the code is it random is it just bad luck is there something fundamental going on think it all through and and decide what's going on all right finally um you know and again I suggest you play with this with a lot of different combinations to get a sense of what the code is doing so one last queuing Network question to test your understanding different question suppose you were given the job of hiring a 600 lab assistant and you had a choice between hiring an MIT student at $15 an hour or two Harvard students at $7.50 an hour suppose further that the m MIT student could deal with twice as many problems per hour as the Harvard students does it matter which you hire well you could build a simulation and you would discover that in your queuing network it didn't matter on the other hand when you ran it in real life you would probably discover that it mattered a lot because the MIT student would answer questions correctly and the moral is the queueing network does never tells the whole story you've really got to think about thing in more detail all right one more lecture see you on Thursday