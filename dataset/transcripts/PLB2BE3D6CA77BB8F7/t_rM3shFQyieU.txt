The following content is provided under a Creative Common License. Your support will help MIT Open Courseware continue to offer high-quality educational resources for free. To make a donation or view additional materials from hundreds of MIT courses, visit MIT Open Courseware at ocw.mmit.edu. So this week the last final topic we were t uh we're really going to talk about in the class is uh dynamic programming. So who can tell me what the key idea in dynamic programming is? Way of optimizing or dynamic programming is like a set of optimization tools you can use in your programming to make correct text. Um sort of it's the the key idea is that you don't want to repeat computations that you've already done before. So you want to find a way to only do everything once. It's a it's a form of laziness. Um there are two key attributes for a problem though that need to exist for it to be uh solvable with dynamic programming. Can someone tell me what those are? The local There's overlapping subs. He had all the right words. It's not the right order. An optimal substructure. Okay. Can you can you describe the first one or anyone? the end solution go through all the ones. So when we say overlapping sub problems, it means that we can take the big problem and we can break it down to a slightly smaller instance of the same problem and then we can use the solution to that smaller sub problem in the solution to our bigger problem. And then optimal substructure is closely related. It's saying that if we get an optimal solution for one of those sub problems, then we can use that optimal solution for the optimal solution of the big problem. Does that make sense to everyone? What's that? It's closely related. And so it's I mean, yeah, I mean it's it's it's it's closely related but not exactly the same. So, uh, so to start off, we're going to do kind of a function that we're all familiar with is Fibonacci, right? So, we've seen this one a billion times before. And so, it's pretty obvious where the overlapping sub problems are. The solution to f of n is f of n minus one. and f f of n minus 2, right? And so if I combine the solutions to these two instances of Fibonacci, I get the solution for the big instance of Fibonacci, right? So on the screen you have an example function. You've all seen this before. And so what I'm just going to do is I'm going to run this Fibonacci function from 0 to 30 or n equal 29 actually. And we're going to look at how many steps it takes to execute. So when we get to Fibonacci of 29, it takes about 1.6 million steps to compute the value. And if we take a look at a plot here, so the y- axis is semi-log, the blue dots represent the actual number of steps that the function took. So the number of times that it had to perform the computation. And then the blue solid line represents 2 to the n. The red line is the golden ratio to the n, which is the tight bound for uh this version of Fibonacci. And then the green line is a plot of the quad of a quadratic function. So nothing really surprising there. So it's pretty inefficient and we established that before. So we can make this more efficient with dynamic programming now, right? So let's draw out the call tree for f of five. I'm doing a lot of writing. Okay. So if we look at this, we see that in a lot of places we're repeating computations. So we repeat f of two three times. We also repeat f of three this computation twice. So the idea behind dynamic programming is that instead of repeating these computations over and over again, we're just going to compute them once. So if we look at the implementation of this recursive Fibonacci, we see that the first recursive call is going down this side of the tree. And so the upshot is that the all the values from f5, f4, f3, f_sub_2, f_sub_1, f-0, they all get computed before any of these branches. So what we can do is instead of recomputing f_sub_2 and f2 here, we can just compute it here. Save off this value somewhere in some sort of a brain. and do the same thing for F3 and F4. But that's not going to matter. So when we get to the second recursive call, so say when we're calling Fibonacci of three and we compute f of two, get f of one, we come back up to Fibonacci of four, right? The next recursive call is going to be to Fibonacci of two. But since we've already computed it and we saved it off in a brain, we can just look up this value instead of doing the all the computation again. So when you have a very small tree like this, right, it's not a huge benefit. But if you have like a lot like f of 100, this is going to make a huge difference. Anyone lost? Okay. So why don't we take a look? So this is an implementation of fib that has an extra parameter called memo. And memo is the brain I'm talking about. This is where we're going to stash those prempute those computed values so we don't have to compute them again. And when it initially comes in if memo is none that is you know we haven't passed in a dictionary or if it's like the first call to this function then it's going to set a key of 0 to zero and key of one to one those correspond to f of zero and f of one right actually no one pointed that All right. So now it's going to after it does that initialization, it's going to come down to this if statement, right? And it's going to check for whether or not n is in memo. What this is actually asking is have we seen this number before when we've been computing this number the the the big Fibonacci number right so if it's down here it's and it's looking at f f of two it's asking have I seen Fibonacci f of2 when I've done this computation before and if it's in this tree then the answer is yes because it's seen it down here if it hasn't seen it though it's got to do the work. So, it's got to actually do the recursive calls and this is when it travels down this left branch of the tree. Does that make sense? And all we're going to do is store it off here and then at the end we just return whatever's in our memory. So, why don't we take a look at how this runs? So yeah, so remember this is 1.6 million for the old implementation and now it's only 57 and in fact it's linear and exactly 2 to the n minus one or 2 * n minus one. Did everyone follow that? Are there any questions? No, it it it's it saves a lot of work for you, right? Because as soon as it So, let's say that it's it's computed f of four. this entire sub tree here. As soon as it sees f of three, it's going to look in its brain and you've already seen f of3 and it says, I've already seen this. So I don't need to do all this computation here. I don't need to do all these recursive calls. I just have to return whatever's in the dictionary. That's where your savings come in. So let's take a look at another example. So the point is is you can have some really huge savings if you do your if you uh write your code right. So let's look at a different problem. So let's say that I have a robot and this robot is positioned on a grid. Say that it has n rows and n columns or m columns. Your robot is starting out here and it wants to get here. Your robot though is very stupid and it can go only down and to the right. And the question is how many unique paths are there from the top left square to the bottom right square given those constraints. So if you try and do this analytically, you'll probably hurt yourself. The easier way to do it or at least I think so is to look is to realize that in order to get to G there's only two places that it can come from can come from here can come from here right so the total number of unique paths coming into G are the total number of unique paths coming into this guy the total number of unique paths coming into this guy so there's your overlapping sub problems right and also your optimal substructure if I can figure out these numbers then I figure out this number, right? So, and then these guys, the same condition applies. If I know these two numbers, then I can figure out this number. If I know these two numbers, then I can figure out this number. So one implementation oh one other thing if I get down to this case where I have an one by m grid how many different ways are there to get from here to here one right and then same thing for n by n right So, first crack at this. Here's a recursive function. All we're going to do is if we only have one row or one column, we return one. Otherwise, we're going to look for the number of robot paths in an n minus one by matrix and then the number of paths in an n by m minus one matrix. So, let's take a look. So, we're going to do this on a 14 by4 grid. And this will take a few seconds. Okay. So there's a lot 10 million 10 million unique paths and it took about 20 million steps to figure it out. So we're going to pull the same trick for the for this problem that we did for Fibonacci. We're going to memorize or memoralize the different paths or the different solutions except our our uh our key is going to be a little different. It's just going to be n andm right. So again if we have well again if n&m is not memo then we need to compute it. If either is one, then we remember it as one. And if they're both greater than one, then we're going to look at the number of paths in n minus one by m and n * n minus one. And then we also know that the solutions are symmetric, right? So it's going to be the same for an n by m and an m byn and just return the solution. So let's try this out. So we get the same answer, but it only takes 104 steps to do it. So it's a pretty huge savings there. So the other the this is an example of a top- down dynamic programming solution. So we looked at the big big problem and then we broke it down into two smaller problems. We looked at those two smaller sub problems. We broke them down into two two smaller smaller sub problems a piece. We can also go from the bottom up. And we might want to do this for a reason that I'll show in a second. So I think I needed that. So, this is going to go from the bottom up. So, instead of starting back here and asking how many ways I can get from these two guys, it's going to start at the beginning and ask how many ways I can get here. One, right? And then here. So, let's imagine that we only have a 2 by 2. It's going to look at again the number of ways to get to the uh square to the left and to the square to the top and add it here. Add it here. So what we're doing here, what we're doing in in this version is we're growing our grid towards the solution. Does that make sense? So this just sets up a matrix. The top row is going to be initialized to one. First column is going to be one. And then for everything else, we're just going to add the row above and the column to the left and return whatever is down in this lower right corner. So gets the same solution just in a different direction. So now we might want to do this because imagine if instead of 14 we had 1400. So this should crash. All right. So Python has a maximum recursion depth. So if you have too many recursive calls, it's going to tell you I can't go that deep and kick you out. So I have 1400 rows and 1400 columns. That's a lot of recursion. But if we do it iteratively where we have no recursion. So that's the number of unique paths uh which is a pretty sizable number. And that's the number of calls you made, which for a 1400 by400 matrix is not too bad, right? All right. So, that was an easy one. So, now we're going to go to a little harder one. Is everyone doing all right? Okay. This is a counting change problem. The idea is let's assume I have a currency with coins of a certain value. I'm not sure where Gary got 27 from, but that's apparently the value of one of the coins in our currency. So, the problem is, let's say that I have a some total. The question is, how many different combinations of coins are there that equal total? So the way to break this down is so does everyone understand the problem? Right? So like if I say I want to give change 41 cents to a customer then it's like you know a quarter a dime a nickel and a penny right so we can think of the problem in two ways. Well, we can we can break the problem down into two subpros by first considering what the total is what the number of combos would be if I use the largest coin in my set or using at least one of the largest coins. And then the other is the number of combinations. if not using the largest coin. Okay, so this turn actually turns into a nicer sub problem which is if I have total minus largest so in this case minus 27 What's the total what's the number of of combinations for this sub problem follow? All right. And then this guy can be formulated as the number. So I still have total number of combinations but then I take out the largest coin. So coins is now instead of one instead of having 27 as the largest coin now has 25 as the largest coin. Does that make sense to people? Okay. And so the solution here to this big problem is a solution to or is the sum of the solutions to this problem and this problem. Make sense? All right. So why don't we take a look at the first version of this problem or this implementation. So we have three base cases. So the first base case is well first let me explain the function. So total that's the amount that we want. Coins it's a set of coins in our currency right and I only have 5 10 25 and 27. The first thing we do is check to see if total is zero. Right? That means that we've we're trying to figure out what combination of coins is equal to zero. And of course, there's only one combination of coins. There are no coins. So that actually is one. this case, this is if we're trying a particular coin that's a little too large to fit into our into our total. So, we wind up going below zero. That means we can't use that coin for this particular total, right? So, there are no combinations that work for this. And then this last case is if we're no longer using if we have no more coins and we still have stuff that we need to you know make up like we still have some value in total then that means that this particular combination that we're trying out also doesn't work. So we return zero. So that's this case where we've taken out everything. So our set of coins is the empty set is nothing. Does that make sense? Okay. So our first recursive call is looking for the number of ways without the last coin. So that's this case. And all we're doing is we're passing in the total we got before and all the coins except for the largest one. So the last one, so we're stripping one off for each recursive call. And then the second case here is if we do use at least one of the largest coins. So in this case, we're just going to subtract that off of total and we're going to pass in coins as is. Make sense? And then we just return the sum. So, okay. So, not too bad. Everyone follow that code? All right. So, this is without doing any memoization. It's just, you know, using recursion, breaking it down into two sub problems and figuring out a solution. We can, but now we're going to use dynamic programming to optimize this a little bit. So, in this case, we have our little memorization dictionary. You notice a pattern here. And yeah, you have like an infinite amount to supply those. Yes. So you're assuming that you have an infinite number of 27 cent pieces, 25 cent pieces, etc. Z, you just add ones until you don't have ones. Then it's possible to get below zero. So let's see. So this is all the same, right? No surprises there. But then what we're going to do is we're going to memoize on the total that we're trying to find and the largest value largest uh currency piece that we have. All right. And if it's not in our dictionary, then we're going to compute it. And once we get the solution, we're going to memorize it and return it. So let's see how this runs. So we got by four. That make sense to everyone? No questions. Wow. So, now let's try a different formulation. This one's a little tricky. Let's imagine that I have a grid and down the rows I have numbers up to total. Okay, starting from zero across the columns I have my different currency pieces. So the first two implementations were going top down. Now we're going bottom up, right? The way you read this is if I have a total of zero, this is a number and my largest currency piece is five or 10 or 25 or 27. It's the number of coin combinations I have that will equal this total. Right? So in this first row, that's my base case, right? And then down here, we know this is all going to be zero because if I have no coin pieces. So now the bottom up way is we're going to fill in this table here. So, we're just going to iterate through all the totals that are possible. And for each total, we're going to iterate through all the largest coin denominations, right? And then we're just going to do two checks. We're going to look at the current total we're looking at. So, let's say that we're on row one. So our total is one and we're going to subtract the largest denomination of currency that we're looking at. So you start out here. Okay. So we're going to subtract five from a total of one. And that's less than zero. And when it's less than zero, all we're going to do is carry the number of combinations from the current total to the next smallest largest denomination. So if we're at five and we know we're less than zero, that means we're going to carry this value over. And then we're going to do the same thing for all these values. Now let's get to an interesting case. So, so now we're looking at a total of five. Okay. When our largest coin is five and we subtract it from a total of five, that's not less than zero, right? So that means we're going to go into the second branch of the if statement. So again, the same thing. We're going to look at the number of ways with the largest coin. And to do that, we're going to use our table. We're going to look at the current total, which is five, minus the largest coin that we're looking at, which is five. So that's going to index us into this row because 5 - 5 is zero. And then we're going to look at the current coin which is five. So that's going to be one one, right? Well, I skipped a step. So we're going to get this value, right? So this is the number of ways with this the largest coin. And then we're going to look at the number of ways without the last coin. So if this is the largest coin that we're looking at, then without it, this is all we have. So that's going to be zero. So 0 + 1 is one. And then for 10. So again this becomes zero. So the next interesting one is going to be 10. Is everyone following so far what we're doing? So this is going to be zero. This is going to be 1 + 0. Then this is going to be 1 + 1. This making sense? Make an error. No. Okay. Then this is going to be zero. Everyone get the idea? So, we're just filling in this table. What's that? Here. This one. There's only one way to make 10 with fives because I the smallest so right if I had one here like so I was using a one piece then this would be two but because we only have five there's only one way to make 10 two fives make sense the next one is you can either use 110 or two. Yes, exactly. So, if we're using the table as Okay, so you have five as the largest coin. So, there's only one way of doing it. Using five as the largest coin, how come that one doesn't go all the way across the road? Because if you have 25 as coin, you use fives. You know what? You're right. Made an error. Well, actually that would be terrible. What? What's that? Use the phone. Yeah. But what can I say? It can be confusing. So to prove that this crazy thing works, let's run [Music] it. So let's expand this. I use this. So all three version Oh, so all three versions. What? Did I make a mistake? No, it's just how you extend the window. Oh, you like that? That's what we like Tracy's code is always really really small. It's a program called Divvy if you're interested. I think it's like $10 on the app store or something. Or maybe it's $5. But it just allows you to do those little grid things. So if you have like lots of windows and stuff, and if you need to increase your font size, that's a little bit more involved with Python. Um anyway, so they all give the same output except for the number of steps that they take. So the the initial one took 855, the one with the memoization took 209 steps and the one without memorization, but from bottom up took only 337 steps. So it's just it's three different ways of attacking the same problem and objectively the last two are better than the first one. Um, we might think of cases where we would want to use say the tablebased method over the recursion method. Like if we had like lots of combinations to explore or some kind of situation where we got into a really deep recursion that was too deep for Python to handle and we got kicked out like we did for the number of robot paths. So that would be kind of like a a criteria for which algorithm you would choose over the other.