the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu okay uh so we're going to test it here's test one it just says for name in range 10 I'm going to build some nodes put in a few edges and then I'm going to print the graph and all I really want to show you here is that if we run it for diagraph and we run it for graph we'll get something different yes I'm happy to save the source uh oh invalid syntax it was valid last time I looked what have we done wrong here did I edit something badly sort of looks valid to me doesn't it we'll retype it yes please save nope well it's one of those days isn't it all right this is a good debugging exercise for us um let's think about how we' go and find this I'm sure you've all had this sort of problem well the first thing to do is I think I'll just comment out all of this and see if I still get an error I do all right well that suggests that that wasn't the problem so I can put it back now shows a problem all the way down there so let's see what's going on here or maybe I'll just skip this but doubtless I'll get in trouble if I do so let's see I must have just made a sloppy editing error somewhere this morning and commenting things out for the lecture well I think what we're going to do for the moment is move on and hope it goes away now that's see seems silly sorry about this everybody people should look with me and see if you can someone may see it more quickly than I can in fact I'm hoping someone sees it more quickly than I can we've now got a microphone I mean the embarrassment of a code with syntax errors does it you got sorry for some reason it wasn't on the schedule so well just because we've been teaching at 10:00 February there's no reason to suspect that we would teach at 10:00 today I check uh well this is embarassing folks and I wish one of you would bail me out by telling me where my syntax error is well random looks okay right node looks okay and it gets more complicated turn the no okay I'll turn on the transmitter but I'm really focused on a different problem right now guys help where are my Tas why do keep doing that to me maybe there's something just funny going on here pardon restarting idle you think maybe that's the issue we could try that ah so it looks like Idol was just in some ugly State let's hope yes all right so I didn't have a bug it was just idle had a bug all right but we did squander 10 minutes oh well so we have the graph and you can see when we look at a graph we have a node from 1 to two an edge from 1 to two from 1 to one Etc and that's the diagraph when we look at the graph we'll see that in fact we have a lot more nodes because everything goes in both directions but that's what we expected um nothing very interesting all want you to do is notice the difference here between graphs and diagraphs now getting to the whole point once we have this mechanism set up to think about graphs we can now think about interesting problems and formulate them as graph problems and I want to list a few of the interesting problems and then we'll look at how to solve some of them so probably the most common graph problem that people will solve is called the shortest path problem we talked about this briefly last time the notion here is for some pair of nodes N1 and N2 we find want to find the shortest sequence of edges that connects those two nodes all right so that's very straightforward then there's the shortest weighted path we're instead of trying to find the shortest sequence of edges we want to find the smallest total weight so it may be that we Traverse a few extra edges but since they have shorter weights we end up getting a shorter path so we might indirect to do the shortest path um this is probably the more common problem so for example that's the problem that Google Maps solves when you ask it to give you driving directions and you'll notice when you use something like Google Maps or Map Quest you can tell it uh to minimize the time in which case maybe it will route you on a freeway where you can drive it 80 mil an hour even though you drive a few extra miles or you can tell it to minimize the distance in which case it may take you on these crummy little surface roads where you have to drive slowly but you'll cover a fewer miles and use less gas so you get to tell it which set of Weights you care about and then it finds you the shortest path given those weights we'll come back to this since so we're going to look at some code to implement it another slightly more complicated problem to understand that stand is finding clicks so to find a click we're looking to find a set of nodes such that there exists a path connecting each node in the set so you could think of this as similar to uh say a social click who your friends are uh it's a group of nodes or group of people that somehow get to each other it's not saying you can't get outside the click but it is guaranteeing that from any member of The Click you can reach any other member of the click and so you can imag well we'll look at some examples of of where finding a click is useful and the final kind of problem I want to mention is the minimum cut problem often abbreviated Min cut so the problem here is given a graph and given two sets of nodes you want to find the minimum number of edges such that if those edges are removed the two sets are disconnected I.E you can't get from a member of One set to a member of the other set this is a often a question that gets asked uh for example imagine that you are the uh government of Syria and you want to ensure that nobody can post a video on YouTube you would uh take the set of nodes in Syria and you would set of take the set of nodes probably outside Syria and ask what's the minimum number of Link communication links you'd have to cut to ensure that you can't get from a node in Syria to a note outside Syria uh people who do things like plan power lines worry about that they want to say what's the minimum number of links s such that if they're cut you can't get any electricity from this power plant to say this city and they'll typically design their network with redundancy in it so that the men cut is not too small and so people frequently are worried about mincut problems and and trying to to see what that is all right now let's look at a couple of examples um in in slightly more detail so what we see here is a pictorial representation of a weighted graph generated by the center for disease controls CDC in Atlanta in 2003 when they were studying an outbreak of tuberculosis in the United States a virulent and bad infectious disease each node and you can see these little dots or the nodes um represents a person and each node is labeled by a color indicating whether the person person has active tuberculosis has tested positive for exposure but doesn't have the disease or tested negative for exposure or not been tested so you'll remember when we looked last time at class node and asked why did I bother creating a class for something so simple it was because I said well maybe we would add extra properties to a node so now in some sense these color would be easy to add so I could add to class node well I could attribute color and call it red or blue or green or more likely an attribute saying TB state which would indicate active not active Etc the edges which you can see here um represent connections among pair of people pairs of people um what I didn't bother which you can't see on these pictures is the edges are actually weighted and the weights there are about how closely people are connected and there really only two weights I think they used close someone who say lives in your house or works in the same office or casual a neighbor you might have encountered but you wouldn't expect to necessarily see them every day so they've taken a fairly complic ated set of information and represented it as a graph now what are the some of the interesting graph theoretic questions we might proceed to ask about this so an important question they typically ask when diseases break out unexpectedly is is there an index patient the index patient is the patient who brought the disease into the community so somebody who visited some country picked up tuberculosis flew back to their neighborhood in the US and started spreading it um how would we formulate that as a graph question again quite simply we would say does there exist a node such that node has TB or maybe not even that has TB well let's simplify it you might say or tested positive because maybe you can communicate it without having it has TB and is connected to every node with t with TB now this doesn't guarantee that the patient is an index patient but if there is no such patient no such node then you know that there's not a single source of this disease in the community how would we change the graph to model it in a more detailed way and remember this is all about modeling so that we could ask the question more formally about or more precisely Well we'd have to change to a more complex coloring scheme if you will in which we'd include the date of when somebody acquired the disease or tested positive and then we could ask those kinds of questions in a little bit more detail but again once we've built the model we can then go and ask a lot of interesting questions by the way the answer to this question for this graph is almost um there is an index patient that's connected to every node in the graph except for the nodes in this black circle they are not connected to any index patient uh so the CDC actually did that analysis and they reached that conclusion that there didn't seem to be and then later it came to light in fact that this particular graph is missing an edge that there somebody had moved from neighborhood a to Neighborhood B and they had not kept track of that and if they had they would have discovered there was a link that's missing an edge that's missing from this graph which in fact would have connected everybody to the index patient um it was an interesting question they only found that because they were puzzled about this tiny little black circle out here and started investigating all the people in the black circle and discovered that one of them had moved from one place to another all right what's another question you might ask once you've built this model well suppose this is the current state of the world and I want reduce the spread of the Disease by vaccinating uninfected people so that they don't contract tuberculosis but I have a minimum I have you know it's expensive to do this I only have so much vaccine who should get it what's the graph Theory problem that I would solve to address the question of what's the best way to allocate my limited supply of vaccine exactly I by the way have really good I have much better candy now so I should uh I think that I think that's where the minimum cut came from well all right it's better for eating it's just worse for throwing that's easier to throw all right um it's the minimum cut problem I take the people who are already infected view them as one set of nodes I take the people who are not infected and view them as another set of nodes find the edges that I need to cut to separate them and then vaccinate somebody on one side of the edge so that they don't contract the disease so again a nice easily formalized problem all right so that's an example let's look at another example uh let's think about the shortest path problem here and we'll do that by thinking about social networks so I suspect that at least a few of you have used Facebook and uh you have friends some of you more than other um there's I see people laughing this is someone who probably has two friends and is sad I don't know or a thousand friends and is happy all right who know I don't I don't want to know please uh and I'm not going to tell you how many friends I have either um but you might ask the question [Music] um suppose you wanted to reach Donald Trump Ur wild Republican vice presidential candidate or presidential candidate say is there a connection from you to Donald Trump do you have a friend who has a friend who has a friend who is a friend with Donald Trump or Barack Obama or anyone else you'd ask well and what's the shortest path how many friends do you have to go through um this is what's called The Six Degrees of Separation problem um in the 1990 the playright John guare published a a play called Six Degrees of Separation under the slightly dubious premise that everybody in the world was connected to everybody else in the world with it most six hops if you took all the people you knew all the people they know Etc you could reach any person in the world in six in six phone calls say any person who has a phone I don't know whether that's true but this is the whole notion of a social network um so if we wanted to look at that in Facebook we could either assume that the friend relation is symmetric if I'm your friend you're my friend which it is or you could imagine a different model in which it's asymmetric if it's symmetric you have a graph if it's asymmetric you have a directed graph and then you just ask the question what's the shortest path from you to whomever you care about and you get that you could imagine that Facebook already knows the answer to that question but just won't tell you but they'll sell it to somebody who has enough money all right so how does Facebook solve this problem they have a very simple piece of code which we'll now look at which solves the shortest path so let's go back so here's a recursive implementation of shortest path comment this out while I'm in the neighborhood takes the graph a start node and end node and to print and this extra argument called visited we'll see why that gets used and we'll think about the algorithm this particular algorithm is what's called a depth first search algorithm it's a recursive depth first search we've seen these before often abbreviated DFS so if you think about having a graph of a bunch of nodes connected to one another just for fun we'll say it does something like this what depth first search does is it starts at the source node for the shortest path let's call it this one it first visits one child and then visits all the children of its those children um this one has no children visits this child picks one of its children visits all of its children let's say it had another one here and goes on until it's done and then it backtracks comes back and takes the next child then we have to be a little bit careful about the circle so to summarize it first thing we have to say is the recur cursion ends when start equals end that is to say I've called it and I've asked is there a path from a to a and the answer is yes there is I'm already there now you could argue and in some formulations the answer is not necessarily you'd say there's only a path that's just there's an edge from a to a but I've chosen to make the simpler ass assertion that if you want to get to a and you're already there you're done kind of seems reasonable so then the recursive part starts by choosing one child of the node you're currently at and it keeps doing that until either it reaches a node with no children or it reaches the node you're trying to get to or and here's an important part it reaches a node it's already seen and that's what visited is about because I want to make sure that when I explore this graph I don't go from here to here to here to here to here to here ad nauseum because I'm stuck in what's called a cycle you have to avoid the Cycles once it's got to a node that has no children if that's not the node it's trying to get to it backtracks and takes the next child of the node it was at and in that way it systematically explores all possible paths and along the way it chooses the best one so we can look at the code here I've just commented out uh something we'll look at later just as we try and instrument it to see how fast it's working um I've got a debugging statement just to say whether I'm going to print what I've been asked to do in case it's not working and then the real work starts I get the original path is just the the node we're starting at if start is end I stop uh shortest if I get to here I say shortest equals none I haven't found any paths yet so there is no shortest path and then for node in the children of start if I haven't already visited the node this is to avoid Cycles I create a visited list that contains whatever that used to contain plus the node notice that I'm creating a new list here rather than mutating the old list and that's because when I unravel my recursion and backtrack to where I was I don't want to have think I visited something I haven't visited right if I had only one list and I mutated it each time then as I go down the recursion and back up the recursion I'm always dealing with the same list by getting a new list I'm ensuring that I don't have that problem then I take the New Path is whatever the shortest path is from the node I'm currently at to the desired end node and I use the current set of visited nodes to indicate where I've already been at this part of the recursion if the New Path is none well didn't find one I continue otherwise I found a path and now I just want to check is it better or worse or the same as as the previous shortest path and then I'm done very straightforward the only really tricky part was making sure that I kept track of visited properly and didn't get stuck in Cycles okay let's run it so here's test two builds the same kind of graph we've built before and then it tries to find the shortest path and I'm going to do it for the same input essentially the same add edge operations but once when it's a graph and once when it's a diagraph so you'll notice that it found two different answers when it was a graph it could get from 0 to four and essentially one hop but when it was a diaph it took longer it had to go from 0 to two to 3 to four and that's not surprising because the graph has more edges and in fact what we saw is that in the graph there was an edge from four to zero but there was no such Edge in the directed graph so again you'll get unsurprisingly different answers but very straightforwardly now let's try it on a bigger problem so I've called this big test and what this does is rather than my sitting there and typing a bunch of add edge command ands it just generates uh edges at random so I tell it whether I want it to be a graph or a diaph and then I give it the number of nodes I want and the number of edges and it just generates at random a graph in this case with 25 nodes and 200 edges so let's see what happens here so it's printed out the graph and now we're waiting a little bit uh it will eventually finish there I can get from 0er to four turns out there's a short path for this random graph from 0 to 14 to four it's not so surprising that there's a short path why is it not surprising that there's a pretty short path I had a lot of edges right I had 200 edges in My Graph so things are pretty densely connected um why did it take so long well remember what it's doing is exploring all the possible paths from zero to four in this case uh this is very much like what we saw when we looked at the knapsack problem right where there when we looked at the cursive implementation we saw that well all right generating all possibilities there were an exponential number of possibilities there in the number of items here depending upon the number of nodes and the number of edges it's also large and in fact exponential we could explore a lot of different paths but let's see what's going on when we explore those so what I'm going to do now is go back to our small example we'll run test two that was the small one we looked at but I'm going to set two print on to true and if you remember what that code did is it told us what it what each recursive call was what the start node was and what the end node was so it found the same shortest path that's a good thing 0 to four but how did it do that well it first got called with the question of okay starting at zero find me a path to four it visited the first child of zero which was one so all right see if you can find a path from one to four it then backtracked and sort of asked the same question can I get from two to four from 0o to four and then I said well I can get from 0 to two let me try 2 to Four 3 to four four to four that's good uh I get to 5 to four and then it tried to find four to four again here it tried to find two to four again so what you can see is as I do that backtracking I'm solving the same problem multiple times why am I doing that because there may be multiple ways to get to the same node so if for example I looked at this graph what we would see is I would try and and and let's say I wanted to get to here just for the sake of argument I'd first say can I get to hear from here I try this then I'd solve here to here and i' do that I'd also go from here to here to here and then for the second time I'd try and solve the problem here to here now here since it's only one connection it's a short thing but you can see if I have multiple ways to get to the same intermediate node each time I get there I'm going to solve a problem I have already solved how to get from that intermediate node to the Final Destination so I'm doing work I've already done before this is obviously Troublesome nobody likes to solve a problem they've already solved before so what do you think the solution is how would you solve this sort of thing yourself what would you do well what do you yeah thank you sky is hungry go ahead some way of storing information that you've already looked at exactly what you try and do is oh is remember what you did before and just look it up and this is a very common technique it's called memorization we use this to solve a lot of problems where you remember what the answer was and rather than recalculating it you just look it up and that can of course be much faster you know so it's a fancy way to say we're going to use table lookup this concept of memorization is at the heart of a very important programming technique called dynamic programming in the algorithms class that's taught in this room immediately following this class they have spent at least four lectures in the topic of dynamic programming but since you guys are much smarter than those guys taking that class we're going to do it in about 20 minutes and today and a little bit in the next lecture all right so let's look at an example we'll look at a solution so I've taken the recursive implementation we had before and Rewritten it just a little bit to call DP dynamic programming shortest path and the most important thing to notice is I've given yet another argument to the function and that's the memo which is initially an empty dictionary the rest of the algorithm proceeds as before except what happens here is when I want to get from a path the first question I ask is I say New Path is equal to the memo of node to end so when I get to one of these interior nodes and I want to say what's the shortest path from here to here the first question I ask is do I already know the answer is it already in my memo if so I just look it up and I'm done I found it and I proceed as before if it's not in the memo well this lookup will fail and I'll enter the accept clause and I'll make a call again so this is a very conventional way of using Tri accept as a control structure failing to find it in the memo is not an error just means I haven't yet stored it away and as I go I'll build up the memo and then I'm done so it's very simple so I should ask the questions anyone need me to explain this again or does it make sense what we're doing here with the memo okay I'm assuming it makes sense Let's test it and we'll first do a very simple test we're just going to use the same little graph we used before and I'm going to run shortest path and DP shortest path and at least confirm that for one search I get the same answer it's just sort of fire testing it to make sure that it's not a complete disaster and we do we get 023 4 0234 so at least for one thing it's the same thing um let's see about performance because that's really what we got interested in so we'll go back to our big test and uh let's go back and for both of these I'm going to uncomment tracking This Global variable just keeping track of the number of calls and we'll see whether we get a substantially different amount of recursion in one versus the other so it's built some random graph again this is the non-dynamic programming one which as we recall takes a bit longer I probably should have said all right so it's pretty big difference they found the same path 0234 but you'll notice the straightforward depth for search took over 800,000 recursive calls whereas the dynamic programming one took only order 2,000 a huge difference um if I ran it again I might see a slightly smaller difference I might even see a considerably larger difference I've run this on some examples where the recursive search depth first took a million and uh got through the dynamic programming in 50 60 but what you can see is there's a huge Improvement in going from one to the other dynamic programming was invented in the 1950s by someone named Richard Bellman um many a student has wasted a lot of time trying to understand why it's called dynamic programming and you or I could invent lots of theories relatively recently I found out why it was called dynamic programming and this is a quote from Bellman it was an attempt to hide what I was doing from government sponsors the fact that I was really doing mathematics was something not even a congressman could object to so you know he was doing this thing that was pretty evil which was mathematics which is what he thought this was the math of dynamic programming and he just didn't want to admit it so he made up a name out of nothing and it fooled the government and he got to do it now why do I teach you dynamic programming and we're going to talk a little bit more about it the next lecture um it's because it is one of the most important algorithms that we know today it's used over and over again to provide practical efficient solutions to optimization problems that on their surface appear intractable they appear exponential it says there's no good way to solve it in fact if it has certain kinds of properties it will always be amable to solutions by dynamic programming which will most of the time and I'll come back to the most of the time end up taking an exponential problem and solving it really quickly as we did here I could have made this graph enormous and dynamic programming would have given us a very fast solution to it so when can we use dynamic programming not all the time um we can use it on problems that exhibit two properties the problem must have optimal substructure what this means is that you can find a globally optimal Solution by combining locally Optimal Solutions so we can again see that with our graph problem that we can combine the solutions from nodes at a distance from the root node to get the solution of getting there from the root node if I know I can get from A to B and I can find the optimal solution from B to C then I can use that to find the optimal solution from a to c so it has optimal substructure the other thing it has to have is overlapping sub problems and that's the thing I emphasized earlier that finding the optimal solution involves finding an optimal solution to the same sub problem multiple times otherwise we could build this memo but we'd never successfully look up anything in it and so the algorithm would give us the right answer but we' get no speed up so it's this property that we need to know that we'll get the correct answer that when we combine the local Solutions we'll get the right Global solution it's this property that gives us an indication of how much of a speed up we can expect to to achieve how many problems will we not have to solve because we can look up the solution we'll come back to this and we'll see how it applies to another problem that you've already looked at say the napsac problem to give us a fast solution to that so that if you want to answer go back to a previous problem set and take the full database of classes you'll be able to solve it quickly using dynamic programming okay see you next time