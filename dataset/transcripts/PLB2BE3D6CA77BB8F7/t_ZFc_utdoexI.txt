the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu so there's too many things I we're going to start with today um one is a we're going to review the quiz and we'll be real quick on that then we're going to talk about object-oriented programming which is something that you will probably be more interested in for your problem set so just going down problem one uh it's false true false false false does anyone have any questions on this no everyone good with that anyone wonder why something's true or why something's false why is the second why is it false it's true because and this is an English thing so or a language thing so it it can kind of trip people up but it's basically saying um that there are some problems that you need to use recursion or iteration to solve why you always have to use why would it be problem that you cannot S without using well if you have um a large number of inputs so the inputs are variable I mean there I mean the point is is that uh there are certain problems that you would need to use recursion or iteration to solve them there are some that you don't but this is just asking if there are problems that exist root Force well root Force usually involves some sort of iteration because you have to iterate through all the possible solutions any other questions okay so the next one this is just this was just an exercise in code reading and we can actually just look at how it runs so if I run it like that also if you don't have your quiz I have them up here if you want to pick it up um but that's just the output of that code does anyone not see how that works or want me to step through it okay okay question three was the double recursion question and those are the two answers we were looking for does anyone not see how that works we want to try and walk through it okay so the way to tackle this problem is just you got to step through the or kind of walk through it in your head right so let's take the first set of input all right at the top that's your initial call now the string s here is not less than one right so you're going to go to this double recursive call here so that means that you're going to get as you return right and the way I got this at is I'm just taking s from one to the end okay so what this means is that this part is going to execute first and it's the same thing going to the function this is now s this is obviously not only one character long so we're going to have again another double recursive call and it's going to look like this all right so now I've got this call to contend with now this string is one character long so what does it do it just Returns the input so this function call is just going to return T and then this function is going to get called with t again and we already know what happens when you pass a t that means that this whole function here results in t right and then we just have we tack on the a so that means this function called a t returns ta and then we pass it into this outer function here all right and we can already kind of guess what this is going to return because for this input it just reversed the characters it just flipped them so for ta it's going to flip them again so the entire function call here results in a t and then we just append M to it so the entire return for this one is ATM so It's Tricky but you've just got to step through the code and step through the functions and look at what at each step what the function is getting as input this was the coding question right most of the questions up until now have been you read code and understand what it's doing this one ask you to actually Implement a function and you when you start with these questions you should always start from the specification right so this function is assuming that we have a list of words in lowercase elster is a string of lowercase letters all the letters in elster are unique and that the return of the function are going to be all the words in word list that have a onetoone you know mapping between the letters in the word and elster so in English let's say that my elster is raft okay and assuming that I have a fairly complete word list I'm gonna have two words that are GNA meet that criteria right I can say there's an r a f t that's pretty obvious and we have a t f a r so that's what we're looking for so a lot of you did um something where you iterated through all the words and then you had another loop inside that that uh tried to find this correspondence the way that we uh solved it and there are multiple solutions to this so if your solution worked you got full credit but the solution that we came up with is first we're going to take the letters in eler and we're going to sort them so we're going to have a r t right alphabetically and then for each word in word list we're going to do the same team same thing all right so raft becomes afrt fart becomes afrt as well then it becomes just a simple string comparison and all we have to do is iterate through the word list right does that make sense to everyone so it our solution has a trick you don't need to use this trick a lot of people didn't they got full credit but this is one way of doing it all right so question five this was the one where we asked you to find the problem with this code or rather we asked does this code meet the specification and so when you get a question like that the first thing you should do is actually look at the specification right and you should look for what this code needs to do because the specification is going to tell you what the function needs to do if it doesn't say you need to do something then that means it's undefined right so it you know in those cases you can do whatever as long as you meet the specification so the first requirement is it returns a list of the pointwise sum of the ele elements so that's the first requirement of the specification and then it gives you two kind of implicit requirements one is this example where it says if I'm given two vectors this is what I expect the return to to be in this case the vectors are two different lengths so it's also saying that your vectors are not always going to be the same length and in that case you take the point Y sum up to the shorter of the two lists and just tack on the remainder from the longer list okay so that's the second requirement the third requirement is if you have two empty lists you're going to return an empty list and finally your fourth requirement is does not modify inputs so now you know the four requirements from the specification and now you need to look in the code and see if it if if this code matches all this requirements so the first one does it return a list containing a pointwise sum of the elements well this is the portion of the code that does that and it looks like it means that specification right result is going to be the longer of the two vectors so in this case if V1 is longer than V2 we set result to V1 and other to V2 that's the shorter and then if V2 is the longer we set result to V2 and other to the shorter of the two vectors does everyone see that so we iterate through and we get the point Y sum so we meet the first first requirement the second requirement is that if we're given two vectors that are of different lengths then we're going to sum the up into up the furthest that we can so up to the length of the shortest one and then tack on the remainder well again this for Loop here that some does a point Y sum it only goes up to the length of the shorter list right so second requirement met third requirement two empty vectors returns an empty vector well if I have an empty Vector here this is going to be zero this for Loop's never going to execute and my result is going to be empty okay and then finally the fourth that leaves the fourth requirement does not modify the inputs well what's result result is what we're ultimately returning and that's the only thing that we really modify in this function well result in this case is V1 or V2 but they're Alias so it's modifying the inputs and that's the violation so the answer to this problem is a total of six characters some of you wrote like entire redefinitions of the function or like copied Ryan's code from the reviews perfectly acceptable but way too much work remember programmers are lazy so um that's all we were looking for if you're if you use the uh code from Ryan or you had a different implementation that you know met the specification but was completely different you got full credit so you got a question I'm just trying to figure out what the distinction is between doing Ace dot copy applies only to dictionaries so if we try and do a DOT copy on a list got it so I think we took like one point for that or something it wasn't like we knew what your intent was but you just BL you didn't have your uh ID there with you all right so question six was another exercise in code reading and the way that I would attack this one is to figure out what the two functions do first so let's take the easier of the two add up takes the dictionary as input and it has a variable result that it initially sets to zero and then it iterates through all the keys in in the dictionary and adds them to result so basically it's taking it's assuming that the values in the dictionary are in or some sort of number and it's summing them up and returning the total and then this F function here takes on a dictionary it zeros out any of the keys it might have and then it iterates through all the characters in s and if the character is already in the dictionary then it's going to add one to it so it's going to increment it and if the character isn't in the dictionary then it's going to set it to zero and then it's going to return the resulting dictionary so knowing that the function becomes pretty easy right F of abbc for D1 which is an empty dictionary well just walking through it we don't have to but if we starting from this point if we iterate a it's not going to be in the dictionary so we're going to set uh D of a to zero then we move on to the next character b b is not in the dictionary so B become D of B becomes zero Now we move on to the second b b is now in the dictionary so we increment B right so now D of B is one and then we move on to to the final character C again not in the dictionary so we set D of C to zero and we return the dictionary so that means that in my dictionary I have three keys a b and c and they have values 0 1 and zero respectively so add up is going to return one right and same process for all of these question I have here is what happens when py gets to that line anyone oh um it's going to be an error what why right it result is a local variable to add up so there we go right we doing good on so again the approach to this problem is to figure out which each of the functions do and then walk through the code did anyone have trouble with this or want me to actually step through it all right all this does this Loop here well first when F gets an integer it just prints out the binary the the integer in binary and then this Loop here prints out the binary representations from 0 1 and 2 so Y is the first output none in this case because in that in that instance in that first iteration I is zero right so when f is called and it's going to be zero it's just going to return nothing so it gives you none all right now the next question was and I don't have it here you know under the assumption that a log base 2 is O of n what is the order of the function f all right and to figure this out you know that this function here is O of n because we told you right and we know that that's one of the first things that's called an F so automatically a runtime is O of n now this Loop here iterates how many times log n right well log base 2 N to be explicit so for this function which is the dominating term here right so so when we want to see o of n it's just going to be that if you had o of n plus you know log n i I think we took a point but we you know just because when we talk about worst case scenario we're looking for what the dominating portion of this uh function is all right how do how does it do it oh you want me to walk through the cone now all right first thing it does is it gets something it's calling Cur digit all right and all that is is if you take the log base two of a number you're going to get the number of binary digits in it all right so think of it as like if I have three which binary is one one yeah um if I take log base two of this then my curent digit is going to be one believe so I'm not sure what Python's going to run to 1.5 but if we con truncate it to an inch it's going to be one all right so that gives us that's kind of like our position marker in the in the binary number and then now we're going to iterate while the current digit is greater than or equal to zero so um we're basically going to start here and then move down the line in this direction and all it does is say says if my n mod two so I'm checking to see if it's odd or even like it's going to be one or zero in this case it's going to be one to the power of the current digit which in this case is one or I'm sorry misspoke n is three so the remainder is going to be one in this case 1 to the power of 1 it's going to be one if that's less than n which it is then my answer is going to be ANS + one so I'm going to pend one to this string that I'm constructing and then I'm going to subtract whatever this um this part is so two to the Cur digit in this case 2 to the one it's just going to subtract this off right and then C digit is going to be decremented and moved here and then in this iteration C digit is going to be zero and N is going to be one so one mod 2 is going to be one C digit one C digit is zero so that's going to be one less than uh one yeah so it should print it out I was not prepared for that all right so the final question number eight so Big O notation if we match it up does anyone know what it is upper B yeah a lot of you put uh the expected running time and the letters are messed up on this but a lot of you put the expected running time but when we are talking about Big O we're talking about worst case scenario so that's the upper bound there is an expected bound so when you if you decide to do any more lgorithm analysis you have big O expected and little o so like if I plot the runtime of a given function like my big O might be this the worst time my expected might be like that and then my absolute best case might be like that so when we say Big O that's what we're looking for or whatever it is all right uh Newton's method what is that an example of yeah are these these don't look right you know what I'm sorry this is a different version of the quiz so so Newton's method yeah that's an approximation and then the last one was recursion on your test so the answer we were looking for was induction so that's that anyone have any actual questions number four why is this okay so what was the part that you didn't understand with number four I gu you knowa well that's kind of the trick we have here so we know we have a list of words so to iterate through the words it's just a for Loop right so that's what that for word and word list does to do the uh thing where you match the letters one to one uh what we implemented here is we first take ster and we sort it sort the characters in elster and then what we do for uh word list is for each word we sort that word sort the characters in that word and what that does is it allows us to just directly compare the two strings and if they're equal then we've met their criteria for adding it into the word list or the return word list all right we good yeah all right so that's the quiz if you don't have it you can come pick it up yeah so if I say my string is ABCDE e f and I just say sorted s this returns a list what join what I'm doing with join is I'm just converting it back to a string you got it okay so on to objectoriented programming so what can someone tell me about classes what do they what do they allow you to do they allow you to define a custom type yes so one thing they allow you to do is Define a custom type now each when you define a class um you can group your methods and data together it's something called encapsulation right so first off we've actually already been using classes you just we didn't tell you right so ins floats uh dicks Etc these are all types of classes right and each of these we've already seen them have something called Methods associated with them right methods are basically functions that are associated with a given class so for example if I have the St Str class which everyone's seen then it has say a method. lower so if I have S equal I mean write it up here on the code if I say something like s equal a bcde e f I can call the method lower so we've actually already been doing object-oriented programming you just didn't know it um along with that classes have methods and they also have something else someone help me what um I'm looking for something so terminology wise attributes so there are way of grouping methods and attributes right so when we talk about attributes we're talking about uh things that pertain to a specific instance of a class so let's say that I have a real world example I have a person class right we've already kind of seen this guy a person has multiple instances so there's a there's an instance of Mitch there is an instance of gy um as an entrance uh an instance of Philip we're all people all right mostly human and we all have attributes so you know we all have an age like when we were born we all have a name some of us have hair um and uh other attributes right we also have actions that we can take so I can talk and I can walk I can talk to you you you you and you all right so a method that I could Define for a person might be talk to someone right so I mean that's one way of thinking about objects so object oriented programming also gives us uh something called inheritance right so I could think of if I'm going along with my person analogy I could think of sub classing person if I'm willing to draw a hard binary on the genders um you have males and you have females right and in this column I might have Tracy I'm just picking on people who come to office hours and then gy Etc Now The Inheritance portion of it is important because I've already said that one of my methods on a person is I can talk to people I can talk to other people it shouldn't matter if I'm talking to garthy as a male versus Tracy as a female like I talk to people basically the same so that gets into something called polymorphism which is we treat objects with a common superclass the same as you know their subclasses so as another example let's say that I have you know dogs and I don't know what's another canine foxes I'm not going to necessarily talk to canines the way that I talk to a person so they would exist with a different super class and then we could all be animals so really what object-oriented programming gives you is a different way of thinking about how you're modeling your world all right and what I want to do is now instead of just talking about kind of these abstract things kind of walk through some concrete examples so the first thing that I want to illustrate is let's say that we want to create a person but we don't want to use objectoriented programming or we don't want use classes Professor G Talk will get angry at me if I say we're not using objectoriented programming so let's say I have a function make person and I'm going to represent my a person as a dictionary that have has a keys name age height weight uh as keys right all make person does is it takes these things as parameters makes a dictionary with them as values and then returns dictionary right then I have a bunch of helper functions like uh get name of person all that does is it just returns whatever is in the name key um I can also set the name um in case the person decides that you know they don't want to be known as you know Mitch they want to be known as Mitchell or something like that um so I have a bunch of these getter and Setter functions these are called accessor or mutator functions uh whatever terminology you want to use I can also Define another function that will do something like print out the person so in this case I'm just going to print out name age height and weight and to see this in action I'm going to make a person Mitch 32 70 200 and then Serena 25 65 130 I don't know if these are actual number actually correct so don't quote me on it um I have a syntax error so if I run this then all it's going to do is just print out what I'd expect it to print out right so I can also set my age so I can go back in time to 25 which is a great age and now I'm 25 all right now this is fine if you just want to do simple things um but the reason why we kind of like object-oriented programming is because we get we run into difficulties so let's say that I print out the type of Mitch it says I'm a dict um but it doesn't give me any more information so that means that I could find any random old dict and pass it to some of my functions that I've defined to work on people and it will probably give me an error it also means makes other operations kind of non-intuitive so let's say that I want to you know Define figure out if two people are equal well I could do that by defining a function people equal or equal people um and passing it into person one and person two and for for all for our intensive purposes it's just going to be if they have the same name they're the same person um so this is going to of course do what we expect it to do and return false right because Serena and Mitch aren't the same person but it's kind of awkward and if we do things using classes it becomes a little bit more elegant and you get a lot more uh Power so let's say I do the exact same thing with a class all right so I have the class keyword I have the name of my object or my class my type new type and then I have the thing called init all init does is it says when I get a new person object python automatically calls a net with whatever parameters are specified and tells the object to make attributes or to set itself up so in this case I need a bigger screen I'm making a mitch person all right and the way that you make a new object or an instance of person is you have the class name and then you pass it whatever parameters are specified in in it now behind the scenes python will create a chunk of memory and then it'll call this an an nit function and it'll pass a reference to that chunk of memory all right so visually so visually let's say this is your magical memory python sees this call person goes in grabs a chunk of of memory this marker sucks grabs a chunk of memory and says this chunk of memory is of type person right then it calls in it and it says basically Mitch is a reference to this chunk of memory right this is a self parameter and then it has the other parameters all right and then when in the init method all we're doing is we're creating new attributes on this chunk of memory so we're going to have an attribute name we're going to have an attribute age height weight okay and then we have a bunch of accessors or Getters mutators or Setters same exact as the same exact thing as the functions that I showed that we had when we were trying to do this without classes right the difference is that these are lexically scoped to person they they they are methods for a an instance of type person whereas before they were just functions that worked on something we called a person but a person was actually a dick so let me just run this so if I run this I'm just going to create a person Mitch or a mitch person and a Serena person I'm going to print out Mitch and it's the same thing that I had before right except I'm using a class now if I want to use one of the accessors so I want to get younger again I can just take my object Mitch and I can call the set age method and pass it in my new age and I've lost seven years all right now so far this is just a different way of doing kind of the same thing right but if we look at the type of Mitch I'm a person right so there's now some in extra information that we didn't have before when we were using a dict to represent a person you know before it could have been any dict we didn't know that it represented a person the only reason that it represented a person before we used a class was because we had set certain keys to certain values but other than that it was just a dick here this is marked as being a person and that also gives us some you know additional kind of power which we'll see in a couple in a little bit so now I've done something kind of sneaky and I've created a way of comparing Mitch and Serena before I had that function people equal now I can use the double equal operator which is something that we're used to we use it with all the other other types why don't we use it with people right the way that we Define that is that on this person class I have to find this function under underbar underbar EQ underbar underbar right the underbar methods and underbar in it is underbar underbar in it is one of them have a special significance in Python all right so in this case the underbar underbar EQ under underbar says that if I have uh an object Mitch and I have a double equal and I have another object Serena it's going to look in the Mitch object and it's going to say does it have an EQ method does it have this method name and what in this case it does so it says okay this object is capable of comparing itself to another object for equality and so it calls this method and self in this case is the Mitch object is this guy and other is a Serena object sorry so when it looks for EQ does it look for EQ or does it look for something that has a double equal sign and then go up there like is the under bar under barq under bar under bar like it defined for all it's defined for all persons all persons yeah um well okay I see what you're saying is it defined for objects other than persons like all objects well we can check that out so you notice that person inherits from object this is where all all classes that you define should inherit from and so object like any other type remember I showed the DT command before if you do this you can see everything that's inherent to an object so in this case it doesn't have the underbar underbar EQ so it might be something special to special that python does so this is where I'd actually have to look it up to answer your question so I'm going to punt on that know to look forq specifically yeah um when it sees the double equal sign it knows to look for EQ it's it's it's the double under bars signify a magical operator or magical method when you're calling EQ you're definitely not giving it you're not formally giving it two formal parameters in the parentheses notation so it's presumably taking like the first thing before the equals and the second before the equals we're getting to that so um so the the question is is it are we actually explicitly passing two formal parameters to it and the answer is yes and no this is uh a bit of syntactic sugar for python which means that it's a nicer way of writing things but we could do something like this which is totally awkward but in actuality this is what python does in the background it does this sort of kind of mangling and I was actually going to show that with something a little bit easier to comprehend so I have a method called get age an accessor right and usually you call a method by having a reference to the object Dot and then whatever method name right in this case at age you can also write it like this which is if you think about it exactly what happened with a double equal operator right python took your nice intuitive syntax Mitch you know double equal Serena and totally mangled it and made it something that was completely ugly and this is how python would actually see it so that's why when you write these methods you have a self parameter this self parameter is you know like this guy right python says ooh I have an object reference and they're calling method get age do I have a get age method yes I do here it is okay now I'm going to take this and make it look ugly it's a person object so I'm going to call person.get age and then I'm going to pass it Mitch the reference to the object and that becomes the self parameter so that's where the self parameter comes from there's a little bit of mangling that goes on and it's partially hidden from you in other languages it's completely hidden from you but in Python you see some of the ugly ugliness Serena so the question was how did python know that the that the par that the parameter was Mitch because let me comment this out so we know explicit what I'm talking about so Mitch is a reference to a person that is you know represents me on a computer right python knows that this object is of type person right because it's it chunked that memory and made it of type person so when it sees this reference and it knows it's of type person it says and it sees this Dot and get age what that automatically tells python is hey this instance of person is trying to call a method does this class have a method get age in this case it does right so python says oh it does so I am going to call this method person.get Ag and pass it Mitch as a self parameter so does it make sense in in somewh so basically allows you to put in the name of person in in the name the type yeah you could so you could do this I don't recommend that you do this I'm just I'm trying to illustrate where the self parameter is coming from it's you know it's much cleaner to write this than it is to write this fewer keystrokes too remember programmers are lazy so but it'll do the same exact thing so can I move on now right wow I've only got three minutes left I don't think I'm going to be able to get through this so my intent with this code was to show uh inheritance with shapes because that's kind of the classic I'm going to define a base class called shape and I'm going to give it some methods area perimeter uh EQ and less than for my purposes shapes are equal if they have the same area uh and they're less than if the area is less than so we're you know when we're doing logical comparisons we're comparing areas so so now I'm going to define a class rectangle it inherits from shape all right it's got two sides or the lengths of two sides right so the area is pretty easy a multiplication and the perimeter is just the sum of the the four sides and then I'm going to find another shape Circle it's got a radius and it does the area and the perimeter and the way that you expect a circle to do the area in the parameter and then I've got Square which is a subass of rectangle because the square is just a special case right and all I'm going to do is when I initialize my Square I'm just going to make it a re I'm just going to call the rectangles knit method and give it the same side twice all right so what this gives us is uh some inheritance and some nice properties so first off when python gets to this line what's going to happen s is a type shape right so what is the method for shape what's that the method uh meth what is what does the area method for shape to because that's what I'm calling here it's going to yeah so voila all right and the reason is is that we haven't implemented it here this method is a it's a placeholder it's saying that if I have a shape it should have an area method all right and this is something that you saw on your you should see on your problem set when you're doing PS5 with trigger doesn't do you can ignore ITC yeah it reminds you yeah like com what's that it's kind of like com it's like commenting except that you get a little bit nicer error checking so um it is a way of explicitly saying that if I have something that is subass from shape then I can be guaranteed that there is an area method but um um if I subass off it so rectangle square and circle they all have concrete implementation for areas so this is all going to run fine all right and then I have my equality operator and my lesson operator those will run fine so let me all right and then the reason why this is useful and kind of the big idea is if I have a a list of shapes circle square and a rectangle then I can treat them all exactly the same because they all have an area method which is defined on a shape they all subass from shape so it'll all it'll print all those areas and then if I wanted to I could even because I have a list I can call the sort method and because I've to finded the less than operator it'll sort the lists into ascending or or the shapes into ascending order by area and that's what this last bit of code does unless I comment out my assignment there we go so I know I rushed through the shape implementation and I'm sorry but I'm actually out of time