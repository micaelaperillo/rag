the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit mitop courseware at ocw.mit.edu good morning Professor good tag has to be out of town today my name's Professor Grimson I'm going to be subbing for him and just to show you how much we value education here at MIT and especially in eecs you get the incoming Chancellor as a substitute teachers so how cool is that all right maybe not very cool but I'm going to talk to you anyway for the next 50 minutes uh at the end of last lecture I think John Professor good tag introduced dictionaries to you really powerful type uh it's got a great capability which is it's a tool a data type that lets you associate almost any kind of structure with a key so it could be that you're associating keys with numbers you're associating keys with strings but you could be associating keys with other things including dictionaries and I don't know if he showed this to you or not but those keys themselves can also be really powerful it could be just a string but the key could also be a tupal or a list an x and y coordinate or a set of names or other things so it's a really great data structure to use now one of the things you could qu or ask though is Gee what if python or whatever language you're using didn't come with dictionaries could we still get the same power and the answer is sure so I want to show you a little example it's on your handout if we look at this little procedure up here at the top key search I could build it out of lists right I could just use a list as my way of storing it so let's look at what this procedure says it says okay if I've got a list and I've got a TK I could write a little Loop that just walks down the list saying is the first part of each element equal to the key I'm looking for and if it is I'll return the second part of that element and if I get to the end of the list I haven't found it I returned none so notice I'm making a choice here I'm assuming that I'm storing in the dictionary things that are lists too long key in the associated value another key in the associated value another key in the Associated value but this would work fine so if I didn't have dictionaries I could build them if I wanted to things make things that had more complicated lookup I'd have to make sure that that equality test did it but you could see how I might do it all right so then question then could be so why did we bother with dictionaries if we could just use it with lists and here's my question to you so how long in this implementation is it going to take me to figure out if something's in my dictionary oh my God he's asking questions at 10:00 in the morning this is really terrifying somebody help me out how long yeah um probably on average the order the size of the list yeah B right on average it's going to take me half the size of the list but that's the same thing as being the size of the list so if that list is really long I'm toast if it's not in the dictionary in fact I'm going to have to go all the way through the list before I get to the end to decide it's not there so this is not as efficient in implementation as we'd like now the flip of that is you can say okay how long does it take for the dictionaries the built-in associative retrieval that you have inside of Python and the interesting answer there is that that retrieval is constant takes the same amount of time independent of the size of the dictionary and that's wonderful we're not going to talk about how today you're going to see that later on in the term but it is something that drives home if You' like the point that different data structures have different costs and while some are easier to implement in they may not be as efficient some may be a little more difficult to implement in but they are much more efficient and that's one of the great things about dictionaries okay the second thing I think you saw at the end of last lecture and I want to just highlight in a slightly different way is I believe Professor gag showed you a little example of a very simple translation function right we had a little dictionary I'm going to give you a version right here I'm going to uncomment it in fact there's a little dictionary that simply Associates English words with French words and yes it's pretty simple but it's a little way of pairing those things up and the idea would be if I had a sentence just a string that consists of a bunch of words I'd like to translate that English sentence if I can into French and let's look at the code that's going to do it I'm going to again uncommented here it's on your handout I want to walk you through it okay so first thing I'm going to do is actually write a little procedure that says given a word in English I want to find the corresponding word in French and that's pretty easy right it says if give me a word and you give me a dictionary I'm just going to look it up in the dictionary that's just that associative retrieval it does all the work to go into the dictionary say if that's a key for something in the dictionary it's going to give it back to me and in particular I can get it back by simply retrieving it out of the dictionary now notice I'm doing this a little more carefully I'm not just directly going and saying give me the thing corresponding to the word in the dictionary because it might not be there so that test basically says if the word is in the dictionary it'll return true and in that case I get out the corresponding element if it's not in the dictionary I'm just going to be stuck with the English word so we'll just return word okay now let's look at the more fun part of it I now want to translate a sentence and the sentence is a string of of words I need to find where the words are I need to look them up I need to gather together a translation so notice what the heart of this thing does right down here in this part of the loop that I'm going to highlight right there oops I misid that let me try it again right there what's that doing it's walking down the sentence sentence is just some big long string and it says for each character C in the sentence I need to find where the word is so I'm going to keep walking along until I find a place where there's a space so that first test there saying if C is not a space just add it on to the end of word oh yeah I need to have initialized word which I did right up here I said let's set word to just be an empty string so I'm just walking along the sentence until I find a space until I do that I'm just gathering together all of those characters so I'm building up the word when I get to the place where in fact C is a space and here's what I'm going to do I'm going to translate the word using that procedure I did wrote it looks it up in the dictionary it either gives me back the French word if it's there if not it just gives me back the English word and oh yeah I'm doing a whole long sentence so I need to add it together so I'm simply going to add it to the end of what I've translated so far and I'm doing a slightly funky thing in there I'm inserting a space in between just to keep the word separate and of course I need to have initialized translation up here which I did to be an empty string so what's this do walks along character by character when it gets get to a space it says I got a word find the translation add it to the end of this other internal variable and keep going and I'll do that till I get to the end of that sentence and then I'll just return the translation nice little iterative Loop and it's simply using two pieces to make all of this happen I lied to you sorry I I didn't lie I misspoke to you okay which is what's that funky thing at the end this what's it returning it's returning this strange thing that says translation starting with the first element a copy of all of that plus a translation of word so what assumption am I making about the inputs that causes me to do this strange thing at the end I'm actually making two assumptions about my input but I'm making a particular assumption why do I not just return translation when I'm done why am I doing this last piece anybody help me out boy I notice everybody sits way back at the back where I can't make any eye contact how do I characterize words in my string have to end with the space Oh is there a space at the end of my examples well I guess I haven't shown you an example but I'm assuming if I give you a sentence you don't usually have spaces at the end of sentences so I'm making an assumption is that the words except for the last one are characterized by spaces so this last little piece here is to get the very last word and translate it because it won't be a space right let's try a couple of examples let's just un translate sorry uncomment these and let's see if this does it oh yes commenting them again is not a good idea we'll go the other direction okay looks like it did it right right Jean we should have translated jean into Jean I don't know what the hell Eric is in French but jean dup Eric B Du John has that right he eats bread I like to drink wine and of course t a c00 or in this case Everyone likes 6 Z you just got H credit by the way for you know listening to me do French really badly right okay as I said I made an assumption which is that the car the words end in spaces what's the other assumption I made here I know you're just looking at the code but I made another assumption inside of my code and it's always good to figure out what those assumptions are yeah you assume that the first word is a noun so you don't have translation I didn't assume that I could if I was doing more clever translation but I actually making no assumptions linguistically here well I'll give you a hint how many spaces do I have between words just one right I'm sort of building that into this assumption it's a reasonable assumption to make but it points out if I wanted to improve the code I should think about these other cases and of course to build a real translation system I need something much more sophisticated all right so just shows you a little example of using the dictionaries but I want to use this to lead into the the main part of today's lecture which is why did I write this separate little procedure up here called translate word I could have buried that inside the code and the answer is is twofold first one is it saves small amount of code right if I don't have to use it sorry I'm going to use it in multiple places I don't want to rewrite the code okay and that actually is valuable not just to save you typing it means I only have to debug it once it's one piece of code but the real reason I wanted to introduce it is it gives me what you might think of as modular abstraction those are fancy words that basically say I am isolating that function in one place if I decide to change how I'm going to translate words I don't have to search through all of my code to find all the places where I was using that I just need to change the definition of that procedure and I agree in a simple example like this it looks pretty simple but if you got a million lines of code you're using it 10,000 different places you don't want to have to find all the places to change so this is an example of modular abstraction isol ating where that thing is and that is an example in fact of a general problem solving principle we're going to use called divide and conquer right divide and conquer is basically the idea of taking a hard problem and breaking it up into some simpler pieces or into smaller problems where those smaller problems have two properties small problems are easier to solve than the original one more importantly the solutions to the small problems can easily be combined I want to stress easily to solve the big problem and we're going to look at a bunch of examples today to show that this is a really old idea Julius Caesar used it he did it in Latin my latin's terrible but it's something like divid impira which literally means divide and Rule but that's how he created the Roman Empire um the British knew this really well that's how they controlled the Indian subcon brilliantly for several decades um Ben Franklin actually knew it in particular he knew how good the British were at this so there's a famous quote I mean you may well remember when he signed the Declaration of Independence he said quote we must all hang together or assuredly we will hang separately meaning divide and conquer is going to be a real problem okay so second H credit for you we just did some history why are we going to use it today boy you're a tough audience I noticed by the way that's all right we're going to use it today because we're going to use it as a tool for problem solving and in particular we're going to use it um with one particular example you're going to see divide and conquer later on in the term when we talk or when Professor good tag talks about algorithm design today I'm going to show you one great technique for doing divide and conquer kind of uh algorithms and that is the technique of recursion how many people here have heard that term used before by computer scientists okay not to worry um if you've heard it you probably think that it's a really subtle programming technique I'll let you in on a secret that's a PR job it's what computer scientists tell you to make you think that they're much smarter than they really are it's not subtle and it's much more than a programming technique and we're going to talk about it okay okay now it gets used not just as a programming technique it gets used two other ways in computer science and we're going to talk about both is both a way of describing or defining problems so it's a way of characterizing a problem independent of how we might implement it and it is a way of Designing Solutions so an example of divide and conquer let me give you an example just to show you why a way of defining a problem um consider the part of the legal code that defines the notion of a natural-born US citizen I remind you to be eligible to run for president which I hope you all do you have to be a natural-born US citizen definition has two parts part number one anyone born within the United States is a natural born citizen part number two anyone born outside the United States both of whose parents are citizens of the United States is a natural born citizen as long as one parent has lived in the US okay a little more complicated what's that actually say well it's got two parts and that's what a recursive definition has the first part's simple you're born here Natural Born US citizen notice the second part it says if you weren't born here you might still be a natural born citizen but what do you have to do you have to decide if your parents are US citizens which they could be by having been born here but there are other ways to be naturalized and that may require you determining if your grandparents or US citizens which may require you to ah so you may have to chain down a several sets of problems those two parts are what exactly we're going to use when we talk about recursive definitions there's what we call a base part which typically describes the simplest version of the problem and then there is a inductive part that tends to describe um how you reduce the problem to simpler versions of the same problem so in fact let me write those both down we have it's called a base case and this typically gives us a direct answer just tells us very simply using very simple methods whether this is something that satisfies that recursive definition and then there is the recursive or inductive case and here you reduce to a simpler version of the same problem plus some other simple operations okay again bunch of words let me show you some examples I'm going to start with well I'm going to start with three or four different examples just to show you how quickly we do this what I want you to see in all of these examples is that when I describe the problem I'm describing it in terms of what's the simplest case and then how do I build solutions to bigger problems from solutions to smaller versions of the same problems okay here's the first case want to do suppose I tell you I want to build a little procedure to do exponentiation integer exponents okay I want to compute B to the end but I tell you I got a really cheap machine and all I can do is multiplication okay so I can't use x mathematician a course 18 person would say what's B to the N that's B * btimes b n times right how could I solve this well recursively I'd like to say suppose I could solve smaller versions of the same problem and if somebody gave me a solution to that smaller version how would I build a solution to the bigger problem oh that's easy that's the same as B * B the N minus one all right I can see you're all going well duh you know I guess is what chancellors know they're not very bright of course you know that but notice what I did I've now reduced it to a simpler version of the same problem okay recursively this basically says if I wanted to solve B to the N it's B * B to the N minus one oh yeah but I got to figure out when to unwrap this so there's an if there and that's true as long as n's greater than one actually as long as n's greater than than zero we'll do it that way and if n's equal to zero I know the answer is just one I know you don't believe me but that's really cool why is it really cool what do I have I have a base case n's equal to zero I know the answer right away if n's bigger than zero oh let's assume that I got somebody who will give me the solution to that smaller problem when I get it I can just use it do the multiplication and I'm done and so in fact here is a simple piece of implementation of that which I know is not in your handout but I'm just going to show it to you because I simply want you to see the form of it it's an exact python translation of what I just said says if I want to take an exponent of B to the N if n is equal to zero just return one if not solve smaller version of the same same problem right there same call or not same call call to the same procedure same function a different argument and when I get that answer back just multiply it by B and return that this may look a little funky right this is the kind of thing that your high school geometry teacher would wrap your knuckles with although they're not allowed to do that anymore right you don't Define things in terms of themselves this is not geometry say programming and this is a perfectly legal recursive definition of a problem it will stop because it will keep unwinding those recursive calls till it gets down to the base case and I'm going to show you an example of that in a second I want to show you a much nicer example of recursion and again part of my message here is when you get a problem don't instantly start writing code think about how do I break this down recursively so I have brought some very high-tech tools with me today this is my version of the Tower of Hanoi problem how many people know the problem the Tower of Hanoi only a few okay so here's the story there's a temple in Hanoi staffed by a bunch of monks in that Temple there are three tall jewel encrusted spikes mine aren't nearly as fancy and there are 64 golden discs all of a different size stack starts out on one of those spikes and the monks move one disc at a time their goal is to move the entire stack of 64 from one Spike to another and the rules are they can move at one one disc at a time but they can never cover up a smaller disc with a larger disc okay I have to tell you I don't know what happens when they move the entire stack I mean the universe ends or you all get A's in 600 or something equally as cool question is could we write a piece of code to help up the monks to tell them how to move them all right so let's figure this out and I'm going to show you some examples so I want to move a stack of size one well that's not very hard watch carefully because you're going to write code to do this right I want to move a stack of size two so I got to just make sure that I move the bottom one off that's not so hard now I want to move a stack of size three I got to be a little more careful because I can't cover up a smaller one with a larger one but that doesn't look very hard got the solution right now we go for a stack of size four this one definitely takes a little bit more care because you really can't cover it up but as long as you do it right you can actually move the oops and I didn't do it right you got to move the pieces in the right way I do this for uh taking off of Harvard students in Harvard Square by the way right got it really easy to see the solution right you could write code for that right now I'm not going to do five but right it's really easy to see the solution yeah okay I blew it too I did one move I had to backtrack on let's think about this recursively what's the recursive solution break it down into a simpler problem or problem of a smaller size ah here's the solution to solve this I've got a stack I've got a stack I'm going to I got a spare stack what's the solution you take a stack of size n minus one move it onto the spare stack now I got a simple problem I can always move a stack of size one and then I move a stack of size n minus one to the Target and of course how do I move a stack of size n minus one well I just unwrap it one more that's a really easy explanation right and it's really easy to write code to do exactly that so let me show it to you and again I know this isn't in your handout but I just want you to see it and you could write this yourself I'm going to write a little procedure right here called Hanoi what are my arguments I'm going to tell how big a stack there is that's n and I'm just going to give it labels the from stack the two stack and the spare stack look how simple the code is says if it's a stack of size one just move it I'll just print out the instruction move it from the from stack to the Target stack or the two stack if it's bigger than one what do I do I move a stack of size n minus one onto the spare stack I move a stack of size one which is what's left onto the Target stack and then I move that stack over here that's on the spare stack over to the Target stack it's what I just showed you right there okay so let's try it oh yes I know I still like French okay we're going to do Hano we'll move a stack of size one and we'll just give this some labels just from to and spare well da you just move it there all right let's try a t a stack of size two it's just what I did I'm sure you remember that that's a little more daring here there's the solution to move a stock of size five I'll let you check it separately make sure it's right one of the things you can also see here I'm not going to talk about it you might think about it ask your ta and recitation is how long does it take to solve this problem how long is it going to take those those monks to actually move a stack of size 64 I'll give you a hint the answer is measured in billions of years this is an exponential problem and you can kind of see that growth right away that's a separate topic but notice coming up with that Solution on your own maybe not so easy thinking about it recursively very easy to think about and that's the way we want to look at it okay let me give you another example of breaking a problem down recursively and then writing the code to do it I want to decide if a sentence is a palindrome remember what a palindrome is it is not an exg Governor from Alaska it is a string of characters I guess or an airport in Alaska it's a string of characters that have the property that they read the same front to back you know the most famous One in English which is of course amusing because it's attributed to a Frenchman is Napoleon supposedly saying Abel was I a I saw Elba okay same thing back to front how would I write a piece of code to decide if something is a palindrome I'm going to do it in a second you got it on the handout but let's think about it for a second what would the base cases be or base case somebody help me out what what's a good base case here what's the shortest possible sentence I could have I a uh don't worry about whether it's a legal sentence or not I might need a verb in there right base cases presumably if I've got a a string one character long it's a palindrome if I got a string zero characters long it's probably a palindrome as well okay how would I take a longer string and break it down into a simpler version of the same problem to decide if something's a palindrome anybody want to help me out is that a hand up there or are you just scratching your head okay well yeah uh maybe take the first and last elements see if they're equal if they are then cut them off and yeah right what's a pal the easy way to start it is take the things at the end first and last character if they're not the same it doesn't matter what's happening in the middle this thing can't be a pal androme so let's check those and oh yeah if those are the same character and I pull them off what do I have I have a smaller version of the same problem I have a new sentence that's now two characters less do the same thing say is that a palindrome so if these characters match and that's a palindrome I'm done how do I tell if that's a palindrome check if they're two characters match and the things in the middle okay so look at a little piece of code to make this happen I'm going to do it in a couple of pieces here's the first piece I'm going to write I'm going to walk you through it okay first thing I got to do is I'm going to do this outside of the recursive call is I need to convert a string that's put in to make sure that in fact it's in a form I want so I don't care about the spaces right able was I ER I saw elbow the spaces aren't in the same places that's Cas it's really are the characters and I don't really care about capitalization so this little procedure basically says given a string convert it all into lowercase if you haven't seen that I'm just importing from a module called string some built-in procedures and this one simply takes the string and makes it all lowercase and then what do I do well just like we did before I'm just going to walk down that string gathering together all of the characters so this little Loop just says let's initialize ants to be an empty string and then for each character in s if it is a lowercase character and that little test simply does that it says if it's in the set of lowercase characters I'm going to add it to the end and when I'm done I'm just going to return answer I'm going to return the answer all right little procedure and by the way this is a nice piece of programming style as well I want to separate out things that I want to do once from the things I'm going to call multiple times so I don't need to recheck every time that my string is all lowercase I'm just going to convert it out all right now let's look at how do we test this well it's literally just a translation of what we said but let's look at the pieces says if I give you just a string of characters I've gotten rid of the spaces I've made it all lowercase what does it say to do I got to check for the base cases and here I'm actually going to be careful we could have discovered this if we programmed there actually are two base cases here which is is the string of length one or is it of length zero why would I end up with two base cases why don't I just check for a string of length one yeah exactly I have an OD and even number of characters so as I'm clipping them off the ends I might end up with nothing in the middle or I might end up with one in the middle exactly and we might have discovered if we tried programming but right exactly right so I can capture that by just saying if the length is less than or equal to one which gets both of those in that case we know it's a palad Drome return true otherwise what do we do well we do what the gentleman over here suggested we take the first and the last character of the string again to remind you s with an index of minus one goes backwards one if you like and gives me the last character if those two characters are the same I've now reduced it to a simpler version of the same problem so I simply say if that's true and everything else else is a palindrome return true now if you've not seen this particular little funky form right here that is taking string s and saying give me a copy of everything starting with the first which means not the zeroth element and ending with everything up to but not including the last element you'll use this to make copies of other kinds of lists but that's all that's doing it's saying give me what's in that string throwing away the first and the last element and that gives me exactly the recursive call I want I'm now saying what if the first and last character are the same and if what's left over is itself a palindrome I'm golden okay now let me just wrap all of that up in a little piece here I'm going to uncomment this okay which is simply going to say I'm going to print out or put a comment in it and I'm simply going to put the two pieces together given a string I'm going to convert it into all lowercase characters and then I'm going to check is this thing a palindrome so again let's um and let's try some examples so we'll pick on Professor gag his name is almost a palindrome but not quite so we're going to give him a name change helps if I can type oh good right G tag is not but G tug whatever that means in German is because the G's the U's and the t's all match up oh and let's see let's try a couple of other ones here and I actually type these in we'll check to see if Napoleon really was right when he used his palindrome and if you can't read this last one it says are we not drawn onward we few drawn onward to and I can't read the tail end of that to New Era okay and if we try both of those they are what's my point you're wondering I solve this problem by simply breaking it down into to simpler versions of the same problem that's the tool that you want if you were just trying to think about how do I keep track of my indices as I'm walking along I'm going to come in from both ends so I got to add and some track and I got to make sure I'm checking things you could write a nice iterative Loop that would do it actually I'll take back the word nice you could write an iterative Loop that would do it but it is not crisp it's not clean and it's really easy to screw up or you could say let's take advantage of recursion let's just break it down into a simpler version of the same problem you get a very nice simple piece of coat now this may still feel a little mysterious and I wouldn't blame you if it did so let's do the following Sor I'm going to comment these out so that we're not constantly looking at them and I'm going to show you what happens if we actually look inside of this thing to see what's going on so just give me a second here we're going to comment all of those out and let's build a version of this that just prints out as we go along okay so I'm going to show you right here okay it's the same basic pieces and actually I realize I need to leave is characters around let me go find my is characters part or two characters part sorry give me a second here I'm going to need that so we'll uncomment that region that's just doing the conversion for us I think this is going to work let's look at what we're doing here this is exactly the same thing but I'm just going to put some print statements in it which as I've already as I'm sure you've already heard from Professor good tag is a good thing to do as well I want you to see what happens so the only changes I'm making here are when I come into the thing that's doing the checking I'm going to print out a little thing that says what are you calling me with so you can see how it does the work and then with it's a b case I'm going to print out a statement that says I'm in the base case in otherwise I'm just going to print out something that says here's what I'm about to return for the piece of the string I'm looking at so it's just instrumenting if you like what I'm going to do inside of here and the other piece I'm going to do is I'm going to have a little space called indent so that every time I call a smaller version of the problem I'm just going to indent over a little bit so you can see how it unwraps it okay and if we do this let me just run that through let's try it okay so if I call his palindrome print with gut hog it would really help if I could type wouldn't it h yes it would really help if I could type your you're all being really polite going ah he missed a character there but we're not going to tell him cuz he's going to have to figure it out for himself administrators cannot possibly do this ah notice what it did this is how you can see the recursive unwinding right it said if I'm going to check this thing out it said way up there actually I'll just do it here it said I'm going to call it initially with good tag oh the two G's worked so that recursively and notice the push in here says I'm calling it a again with utta oh that one didn't work so I didn't have to check any further and I pushed it out the other hand if I do this ah you can see all of the stages you can see it unwinding it right it says that de side of good tug is a palindrome well I check the ends and I got to check uttu I don't know what that is something interesting which says I got to check that and having decided that that soorry which means I got to check oh there's that base case of the empty one I can now return true and I'm going to open this up so you can see it from the base case true for that true for that true for that let's do one last one again assuming I can type I can't well you get the idea right it's a little messy but we go up a little bit you can start see I'm obviously just going to run out of those pieces there but notice what it's doing it's rest stripping off each of those characters in turn you can see how deep this goes in which is why you got all those weird spaces there as I keep going in but it starts off by saying I want to look at that oh to look at that I got to look at which says I got to look at you get the idea but notice the key thing I'm simply reducing it to a simpler version of the same problem you can also see that to get the answer out I got to stack up a whole bunch of things all those indents are basically held operations which is one of the properties of a recursive procedure you have to hold on to intermediate things and that can cause in some languages some efficiency issues but in terms of solving the problem this is really easy I've just broken it down into those simpler pieces and that's really nice okay so let me finish up with one last example of a recursive procedure again my goal here is to let you see what am I doing I keep repeating this but it's important solve a problem figure out how to break it down into a simpler version of the same problem one of the classic examples of recursion is Fibonacci how many people here know the Fibonacci numbers a few more good all right for those of you who don't here's the story probably heard the phrase they breed like rabbits all right it's been used to describe a population that the speaker thinks is growing too quickly works with rabbits it works if you put two pennies in a drawer there's a whole bunch of ways in which this happens okay the history of this is actually very old it goes back to 122 when a mathematician uh an Italian mathematician named Leonardo of Pisa also known as Fibonacci um developed a formula that he thought would help him quantify the notion of how rapidly do rabbits breed and here was his model his model is not great and we'll see that in a second but here's his model you start with a newborn pair of rabbits one male one female uh you put them in a pen you assume that rabbits are able to mate at the age of one month and you further assume that they have a one- Monon gation period so they can produce Offspring at the end of a month finally let's suppose that these mythical rabbits never die and that the female always produces one new pair that is a male and a female every month from its second month on and the question is how many rabbits will or how many female rabbits will there be at the end of a year H okay let's see if we can figure this out so I've got okay at month zero when this starts off there's one female rabbit and one male rabbit at the end of the first month there's still one female rabbit but she's now pregnant okay so there's still one at the end of the second month what do we have well that initial female is still there and she has produced one pair so there is a second female the end of the third month that initial female has again been pregnant and has produced and these two are still there so there are three okay at the end of the fourth month both of these females have now produced Offspring and those three females are now pregnant there are five the end of the fifth month those three females have produced Offspring those five are now pregnant there are eight and at the end of the sixth month there are 13 what did I just describe I just described a nice recursive relationship okay that says gee there ought to be a base case and there ought to be a recursive case and in fact in this case we can describe this very nicely the number of females at month n is the number of females there were two months earlier because they've all given birth so that's that many new females Plus number of females there were at the previous month who are now all in whelp Ah that's a recursive relationship if I wanted to figure out how many females there are at month end what do I have to do well I just have to say what's the base case because there's the recursive case and the base case is uh at month yeah so let me do it this way if n is equal to zero or one it's one and as a consequence I should be able to figure out how quickly do rabbits breed at least according to 12th century Italian mathematicians okay couple of things to notice here by the way sort of similar to what I saw in the towers of Hanoi problem I'm going to have multiple recursive calls right to solve this problem of size n over here I've got to solve two smaller problems and then do the simple operation of adding together that's okay it's going to change the complexity of my algorithm but it's perfectly fine to have multiple recursive calls and as I saw in my case of the palindrome I may have more than one base case that's also okay as long as I can ground this out all right so let's just look at it how would we write this let me get rid of that I'm comment that out well we can write a little procedure to compute Fibonacci okay and there's the procedure which in your handout I've got some things up at the top here that are just making sure that I got the right kinds of arguments to pass in which is a a clean or crisp way of doing it but what do I say I see if it say if either X is zero or X is one two base cases just return the answer which is one otherwise solve two right there smaller sub problems and what's the simple operation just add the two things together and return it out okay and if I do this we can check to see if we actually compute Fibonacci properly all right let's do a test FIB of zero okay says Ah FIB of zero is one let's do a test FIB of one there's my other base case aha says there they go and now let's do something a little larger okay there it is as it gets each computation it's doing it it says to get FIB of zero sorry FIB of three I got to solve FIB of zero FIB of one and FIB of Two And there's the answer and just to make sure we're really doing this well just reproduce my table over there do I expect you to get all that code right away no although it's pretty easy to understand what I do expect you to see though is notice what I did I took a recursive problem I broke it down into simpler pieces and then I used the solutions to those pieces to give me the solution to the larger Problem by the way Leonardo Pisa had it wrong um in 1859 as I'm sure many of you know a wonderful Australian or sorry yes Australian farmer named Thomas Austin imported 24 rabbits from England to use his targets for hunting 10 years later there two million rabbits being shot and trapped in Australia and FIB while it grows fast doesn't go quite that fast so Leonardo Pisa had it wrong of course as you probably also know Australia and I think New Zealand have the Wonder wonderful property of having more sheep than people um I don't know what that says other than it's a great recursive problem Fibonacci by the way actually shows up in other places um again may not be a perfect model of rabbit populations but it has some other really interesting properties one of them is if you let N get close to infinity and you look at the ratio of FIB of n over FIB of n minus one sounds like a strange thing to look at it basically tells you how quickly does FIB grow anybody know the answer to this golden ratio 1 plus root 1 plusun 5 over2 which Leonardo the other Leonardo the really good Leonardo by the way used to design buildings with so there's a very strange connection the other one thing thing I like about this is that Fibonacci uh shows up actually a lot in nature so for example did you know that the number of petals on Most flowers is a Fibonacci number um for example uh blackeyed Susans 13 pedals um daisies field daisies 34 pedals you might ask why oh sorry I'm out of town I'm out of time I won't answer it today but you can ask Professor goodtech next time around why it is that pedals come in Fibonacci numbers what's the message of this lecture recursion divide and conquer break a problem down into simpler versions of the same problem life is really easy and you'll see Professor goodtech next time