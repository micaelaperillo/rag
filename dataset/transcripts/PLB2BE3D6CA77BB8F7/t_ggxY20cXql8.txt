the following content is provided under a Creative Commons license your support will help MIT open courseware continue to offer highquality educational resources for free to make a donation or view additional materials from hundreds of MIT courses visit MIT opencourseware at ocw.mit.edu I apologize to those of you watching on open course whereare I forgot to turn on my microphone and you missed some incredibly brilliant things but such as life uh all right let me go back to where I was which was we were looking at this code to find the cube root of a perfect Cube we saw this last week and indeed you also saw it in recitation I'm not going to belabor it I do want to ask you the question uh for what values will this program terminate that is to say the only input is to X for what values of X is this program guaranteed to always stop anybody want to volunteer an answer to that ask a simpler question let's assume that X is uh a number in fact let's assume that it's an integer will it terminate for all positive integers all positive values of X yeah all negative values as far as I can tell how about zero yeah so in fact it terminates for all values of X how do I know that and that's a key question I know that because I've used and I mean by used as a mental tool something in my head the notion of a decrementing function and every time I write a loop I think about one of these because that explains to me why the loop is guaranteed to terminate we'll go over here where we have a bigger board and look at the properties that a decrementing function function needs to have one it will map some set of program variables to an integer two when the loop is entered for the first time or when I encounter the test of the loop for the first time its value is non- negative three when its value gets to be less than or equal to zero the loop terminates and finally four it's decreased each time through the loop so what we see is if it starts to be a positive value or non- negative and it's decreased every time I execute the body of the loop that eventually it's got to reach zero or something less than zero and when it does the loop stops if such a function exists then the loop is guaranteed to always terminate now of course one can count up to a value instead of down but there's always a trick we can use of subtracting to make it the same so what's the decrementing function for this Loop how did I know it will always terminate yeah answer equals answer + one I don't think so does that satisfy all of these properties remember a function is going to map some set of program variables to an integer so what are the interesting program variables here well there are only two ants and X right at least that's all I can see so what would be an interesting function somebody surely there's someone who can figure this out yes or no you're just scratching your head you fooled me I can't see because of the light but I'm sure there must be dozens of hands up if I could only see them actually I don't see any hands up all right this is not so hard guys it's the absolute value of x minus answer cubed so what is this value start at let's pick a value let's try suppose that X is equal to uh eight what is the initial value of the decrementing function wow come on let's be a little Cooperative please yes so it's answer is z and absolute value of x is so it's 8 - 0 which is equal to 8 so it satisfies uh conditions one and conditions two what happens to this value every time through the loop does X Change does answer change and how does it change it's increasing where does where does answer start at it starts at zero and it increases so I know that answer cubed will always be positive right so I know that every time through the loop it will be eight the first time through it'll be 8 - 1 cubed which is 7 and the next time through it will be 8 minus 2 cubed which is zero and then I exit the loop and it's that kind of reasoning that I use to convince myself that this Loop terminates and every time I write a loop and I hope every time you write a loop you will think about what's the reason in the loop is going to terminate and you will do it by thinking about what the decrementing function is all right people get me on that and whoever finally answered a question surely deserves to be fed I obviously have to bring better candy to encourage better qu responses okay now let's go back and look at the program itself now that we know it stops and you can take my word for it that it actually computes the correct answer let's think about what kind of algorithm this is what's the method this is an example of guess and check and it's a particular kind called exhaustive enumeration each time through the loop I'm taking a guess to what the value is and I'm checking whether it's true but I'm enumerating the guesses in a very systematic way they're not just random guesses I'm enumerating all the possible answers if I get through the entire space of answers of possible answers and I don't find a solution then I know that it doesn't exist and it's not a perfect Cube so that's why it's called exhaustive enumeration because I'm exhausting the space of possible answers does that make sense to everyone so let's try it let's try it with uh say a very large value of x because that's always an issue of course when we do exhaustive enumeration so I'm going to enter this value all right is that a perfect Cube who thinks it is who can tell me what it is what's the cube root of that all right well this is a question I did not expect you to answer but it's 1,251 uh that'll be in the first quiz so make a note of it um notice how quickly the computer did this found the cube root of quite a large number very quickly and so while one might initially think that exhaustive enumeration is a silly technique because takes a lot of guesses for an awful lot of problems we can actually just write a pretty stupid program that solves it by exhaustive enumeration we typically would refer to such programs as brute force and brute force is often exactly the right way to solve a problem why does it work because computers are really fast uh how fast are computers well today a good computer can execute in a single processor on the order of a 100 million instructions a second how fast is that and now we're going to see if Mitchell has answered the question I asked in the way in the class how many instructions can a computer execute between the time I say something and the time the people in the back row hear it Mitch thinks it's 400 million instructions I think that's about right it's hundreds of millions at any rate that's kind of amazing between the time I say something and the time you hear it hundreds of millions of instructions it's mindboggling how fast that is and that's why we can often use these kind of solutions next lecture actually even a little bit later in this lecture I hope to get to an example of why that doesn't really get the job done uh at least not always before before I do that I want to look at one more programming construct and that's a variant on the while loop so if we think about what the while loop we were just looking at did or does as the decrementing function told us it's looking at all the possible values of answer ranging from zero to the absolute value of x and at each step testing and doing something we can abstract this process using something called a for Loop all right so let's look at this code it's essentially exact the same algorithm I got bored of typing ants times ants times ants so I used the python notation for exponentiation which you'll see is star star now easier to read if I get rid of that so but other than that the interesting thing I did was replace the while loop by a four so you'll see this line of code there for ants in range Zer to abs of x + 1 what that says is range is a built-in function of python that generates in this case a sequence of integers something called a tupal which we'll be looking at in a lecture or so but for now it's pretty simple to think about what you get is if you look at the expression range of x to Y that gives me a sequence of values x x + 1 up to Y -1 notice not up to Y but up to Yus one so it gives me length a sequence of length y well starting assuming that's zero right doesn't have to be zero it can be anything can be another value as as well it's zero in my example and then the for Loop executes it on this value then the next iteration on this value and finally at the very end on that value value so it executes it one iteration of the loop on each value in this sequence of values generated by the range statement and normally it does all of them however you'll see I've added something called a break here a command in Python and what break says is exit the loop so it exits it prematurely without executing all of the values generated by range you can Nest Loops just like you nest if statements and if you do that break always executes or always exits rather the innermost Loop so what this does is it generates a set of values to test it checks whether or not it's got the answer if it does it terminates the loop and eventually you exit the loop and then it just checks as before whether or not it found a correct answer and does the right thing so you'll find particularly when you're iterating over integers but later we'll see when you're iterating over a lot of other kinds of things four Loops are a very convenient shorthand there's nothing you can't do with the while loop you don't need for Loops but they do make life easy and over the semester I think you'll find you'll end up writing a lot more for Loops than you will while Loops okay any questions about this if not I'm going to move right along so this is the moment all right I'm going to move right along so we've now got a program that does something really silly really it finds cube roots of perfect cubes that's not typically useful right I mean you've even got these 50 Cent four function calculators that find say square roots and they don't insist that you only give it perfect squares so now let's think about how we would take this kind of program and indeed this kind of method of writing programs and use it to find for now we'll look at the square root of any number of any floating Point number well the first question we need to ask is what do I mean and that's kind of a subtle question what does it mean to find the square root of a number number what does it mean for example to find the square root of two well we know that that was an endless series of uh digits before we can find the square root of two right it does not have a nice answer so we can't just say we have to find something that if we multiply it by itself it will equal two because we can't find such a thing so we've got to think about a different notion of what we mean furthermore even for some numbers for which there is a square root it might be a million decimal places long and consequently really hard to find so we need to think about a different kind of concept here and it's the concept of an approximation finding an answer that is good enough so what should we do here how do we think about this typically what we do when we think about an approximation is we Define how good an approximation we're willing to accept so for example we might want to say all right I want to find a square root that lies within Epsilon of the true square root so find a y such that y time Y is equal to what what does it mean how would I express it within Epsilon of the perfect answer I don't want to say it's equal to X because that may be impossible or too time consuming to find so really what I mean is X plus or minus Epsilon right so that's what I'm asking find one that's close enough and that's what the next piece of code I want to show you does whoops excuse me so I'm starting just giving it a value for x so I don't have to keep typing one in let's say it's 25 um I'm going to take Epsilon to be 0.01 so I want it within that distance of the true answer um I'm going to keep track of the number of guesses here not because we need it to actually compute the answer but because I want to then discuss how many iterations of the loop we're doing going to start by setting my first guess at 0.0 again this is going to be a exhaustive enumeration then I'm going to essentially encode this as the test of my while loop while the absolute value of answered squar minus X is greater than equal to Epsilon and answer is less than equal to X so it's now a more complicated test I've got a Boolean value two things have to be true to execute the body of the loop I'm going to increment answer by a tiny amount increment the number of guesses just so I can keep track of it um maybe I'm going to comment this out for the first go around just so we don't see too many print statements and keep doing it and when I'm done I'm going to see whether or not what I found is indeed a square root or close enough so if we think about why this Loop terminates why am I guaranteed that this Loop will terminate what's my decrementing function here somebody what's the decrementing function what am I guaranteed to reduce each time through and when I get through I'm done yeah uh no close sort of but I appreciate your trying that's worth something just for the effort somebody else remember if we look at the properties it has to have it's going to guarantee me that when it gets to the right value I exit the loop which suggests it's going to certainly be part of the test of the while just look at this piece over here at the end right answer starts at zero I keep incrementing it eventually answer minus X will hit a value right eventually I'll get to the point that this condition must be true must be false rather and then I exit the loop so this piece is not really the key it's this piece that guarantees me I'm going to get out eventually this piece can get me out sooner it's kind of an optimization if you will all right so I'm just going to go until I find the answer let's see what happens when I run it all right it tells me that 4.99 Etc is close to the square root of 25 so there's some things to to note about this first it didn't find five 25 happens to be a perfect square yet I didn't find it is that okay yeah because that wasn't what I said what I said is find a y that has these properties over here and I did I didn't say find the Y that gets closest to the square root of x I said find one that has these properties effectively what this is is a specification of the problem and I've now written a piece of code that meets the specification it does what I set out to do and that's good enough now let's turn this comment this print statement back on took almost a half a million guesses to get there um but it was still blindingly fast so once again exhaustive enumeration seems to be okay suppose however I choose a a bigger number now first let's choose something that uh doesn't have a good answer let's see what it does for that all right pretty good also pretty fast not too many guesses but now let's try this one well it's going to wait it's going to get done but it's going to take a little bit longer than uh maybe we want it to take why is it taking so long there it is it found a an answer which I think is good but as you can see it took quite a few guesses to get there so why well let me at first ask this question can we look at the code and anticipate how many guesses it's going to have to take we're going back into this issue of computational complexity but here not of the problem but of the solution so this is algorith mic analysis we're analyzing the algorithm this exhaustive enumeration algorithm and trying to figure out how long it's likely to take to run what do the running time of this algorithm depend upon yeah it depends on the actual square root um yes but in particular the distance of the actual square root root from the starting point so that's one factor it depends on but that's not the only Factor what else does it depend on o do we have an injury we had a dropped pass and a deflection there all right um yes also depends on the level of accuracy so how you define Epsilon it also depends upon the value of Epsilon absolutely but how long it takes to run someone with a concern for safety all right um it depends upon the actual value of Epsilon because if Epsilon is small um we'll we may have to take more steps to get a precise enough answer and it depends upon one more thing yeah on the increment the increment exactly because the number of times we go through the loop is going to be related to how big a step we take each time through no applause thank you all right so it depends upon all of these things and here since we're trying to find a pretty brri square root and a sort of precise answer but we're taking Tiny Steps it's going to take a long time to execute so we could make it faster for example suppose I change the step size to uh to this plus equal by says increment the value by whatever the right side is so I'm going to increment it by one well it was really fast but it didn't work it failed all right that's not so good uh so I can't just do that and of course it's not surprising because I ended up jumping over the answer I could make Epsilon smaller but that seems like cheating um so really what I need to do is find a better algorithm a better way to attack the problem fortunately I don't have to invent it some people a lot smarter than I am figured out a long time ago a good method for solving this kind of problem and they're doing it using something called bsection search as we look at this particular implementation of it we're going to use two algorithmic techniques that you'll use use over and over again because they're generally useful so the first one related to bsection search is we'll cut the search space in half each iteration so with my Brute Force algorithm we're trimming the search face only a little bit each step so if we think about it what it looked like we had a space of values to search for the answer and I started here and each step I just trimmed off a tiny tiny little bit 0.001 leaving me a lot of space to search and that's why it took so long when I do bsection search the basic idea is each step I want to cut the search space in half get rid of half of the search space each time so one way I could do it is I start with a guess say in the middle just pick some guess that's in the middle of my search space and now I say is it too high or too low I can easily answer that question I Square it see is my result bigger than the actual square root or smaller than the actual square root and that tells me whether my guess is too big or too small once I know that I know which side of the guess the right answer is on so if I knew that my guess was too big then I know there's no point in looking over here for my next guess so I can get rid of this whole half in one step now what should my next guest be yeah my next guest should be half way through there exactly oh and now you'll note let's say this time my answer is to small then I know I can get rid of this so now I'm very quickly pruning my spch space if I think about that how many times am I likely to have to prune it it's much faster right as we'll see later it's basically log base 2 if I have some number of values to look at and what by the way how many values do I have in my search space to start with what determines it clearly the first value and the last value but also how smaller I'm dividing it up right so I have to think about that too what is the Precision with which I do this am I looking at every one millionth of a number or every 0.01 that will tell me how big it is once I know how big my search space is I know that if I search it linearly looking at every value my worst case is I look at everything until I get to the end but my best case well my best case is I get lucky and my first guess is right but if I use bsection search my worst case is going to be log number of values in that space because each time I throw half of them away we'll see that in more detail uh later on let's go back and look at the code now so it starts as before with a value for Epsilon but now I'm going to take a lower bound here and an upper bound on my search space I'm going to say my initial guess will be the upper bound plus the lower bound over two halfway through my search space and then I'm just going to work my way through it until I get to the answer or don't find it so should we look at what's going on here let's try this well let's first make sure it works for uh a small value never test your program first on something big always try your program on something small first let's try it on that got an answer uh notice that it's different from the answer we got last time we looked for the square root of 25 but that's okay because it still meets the specification it's still within Epsilon of the actual Square square root and I didn't have to say that I wanted it below or the square root or above just said within Epsilon sure enough different algorithm different answer but equally good but a lot faster now let's try it for the big value wow that was a lot faster wasn't it it got me an answer um probably not exactly the same answer as before but pretty close but it did it in only 26 guesses pretty cool and in fact we'll see over and over again that bsection search is a really good technique for finding quick answers all right and again why is it 26 well we had some number of guesses to start with after one it was half as big then a quarter is big and eventually log two of the size but what was the size SI was it the number 1 2 3 4 5 no we already sort talked about that what was it let's look at the code and let's think about what was the size of our initial search space it's a little bit tricky to think about this right now we have to think a little bit harder about when we exit the loop because in fundamentally that's telling me the size of the search space so what determined the size of the search space well we talked about the upper and the lower bound but what's telling me roughly speaking how many divisions I have it's Epsilon right it's not 0.01 because when I Square it it gets to be a has to be smaller than 0.01 but that tells me roughly how many I have and so it's going to be roughly 1 2 3 4 5 divided by 0 01 squared which turns out to be 26.89 7 more or less so we could predict it and son of a gun when we ran it we actually matched the prediction that's a great thing about algorithmic analysis we can actually get accurate guesses as to how long a program is likely to take to run this is an important thing because sometimes we do that we say oh it's going to take a year I better not even try I better find a smarter algorithm or we do it and say well it's going to take almost no time at all I'm not going to waste my time looking for a smarter algorithm I'm going to live with the one I've got it's important and again as I said it's a topic we're going to get back to of course whether it's 26 27 or even 50 doesn't really matter what matters is it's not a billion right because we don't don't really care small differences whether it takes 25 or it takes 50 will be an imperceptible difference it's whether it's a huge difference that matters and that's really the kind of things we're going after is orders of magnitude now I have a question about this program I've been obsessing about whether it's fast enough and we've shown it is but does it work kind of more important it's always possible to write a really fast program that gives you the wrong answer the problem is to write a fast program that gives you the right answer does this program always work well it worked for 25 it worked for 1 2 3 4 five is that good enough probably not we might want to try it in some other values um I'll ask a simpler question does it always work on positive value all right I'll give you a hint no it does not I'm not going to however tell you why it doesn't because I want you to think about it and I want you to tell me why it doesn't in the next lecture but because I'm not a complete satus I'll give you a hint when we use bsection search or for that matter any search method we are depending upon the fact that the answer lies somewhere in the region we're searching if indeed the answer is out here or out here then it doesn't matter how carefully I search this region I'm not going to find the answer and so this program doesn't work on some potential values of X Because the actual square root of x will not lie in the region that the program is searching I leave it to you to think about what that such values are and we can talk about that on the next lecture suppose I want to use this program to find a cube root suppose it worked and I wanted to use it to find a cube root what would I have to change how would I change it so that it found cube roots instead of square roots well I could take it up I could use cut and paste and paste it into my editor and get a new program and how would I change that new program to make it to cube roots not very hard I think only two places have to get changed let for the Simplicity say cube roots of positive numbers I think you said the right thing uh all I have to do is change that two to a three and that to to a three and I'm done and I should probably change the uh message to say Cube rot pretty easy on the other hand suppose I also wanted to find the fourth route and the fifth route and the sixth root however many roots well I'm going to get pretty tired of cutting and pasting and building a whole bunch of things so really what I want to do is find a way to write the code that will find the nth root of a number for any end to do that I'm going to introduce a new programming concept and that concept is the function and that will be the main topic of Thursday's lectures