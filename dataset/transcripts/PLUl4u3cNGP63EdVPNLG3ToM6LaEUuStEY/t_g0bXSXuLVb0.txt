all right welcome to practice problem session three double o six um today we are going to go through a bunch of problems which you should have already um i was thinking of skipping the very first problem because it's just a mechanical thing if we have time at the end we can come back to it but there's not really any insight i can give you in how to approach this problem it's just do you understand hashing so i want to go into the more creative problems first i'll start with problem three two hash sequence uh so i'll just read it and then our first task is to convert the la the word problem into a concise formal algorithms thing we need to achieve then we need to come up with ideas for how to achieve it and we need to check the details that'll be our general pattern so this problem says hash tables are not only useful for implementing set operations they can also be used to implement sequences remember from lecture two we have a set uh interface which is about querying items by either key and sort of intrinsic order that's about the items themselves versus a sequence interface that we started out with of linked lists and so on and arrays for uh where we're given an order we want to maintain that order and that order may not have anything to do with the items themselves that's what we call an extrinsic order we're told what the order is by saying insert this item after this one or append this one to the end or prepend it to the beginning so in lecture last week we saw hash tables implement sets and let me just remind you some things that they can do so we have on the one hand set hashing so this we're going to need this in a moment this is just a reminder from lecture we can build one in linear time expect it we can find an item in constant time expected by key and we can insert or delete an item in constant expected amortized okay uh so this is a black box that we're given and the problem statement says that imagine you're given a hash table as a black box which means we're given a thing that behave behaves just like a thank you to uh we're given something that is a hash table but it's black box in the sense that we're not allowed to reach in and change the implementation details we're supposed to use it as is just by calling its interface so in particular we're given these three operations i'll maybe also use it to iterate through the items so we're allowed to build something in linear time find and insert and delete and constantly expect it amortized and what the problem is asking is to build out of this data structure a sequence with particular time balance uh so this is what we call a reduction in that we're going to convert uh i guess technically we're reducing the sequence problem to the set problem um because we're showing how to solve the sequence problem using the set problem but the way we'll think about it is in the other direction we're given a data structure to solve set and we're going to convert it into a data structure that solves sequence so given that we already know how to do this from lecture we're going to learn how to do this this is teaching you new stuff in a problem set so the specific bounds that we're told to achieve are build and constant expected time get and set at inconstant expected time insert and delete app and linear expected time and insert and delete uh first and last and running out of room here constant expected amortized okay um so this is just what we're told to do and now we start thinking so we're given this we want to build this um and so i'm going to tell you a little bit about my thought process about when i'm presenting with a problem like this first thing is to read the problem and see okay what what's what's the hard part here what are the challenges so clearly we have to do all for all four of these types of operations building linear expected time that's basically everything we've seen uh get or set at in constant expected time that's fast and that feels kind of like this find operation so both of these seem pretty matchy-matchy so that looks like a good mapping i'm gonna try to build these operations using those operations insert and delete uh at a specific location in constant expected time sorry linear expected time that's big linear expected time means i can rebuild the entire data structure every time i do an operation so this is easy okay that's first thing you realize this is big great so i don't really have to worry about these operations i mean i do have to implement them but it's not hard to do it that fast because i can rebuild uh and then here insert and delete at the beginning and the end of the array these are the deck double ended queue operations can certainly leave at either end and constant expected amortized time this i feel like is a tricky one uh you've seen one way to do this in problem set but now we're gonna see another way with okay the other thing to notice is these expected words uh in this case we're told to use hashing but a lot of the problems you're not told how to solve it or what you should be basing your thing on and so expected is always a good keyword because it means randomization is involved somehow if you're told the bound is going to be expected you should you probably need to use randomization and in this class the only form of randomization you will use is essentially hashing so uh that's a good hint in this case we know that we're supposed to use hashing all right so this is going to be the challenge but any ideas on how we might tackle this problem how can we so set remember every item has a key in a sequence items are just items and we're told to insert and delete them at particular locations but they don't have keys so one of the challenges is going to be to take our items here give them keys so that we can store them in a set otherwise we can't use find there's no keys there there's no way to search by key ideas so let's think about what we want to do let's start with so build i think is fine if you just want to build a data structure you don't need to do anything the hard part are the queries or updates you want to be able to do on your data structure let's start with this operation get and set at so remember get at your given and index i and you want to find the item at position i and set at we're given a position and we want to change the item stored at that position at that index i now over here what we're given we can insert and delete but the main sort of lookup let's think about get at first the natural mapping given this arrow is find find will search for an item by key so here's just staring at that once you look at all the possible pairings you could do we have find by key over here and we need to implement get at by index so let's make the indices keys okay so this is idea number one uh index assign a key to each item equal to the index in the sequence okay so then when i do to implement get ad i can just call find of i if i is also a key and that should give me the thing that i want maybe for this to make sense let me tell you how i'm building so if i'm given say an array of items uh and they're both the only name conflict here is built so let me call this one sequence build and i'm going to implement it using set build and i'll use some short shorthand notation here let's say i want to make an object that has a key equal to i and a value equal to a of i that's my object notation for i equals 0 1 to size of a minus 1. that's a little bit code-like but not quite literal code so i'm just going to use this to say let's make an object that has two parts one is called the key so we can talk about the object.key so we can see which sets want to do and we're also going to store a value which is the actual item that we're given so i'm just because these are given in the sequence i'm just representing that sequence order by assigning i to be the key and so now if i want to find the item at index i i can do find of i and technically i should probably do dot value that will give me the actual item that's stored at that position when i do find of i i'm going to get this whole object with the key of i and then i want to get the value part of it so then set at i can just use this find operation to get the object and set its value to x boom we've implemented array like semantics get at i and set at i using a set if you've ever programmed in javascript this should feel very familiar because javascript actually implements arrays it's at least at the conceptual level as just general mapping types which are they call them objects but they are basically sets and if it's even grosser they convert the integers into strings and then index everything by the strings semantically anyway implementation details can be more efficient but conceptually that's what's going on and so that's the the idea we're doing here which seems great um any any problem so i have let's see there's insert and delete app as i mentioned what i'm going to do for those operations just rebuild the entire structure and just write that briefly basically uh let's just iterate all the items iterate all items um let's say into an array insert delete one of them and then rebuild okay if i was writing a pset answer i would say a little bit more detail what i mean in this step um i've done it in the notes not that hard but we can afford linear expected time i can afford to call build again i guess technically i'm calling this build sequence build uh so i can afford to just extract things into an array do the linear time operation on the array of with the shifting and everything and then just call build again yeah questions no these are separate definitions yeah sorry they got a little close so this is the definition of get at this is a definition of sequence build yeah thanks for asking okay all good yeah can you explain the answer explain insert and delete okay so maybe i should actually write one of them down or i'll just draw a picture maybe so we have this data structure which is now a sequence data structure represents some sequence of items and my goal is to say delete the i item so there's some items in here x0 up to xn minus 1. i want to remove x i from the sequence or i guess i should drop it this way it's coming out so uh what i'm going to do is first extract all the items from the sequence and i didn't write it but there's a an interface over here called itter which just gives me all the items in order so i'm going to extract this into an array sequence let's say i'll just build a static array of size n i also have a length operation that tells me how many items are in here and the the iter operation will give me all the items in order and so i'll put into my array x0 and then x1 and so on as they come out then i go to position i and i want to delete that item and shift all the others over this is the boring this is i think we even said how to do delete at in dynamic arrays in recitation 2 pretty sure so i'm just mimicking that i'm building this just to get the new order of things and then i'm applying via the build operation i'm building a totally new sequence and that's how i would implement delete app one way there are other ways yeah um how much space is this using uh oh it problem with space if you're inserting if you're inserting you probably want to allocate a static array of size n plus one you know exactly what's going to happen so just allocate a little bit bigger then you can do the shift you could also use dynamic arrays but then you would get maybe an it's not an amortized bound because you're only doing one insertion the point is this is really easy we can spend linear time so we can rebuild the we can rebuild this array three times if we want it question uh what if you weren't allowed externally uh non-constant space ah you gotta throw me open problems uh what if you only have constant extra space uh right then i think we need to use insert and delete so we could good question um we could conceptually do this shifting but do it using insert and delete so we can so let's do the delete case again so we want to here's x i we want to replace it with x i plus 1 and so on and so we can start out by deleting the item with key i that will get rid of this guy then we can delete the item with key i plus one give it and that gives us the item and then we can reassign its key to be i i instead of i plus 1 and then reinsert it so we can take this item out it has a key which is draw this properly so we have key i plus 1 and value x i plus 1 stored in this data structure then we update the key to i and then we reinsert it and it takes the place of this guy so you could do that you could go down this list and or not the list but you could iterate for i equals sorry for j equals i to n minus one and for each of those items delete it change its key reinsert it with a new key and then you don't have to build this intermediate data structure so if you're told to have been in myspace great and maybe you think of that as simpler i like to think of this as simpler because like the point is i have linear time i can do crazy silly very non-data structuresy things where i just start from scratch okay great but there's one more set of operations insert delete first and last are these easy good shall we try uh we can insert last so this is given an item x we want to add it to the end of the structure so that means its index is going to be equal to because we start at 0 it's going to be equal to the length current length of the structure so let's just insert a new object which has key equal to the length and it has value equal to x we're done delete last similar just delete the item with key length minus one okay what about first this is supposed to add x to the beginning of my sequence well now i realize i have a problem because i want this new item to have key 0 because after i do an insert first get out of 0 should return this item but i already have an item with key 0 and an item with key 1 and an item with key 2 and so on down the way and so if i wanted to give x a key of 0 i have to shift the keys of all of those items just like we were doing here and that's going to take linear time but we're supposed to do this in constant expected amortized time so that's no good so this idea is not enough it's not a bad idea it's still a good idea but it's no longer what we actually want to do it's only morally what we want to do so what do you have any thoughts on how we might get around this problem seems like inserting at position zero i need to shift everything down linear time that really sucks yep um you could create some sort of link to something else link this data structure with another one so we could build more than one set that's certainly allowed uh i don't know how to do oh i see you're saying maybe build a whole another structure for the items that come before xero yeah yeah actually that would work i think maybe uh it's like in the pset then you have to deal with when if you delete one of them it becomes empty then things get messy delete first is also going to be a problem because i delete the beginning of this data structure then i lose my zero item and i want the new zero item to be the one item that's again all the indices shift so delete and inserting at the first is heart so we could do that trick like in the pset but or in like in less problem session and so on um but there's a much simpler idea can you have an extra very to keep track where is that nice i have an extra variable to keep track of where the beginning is call this first this is going to be the key of the uh first item index zero another way to say this is let's just use negative integers right set sets work for any keys any integer keys okay actually we technically said they should use keys zero to u minus one but then uh if you have negative numbers you can easily fold do you know the string ah python negative numbers means something else but we're not using the python interface we're using our custom magical set interface which we show how to implement in recitation nuts which can take an arbitrary key it hashes that key and you know finds a place to put that item so we're not actually storing things in order here we're storing things in a hash table but we're not supposed to get into the implementation details i think the way we presented hashing with our universal hash functions we only allowed positive numbers so maybe technically i should point out if you have positive and negative numbers you can fold this in half by mapping zero to zero one to two two to four spreading it out and then you can take minus one and map it to plus one and minus two and map it to plus three so this is like uh multiplying each of these guys by 2 and multiplying each of these guys by minus 2 and adding 1. and then you get non-negative integers out of all integers this is a typical math trick for showing that the number of integers is equal to the number of non-negative integers which may seem weird to you but they're both countably infinite so you could if your structure only supports negative keys you could map negative keys in this way and throw them into the hash table okay so now i allow negative things for [Applause] like that and so great if i want to insert at the beginning what i can do is just decrement my first variable which is keeping track of the index so initially first is going to be 0 so i'm going to add into my build first i'm going to say first equals zero because i start with key zero and when i initially build a structure and if i wanna if i need more room before zero i just set first to minus one and if i already have minus one element i'll decrement it to minus two decrement means decrease by one it shows my assembly language programming this is usually a built-in operation on most computers and then i can insert an item with key first and value x right now if i want to delete the first item i would delete the item with key first and then increment first and now all of my operations have to change a little bit let me use another color um because i was implicitly assuming here that all my indices started at i but now they start at first they index zero maps to key first and so the right thing to do here is plus first and plus first basically add a whole bunch of plus first throughout this one's probably fine if i'm globally rebuilding i can reassign all my labels but this one should be first plus plus length okay so just by keeping track of where my keys are starting i can do this shifting and not have to worry about stuff and this is a lot easier than having to worry about maintaining two structures and keeping them both non-empty and stuff like that because of if i assume my set has this power of dealing with negative integers and strings and whatever else oh why didn't i use a linked list because this linked lists are very bad at get and set at a given index this is not a linked list this is just storing a single number as integer in your data structure that says what is the smallest key in my data structure that's all it does it's a it's a counter okay so data structure keeps track of its length and it keeps track of the minimum key and so it will always consist the invariant is you'll always have keys from first up to first plus length minus one and that's what we're exploiting here we have no idea where first will be it depends how many operations you've done how many inserts at the beginning and so on but the keys keys will always be first to first plus length minus one this is what we call an invariant useful to write these things down so you can understand what the heck why is your data structure correct because of invariance like this which you can prove by induction by showing each time you do an operation this is maintained even when i'm changing first in order to maintain this invariant cool sometimes you come up with the invariant first in this case i came up with it episode uh post facto after the fact uh cool let's move on to problem three which is called critter sort and the other key thing i want you to learn about a question sorry um so when you do first first plus one is that a rebuilding of use this is just a sentence is not an algorithm or data structure this is a mathematical property this is not an assignment this is a mathematically is equal to but you are reinvesting it though because you're doing first plus one so are you asking about one of these operations like this one wait oh okay never mind i get it yeah okay so the other important takeaway i want you to get about reading our problem sets is that they have hidden humor inside i don't know if you've noticed but here's an example of a problem called critter sort ashley getum collects and trains pocket critters to fight other pocket critters in battle what is this a reference to digimon digimon wow you guys are so young pokemon the the old the ancient form pokemon is short for pocket monsters and in fact in the original anime okay actually i i don't know it was all after my time we can debate after so pocket critters is a reference to pokemons pocket monsters which is pokemon who's ashley getum ash ketchum is his full name in the english version um totally different name in the japanese version but they're both puns on collect them all right all right so that's the important stuff we'll see more jokes later so there's this setup but basically we have n critters and we want to sort them by four different things and so i'm just going to abstract this problem into sort m objects by the following types of keys and for each one we want to know what the best sorting algorithm is and there's this footnote that's very important it says faster correct algorithms will receive more points than slower correct algorithms also correct algorithms will receive more points than incorrect algorithms but that's implicit incorrect generally gets zero okay so uh part a uh it says species id but basically we have integers and the range minus and n so if i want to sort and integers in the range minus end to end what should i do reference to yesterday's lecture yeah radix sort yeah always a good answer for almost always a good answer when you have integers it's a good answer whenever you have small integers now radix sort the way we phrased it let me maybe put it down here uh radix sort sorts n integers in the range 0 to u minus 1 in m plus m log base n of u time and in particular this is linear time if u is n to some constant power okay so can i just apply this as is to these integers no because they're negative so what should i do maybe i should do my folding trick we just saw how to take negative numbers and fold them in interspersed with positive numbers if i sort that will that work no because that does not preserve order it would intersperse it's just we want all the negative numbers to come before all the positive numbers yeah just add n yup boom plus n now we have integers in the range let's be careful 0 to 2n cool now we can apply this now u equals technically 2n plus 1 because we're only supposed to go to u minus 1. but that's fine that's linear and so we can sort in linear time easy this is a super easy problem okay but in each one we might need to do some transformation all right part b is a little more interesting so we have strings over 26 letters of length at most 10 ceiling log n okay this is a little trickier what could i do again i'd like to see whether radix sort applies um i should say radix sort sorts i'd like to see if radix sort applies to do that i have to map these strings into integers somehow any way to do that this is easy if you understand radix sort yeah index the letters yeah yep we can we can map right so we can map a to zero b to one then one but we have a lot of letters there are only 26 letters but then we have uh 10 login letters in a string that is together a single key that we need to sort yeah i'm going to sort by the first first letter first start by the first letter then the second letter that is exactly the opposite of radix sort remember radix or we want to sort by the last letter and then the next the last letter and finally the first letter by the first one here it's alphabetized no to alphabetize we do want to in the end sort by the first letter but that's at the end oh wait so that at the end remember radix sorry always goes backwards from the least significant to the first to the most significant so indeed that is what we want to do you're just saying use radix work but what am i radix sort on what am i radix sorting on yeah on the on the last letters not the first letters so technically that would be using counting sort on the last letter counting start on the next last letter dot dot counting sort on the first letter but that is together radix sort on something or jason likes to call this tuple sorting tuple sort is the thing is the algorithm that says sort by the last thing then sort by the previous thing and so on you can also think of this as radix sorting on a number written in base 26. they're the same thing okay but in the end we can sort in linear time how do you tell the algorithm that you want a to come like just like not zero is less than one a is less than b right so i mean technically when you call something like tuple sort or maybe it's even clearer when you call it radix sort rakes are giving it a bunch of numbers so you're taking these strings and mapping them to numbers and when you do that you get to decide which letter is the most significant which is the least significant all right so you you will choose to always map the first letter in your string to position a two uh um value or the the position and positional notation position uh 26 to the power 10 log n right as the most significant so it's always most significant even if your string is of length one you want to put that in the most significant digit and you'll pad with zeros at the end if you run out of letters in your strings here how many times am i running counting sort oh 10 log n times whoops yeah good question good point uh computed this wrong so uh right there are log n digits in the string uh so that is bad i mean it's okay we'll end up with a n log n running time however so that's the tuple sort so i should really if it's not equivalent if i run tuple sort letter by letter i'm going to do i'm running counting sort log n times and so i get n log n because each one takes linear time if i map my strings into numbers first radixor doesn't use base 26 it uses base n and then it will only run 10 times because uh you know 2 to the 10 log n is n to the 10. and so uh the numbers that we're sorting are between 0 and n to the 10 and so u is n to the 10 and so that's the case when radix sort runs a linear time so if you run tuple sort letter by letter it's slow if you run radix sort it's doing a whole bunch of letters at once effectively it's doing log n letters at a time in a single call to counting sort and so the radix sort will actually win and get linear there's a subtlety here which is i'm assuming that we can actually take these strings and convert them into integers in constant time each and this problem set was ambiguous and both answers were accepted if you assume these letters are nice and compactly stored then and they fit in 10 words because a word is at least log n if it's long then you can actually do this if you store each letter in a separate word then just reading the entire input will take and log in time that's a subtlety which we don't need to worry too much about in this class yeah yeah there are 26 possible letters numbering them 0 to 25. um and then when we take a string like a a map this into 0 0 in base 26 that's a number if we do bb for example this is maps to 1 1 in base 26 which means uh 1 times 26 plus 1 which is 27. okay so that's that's the mapping that i mean you're mapping the whole string the whole string to a single number yeah and there's a subtlety because i want lexicographic i need to pad things with spaces at the end or pad them with a's at the end in case they're shorter than 10 log n okay uh cool that was b c is not very interesting it's integers in the range 0 to n squared this i can just solve with radix sort because my radix sort at this point we've done it it's our third time rate of sort we can sort as long as uh the integers are bounded by a polynomial here it's a fixed polynomial with constant exponent so this will and this is radix sort i like to saw that just calls counting sword twice uh linear time d is where things get more interesting let me get this phrasing same so v we have rational numbers of the form w over f this is win some win ratio always in the range zero to one as you say w is at most f and zero is less than w is some f is less than n squared because the that is really confusing it's less than n squared those are separate statements uh because the f actually comes from part c c is really a set up for this one um doesn't really matter what this means it's just that we have numbers w and f where w is always less than f and they're between 0 and n squared so you should think this is a good range for me right that i'm representing this rational in terms of two numbers between zero and n squared so there's like n to the fourth possible choices for what w and f are so the range of my values is n to the fourth that's the setting where rate of sort should run fast unfortunately these numbers what i want to sort by is not an integer it's a rational and that's annoying so there are a couple of ways to solve this problem uh in general a good way to solve sorting is to use merge sort workshop is always a good answer it's not the best answer in these cases we've we shaved off a log we got to linear time but n log n is pretty good it's pretty close to n so first goal might be can we even achieve n log n via merge sort what would i need to do in order to actually apply merge sort to this instance what does merge sword do to its keys sorry it isolates and compares them yeah right so there's an array data structure and it indexes into the array that's the isolation but then it the thing it actually does with the items themselves is always a comparison this is why we introduced the comparison model and proved an ad log and lower bound in the comparison model because merge sort and insertion sort and selection sort are all comparison algorithms rated sort is not but this one is but to run to apply merge sort i need to say how do i compare w i over f i versus w j over f j my computer only deals with integers we can't actually represent w i over f i explicitly in in binary because it has infinitely many bits but i can represent it implicitly by storing wi and fi yeah multiply by f i and fj yeah as when i went i didn't go to school but then we learned cross multiplication uh so it's which is the same as multiplying both sides by fi and multiplying both sides by f j as you said so then we get f i f j less than question mark uh f whatever f i w j uh when we do that we better make sure that the things are multiplying by our non-negative otherwise the sign flips but here we assume they're all non-negative so this is good and now we're just multiplying two integers here multiplying two integers here and comparing those are all things i can do in a word round okay so this was actually the intended solution when this problem was posed here's a way to do comparison sort we get n log n but in fact you can achieve linear time yeah uh i feel like there's a joke here like pikachu is superior that's always the answer so how do i tell whether one pokemon is superior to the other if i i multiply uh my i multiply i's f value with j's w value and i see whether that's greater than i's w value times j's f value and if it is so these are equivalent if this one is greater than this one i know that this is greater than this these are equivalent sentences by mathematics by algebra and so uh this is what i want to know this would say j is superior to i and so i determine that by actually doing this so then i don't have to divide and deal with real numbers because i don't know how cause i'm a computer [Applause] we're all computers okay uh so it would be great if my numbers all had the same denominator if they all had the same f then i could just compare the w's so that's one intuition for why we can actually do this in linear time um but the the way i like to think about it so let's just draw the real interval from zero to one and there are various spots all over here um that represent i can't actually compute this but conceptually each of these wi over fi's falls somewhere in that interval from 0 to 1. and i want to sort them somehow so one thing that would be great is if i could take these real numbers and somehow map them to integers which are uniformly spaced maybe a little a few more of them but these go from zero to u minus one if i could get u relatively small and i could map each of these so i want the mapping to be order preserving and i want two very close but distinct items to map to distinct keys here i want them to map to distinct integers down here if i could do that then i just sort by the integers and that's the same as sorting by the real numbers and so at this point i wonder how close can two of these numbers be so how close can two keys e so i want to consider w i over f i minus w j over f j an absolute value okay now i do algebra um so this is i'd like to bring this into one ratio so this is i can do that by multiplying one by five one by f j and it's w i f j minus w j f i which should look a lot like something here uh but never mind so i'm sure there's a deep connection here i could probably use this to prove that or vice versa cool so with some absolute values same thing uh maybe these are non-negative so i can actually just put absolute values on the top part and okay wi is an integer fj is an integer w j is an integer f is an integer all greater than equal to zero so this thing is an integer so uh it could be equal to zero it's a non-negative integer because all the things are non-negative it could be equal to zero but if they're equal to zero that's actually identical ratios right if this is zero the whole thing is zero and so these two values were the same okay but let's suppose it's not zero if it's not zero it's actually at least one an absolute value because it's an integer what about the bottom f i so now we want this i want to know how small this ratio can be it's going to be small when this is small and this is big how big could fifj be well we're told that all the f's are less than n squared so this thing is at most n squared n to the fourth less than n to the fourth n squared minus one squared but less than n to the fourth uh f i is at most n squared f j is the most n squared so it's n squared squared so this is at least one over n to the fourth so the the closest the two points can get here is one over n to the fourth so what could i do to scale that up to make them kind of like integers multiply by n to the fourth so just multiply by n to the fourth and then floor so we're going to take each fi over i like to compute this ratio but i don't know how so instead i'm going to take f i multi okay conceptually what i want to do is multiply by n to the fourth and take the floor how do i actually do this [Applause] in a machine that doesn't have real numbers like this and so i don't have a floor operation just have integer operations then i can uh take f i multiply it by n to the fourth and integer divide by w j that is the same that computes exactly this because i can do the multiplication of the division in either order uh in real space and then this does the floor at the appropriate time but this is just operations on integers and now these are integers representing how good my pokemon are that have the property that any two distinct ones before i take the floor any two distinct ones are at least one apart so after i take the floor they will remain one apart they will remain distinct integers and so i have successfully mapped my real numbers to integers where distinct real numbers map to distinct integers yeah wait so why is fi now in the numerator did i flip them yeah sorry please invert everything just here this is w and f5 that was just a typo that's all that okay are they both i's or js uh these should are supposed to both be eyes yeah thank you this was for each for each pokemon i we're going to compute this as our key then we're going to sort by those integer keys and that will sort the pokemon by the ratios [Music] that's right for monster uh so my u was just a sorry this is uh a label on this thing can i help you yeah so uh now my u all right what is my u how what is my largest key occurs to me i really would like fi to be bigger than zero but yeah let's not worry about it uh how big could you be well the biggest this could be is if f i is small and this is big let's say f i can only go down to one otherwise i get a division by zero i have to deal with infinity especially probably the problem isn't even well defined then uh how big could this be well i know the w i's i'm sorry defined as positive oh good here's also a positive constraint here just i failed to preserve that constraint in my mapping from the word problem into the formal problem so f is at least one good but let's minim worst cases when it's one and when wi how big could it be well n squared minus one so this could be basically n squared times n to the fourth divided by one which is n to the sixth so w is sorry u the largest key i can have plus one is n to the sixth but that's okay because radix sort can handle any fixed polynomial in n so it's going to end up doing six counting sort passes yay that's problem three let's move on uh so problem four mit has employed gank freri who's that frank gehry yep this is a common uh encoding that jason really likes i've grown to like it uh is this called spoonerism where you replace some some part of the beginning of your uh thing okay that's one joke there's another joke in this problem uh anyway they're building a new wing of this data center as one does uh we have a bunch of cubes if you read long enough you realize that's a red herring that's cubes do not play a role in this problem in the end what we have is a bunch of integers which happen to be the side length of the cube cubes but we just care about the side lengths not their volume or anything s n minus one and we want two numbers in s summing to h this is the side length not the number of sides so you got a cube cool i didn't know we'd be doing 3d geometry today ssi okay so you've got little cubes you've got big cubes okay this is the smaller side it's the biggest eye doesn't matter though they're just numbers okay we're not using them at all in the problem you're trying to like stack one cube on the other but all we really care about is two numbers who's whose sum regular old sum is exactly h ideally there's going to be two versions of this problem and so first goal is to solve this exactly in linear expected time that's what the problem says so what do we know well linear time that's can't get much faster than that because we need that just to read the input expected time hashing right we're told basically we should use hashing now if we're really annoying maybe we throw that in even when you don't need it but that's pretty rare uh so when we see expected we should in a problem set setting like this in real life you never know what you should use but in our and was your learning in this class we're going to tell you basically what tricks you're allowed to use here you're allowed to use randomization so probably we need it indeed you need it to achieve this bound ah cool not obvious how to approach this problem with hashing so i'm going to give you uh the way i it's it's hard for me to not know this algorithm but um to me the first thing you should think about is if if i have linear time and n things and i'm going to use hashing the obvious thing to do is to take those n things and put them in a hash table build why not uh so let's just build a hash table on all the keys in s that's idea one seems like the first thing to try so what does that let me do it lets me i just erased the interface for hash tables but i can build a sequence out of it but normally it gives me a set interface so i can call find now in constant time it lets me given a number determine immediately whether that number is in s well that sounds interesting because i'm looking for two numbers in s so it lets me find one of them so i call it twice no uh calling it twice and only spending constant time on this beautiful data structure will not give you anything useful but we have linear time right so in addition to building a table we could call find on that table a linear number of times because each find only takes constant expected amortized time so if i do n of them that will take linear expected time the amortization disappears because i'm using it 10 times all right find never has amortization so it doesn't disappear because it was never there never mind i can afford n calls or five n calls to find because each one costs constant constant expected and the total for that will be linear time so next idea is let's just somehow call find a linear number of times okay okay uh so i want to find two numbers summing to a given value h that wasn't maybe clear but h is given sorry um how long does it take to build the hash table how long does it take to build a hash table it was previously on this board linear expected time see previous lecture no two lectures ago ah okay well if we're gonna do this linear number of times i guess we should have a for loop let's do a for loop over the numbers this next idea loop over s and at this point we're done almost um space so i want to loop over the numbers and each one i want to do a find that's kind of all i have time to do so seems like a natural thing to try this this is by no means easy don't don't get me wrong having these ideas is well i'm explaining them as the obvious ideas they're not obvious but uh they are easy at least just not obvious to come up with the easy ideas so let's loop over s somehow called find using our hash table so the order is actually we're going to build the hash table then loop and inside the loop we're going to call find once per loop iteration so let's do it let's say for uh s-i-m-s so i want to find two numbers here i've exhaustively looped over one number i just need to find the second number that could possibly add up right i want to find whether there's an sj in s such that s i plus s j equals h can i do that query with find oh so what what does find do find says if i give you a key it will tell me whether like if i knew what sj was i it would tell me whether it's in s subtract h from s i and see whether that exists okay get it right h minus s-i let's get wrong i don't feel bad that you also got it wrong makes you feel better because i always get it wrong so a claim is this why because what we want to do is find well okay let's write see what it says over here so if we do h minus s i equals sj right so these are equivalent statements just by moving the si over and this is a query we can do we don't so let's remember these are things we know and sj is something we don't know although we know is that it's an s okay so we know these two things so if we bring them over to the same side we're searching for an unknown thing which is equal to exactly this thing that we can compute so we just compute h minus s i we call find that will tell us whether there is an sj equal to this okay so this is this is like a comment all right and then this is what we actually do and if there is a pair of numbers summing the h this will find it how much time did it take well we're doing n iterations of this loop each one we're calling a single find operation and find cos constant expected time and so the total is linear with respect to time great part a done then they throw part b at us to make it harder those pesky instructors so we read part b and part b says two things to make it harder so first of all we want linear worst case time and furthermore so we can't use hashing anymore furthermore uh so here we just needed to solve the exact problem to find whether the two numbers summing exactly to h now we would like to find the best solution smaller than or equal to h so find biggest pairwise sum that's less than or equal to h if no if there's no perfect pair but we're given a little bit of extra information which is we can assume h equals 600 n to the sixth it's a weird polynomial it took me a while to even notice that that was jerk in here 6006 hiding in a polynomial all right so polynomial that should make you think radix sort it is radix or weak so that is a natural thing to try but in general even later in the semester when you see uh a nice polynomial with a fixed constant like this and it's somehow related to the integers we're dealing with you should think radix sort especially because now we want constant worst case time rate of source seems like a good thing to do don't know what to do with it yet in fact i can't even apply radix sort but idea one is radical just because i see that polynomial i think maybe i should try it now there's a problem here because we're given some numbers we're all some integers s i's we're also given h we're told now that h is a nice small polynomial we have no idea how big these numbers are so problem with this idea is that um when s i could be bigger than h we we have no idea how big the s i's are can i what can i say about s i's that are bigger than h for this problem summing to h oh i didn't say but all these numbers are non-negative that's important that looks like korean greater than or equal to zero yeah well they can't be a solution right if i'm finding a sum that's less than equal to h they're non-negative uh and any number any number that's greater than h i can just throw away they'll never be in a solution it's like already a single sum of one numbers here than h so two is only going to get bigger if they're non-negative so let's idea number two is let's just throw out all the big sis anything bigger than h now that won't change the answer because those can never be in a solution and now i have all the sis having the property that they're less than or equal to h and so they are small bounded by a fixed polynomial and now i can apply radix sort so after this idea i can apply this idea okay this gives you a flavor of how i like to think about problems i see clues like polynomial i think radix sort doesn't work but with some more ideas i can get it to work okay uh what good is it so now i've sorted si okay great s is sorted i guess we can try to do the same algorithm except i don't have a hash table anymore so let's just try doing a for loop over the s why not so let's do 4 s i and s but now it's sorted so presumably i should exploit the sorted order so let's do do them in order so i equals 0 1 up to n minus 1. let's say that s 0 is the smallest s 1 is the next smallest s n minus 1 is the biggest so i want to do something with this so i have s i and i want to figure out whether h minus s i is in there hard to do that better than ah actually i could do this with binary search right i know i'm looking for this value so i could and i have a sorted array now so i could binary search for h minus si and in login time i will find whether that guy is in there and if not keep looping i can keep track of the best thing that i've found and so in n log n time i can definitely solve this but i'd like to get linear time okay good question i'm not looking for s i i'm going to compute h minus s i so so this is maybe i shouldn't even write this down right so in particular if um if there are two items that sum to h i want to find it so uh so let's start with that so i'm binary searching for h minus s i in s so i could certainly do that and um if i if i find it great i found a pair that sums to exactly h if i don't find it binary search tells me not only that it's not there but it tells me what the previous and next value are so even though h minus s i isn't there i can get what the large the next largest thing and the next smallest thing what i want is the next smallest thing and that will be the largest sum i can get using s i and so then that's one candidate for a sum let's equal to h i want to find the largest one so i do a for loop i always keep track i take a list of all the candidates i got each time i do a four iteration of this loop i get one candidate then i take the largest one okay so return largest candidate so this gives me a candidate which is uh the previous item this is what we called find previous or find prev probably in our set interface and if you have a sorted set you can do that in log n time so this is an n log n solution i want because we do n iterations for the loop each binary search takes log n i want to get linear this is not obvious the best intuition i can think of for this next idea is well i start with a very small smallest item in s and i want to sum up to something that's kind of big i threw away all the items bigger than h if i start if s zero is like tiny like close to zero because it's the smallest one then maybe i should look at the end of the array because i want to compare or i want to add the smallest thing probably with the biggest thing that's as close as i can imagine uh so then so here's my sorted s this is the smallest item biggest item so i'm going to loop over these items one by one so let's start by comparing the first one with the last one the two-finger algorithm okay this is the big idea you're doing it all the time in this class it's super useful we saw it in merge sort for example and merging two lists we have fingers and two lists that advance and because they only advance it takes linear total time so we're going to do this kind of folded and backwards here we're going to start here this seems like a good candidate to start with now what else could this add with well maybe smaller items and maybe i have to go all the way through here and then i've got to advance my left finger yeah okay so uh here's the idea so um let's look at so i'm going to call this finger i this finger j so we want to sum two things so i guess another inspiration here is we want to add two things up and we have one algorithm that has the word two in it and it's the two finger algorithm so let's try that um so we're gonna start with i equals zero and j equals n minus one we're gonna look at s i plus s j and see how good it is it how close to summing to h is it well in particular it's either less than or equal to h or bigger than h if it's bigger than h so this sum is too big i can't even use it as a candidate well that means i really don't need this guy right it's too big overall this is i'm adding the smallest item to this item and it's too big well then i should go to the left i should move my right finger to the left so in this case uh we decrement j move the right finger to the left so i'm guessing in this case i'm going to increment i why if i add these two items up and this is too small smaller than h then this item was probably too small it might actually it's an okay solution it's less or equal to h so i should keep it as a candidate um let's say add candidate so i'm just going to keep a list of candidates that i see so this is a possible solution it might not be the best one but it's one to add to my list and then i'm going to increase i and now work with on this sub array because that will be a little bit bigger i can't go this way to make it bigger because i'm at the last item and it's not obvious that this works i think there's a nice invariant that will help somewhere wherever i put my piece of paper here's an invariant oh yes it's really clear this is the right thing to do in the first step and the tricky part is to argue that it works in all steps because when i really have the smallest item and the smaller and the largest item it's clear that i should advance one or the other i'm too small or too big but the way to prove it in general by induction is to show this invariant that so it in at some point through this execution i and j are somewhere and i want to say that if i take any j from the right any j prime to the right of j and any i prime to the left of i unstrictly then all of those pairs all those pairwise sums are either too big and that's when we decrease j or they're less than or equal to the largest candidate that we've seen so far that's because we add these candidates in there so this that invariant will hold by induction because whenever there's a possible thing that's good i add it to my candidate list and then at the end of the algorithm i just loop through my candidate list compute the max return that pair okay so that is two-finger algorithm which solves the non-exact problem in linear worst case time yeah oh i cannot right so what are the termination conditions when i equals j that's probably when you want to stop it depends you could say if i is greater than j stop uh return max candidate uh it's there are two ways to interpret this problem one is that the two values you choose in s need to be different values or you allow them to be the same value like they can both be h over two and either way is easy to solve if you if you want to allow s over 2 then i would put greater than here if you don't want to allow h over 2 then i have a greater than or equal to either way both both of these problems you can solve both ways or both algorithms can handle both situations okay one more problem all right yeah a lot of time but i'm getting faster and faster so of course on the hardest problem i can do it the fastest all right so jet so meh jah this is a reference to jeff ma of the mit blackjack team who i got to see speak here at lsc a bunch of years ago but he's featured in the movie 21 and so on fictionalized um so as playing this game it's great great great setup you should definitely read this problem uh po k er and he has a deck of cards where each card has a letter of the alphabet on i get this the right way up so i of course have such a deck doesn't everyone you can buy these i have several actually um and so we can do a quick magic trick like uh pick a card any card here pick a card okay oh good choice i can't force so it doesn't really matter okay and uh so this is your card right and your card is an s right okay good okay no not all the cards are s's but he has mirrors in his glasses no i can reveal later how that's done um okay so a deck of cards each card has 26 possible letters on it and uh there's this weird dealing process even just defining this problem it's going to take a little while oh here's my piece of paper so we have this dealing process here's an example it's in the problem a b c sorry d b c so that you know the order of the cards this is the top card this is the bottom card and now randomly you do a cut cut is this right so i take some chunk off the top move it to the bottom once randomly so for example i could take this cut and then what i would get is cdbc for for this part that's copied here and a b that's the so this is so the first thing we do is cut at i this is position i this example i equals two okay then we deal the top k cards so uh let's say we deal the top four cards k equals four so this is uh dl k so we get cdbc in that order but the order doesn't matter because the last operation we do in the problem is sort them which is b c c d okay like you do when you get a hand of cards you tend to sort them okay so this is a process given a deck so the deck here is fixed uh we call this process i think p of d comma i comma k we're told what d is we're told what k is i is chosen randomly and we'd like to know what happens with different eyes so so if you start this problem enough it begins to simplify this is a complicated setup but what's really going on is we're starting at position i and we're taking the next k cards from there cyclically so here we just took those four if i equaled three would deal d then b then c then a but then we sort them okay so we're getting different substrings of length k cyclically but uh then we're sorting those letters sorting is really crucial for this problem to at all be feasible it took me a while even to see how to solve this problem but the key is sorting that they get sorted because that means because we sort it doesn't matter whether you have a a b a these are all the same if you take these cards dealt you sort them to the same thing which is the one i didn't write a a b all these get sorted to the same thing so we lost some information when we sort lost the order the first question to get you thinking in this direction part a says build a data structure given d and k that lets you lets me know given two indices i and j do i end up with the exact same hand this thing is called a hand and it's exactly this pdik so i want to do p d i k and p d j k and i want to know j k and i want to know whether those two things are equal in constant time that's what this says constant time doesn't say worst case but worst case is possible uh and that sounds hard because i mean there's k symbols for one of them another k symbols for the other guy but we don't have to compare the symbols we just need to compare the sorting of those strings and this we can compress so this is a subtlety but what i really need to know is that there are three a's here and one b and zero c's and zero d's and zero e's and so on but uh because there's only 26 letters in this deck and indeed in this deck happens to have upper and lower case a through z but we might have n cards but they're only 26 possible labels so in fact a lot of them are going to be equal if n is large so this is a good compression scheme because i to represent the things i get after sorting i just need to give you 26 numbers and for us 26 is small because 26 is a constant independent of the number of cards i just need to say how many a's are there could be anywhere between 0 and n how many b's are there between 0 and n how many c's are there between 0 and n so 26 numbers in the range 0 to n i like to think of this as a 26 digit number base n plus 1. we can map this into base n plus 1 and we get 26 digits in that base another way to say it is that the number of possible uh combinations here how many a's how many b's how many c's is um not even theta it is n plus one anything between zero and n uh to the power 26. this is a good polynomial so i can do stuff like radix sort cool so let me summarize a little bit how we solve part a so i want to build a data structure which is for each value i i know i'm going to end up serving these four cards or in general k cards so for those cards i would like to compute um how many a's how many b's how many c's are there and then just write down this number this is a number which i can write down in at most 26 words because we can represent numbers between 0 and n in a single word that's the wb's at least login assumption uh so it's constant size in a constant number of numbers i can represent all i need to know about a thing of size of length k here because i don't need to know the individual which letter is where just need to know the sorted order so i just need to know this is called a frequency table how many a's how many b's and so if i can compute those then given that representation for starting at i and given that representation for starting it j say which would be these two and these two i can compare them by just comparing those 26 numbers they're all equal then they're the same string after sorting and if there's any difference then they're different so that's how i could do it in constant time if i can compute these representations and it's not hard to do that you it's called a sliding window technique where you compute it for the first k guys and then you remove this item and add this item into just by incrementing the counter for b decrementing the counter for a now i know this the representation for these guys make a copy of that which is a copy of those 26 numbers constant then i add on c remove b then i add on a remove c add on b remove d add on c remove b and add on d and remove c i got back to the beginning so now i have representation of those okay so i by sliding this window i'm only changing at the two ends i add one guy on i increment one of these counters i decrement one of these counters so in constant time given the representation of one of these substrings i can compute the representation of the next one that's how in linear time can build such a data structure that lets me tell whether any two hands are equal the next problem part b is given all these representations can you find which one is the most common because we're choosing i uniformly at random i want to know what the most likely hand that you get is and i think the easiest way to say this is you can do that by radix sorting you take all these representations they are nice numbers in the range 0 to n plus 1 to the 26th power so i can just run radix sort and sort them all and then do with a single scan through the array i can see which one is the most common or rather i can in single scan i can compute okay how many of the same things are at the front they're sorted then all the equal ones will be together so how many are there then how many equal ones next and how many forms before this next each time comparing each item to the previous one then i get frequency counts for all of these uh hands and then i do another scan to find the most common one and i can do another scan to find the lexically best one because that's lexically last one and that's how you solve problem five