okay well uh welcome back to another problem session it's great to see everybody's smiling faces again uh uh right so today we're going to continue our discussion of graph Theory problems uh this time focusing on well a little bit of this a little bit of that some shortest path problems all pair of shortest path uh and then a modification of the dier algorithm to finish us off for the day um so as always we'll go through our problem session problems in order for no reason other than that's the way they were presented to me uh and I think roughly isomorphic to how most of the homeworks in this class go anyway uh but in any event uh let's get started here so uh in in uh problem session problem 7-1 here as always our first problem is sort of a warmup to make sure that we understand all these sort of definitions techniques that we use in 66 uh today uh we're going to go over Dyer's algorithm so if y'all recall ders algorithm is a technique for computing shortest path from a single source to your rest of your graph uh there's about a million different ways to explain understand uh D's algorithm so I'll undoubtedly revert upon the one that I remember which is probably not the one that Jason just covered in lecture but we'll make it work and of course if there are any questions we'll we'll we we'll address those along the way here uh I'm going to switch to a piece of chocolate that isn't an e/ of an inch and get started uh right so in problem uh 1 a of our homework here we were asked to run dce's algorithm from uh vertex s here by the way just sort of a standard terminology in graph theory that I think we'll see a lot in the homework uh is we typically use S for the sort of starting point of a path or sometimes the source if we're talking about Network flows but I don't think we do those in this class uh and then T is usually the destination um why T you might ask because it's the letter after s uh right so uh our our first uh task here is to compute the single Source shortest path from s to everything else in our graph initially this looks painful uh but it's not um so you're going to forgive me I'm going to write a sort of shorthand version of DA's algorithm because I'm talking to you as I solve this problem which of course it would be much more annoying for you guys to do uh on paper uh but that's life in the city uh so so so there that's my what in the words of Britney Spears It's my prerogative as your instructor here okay so in uh D's algorithm what do we do we initially label all of our vertices as having distance Infinity to the source or and and we insert them into our priority Q except for one vertex which of course is our source vertex uh and he or she has vert uh has distance zero for an obvious reason which is that if my path starts at the source it has distance zero to the source so as our shorthand what was that do I want to use red yes of course I do uh yeah but see it's this fat chalk man um okay zero I can make this work okay so uh our our convention for today is going to be if a Vertex does not have a label on it it is distance Infinity okay uh so what does Dyer's algorithm do uh Dyer's algorithm grabs the closest vertex that I haven't yet processed uh and closest in terms of the distance value that I've stored at that vertex and then updates all of its neighbors using sort of a triangle inequality uh style construction so let's see what that looks like so so far everything is distance Infinity away except for one vertex which is vertex s which is distance zero so obviously that should be our first iteration of D's algorithm and now what vertex s is going to do is look at all of s's neighbors and update them using the triangle in equality quality and if they're Closer by having a path through S to the neighbor then I update the distance and if it's not then I don't uh in this case everything is infinity so it's pretty clear that I should route my path through S because any distance less than infinity is smaller than infinity uh so in particular notice that there's an edge of length eight from s to a so now rather than being distance Infinity away I can see that vertex a is really distance eight away oh this truck gives me shiv uh similarly here there's an edge of length seven uh and I believe that's all of the edges out of s so we're good and now the kind of nice thing about the way dier algorithm Works um which I guess was a little bit implicit in the construction we saw yesterday but but that's okay is that once I visit a Vertex I never I never touch it again right it gets frozen in time uh in in distance I suppose uh but in any event what that means I'm going to pull a little box around it meaning I'm done with this guy he he is no longer in my queue okay hopefully our pictorial system makes some sense here again on your homework problem you actually have to write this stuff out and I'm sorry that sucks uh but I don't have to because I'm talking to you all today okay so remember D's algorithm we're going to look at our list of vertices we haven't seen yet so that's everything except for S find the one that's closest and process that one next so in this case that's the seven here uh okay so let's take a look what are the neighbors of seven well I've got s uh and that's oh and D here okay so first of all let's take a look at s obviously if I have a path that goes through C back through this vertical Edge to s that path to have length eight right 7 + 1 eight is bigger than zero so I do not update s but we actually already knew that because s was frozen here so I didn't even have to look at that edge I could have removed it if I wanted to uh okay but there's another Edge coming out of C which is pointing toward D that has length four 7+ 4 is wait for it 11 uh and that's less than infinity so I update D's distance to 11 and I don't think I've managed to make a mistake yet uh okay so now uh We've looked at all the edges out of C and C is frozen and we move on okay next uh let's see among our vertices we have Infinity 8 and 11 so the smallest of those three numbers is eight and we're going to update all the neighbors of the eight uh which thankfully although this graph looks big uh they had some mercy on your your section inst structure today and and really there aren't that many edges so this isn't too hard to uh process but here's the thing uh there's an edge of length Zero from a to d here I can get to the a in eight units so I can also get to the D in eight units uh by traversing that edge eight is less than 11 that's good news do I want to erase it or scratch it out what's going to be better I'll scratch it out just to be messy okay so now uh D is a distance eight from a Vertex s and I believe that's all the edges out of a so a set okay this fun or what so now we look at all the edges out of oh oh sorry we step back and we look at all of our uh vertices we find the closest one that's D now we got to update all of D's neighbors so uh thankfully all the remaining vertices have distance Infinity uh so what do we know there's an edge of length one here so I get a n there's an edge of length two so I get a 10 um and I believe those are all the outgoing edges from d and now D is set I'm going to start moving faster because this is hella boring uh okay now the next closest uh Edge is the nine uh notice that the nine only or rather B I suppose is the vertex which is currently at distance 9 uh it only has one neighbor that hasn't yet been processed which is e uh so we know that that's 9 to 11 12 distance away I'm going to check my scrap paper and make sure I haven't made any mistakes yet seven eight cool okay so now our next closest vertex is vertex H which is distance 10 and aha if I Traverse The Edge upward from H to E I can get a path of length 11 and 11 according to most mathematicians is less than 12 and hence we should update the value here uh in addition to that there is an edge of length two out of H pointing into G 10 + 2 is 12 and I believe that's it getting there okay so the next closest uh vertex is e e has no outgoing edges so e is all set uh after that we've got g g has an outgoing edge of length 1 into D 12 + 1 is 13 Which is less is larger than eight so we don't update uh and similarly 12+ 0 is bigger than seven so we don't update but again the edges that point into vertices that we've already processed we really don't have to even consider uh just by the way that D algorithm Works notice that if there were a negative weight Edge where we're going to come back to uh then that assumption would be problematic so the takeaway here is that this guy's Frozen in stone and now notice that our Q is actually empty yeah so depending on how we set up our well it's not empty um but it only contains one vertex and it's at uh distance infinity infinity plus Z is still Infinity uh so that's this guy's uh distance here and now we're now our Q is empty sorry okay so I believe I managed to do that right excellent so the problem ask for two things it ask for the single Source uh shortest path distance it also ask for the traversal order which I forgot to do while I was doing this problem but you could retrace it pretty easily okay so uh that's part A then in Part B they say change the weight of the Edge from G to C to minus 6 so we have G to C and now instead of zero we're going to make it minus six and the question is if I ran Dyer's algorithm essentially what would break and I think it's pretty easy to eyeball remember that g was essentially the last interesting vertex that we touched in our algorithm here the only one that we looked at was was F and so this outgoing Edge from G actually wouldn't even be seen by d's algorithm thankfully until we've touched all these other vertices in an identical fashion to our previous traversal uh and then we finally get to G and now what's going to happen well if I had this edge of length Nega six what's 12 minus 6 it's six and notice that that's less than um seven which is the the label of vertex C but that breaks our assumption which is that as soon as I visit a Vertex I never have to touch it again right because now I've identified a path through G back to C that has a smaller distance than the path that c had when it was visited in the Q so somehow spiritually I should add C back to the Q but that's against the rules in DA's algorithm right so like for instance if I did that I I would have to convince myself that the runtime doesn't explode uh and that this algorithm terminates right which could be a problem if you have a negative weight cycle thankfully we have algorithms for detecting negative weight Cycles but that's a different matter okay so I think this is pretty straightforward it's just essentially asking you to walk through DA's algorithm make sure you understand what's going on any uh questions about that one cool I think this is one of the easier uh problem sessions so maybe we'll finish early except I always say that I talk too much sorry not sorry okay so uh right so in problem s-2 um this is an extension of a problem that we considered I believe two problem sessions ago uh and it looks something like this I'm going to go back into my notes so remember in two problem sessions ago we defined the radius of a graph for an unweighted graph we came up with an algorithm for computing it and approximating it all that good stuff uh now in this problem uh we're going to do basically the same thing but now we're on a weighted graph yeah so in particular we're going to define a quantity this is problem two uh called weighted eccentricity uh which is associated to a vertex in a weighted graph uh and it looks like this so the weighted eccentricity Associated to vertex U is equal to the max over all vertices in my graph of the shortest path distance from U to that vertex again hopefully our audience will catch if I accidentally swap the argument to shortest path because I'm used to thinking of that as symmetric but it's not uh because our graphs are directed um actually in this problem I don't think the graph is directed so I forget it's directed okay good yeah then good I'll try to be accurate okay and just like the problem we had uh two PR sessions ago um so the eccentricity is associated with the vertex is sort of like the distance to the farthest away thing in My Graph and now the radius of My Graph tries to find the most Central vertex which is the minimizer of weighted eccentricity and we call that the weighted radius and so the weighted ah the weight o that's a tough one the weighted radius is a measurement uh which is associated not with a Vertex but rather with the graph and it's equal to the Min over all possible vertices U of the weighted eccentricity of U okay and so the problem here is that we're given a weighted directed graph with no negative weight cycle so it may have negative weights but they can't have a negative cycle and the question I touched my face uh the question is what is the uh can I find uh the radius of My Graph uh in time uh that looks like order mod V cubed okay now if you recall from our previous problem session when we considered Computing the radius of a graph what did we do well we tried to come up with an a clever algorithm and then we realized that that was actually kind of unnecessary that it turned out that the kind of brain dead thing where you just look at the definitions and just make it work uh was actually good enough uh and that actually turns out to be the case here right this is a good reminder for us all that before we go crazy you know 66 is a fun algorithms class we get to learn about cute you know references to TV shows and and all that um before we go crazy with that of course if there's an obvious algorithm staring Us in the face to solve a given algorithm's problem we should try that first before we try something more clever uh and indeed in this case uh that works so what are the sort of ingredients that we need to compute the radius well the radius is the minimum eccentricity so what would be the smartest or the simplest thing to do rather would be compute the entric for every vertex and take the smallest how do I compute the centricity for every vertex well I have to have the max distance uh away from that vertex so what would be a simple thing to do would be to compute distances between all the possible vertices and conveniently in lecture in some day or another I'm a little confused about the time ordering of this class because of the way we're filming it uh we covered an algorithm that computes the distance between every pair of vertices and that's called Johnson's algorithm yeah so if we were to do a totally brain dead version of uh solving this problem maybe for convenience the first thing we do is compute Delta UV for every possible UV pair and because our graph doesn't have a negative weight cycle we can do that with Johnson's algorithm yeah so step one is to use Johnson's algorithm uh for all pairs shortest path and I'll uh refer you guys to the lecture for how to do that um but the important thing is the runtime of this step of our algorithm so Johnson's algorithm generically speaking has v e plus v^2 log V hopefully I got that right uh run time and uh what do we know about our problem well I believe we're given that the graph is connected um and so one thing that we can do is notice that e is upper bounded by v^2 I guess even if it's not connected I'm sorry that was a dumb thing to say just generically speaking our graph is is simple so we know that e at most is I guess 2 v^2 which means that this term is upper bounded by V cubed right so we have V cubed plus order v^2 log V so at the end of the day the first term wins and we have this is V cubed time notice that we're given that budget in the statement of our problem so this is perfectly fine in other words this is a longwinded way of saying it's kosher to compute all pairs shortest path in the constraints of our our problem here so that's convenient because now in step two well maybe now we just keep you know we follow we do the the twocan Sam approach again we follow our noses and well now that we have our our pairwise distances we can now compute the eccentricity for every vertex for all you just directly of course in your homework you should write out what that means um but here directly just means that for every u i Loop over every V and I take whatever value is biggest so notice that I have two Loops one over U one over V so this is order mod v^ 2 time so already the first term is is dominating here so that's that's a good thing I guess uh and then finally we have to take the smallest eccentricity of uh any U which just requires one more for Loop so this time I I for Loop over this array and I just take the smallest value right so this is just one for Loop so that takes order B time and then we're done right so that's uh our our technique for computing the radius and notice that all I did was translate the definition into an algorithm I didn't do anything smart in this problem at all uh and then we should really quickly double check our run time so step one take V Cube time step two two takes v^2 time step three takes V time so we add them all together and of course the V cubed wins uh and that is what was given in our uh our problem as our our budget okay so I think the first two problems in this uh this this problem session are fairly straightforward are there any questions so far I'm talking fast cool all right so now we're going to move on to problem three involving atus kevine uh who is uh you know probably playing the what the the gunger hams anger games that was close um sorry under uh whatever uh you get the point yeah so before I get carried away trying to read Jason's uh jokes here um what's going on in this problem so this is problem three there's an underground sewer Network I suppose we also could have written this problem about MIT right there's all kinds of crazy underground tunnels here uh I remember when I was looking at MIT as a potential undergrad I they had us like slepping around in the tunnels and I thought they were very dirty and I didn't get the point so I went to Stanford but uh in any event um right so uh what I'm given is a map and uh this thing has uh n bidirectional pipes not going to write it down but the problem tells you that they're all connected they make like there you can get from your source to your target moving through the pipes um and uh right the and they're connected at at Junctions uh but uh at every Junction there's less than or equal to four things that come together so just like in our last problem session every time you see a phrase like that it's like screaming out there's a degree bound uh hiding inside of your graph uh and moreover uh every Junction is reachable from every other Junction I believe okay uh in addition to this uh we're given a positive integer length for each pipe um so it's starting to smell like a shortest path problem but is it that's our question uh but just to make things a littleit but worse atus uh kevine here is trying to escape through the uh pipes and she doesn't want to be detected and in particular there exist Junctions with uh motion sensors and apparently atn's uh Intel is pretty good here and she knows which of the Junctions in her pipe network uh actually have a motion sensor sensors uh that um that can detect people moving around okay um now what this problem is asking her to do is to say like maybe apparently she knows where the motion sensors are but maybe she doesn't know if they're like you know what kind of brand they are you know is it a Microsoft sensor or a apple sensor or something and of course the sensors have different ranges right so so atus kevine here she wants to be as conservative as possible when she traverses this pipe Network in particular what we looking for what she wants is uh in uh n log n time here find the PATH um that maximizes uh the distance to the sensors so hopefully this problem makes sense so you've got some you know grid graph well not necessarily a grid graph but the a bunch of vertices of veilance 4 maybe something like that you know makes sense you know she's living in a city somewhere uh and she has some source that she's starting at some destination she wants to go and then a few of these vertices are marked as having motion sensors at them and rather than like giving you a radius or something like that instead what we're saying is that she wants to go from the source to the Target she's willing to walk a long distance the length of the path doesn't matter what matters is that she never wants to get closer to any motion sensor maybe there's a second one like here then she has to okay so like in this case I guess if I were to eyeball it looks like you can't do better than one Edge right so she would go like that uh and of course uh in an extreme scenario it might be the case that like there's a sensor at every Junction in which case she's uh hosed um but she we'd like to let her know that before she uh embarks upon her J here okay so does our our problem make enough sense excellent um okay so right so unfortunately for us this isn't again it doesn't look like a shortest path problem and the reason is cuz you know it's it's not uh but rather uh it's sort of a reachability problem in Disguise and and let's think about what I mean here so um right so there's an obvious graph here we'll call it g out of a lack of creativity um where what I'm going to do is uh give a Vertex per Junction and uh I'll have an undirected edge for each pipe um whose weight is the length okay by the way I think the length I didn't even mention in the problem description but I believe she wants to find the shortest path that maximizes the radius so like if there are like multiple different paths that she could take that both have the same radius from the sensors then she'd like to be lazy and not walk too far so that's that's where this going to come into play okay um that's sort of a secondary concern I would imagine on adn's behalf here okay and moreover uh I'm not even attempt to remember the the details of this problem but but rather there's a source which I'm sure has some cute Hunger Games uh name attached to it and some other Target um and these are just two nodes in the uh the network of pipes and she wants a path from s to T okay so first of all uh let's just count um and make sure that we know uh so there's uh how many vertices are there well the problem actually gives a name to that there's order n vertices because that's just the number of Junctions which is what we Define to be n guess I forgot to write that there uh and because we have a degree bound uh our favorite argument uh in this class uh we know that there's order and edges as well so that's that's good news why can't I use this graph directly like like let's say that I computed the shortest path from s to T notice that that completely ignores the point of the problem right the the point of the problem is that uh atus wants to avoid these starred vertices on our graph up here but the shortest path may not do that in other words she may have to walk like a really indirect path to avoid being detected by the sensors that's the problem so we need to be a little more clever than that we do have to think on this problem a bit okay but not too much uh and so here's the basic trick like let's say that let's solve a slightly different problem first which is let's say that I give you a radius k and I want to know does there exist a path that can get me from s to T without coming more than distance K away from the sensors notice that once I if I have a tool that can answer that like yes or no problem I could come up with an algorithm that that finds my number of sensors by like looping over k or something it may not be fast enough but I could do that okay so that problem is actually not terribly difficult because essentially what I could do conceptually is just remove the vertices that are too close to the sensors and then solve a reachability problem like can I get from s to T without getting distance K away from any one of the sensors well what do I do I just remove any vertex that's distance K away from the sensors and then I compute reachability so so conceptually I think this isn't a huge leap intuitively uh speaking but there's a lot of details to fill in yeah so unraveling just a little bit more we might Define a graph g k and GK is going to be the sub graph um of vertices whose distance uh with uh distance bigger than K to any sensor right and somehow reachability in this thing can answer yes or no can I get from s to T without coming you know distance K to a sensor by way do we know this term subgraph in this class essentially it's pretty clear what it is just from the the word right like essenti I'm just going to remove vertices uh that that um inside of our larger graph and any edges that touch those vertices uh and obviously if my original graph had order n size then the subgraph has Big O of n size might have less but but it certainly it's an upper bound okay so we unravel a little bit more somehow this seems like a convenient structure but I haven't told you how to compute it uh and in particular uh the sort of annoying thing is uh this piece right I need to be able to figure out if I'm distan K from any sensor or more generically speaking it might be kind of Handy to compute distance from every from the set of sensors to every other vertex in My Graph every other Junction in my pipe Network okay well we already covered a trick uh in our problem sessions so it's going to help us do that right because okay what would be a very simple algorithm for doing that would be to Loop over every sensor call D's algorithm for each one right so that gives me the the distance to sensor number one and the distance to sensor number two the distance to sensor number three and I take the men over all those and that function gives me the distance to any sensor that's going to be a problem right because Dao's algorithm runs in N log n time but now I've incurred another Factor because I have to Loop over all the sensors and we didn't give you a bound on how many there are so more generically this is actually a problem that shows up all the time uh in my everyday life which is that like we don't just want comput shortest path to a single point sometimes you want shortest path to a bunch of stuff like in other words I don't care which sensor is close to me I don't want to get close to any sensor yeah uh this shows up in Geometry all the time like maybe I want to know the closest you know like I want to find the closest point on the highway you know so the highway is driving past uh my house so the highway is a whole bunch of points on some Network and I just want to get on the highway and start driving um I don't care about the closest path to every single point on the highway I just want the whatever closest to me right so this is a pretty practical thing to think about so how do we solve that so um let's say this is our pipe Network I feel like I draw this network a lot maybe I'll spice it up with an extra Edge okay and maybe uh for board drawing purposes these two vertices have sensors so I'm trying to find the shortest path distance to either one of these two vertices uh from every other vertex on the graph or vice versa it doesn't matter it's undirected um and I don't want to Loop over all these sensors that's the basic headache here so one thing that I can do is it's kind of a sneaky trick and it's exactly the same trick that we've applied a few times in in the problem sessions here is to add a new vertex that's kind of like a source and make that vertex distance zero to every one of my sensors and now what I'm going to do is do single Source shortest path from this new extra vertex that I added to All the Rest of My Graph now why do I do that well if you think about it well there's an edge of length zero to any sens sensor topologically I can think of it like I glued all the sensors into one vertex if I wanted but that doesn't really matter um fact that would be a different way to solve this problem I guess would be to take all the the sensor vertices glue them together into one and then solve this problem but I digress um right so the the shortest path distance from our new uh Source vertex all the other ones is going to be just the shortest path to any sensor because notice that any path coming out of s necessarily has to pass through a starred vertex okay so let's write that down um basically uh what I'm trying to do here is uh in step one of my algorithm I want to label each Junction with its distance to a cent answer right that's the high level goal here and the way that I'm going to do that is I'm going to make uh oops in in the problem solution we call it X so I'll be consistent uh I'm going to make a new Vertex or a new graph rather G Prime which is equal to my original graph G which is coming from the pipe network uh with one extra vertex which we're going to call X which is connected to every motion sensor uh with weight zero okay and now I'm going to do uh Dy stress starting at x uh which takes n log n time because I just gave you the size of our graph up here and gives me essentially the shortest distance to any motion sensor from all the vertices in My Graph so that's good thing that's sort of like a convenient piece of information but when we're solving these kinds of algorithms problems notice that I've done sort of a similar reasoning in both of the last two problems um which you can do and actually is a pretty practical way of thinking about algorithms where like this problem tells me at the end of the day my algorithm has to run an N log n time right where like in the previous problem it had to run an N Cube time I guess V Cube time so one thing I can do is say what is all the information that I can gather out of my graph in nlog and time and I might as well compute it right so for instance the distance to the closest Center sensor I just gave you an nlog and algorithm for computing it it seems like a useful piece of information so what the heck I I might as well compute it in step one and just have it around um obviously you could do breath first search on all the computable numbers and this might not be the most efficient way to solve a problem but I think for graphs there's only so many things that we we typically want to compute so it's worth kind of going down your checklist like similarly here notice that like we gave you a budget of of VCB time so like you might as well compute all pair of shortest path because we can do it in V Cube time and why not have that information around it seems useful for computing radius okay so in any event now in step one we now know how uh close every Junction is to every sensor so now I can argue I'm I'm numbering these like Steps but they're not really steps these are more just like thought bubbles so thought bubble number two it's going to be how do I actually construct GK right and notice I have a nice piece of information here I now know what vertices are inside of GK and which ones aren't right because I can just Loop over all the vertices if the distance is bigger than K I keep it if it's not I don't yeah so that gives me an algorithm for computing um GK so we can construct construct starts with a C construct GK from our original graph G um and that's really easy to do right just by looping over the vertices and remove any uh whose distance is too big or too small rather uh V that make sense because those are the ones that are are dangerous if like the radius of my sensor is K any vertex with this is less than equal to K I want to throw away um and how much time does this take well there's just a loop over the vertices I guess I need to account for the storage of My Graph also but of course this graph takes less space than G and so overall uh this takes order n time Tim time and space but there's a catch which is this is per K okay so every time I want to make a new G uh a new GK I incur an expensive order n but this is already getting us pretty close to our problem because what can we do if I have GK I can say that BFS on GK establishes reachability from s to T right which is what we care about um outside of radius K and how much time does BFS take linear the size of the graph I only ever asked Jason one question which is you know always has the same answer um right so BFS takes time linear in the size of our graph our graph has size n or kind of 2 Nish uh so at the end of the day this takes order n so if our problem were written slightly differently we would be done right if the problem said you know given a radius K and the graph you know tell me yes or no does there exist a path that stays outside of radius K of the sensor this is how we would do that hopefully we all agree and we can do that in order and time oh just kidding order n log and time because I had to do D's algorithm first thanks okay uh but uh sadly for us we're we're not quite done because we want to find the largest uh possible K right want to to find the biggest radius that we can stay away from the sensors uh and still get successfully from s to T so let's say that I uh want to find this number so this is when to Define K star like got a moving Target to right on is the largest K where g k is connected well that's not quite right from s to T this is a weird way to phrase it really this is should say where there exists a path from s to T and GK I'm sorry re uh yeah where GK I've just phrased this in a funny way has path from s to T there we go all right so our question is how do we find that well here's a dumb algorithm I could Loop over all case construct GK and then if my answer is yes is reachable then go to the next K increment by one and start over right so this is the dumb answer uh when I say dumb I mean the answer that your instructor wrote down on his notes and then realized was done okay uh which is Loop over K until you get to K star I guess plus one right because once I get there then I get a thumbs down obviously getting any bigger than that is only make my graph smaller this is called a filtration right because each graph is contained inside of a different one um actually a filtration would be the other way I'll think about it for later because this is not a topological data analysis class uh but in any event um if I did that how much time will it take well remember okay so for one thing I have n log n from D algorithm I don't get around that so I always have to account for that but now every time I try a new k i incur cost n right that's what we argued up here and so at the end of the day this algorithm takes order K star and time like that of course it's a little weird to have the answer of your problem in the runtime but K star here it could be we don't have any bound here it could be the the number of vertices or or anything like that yeah and so if we have a budget of n log n time this doesn't quite work and so the question is can we rescue this uh this strategy here here and the answer of course is yes or else I wouldn't be standing here today uh one way that you might do that so there's the uh way that you would do that as a real algorithms person and there's a way you could do it by psychologically diagnosing your instructors let's let's talk about both of those um let's actually do the second one first because I think that's the most practical if you want to get your homework done quickly um which is as follows this problem tells you that you have an an Logan budget of time uh in order to run the algorithm and so what does that mean well when we Loop over potential gks that we can try we have a budget of log and tries before we're done yeah uh so we kind of know that any algorithm that constructs a GK and tries it can only do it log n times and to my knowledge we only have one algorithm that runs in log n time in this class uh which is binary search and so we might be thinking very critically about how we could use that tool but more generally than that I I think this is actually a strategy that shows up a lot both in algorithms and actually numerical analysis a lot uh which is you have some like yes or no answer and you want to find like the point on the interface right but where yes flips to no and so one way to do it is to sort of bound it on two NS then keep dividing in half and as long as your relationship is a bunch of yeses then a bunch of NOS you can keep doing that by binary search right so so let's think about it this way so like we have a long interval of K values by the way obviously there's an upper bound here which is like the biggest distance to any vertex in my graph or something like that yeah like the sum of all distances or some large number uh compared to but you can afford a lot you could if you took the sum of every Edge here's a way to do it if you if if you took this to be the sum of every possible Edge length um might not be bounded in N polom polom be bounded in N difference between between you and M sure so very large numbers uh in the near space okay I'm not sure that that's quite right but but but that's okay um in any event let's say that we have an upper Bound for k for now then then what do we know we know that here's like the K star that I want and to the left my algorithm will return Yes this algorithm up here up here it'll say no right so one thing I can do one thing I should do is put K star not right at the center of my interval um for illustration purposes but now I can binary search right because I could query here and now I'm going to get a no and maybe I subdivide that the midpoint for some reason now I get a yes and I can kind of triangulate in on what I want right so that's our our basic strategy is binary search here um but uh we have to figure out how to do that exactly okay so first of all um okay there is an obvious upper bound here which is just the biggest distance from any vertex to any sensor yeah uh right so we could probably come up with a conservative one we didn't feel like it but um conveniently in step one remember that Computing convenient numbers is always a convenient thing to do um clearly if Katniss wants to sorry sorry atus wants to go uh within a radius that's bigger than the distance of any vertex to any sensor she's in trouble because like that covers the entire graph yeah so um right so we actually do have a upper bound here which is the biggest distance to a sensor and now we want a binary search but we have to be a little bit careful how to do it because we want it to be logarithmic in N which is like the number of vertices in our graph and of course the way that I've drawn this interval here uh as Jason points out I I don't at least immediately have a bound on this number in terms of n right like it could be that my Edge weights are like really ginormous uh okay so uh right so how can we get around that well essentially what we want to be doing is binary search in an array that scales like the vertices okay uh and here's the solution that I came up with which I'm pretty sure is the same as one in the answer I should really check that before uh teaching this thing uh which is to do the following which is a remember like again we have a budget at n log n and so we can do a constant number of things that take n log n time we just might as well keep doing it yeah and so another kind of convenient thing we might do is sort my vertices by the distance to X which of course remember is exactly the distance to their closest sensor why would you do that well in some sense like as I move along that array that's the sort of order in which I'm going to remove vertices from My Graph and make the radius get bigger and bigger and bigger does that make sense because like these you know the first couple ones the ones right next to the sensor as I move along this array uh they get farther and farther away okay so we're going to say and and of course why can we do that because sorting I think this is one that all computer science students everywhere know takes n log n time using whatever your favorite sorting well that's not true whatever my favorite sorting algorithm is okay and we're going to take di to be the uh distance uh the ith largest uh actually I think in my notes I got this wrong the I is smallest I'm diverging from my notes so there is a high likelihood of a sign mistake that's about to happen Okay and now what I'm going to do is I'm going to binary search on I in other words on the index into my distance array is a reason to do that is there a r like let's say that my distances are like one 2 five s right so these are the distance of some vertex to a sensor and let's say that I test three and I notice that three is admissible you know in other words she can get from one vertex to another um never getting within a radius of three should I try a radius of four well no because I'm going to remove vertices only when I pass an element in this array right so it makes sense to do binary search not in distance space but rather in Array index space because those are the sort of place junctures that determine when I'm going to uh remove stuff okay so uh right so remember how big is this array it's got length n so overall this binary search takes log n time and that's good because our whole algorithm now what do we do we binary search on D or rather we binary search on I and then we take Di and plug it into our our algorithm up there to construct our subgraph we test yes or no and that tells us the left or the right interval in our binary search and and we recurse uh and so overall uh this takes log n time but uh or rather log n steps of binary search uh and of course each one of uh these steps as I argued up there takes order n time so overall our algorithm takes order and log oh no I made an accidental Theta and log n uh time and that was the bound we wanted uh to achieve as usual there's like a lot of detritus that we need to clean up at the end of our problem here one of them is that we actually want to return a path uh but that's not so bad right so now we we we've essentially determined that we can compute Kar in N log end time well that's good it says now if we actually want the path we can construct our graph one more time right at K star I suppose you already have it around from the end of binary search uh and then use whatever your favorite reachability algorithm is uh to go from s to t uh and and give Katniss the path that she wants or specifically dicer's algorithm if you want the shortest path um which is courteous because she doesn't want to walk too far she doesn't have to uh moreover uh let's see there a couple boundary cases that are probably worth mentioning in your problem so for instance if Kar equals zero in other words I do my binary search I get all the way back to the first element of my array and it's still saying I can't do it what does that mean that means that I cannot go from my source to my target node without passing through a Vertex that has a sensor at it yep uh and in which case what do you do well you can return any path or you might as well return the shortest path so that she can run okay uh and that I believe uh concludes our problem any questions about that one thumbs up cool how are we doing on time as usual I think I'm going to end early and and we're precisely the same time I'm always added problem four okay so problem four we move from one fictional Universe to another here so now we're playing like okay Pawn or something like that [Applause] sorry if I didn't write so big I wouldn't have to waste half of class erasing but that's okay right so cool so now we have Ashley gum and Ashley gum is trying to go from twinkl town to blue blue Bluff and uh these are both two clearings in the TKO region I'm sure if I played Pokemon this would have meaning to me uh or whatever this is uh but in any event we have a bunch of map we have a map of a bunch of clearings not liking the erasing on this board so maybe we'll start up here okay so we have uh n clearings uh and they're connected by two way Trails uh and thankfully there's less than or equal to five Trails connecting in every clearing this is like our favorite detail to add to six6 problems is a degree bound y okay now with every Trail um we associate um a length um which we're going to call L subt for Trail T but an addition to that we're going to have another piece of information which is that it has a set of Critters on a c subt right so now every Trail you know our our our character here is walking along the path and what does she want to do anytime that she walks along a path she collects a critter or however many Critters are on that path in fact she feels a very similar way to how I feel at TJ Maxx right she she's walking down the aisles and like she can't help herself she's got to catch every Critter that she goes past on the path there's there's no option here she can't leave it behind because if she does then she'll be sad and the way the reason why our our character might not be able to pick up uh one of the critters would be if she ran out of her tools for picking up these Critters which are apparently pocket spheres and she has uh K spheres in other words she has like a backpack and the backpack can hold that many spheres at a time okay uh there are a few uh details here one is that every time she walks down a path she collects all the critters but then if she walks down that path again she'll collect the same set of Critters apparently they they respawn they're very prolific these these Critters uh and moreover uh there are stores uh some of the clearings and at these stores uh she can get rid of the critor she currently has and drop them off and pick up uh empty uh spheres instead right so essentially every time she does that she empties her backpack and gets a new set of material where she can keep picking up the critters I have many questions about this character like does she just leave them there does she come back for them later what does she do with the critters there's there's a lot of questions like does she have a bigger bag she can go back around to the stores but in this fictional Universe we're not going to worry about these problems okay and so um right so essentially the question here is that there are two uh uh locations I don't remember the name trundle trown to Blue Bluff that she's trying to travel in between and she gets sad if she comes across a critter that she can't collect so the question is can you find the shortest path without being sad and in like kind of a da da twist in this problem uh if no such path exists in other words there's like she has to walk along some long trail with a bunch of Critters more than K Critters I guess in the worst case then sadness is unavoidable is what your code is apparently supposed to uh return which is really defe us I I don't know who wrote this problems that um okay the question is how do we how do we solve this it looks like a shortest path problem but as with all problems in 66 there's a slight twist right and in this case the twist uh is that it's the shortest path without becoming sad where sadness means that you ran out of spheres to collect your your craters now notice that we're given a budget by the way of I believe NK log NK time is that right like that okay notice that this is a little suspicious somehow it makes us think that the size of our problem really is NK rather than just n or k okay so uh how could we do this let's think back to a problem that we solved yesterday under the assumption that you guys are binge watching your uh 66 problem sessions here uh and remember the problem yesterday we had this dude that was walking along paths and like every third path he had to drink a beer that's I've tried this on my commute home and it doesn't doesn't work terribly well uh but in any event we have kind of a similar scenario here where like there's some number that we need to keep track of right there in this case is the number of Critters that our our character has uh remaining that she can pick up right so she starts with an empty bag as she collects them the amount of capacity in her bag decreases until she gets to a store and then it goes back again but the good news is that our runtime bound includes K in it so it's actually okay to make an algorithm that scales in the number of Critters that she can carry around this kind of a typical but but an interesting uh Choice here okay so remember the the term I introduced last time for this kind of universe is that it's called like a state machine like in addition to walking along the graph she needs to know how much capacity she has for craters uh and so here's here's a way to do it so I think actually this problem isn't too bad given that you saw the problem where you do every third vertex uh in our last problem session somehow it's it's just like a same church different Pew kind of scenario here so in this case uh one thing we can do is we're going to make a graph to colum G he's got vertices V EDG is E just for fun um but what we're going to do is have k + one vertices for every clearing and the reason is that what we're going to do is we're going to walk along the graph and as we Traverse our edges we're not only going to keep track of the costs like the distance that she's walking but also the number of Critters that she has remaining in her bag that she can store and the way that we can do that is by like keeping a bunch of copies of our graph and ascending every time that we collect a new Critter does that make sense okay so here's a let's let's add a little bit more detail here so in particular I can define v c comma I is going to be the vertex per clearing comma crater space uh and and the way that I can view it is that this is um sort of representing that I'm at clearing oops this should be a c uh and I have a i pocket spheres uh that are empty okay so like initially I'm going to start at vs comma 0 and go from there okay okay oh it dep I guess it depends whether you're decreasing it or increasing it oh you're right yeah I'm sorry so in that case I guess it would be K we'll see if I manage to do that consistently throughout my my answer here um okay so now I need to tell you how to make the uh the edges in our graph and so let's do that next next so in particular for all trails from a uh between a and b um with length uh L um and uh Critter C right so she picks up C Critters she traverses distance L she gets from A to B or vice versa our trails are are are bidirectional here uh we need to Define edges and they look like this so we sort of have two different cases uh one uh is where uh you have a store and when is when you don't right because that that's going to affect how your your state changes so right so the first one would be uh oh did I get this whole thing backward oh don't tell me that no I did okay good um great so the first case would be a does not has have a store um right so in this case she leaves with the same number of Critters she had in her bag minus whatever Critter she picks up along the way right so now I'm going to have a uh an edge of length L uh and I'm going to go from va a comma I to v b comma I minus C right so the idea is that I go from A to B and in the process I lose C Critters right but I have to do this for all the possible eyes that I could see in my state so that goes from CT oops to K right C associated with the Trail T which I decided not to use okay uh right so the the basic Point here is that there are a bunch of different states where I can Traverse this Trail but I have to have at least C Critters in my bag if I'm allowed to Traverse this Trail or else I will be sad okay uh and so kind of copy this Edge a bunch of different times to represent all the possible transitions I could make and similarly let's say that a does have a store well I still want to add an edge but now I have the luxury of clearing out all the stuff in my bag uh before collecting the critters yeah so now uh I still want an edge of length L um but now I get to connect more vertices and reset my state state in the process right so now I'm going to go from va a comma I to v b and uh where am I going to end up well how many Critters are going to be in my bag I have a bag of capacity K and I just Traverse The Edge from A to B which contains C Critters so I get in v k minus C like that uh and of of course um I can do that for for all I uh [Music] from oh yeah I have to be careful well no actually just for all I is fine yeah I think there might be a there's either mistake in how I copied it down or a mistake in the problem a mistake in the problem yeah I think this is right yes so I think there's we we wrote for all I and some interval but we didn't have to okay right so uh those are our different cases right so essentially in this case we we we clear out our our Q here or or well not even a q just our our set of spheres we reset we go back here notice that the second vertex doesn't even have an i in its index because it doesn't matter okay and then similarly uh you know so that gets me from A to B I also have to do the symmetric thing to go from B to a okay so now I have a graph um and first of all we should reason and make sure uh that we can actually construct this graph in a reasonable amount of time so let's do that really fast right so uh the number of vertices on our graph well I basically have k + one copies of my graph so it's equal to k + 1 * n that's good so that's order K and time uh order K and space I suppose uh and similarly uh there's K edges um that are associated with every Trail and there's order n Trails because I have a degree bound so overall there's order k n is in my graph okay great so now uh my problem is not so bad I have a a source uh which is the the place where our our Walker starts f t which is the destination where she wants to go um so what do I need well I just need any path that starts at vsk right in other words she starts at s and has a full bag with K capacity and ends up at to V uh T comma I for any I right because it doesn't matter how much capacity she has in her bag when she reads her her her destination um so this is for all I any path avoids sadness and the way this problem is written right so how could I do that well she wants the shortest path um so I can just do dicer's algorithm from vsk and do a bit of cleanup afterward to check all the different eyes and find this closest one and how much time does that take well my graph takes KNN spa space because it has knen vertices and Order knen uh edges so overall this is going to take order KNN log KNN time time which is a good thing because that's exactly what the problem asks for and of course uh uh if the uh shortest path is infinity then what do we know you say it with me sadness is [Laughter] unavoidable this is a weird thing to write on a Blackboard okay so that's our basic problem here so what was our strategy if we step back 10 ft essentially we took our graph um and rather than just making our graph we make K copies of it with edges that kind of Point upstairs uh meaning that you you you give away spheres uh in the the process of traversing these different edges except when you hit the stores which brings you back to level zero um so that was our our basic graph structure and then we just need to do shortest path on that thing all right any questions about that yes last time we did graph duplication we made a it was layered graph and you kept making these Transitions and it was a d so can't we do this in linear time can't we do this in linear time so in other words why is our graph not a dag in this particular case um let me think about that for a second what there's something about this problem that mean it says that the graph has to be a dag uh in particular I guess you could keep walking like if you had a path with a store that were exactly the same as the number of Critters you could keep walking back and forth along that path um and so there's like a little cycle there which would be enough to not be able to do it in linear time well the edges that we constructed are not Ed are not don't necessarily correspond to the edges in the original Trails that's not the problem uh sure that's absolutely right so we we constructed a directed graph out of our original one but that director graph also can contain Cycles right um so yeah so I I think the example I'm giving you works so I have a graph with two vertices maybe there's other grass stuff going on but whatever I have two vertices here and I have some number of Critters here and I have a store on either end of my Edge just because I'm boring and conservative and now well assuming that c is less than K I can just keep going back and forth along this Edge as many times I want and this is for free right because every time I get to the end of The Edge I throw all my critters away um so that's an example of a cycle in My Graph and because there's a cycle I'm not in the the dag case anymore a cycle in the in the constructed graph sorry yeah it is a cycle here and also a cycle in the constructed graph um yeah sorry I guess that's true all right any other questions I can make a hash of here excellent so am I out of time ah Shucks no um okay in that case we'll do the last problem here actually last problem I think is the most interesting one so as usual I've left myself with not enough time okay which of these boards is the tidiest the answer is none of yeah none of the above so let's use the backs here um okay right so our last problem is a uh shipping problem not a trans shipment problem which happens to be my area of research but rather uh just uh a a good old uh shipping thing so here um Strangely I did not give myself my complete notes so this will be fun um right so I'm trying to ship servers from San Francisco to Cambridge by truck and I have all these bunch of third-party companies that all have pairs of cities that they can ship between and only so much these companies are kind of Divas they have a weight limit they only have like cities they're directed edges I can't like they don't drive their trucks back apparently or maybe they like pick up somebody else's stuff and they're just picking your stuff up in the boring direction or or whatever uh so I have a bunch of I have N Trucking roots and uh each root are sub I uh is a tupal with SI I TI w i c i and what are all these things so here uh this is the source of uh every shipping route every Trucking route here this is the Target right so this is like where the truck starts this is where the truck ends this is the max weight that the truck can handle so like the truck only has so much space in it uh you know the tires are only so big uh if I put something of of weight bigger than W uh then my my truck is is going to die so that's the most that I can put on this truck and this is the cost okay and I have uh end roots that look like this I'm trying to ship servers and of course some of my servers are are too darn busy but we make an assumption here which is that our Trucking routes form a uh sort of a continuous Network I can get from s tot and ship at the very least like a pencil eraser you know like some minimal amount of weight okay and so the basic uh end point of this problem is going to be uh to sort of figure out the heaviest thing that I can ship uh and and uh we we give you a problem on the uh sort of on the path toward that uh to help prove a little bit about this this is a very typical kind of setup so again I've got a bunch of trucking routs each one of which has a max weight and I'm going to want to know first of all what's the maximum amount of weight I can ship and then what is the minimum cost I can ship that that weight so in problem a which is marked as useful digression um we're first going to prove kind of a handy uh in equality I decided to go off book with my proof ever so slightly of this so get excited uh for this to be slightly uh wrong in a subtle way which is what I specialize in um but in particular uh we're going to make a a definition here so let's say that Pi is a weighted path okay then uh the bottleneck of Pi of Pi is going to be uh the the minimum Edge weight of of any Edge in in in pi and to make sure that we see how this is connected to the problem um you know if I'm trying to ship a server and I have to put on truck one and truck two and truck three and truck four and truck five um obviously of those five trucks the one whose capacity uh for weight is the small is the only one that matters in terms of the heaviest thing that I can ship okay so uh right now uh given two given a directed graph uh and two vertices s and t we're going to define a quantity called B of s comma T and we're going to say that this is the max over any path PI from pass to T of the bottleneck of Pi okay so so to sanity check this quantity here essentially what it's saying is at the end of the day I have this big network of trucking routes I just want to go from one city to another and I don't care which series of trucks I want to use I just want to maximize the weight that I could ship right and so this is saying I'm going to look at all the different paths that I could take each path is sort of band limited by the one truck that has the lightest weight that it can carry um and I'm going to find the path that has the best bottleneck as measured by this quantity using the word best because I tend to make sign mistakes and that's a vague term okay and then uh right uh so writing too big I hopefully I won't run out of space we're going to make one additional uh definition which is I of T is the incoming neighbors of uh t okay and then the problem is asking you to prove uh a particular uh inequality here claim which is that b of s t is bigger than or equal to um the Min of two values B of SV or W of VT for all uh V in I of T so let's see what this is saying so remember that this is like the capacity that I can ship from s to T using any route um and that that uh upper bounds the minimum of two things right either the capacity of shipping to one of my neighbors with an incoming Edge or the weight of basically shipping from that neighbor to me notice this is kind of similar to a triangle inequality which is why we're going to kind of know how to solve Part B of this problem pretty easily okay um and moreover uh with uh equality uh for some V Star in if okay guess what that VAR star is going to be it's going to be the vertex that's sort of the previous one on the path of of of of of trucks that I actually take to ship stuff right okay so how could we prove this so the intuition here is that the path that's actually giving you this bottleneck this BS comma T has to include one of my incoming edges and I'm just trying to find it right that's that's roughly what's what's going on in this inequality and and by the way whenever a problem asks you to prove an inequality you should step back you know like I feel like I spend like 85% of my day with research students sort of saying like Okay but like what is this really telling me about life and and and this is a good uh example okay so to that end um I'm going to make a definition which I found to be convenient when I was solving this problem um which is the following I'm going to say that Pi s comma t uh is going to be the actual path uh that gives me the bottleneck so this is kind of like the ARG Max over all Pi I'm use really bad notation Pi is the connect S2 T that's how we're going to think of that of the bottleneck so in other words like this is the uh path that actually realizes uh this this quantity B right so in other words B of s t is equal to bottleneck Pi only has two lines has two this is convenient for me because the reasoning about that path uh makes some sense um okay so now uh we're going to prove the inequality first and then we may or may not choose prove the equality case depending on how I feel okay so uh right so let's section this off try and use my board a little more conservatively here uh okay so right so now let's take a Vertex uh V from the incoming uh edges here of t right because that's what we need to to prove this and we're just going to prove the inequality directly here uh in particular um we can define a path that goes from s to T as follows I could take the uh Pi SV and then concatenate onto the end of this guy um T right because we know that there's a directed Edge from V to T by definition of of what this I is okay um right and so this is kind of convenient because this is like the bottleneck path for one of my neighbors and now I'm just kind of sticking an edge on there and we know uh that of course this is a candidate path to get from s but it may not be the one that actually achieves the bottleneck okay right so uh yeah uh and let's uh oops let's define that to be Pi uh twiddle just for for fun I like give things names okay so what do we know we know that b of s comma T well this by definition is the max bottleneck of any incoming path going from s to T this is a path from s to T yeah so because this is the max it is bigger than or equal to bottleneck of Pi twiddle right that's the nice thing about Maxes they tend to be bigger than other stuff okay uh well what is the bottleneck of Pi twiddle well remember our definition of bottle bottleneck here right it's the Min Edge weight over my entire path well I have two options either that edge weight is The Edge from V to T or it's the edge we that's associated to the rest of this stuff yeah so either um this is the Min of the uh bottleneck of the first segment of our path Pi SV by the way that may be empty and that's like okay that's just like a one Edge path you can dispense with that case pretty easily uh or the weight of VT cool well by definition bottl neck of Pi SV is exactly this quantity right because that's what I chose it to be over here yeah so this is exactly Min the b s comma V That was supposed to be a v but I wrote a t or W of V comma T and that is exactly what we wanted to prove yeah so that takes care of our inequality case do I want to do the equality case I don't think I do yeah so uh it's not too hard to check the equality case essentially you you can make a pretty easy contradiction right because if it's strictly larger then what does that mean that means that every single incoming Edge none of them can be the edge where your bottleneck path comes in and obviously there's something wrong with that uh okay so I'll refer you guys to the uh the notes for that one and finally uh the problem says uh assuming that uh so now we have kind of a funny constant in here just to make your life a little bit annoying we have um at most three Square Ro TN cities that we care about um again why three why not uh I think uh and what we want is the weight of the single uh largest server and the minimum cost to ship uh that thing so we want one the largest weight we can ship we'll call that W star to ship and two is the smallest cost um to ship that weigh W star okay so let's do two first because it's easy so let's say that I was able to compute W star so now what can I do well I can construct a graph by only keep around the the the trucks that can ship at most at least this amount of weight because the other ships are I really want them to be boats in this problem but the the other trucks uh are are useless right if they can't cover W star then they're not pulling their weight yeah so to do uh part two here what can I do um I can make a new graph uh G Sub C with a vertex for every city and um and uh right and an edge d a directed Edge sorry per uh shipping route uh with um this is going to be an unfortunate clash in terminology I'm going to say Edge weight to refer to the edge in My Graph and that's going to be equal to the cost of the edge um uh and only keep around uh but only for roots that can carry at least um W star amount of weight and now what do we do well it's the shortest path right at this Point um you know shortest path which is really the minimum cost in this case because that's what we're associating to the edges um is going to give me the cost of shipping wstar in my network I think that's pretty obvious from this construction um so that's drra d i j k s t r a and now the only question is how much time does it take so let's say that I do the brain dead version of dyra where I just use a direct access array to do my priority CU so if you call that'll take Big O of mod V cubed here squared squared yep you're right sorry I was thinking Johnson's algorithm okay well in this case how big is V well it's square root of n 3 * square root of n at most so of course v^2 uh is really big O of n uh and and and the that part is solved yeah so really our only uh remaining problem here is to do part one and I don't have nearly enough time in fact I'm completely out of time so maybe we'll just talk through it really briefly sorry about that um essentially the basic observation here is that the inequality that we proved in part A of our problem it's kind of like the triangle inequality of the bottleneck World in some sense um essentially what it's giving you is some or you know update formula that looks kind of like the update formula that we'd apply in dce algorithm for shortest path right the basic assumption here being that well my shortest path has to come from somewhere right so if I look over all my neighbors and then I kind of add in my closest The Edge uh or rather you know the sum of the path length to the previous vertex plus the edge to me it gives the shortest path to me here instead of that we're saying the biggest bottleneck path so what do I do I look at all of my incoming neighbors I find the one with the biggest bottleneck which is band limited by their bottleneck plus the bottleneck of the incoming Edge uh and then I update myself so the only thing remaining here is to basically do exactly uh dce's algorithm but rather than updating by summing EDG length we update by using this formula and essentially everything else Remains the Same so conveniently I've run out of time so I won't even have to uh uh jumble this one on the board I'll I'll let you guys do that one at home but I actually think the explanation of the written material is pretty self-evident for this problem so that's probably just as well