i'm jason hopefully you guys saw me on tuesday uh this is our first ever 6006 problem session that we'll be having on fridays this term it's really an experiment we've never done this before but one of the things that we were discussed while preparing for this class is that we have two different methods of instruction formally usually in this class a lecture which is there to present you with the fundamental material the the data structures and the algorithms uh that are kind of the base the foundation of what how you will be approaching problems in this class uh and then the problem sets that you will will you will work on our applications of that material but it's there's usually a much different feel between those problems that we'll give you than the underlying foundational material right so the application that material feel very different and a lot of times there are tricks to approaching the problems uh or ways of approaching the problems that um you kind of just have to figure out by working on the problems sometimes going to office hours but what we wanted to do this term was to since we had the opportunity to be recorded by ocw was to record us going through some problems that we've had on problem sets in the past so you could see how we would approach working on these problems that you'll be working on at least in a similar vein so that's the goal of this these problem sessions in the past for ocw we have recorded recitation but we felt that that was a little less useful to you guys because recitation is meant for interaction questions one-on-one questions we wanted to be a safe space for you guys to interact with the material with in a in a smaller environment that might not be recorded so that's the goal of of this these sessions that we'll be doing on fridays any questions about what we're going to be doing today okay so uh we do have a handout up here by the door um which uh we may or may not have in the future this is all an experiment so you'll have to work with us as we figure this stuff out um they were posted on uh elmod about an hour before this session we'll try to keep that uh as a standard uh but it just shows you the the questions we'll work on uh today in the in the session it won't necessarily be the entire it's it isn't just the problem set from last term it's a selection of problems from previous terms and some of them have been edited to be maybe a little shorter and things like that um so what we're going to do is just go through the problems one by one i'll try to just kind of show you how i'm approaching the problems uh but at any point if you want to you can ask questions that's fine okay all right so the first question we have is has a setup that's very similar to what you will have on your pset one it's essentially saying that uh it has it is usually many parts this has two parts an a part and a d part uh i've i've omitted a b and a c that that was on last term's problem set and it has five functions each and you're trying to order them increasing asym based on their asymptotic behavior so here are the uh the functions that we have uh maybe i'll stick it up instead all right so we have a few sets of functions and we just want to order them and some of the the functions may be uh asymptotically equivalent right in which case when we are ordering these things we're going to put those numbers in a in a set so what we have is as an example are three functions uh n uh root n and n plus root n this is one two three and what we're going to ask you to do is order those functions uh based on their asymptotic complexity so hopefully you guys can get this one which one's the slowest growth in term root n so number two so if we say f of two will be our first one and then how about the other two they're the same they're both order n right so we would put in set brackets f1 and f3 on your problem set if you put just two and one and three here that would probably be fine okay but if you were to put two over here or not have these curly braces around here those would not be correct and you'd get points marked off does that make sense okay so we're going to approach the first set of problems first set of functions which is a little different than the second set of functions hopefully this one's a little easier one of the common approaches that i have in going through these things some of these are in a form that is hard for me to tell how they would compare to other things actually most of these are are fine but in general does can can anyone just buy eyeballing tell me an order that that works for them yeah um okay this is a little a little difficult to do on the spot with five functions okay okay great that's that's excellent so what we've got here is on f2 f3 and f5 we kind of have this n leading term if we factor an n out of that then we're comparing log with a you know basically we look over here at the polynomial function right this one's smallest out of them and then the log factor is smaller than a polynomial factor right log grows slower than linear right and so this guy is smaller than f2 is smaller than f3 that's great that your colleague said um in general you hopefully you proved in recitation today no wednesday this nice uh you know fact i guess that a is is less than asymptotically this polynomial this log and to any power is asymptotically less than any polynomial for any positive a and b and in particular there's actually a stronger thing you can say which is little o did you guys talk about little o in recitation at all probably not it's kind of the same as big o except is big o minus theta right so things that are asymptotically equivalent are not going to be included in this set so actually these things are strictly asymptotic grows strictly asymptotically slower than any polynomial does that make sense okay so knowing this identity right or this uh relation can we say anything about f1 someone maybe maybe someone else any a and b any positive a and b anyone else have a a guess on how yeah uh that f1 is less than f1 yeah f1 is less than f5 right because just using that identity this sorry a here that i erased stupidly right is smaller than say this is small this is bigger than n right and n to the b being one is bigger right so uh and then as your colleague pointed out before this thing is exponential so definitely higher than a polynomial okay so that was very easy right so the the answer here is if i if i got uh if i remember correctly f1 f5 f2 f3 and then f4 great so that one was pretty easy how about b or d i guess yeah sure how would you go about proving that so there is a proof in your recitation handout uh there the the method in which they proved that in the recitation handout was putting um the the two taking a ratio of the two functions and taking their limit as n goes to infinity right and if the top one if it goes to it it grows arbitrarily then the top one would be asymptotic grow absent faster and if the it went to zero the bottom one would grow asymptotically faster and if it went to some constant then that would be asymptotically equivalent does that make sense in in actuality to make the limit easier to take we take the limit of the logarithm of the ratio it just made it easier does that make sense okay so let's move on to b b we have a polynomial and an exponential and then we have these things down here what do these things in in parentheses mean choose right it's a binomial coefficient uh does anyone know what a binomial coefficient is yeah pro hopefully from o42 or something like that or whatever your competition math background is um but in general we have this definition right this thing is what does anyone remember what does n choose k mean it means that yeah to choose k objects yeah the number of ways to choose k objects from n things right i never remember this formula uh and probably a lot of you have memorized this formula uh i'm not going to ask you to do it i'm going to tell you how i kind of think about this uh what if i want to know the number of permutations of n choose k i mean of of of n so sorry just how many permutations are there of n items what is that that's just n factorial right so what we do here is we want to choose some n number of things okay i have n factorial different ways of choosing those but then essentially in here and in here k and n minus k i don't really care what their order is right so i'm going to divide out the permutations of this stuff and this stuff does that make sense so the formula here as i remember it that hopefully is correct is n minus k factorial right so i'm getting all of the permutations of the whole thing divided by their constituents does that make sense did i do that right okay cool so that's a nice transformation so the first step is kind of writing these in terms of factorials that doesn't really help me any because i don't know how big factorial is base with respect to these other things does anyone know how big factorial is yeah you can use sterling's approximation so that's that's nice does anyone remember what sterling's approximation is no i don't remember either i always have to look it up uh sterling's approximation says n factorial is uh approximately and this approximation is much stronger than um uh than an asymptotic behavior it's actually as these things as n approaches infinity these things are equal the limit is the identity uh but the approximation is the square root of 2 pi n n over e to the n okay that's fun so what kind of growth is this super super bad right right it's it's you know definitely exponential it's higher than exponential it's n to the n something like that dividing out uh an e e this is uh you know e right uh the base of the natural logarithm right and this is a constant right and so it's pi pi is a constant kind of interesting that we have two transcendental numbers here that's that's kind of fun like mathematics i'm sure some one of your o42 instructors could tell you why uh i can't right now off the top of my head but this is this is an approximation that's very good right and actually uh some sometimes other people will think this is this is what people call sterling's approximation one a weaker notion that sometimes is useful for you is uh if you take the logarithm of both sides this is asymptotically what if i took the log of this thing it is uh you know a polynomial thing it's it's basically n log n right so it's if we take a log of this thing it would be uh various things all right let's let's do it out 2 pi n n over e to the n so when we're inside a logarithm multiplication we can split it out becomes addition division becomes subtraction right and this thing grows faster than all these other things so we can ignore them when we add them out asymptotically and so we end up getting is this n to the n the n comes out on the logarithm and you get something that's theta n log n oh that's fun this is something we might use later on in the class okay okay but when we are comparing these functions one of the nice things to do is convert them into something that's familiar to us so that we can compare them easily right so here this thing is whatever that thing is right roughly square root n n over e to the n right that's that's the this is uh i'm gonna say theta okay that's a little bit more precise all right then what about these two things let's start with the bottom one can someone tell me what this is asymptotically yeah n cubed why is that well if we plug this stuff into that definition here right we have n factorial over 3 factorial n minus 3 factorial right n factorial over n minus 3 factorial just leaves us with an n an n minus 1 and an n minus 2 over 6 right and if you multiply all that out the leading term is an n cubed right so this thing is asymptotically n cubed i kind of skipped some steps but hopefully you could follow that okay and then the last thing to remain is this one right there that one's a little tricky anyone want to help me out here what we can do is we can stick it into this formula and then apply sterling's approximation to replace the factorials that make sense okay so what i'm going to do is let's do this in two steps uh this is going to be n factorial over what is this n over 2 factorial and then what is n minus n over 2 that's also n over two so this is going to be n over two factorial squared is that okay yeah now let's replace this stuff with sterling's approximation and see if we can simplify okay so on the top we have 2 pi n n over e to the n over and then we've got a square here pi n x canceled the two n over two over e to the n over two did i do that right okay i can't spell and a lot of times i make arithmetic errors so catch me if i if i am doing one okay so let's simplify this bottom here uh i'm not going to rewrite the top the bottom here we square this guy it's pi times n and then this guy n over 2 squared that just stays as an n right then we have n over 2 to the n over e something like that and over 2 over e to the n that makes more mean happier okay so now we have this over this how do we simplify well we can cancel out one of the root n so we've got square root of pi n down here and square root of 2 up top and then what do we got we've got n to the n down here and n to the n down up there so those cancel we got e 1 over e to the n 1 over e to the n up there those cancel what's left in this term when after we cancel uh 1 over 2 to the n in the denominator right which is 2 to the n in the numerator okay so this thing is what this thing is right asymptote we can get rid of these constants and it's root n it means it's 2 to the n over root n asymptotically right does that make sense everybody okay with that knowledge and i'm sorry for my messy board work uh what is the ordering of these functions then can someone help me out someone else eric i'm sorry you can't answer come on guys you followed what i said how about some of the starting start it out for me right so both of these things are asymptotically equivalent so we should put those in brackets f2 f5 f3 this one why this one i'm i'm just asking you to justify what you're saying this one's the biggest i don't know if that's f4 f4 is the biggest right so this one's definitely bigger than this right because it's n to the n as opposed to two to the n okay so for any n larger than 2 plus e is is you know fairly obvious that that's bigger so when have 3 why would f3 be before f1 but we're dividing by a polynomial factor right so it's going to be uh slower asymptotically than than the first one right there right so you got it right what is it f3 f1 and f4 okay cool so it's a little complicated but you know just applying some logarithm and exponent rules uh understanding that log rhythmic factors grow slower than polynomial ones and again grow slower than exponential ones and being able to do some transformations of some of these mathematical quantities to get them in a polynomial like looking form is how you're going to approach these problems does that make sense all right so we're going to move on to question tuna yeah you've got a question so it's just that i don't i don't know how to simplify that any further right you've got a polynomial factor here and then this is an n to the n term divided by an exponential okay f3 took this uh this little cycle here okay what we did was we probably we uh expanded out the definition of the binomial coefficient here then we applied sterling and then we simplified and got back does that make sense yeah sure is there a reason why is f3 before f1 right so this is if i erase the 2 and the pi this thing is theta of that 2 to the n over a polynomial factor right it's over n to the one-half right n to the one-half grows uh non-trivially right right and so this is going to decrease the running time of this thing by a polynomial factor right you could think about a we're multiplying this by a n to the minus one-half as well right that's another way of thinking about it any other questions okay so we're going to move on to problem two i guess i need a an eraser so problem two is kind of a funny looking problem uh the point of this problem is uh kind of to get you to think about using some of the things we're going to be using in this class as a black box if you if you using something as black box means is that it has a kind of a public interface that you're allowed to work with but i'm not allowed to see what's inside of it right and a lot of times what we'll do in this class is try to use a black box and just try to use the abstracted outer functions uh so that we can prove things about it right we can just accept those as true and then use those to to deal with our analysis so what we're given in this problem is a data structure supporting um a sequence interface that you heard about yesterday right what's the sequence interface again it what is a sequence interval how does it store items anyone remember yeah in in well it okay all right so so what your your colleague is saying here is we list them in a contiguous array okay does anyone have a problem with that definition yeah up there okay if you use the link so um one of the the important things about this class is abstracting this idea of an interface versus an implementation and so what this student down here said is talking to me about an array as an underlying implementation and what the student back there was talking about is a linked list these are both things that can implement that interface right but in reality the interface is something abstracted outside of those ideas we could implement with either of those data structures right so what makes the sequence interface a sequence interface yeah an order or at least an index specific way that allows for calling though so so it's about the data right that we're storing right the data that we're storing we're storing some number of things right and the important thing is that the data structure is maintaining being able to find items in that set by by maintaining an order on them right i usually like to call it an extrinsic order on these things right it has nothing to do with what the items are right it has to do with how i put them in order there's a first thing there's a tenth thing there's a last thing right that's what a sequence of items is right and so uh what this data structure is doing that's the input that is the kind of uh what we have available to us in this problem is some kind of data structure storing a sequence of things and it can support these four operations right and insert first insert last delete first and delete last and it supports each of those things in constant time okay you don't know a data structure that does that yet you will on your problem set one and we'll talk about another way to do that today um but we we don't care how it's implemented we just give you this black box that achieves these things yay awesome uh and so what we're trying to do is we have this thing right and i want to be able to manipulate the sequence stored inside but all i have access to are these external operations okay so the idea is going to be let's implement algorithms for these some higher level operations in terms of these lower level things that are given to us does that make sense okay and this is actually a pretty easy question hopefully we'll have slightly more difficult ones for you on in a different context uh on problem set one okay so uh the first uh operation we're going to support or try to support uh is an operation called swap ends okay and what this is going to do is take the data structure that we gave another way you could do this is put this as a method on that data structure but let's do this separately it's going to take that data structure that we gave i gave you that's storing the sequence as the only argument and what is going to what we're asking you to do is describe an algorithm to swap the first and the last items okay so i i mean i if it's if it was an array i could just look at index 0 look at that look at the last one look at that and swap them okay but i don't have access to what that underlying representation is so how would i do that using the the things that we have available to us this is a pretty easy question uh what do we got just a quick question yeah does the delete method also return whatever deletes yes yes it does so in general if you actually take a look at the session notes it's giving you a nice little reminder recall the delete operations return the deleted item okay it says it right there on the thing all right uh yeah did you oh i i also had a question sure and then this actually after you got it it's not related if they don't specify a space of complexity one of the things that eric talked about yesterday was generally in this class uh if you have it usually what we'll give you is a running time bound on the things that you ask for and because allocation of space by our model takes that amount of time right the amount of time but the amount of space that we are using is going to be asymptotically upper bounded by the time that we're going to use for the algorithm right and so generally we'll ask you to stay within a time bound and not ask you to do something separate with space but there are problems probably at the end of this unit where we might talk about space complexity uh but usually we will be we will be very specific if we if we want you to think about space any other questions all right so how do we implement this swap ends thing yeah this is a pretty easy one yeah okay so another thing about this class right your your colleague over here is trying to write code to me okay uh which is great for a computer and that's great if you're taking six level nine it's not great if you're talking to your friends or if you're talking to me right i am i can't parse code in my head and compile it all the time sometimes something i can but but not all the time especially when it gets to be a large program so i want you to explain in words to me and we want you to explain in words in your latex submissions what it is the algorithm is doing okay so can you start over with your description words are hard i agree with you okay computer science i would delete the last the last then okay okay okay so proposal we have a sequence of things uh again as eric was doing in lecture yesterday uh this isn't representing an array it's representing a sequence so this is the front first i guessed and last and what your colleague was saying was to delete this guy yeah and stick it on the front okay maybe by using delete last and insert first okay that sounds pretty good does that do what swap ends is doing swap ends swap the first and last items in the sequence it's probably better to first store it in some other variables so that way we can get the delete the end so what your colleague is saying is well we've done kind of half of our work the first one's still over here right that's no good okay does someone have a way to modify this yeah before i modify the question in order to modify um restrictions about the amount of things we're storing ah yeah so how much extra space can we use for example right the easiest way would be to um delete the labs that they prefer and then just if we have them already kept them but i don't know if i can keep two different bibles good good question so the question right can i use additional space and in general if we don't give you any restrictions on what you can store then you can go wild do whatever you want outside of this data structure right like one of the things you could do is you know remove first on all of these things right store it in some data structure you like manipulate it as much as you want and then insert first i'm all the way back in and rewrite the thing but that's not going to give us constant time which is what we're asking for right but if we don't tell you otherwise feel free to you know i mean probably you're only allowed to store a constant number of things since we have constant time but generally uh unless we say no you can't use additional space you can use additional space okay so how would you do that would probably erase the last one that's great so what your colleague is saying we delete both of them we store them in temporary variables and then one at a time we insert each of them in their corresponding place using the functions that we have available okay so if i were to write little pseudocode for this um i might take you know the first one right i'd delete uh first okay i'm really abusing notation here but that's okay you get what i'm saying uh delete the last and then store them in their respective places insert at the front which one i'm going to insert what's up hmm speak up guys x2 yes thank you and insert last x1 right okay that's pretty easy yeah what would in this case what would let her and i think this might be relevant from like what would constitute a pseudocode versus writing pythons all right so for this this problem you'll see the solutions posted to this later on in that one i wrote up a description of what i was going to do and then i actually because this was pretty easy you know i actually wrote down some python code to do whatever whatever this thing was but in general and uh it's actually okay to write python or pseudo code of this form on your problem sets or on an exam or something like that but if we can't understand what your variables mean if we can't understand what your pseudo code is doing then that's not sufficient right so the reason why we ask for words is so that you can communicate those ideas well okay so can you also have a combination of pseudocode and description sure yeah including both of them can be clarifying for you potentially yeah any other questions okay so now we have so one of this is not such a interesting question from an algorithm standpoint right this is a constant size problem kind of right i have this data structure i do two operations i need to do something right and this is so easy that i'm really not even gonna argue correctness i'm not even gonna have to argue correctness to you because we're essentially just doing exactly what we asked for right so you don't most of the time in this class when you're doing something non-trivial especially when you're doing something that has to recurse in some way we do want you to argue correctness okay but in this case the for example the time analysis is very easy right we do four operations they each take constant time so this operation takes constant time done yeah all right so how about the second operation second operation at least uh allows us to use a little bit more so shift left the k this is the operation we're supporting now is we're given this sequence and what we want to do is take the first k right here and stick it over here at the back okay so that the uh these k go here so the kth item ends up being the last item and the k plus one item now becomes the first item does that make sense okay again this is actually not such an interesting algorithm from an algorithm standpoint but it's hopefully uh helpful to talk about from an instructional point of view okay so how would i approach this problem i i need this operation to happen in order k time yeah okay so first i'm go and delete set a variable x1 to be the d dot delete first element then a pet do dot insert at the last exponent d write a for loop and then do that k2 okay and i should have take two steps which is okay okay so what your colleague was saying is uh that we're just going to delete this guy stick it on there do it k times that sound good yeah so there's one of the things in this class that you have in terms of implementation right usually there are two ways at least two ways you could do something that takes longer than constant time you could write a for loop or you could use recursion right and that's sometimes approaching a problem would be good one way rather than another right why is it that a lot of computer scientists as opposed to coding engineers prefer to think about an algorithm recursively does anyone know why at least i do when i'm explaining it from a theory standpoint it actually might not be good from an implementation standpoint because your computer can vectorize for loops and things like but that's not something we need to talk about uh why would we want to talk about a recursive algorithm maybe more it lets you break up the problem much smaller more manageable pieces okay so recursion uh lets you break up the problem into small measurable pieces that's that's actually true in in some context what your recursion how i like to think about recursion a lot of times is if i have a non-constant amount of work that i have to do usually easy for me it's hard for me to hold a non-constant amount of information in my head right what i want to do is think about a constant amount of information at at any given point in time because that's easier for me to argue on right it's easier for me to think about making arguments case analysis on these small amount of things and so one of the things you can do is if you break it down so that i i solve a slightly smaller problem recursively and then do a constant amount of work and maintain some invariant then it's very easy to argue things about it right it's very easy for me to convince myself that this thing is correct okay so i'm going to provide a recursive way of solving this problem can anyone set up maybe a recursive way of thinking about this problem instead of putting this inside a for loop like your colleague was saying um ah so what your colleague is saying is setting up the a very nice thing right but she is saying that if we if we think about this recursively we'll think about a base case which your colleague was saying maybe k equals zero right uh and otherwise if we're not at zero what we'll do is we'll start it out right move one of these guys over and then we have an instance where we want to shift k minus one things over right it's we want to do the same thing but with k minus 1 things and so we can just call this thing for a smaller value of k does that make sense all right so let's try to write that out um the first thing i'm going to write out is kind of a a break if if i'm at a base case let's not do anything to this thing right and maybe i also want some bounce checking to make sure that we're in range okay so i'm going to say if you know our k is less than one right we're certain i don't think we should be doing anything to this array so let's just not do anything right if k is less than one or k is bigger than the length of d minus one so i don't know what to do if i'm you're asking me to shift more than the things i have right so let's not do that uh is this uh i guess it's really yeah because if it was length of d right we would just not move anything anyway right because we'd shift the whole thing right so we don't have to do anything all right if we're in either of these cases we're just going to return because i either shouldn't do anything to the array or i have no idea what you're talking about right if it's negative or something like that okay so that's the first thing otherwise what do we do we shift one thing over and then we make a recursive call does that make sense okay so we'll delete the first thing as a temporary variable right delete first okay and then we'll insert last uh x right and then we need to do the recursive call so what's our recursive call look like yeah yeah so shift left d k minus one okay and then we can return this this thing doesn't need to return anything it's just doing stuff to the thing right and whenever we get this k we make a call that gets down to zero we will terminate right because we will return right we're in this range somewhere between we have an input after this line we know that k is somewhere between 1 and n minus 1 right and what we'll do is every time through this recursion we will subtract 1 from k so this is a nice well-ordered sequence right we do the correct thing obviously right in the base case and as long as this thing was correct for a smaller value of k this thing also does the correct thing right because we're shifting over one as we are asked and we're letting this do the work of the rest i don't have to think about that right like i just have to think about this one loop this one part of the thing that i'm doing constant amount of work is done in this section and how many times do i call a function okay yeah i think k minus one times or i don't know i forget but it's order k for sure right and we do a constant amount of work per call ignoring this extra call does that make sense right so this thing runs in order k as desired okay does that make sense all right so now we'll move on to question three does that any questions about question two it's that one's really probably one of the easiest problems we've ever had on a problem sorry to uh scare you okay so problem three okay so this is a little block of text right here okay a dynamic array can support a sequence interface supporting worst case constant time indexing as well as insertion and removal of items at the back of the array in amortized constant time so this is what we did yesterday in lecture right we showed how a dynamic array it's fast to do dynamic operations at the end right okay however insertion deletion at the front is not very efficient because if you tried to do that you'd have to shift everything over right that makes sense all right on the other hand what we talked about yesterday was linked lists uh they can be made to support insertion and uh deletion at both ends in constant time okay so that's a little foreshadowing of something you're going to do on pset one okay but in lecture we talked about that operation that data structure a singly linked list being good at dynamic operations at the front of the list right because essentially we could just remember where the front of the list was and swap things in if as as needed right that makes sense okay so on your problem set what you're going to do is make end operations good on the length list as well as well as supporting another operation uh but what's the problem with linked lists uh as compared to dynamic dynamic arrays yeah yeah linked list lookups can take linear time right because i have no i don't have the benefit of an array where i can randomly access something in the middle by essentially just doing one arithmetic offset calculation from the front address right and being able to find this thing further down in constant time using our com model of computation of the random access machine right you know linked lists these things could be stored all over the place in memory and i have to kind of traverse those pointers until i get to the one that i'm looking for right that's that's a benefit of an array-based data structure versus a a link to a pointer-based one right okay so the then we get to the meat of this question show that we can have the best of both worlds right we can have a data structure that supports um worst case constant time lookup just like an array but amortize constant time dynamic operations from the back and the front of the sequence does that make sense all right so is this question or if okay yes can i define sorry about that can i define amortize one more time okay so this is this is a tough thing to define in general but and uh but not that much right so all right so amortization usually you put in the at least in this class we're going to put in in terms of the data structure okay so you have this thing right it supports some operations and you're going to do a bunch of operations on that thing right there's not really a reason to have a data structure unless you're going to do lots of things to it right otherwise you just write a single algorithm to do whatever it is that you want to do right so data structure the the value of the data structure is that you can do some work up front by making this thing to make some of these operations faster okay so what amortization means is okay if i have say a dynamic array where i'm going to be inserting things at the end right yes sometimes when i add something i'm going to spend a lot of time to add that thing i'm going to spend linear time right but what's the point of this data structure in the first place the point is that i want to be able to potentially add a lot of things to this thing does that make sense right amortization is saying that even though sometimes this operation will be bad right averaged over many operations this is going to have a better running time that's the amortization so more formally right what's that's going to say is if i have an operation the definition of it running in amortize some amount of time say k time or yeah sure that means that if i do n operations kind of generally for large n right if i do that operation n times the total time it takes me to do all of those operations is not going to be more than n times k right so on average it's going to take me k time okay now in o46 you'll get a more formal definition of that and you'll get a lot of ways of analyzing things like a potential function and we're going to use some what we call charging arguments even even today um but it so it's a much broader uh uh analysis paradigm than what we're going to talk about we're only going to talk about it for this this material with dynamic arrays and we'll just kind of it's just kind of an introduction to that concept but does that make sense amortized as a financial term right if you know from financial term it kind of means over the long term this is what it is on average right you can think about that but that's different than running time that's average running time of an algorithm right it's it's a much different concept right what do what is an average running time well that that's that's hard to define because it's talking about an average over all possible inputs and then okay maybe some inputs are more likely than others right and so you've got a distribution on the inputs and you're trying to average the running time that's a much that this has nothing to do with that right amortization means that you have a usually a data structure that you're operating on and you're doing an operation multiple times and you're getting a benefit because you're doing that operation lots of times okay and so when you are instantiating a python list and you're doing push and pop operations on the back right that's or is it append a pendant and pop okay i'm i've been writing javascript a little bit recently um but so append and pop right those those operations while not cheap all the time are cheap well enough that when we analyze an entire algorithm that might do a linear number of uh appends to this list right all of those pens added together will only take linear time because i've done a linear number of them does that make sense okay long-winded uh answer to your question sorry about that uh any other questions before we get going all right so how can anyone have any ideas of how we can use the ideas of a dynamic array and make it good for operations on both ends i'll let someone else answer i'll give give a second and then go to you in a second yeah sure that's that's an excellent idea is one of the ways we're going to we're going to talk about two ways of doing this um right so what your colleague was saying was that in lecture when we were talking about dynamical ways and we wanted to make operations on the kind of the right side the end uh fast right what we did was we allocated some extra space at the end and then when we added things right we didn't have to reallocate we had space to put those things right so what your uh what your colleague was saying was let's just do the same thing on both ends okay let's leave some extra space on the front and extra space on the back when we instantiate this thing and then we can rebuild less frequently than if we didn't have that extra space does that make sense okay so what we had for let's stay down here so this is question three right the idea of the dynamic array right was that we kind of left some extra space here at the end right so that uh sure we allocated more than we needed to right but when we insert things now it's cheap and we don't have to allocate more space for this thing until we've done a linear number of insertions right this was and this was n really any constant factor we'll do here but if you had n things here we'd be assured that i wouldn't need to rebuild this thing until i've done a linear number of operations and so in a sense i can charge the linear time operation of re-expanding this thing to each one of those operations and so on average it'll be constant does that make sense right so instead what your colleague was saying let's instantiate this thing with some extra space on both sides okay so now as i insert thing here insert thing here blah blah blah blah i'll definitely know that after a linear number of insertions when i rebuild this thing i'll have done enough operations to pay for that expensive operation does that make sense so that's the idea behind you know expanding this dynamic array to be kind of this dynamic deck right so it does it's a doubly ended queue kind of system where i can do dynamic operations efficiently on both ends okay so one of the things that we talked about uh yesterday was also removing right at the end right removing uh items from the back of this thing will decrease the number of items we're storing right that makes sense and maybe we're just fine with that right but what's what's a problem what what's as a programmer why might you not like just removing items until you got to nothing and just leaving the space where it is yeah it might lock up a lot of memory yeah so let's say over the course of my program i use this data structure right i'm just trying to fill it up with stuff and then i remove all but like two things right and then i go about my business i run through the program right but i'm i'm never really using all any but those two things for the rest of my program but now i've got i don't know maybe i did put a thousand or a million or a billion things in that thing and then when i as i decreased uh as i removed things from that item i still have all that space there being taken up by essentially is nothing right because i've removed everything from it at least in my conception right so what i would really like to maintain with this data structure is that at no point in time am i using more than a linear amount of space with respect to the number of things that are stored in it right does that make sense so in a dynamic array right what we do is when we get small enough let's resize this thing down so that we have we're using less space okay so when should i as i'm decreasing as i'm popping things from the end of this thing right at what point do you think i should rebuild my array when i'm no longer a linear amount well that's a little hard to tell what that is in real life because our ends aren't arbitrary we need to actually have a a time at which we need to transition over and copy things over so when might we want to do that say again after n over two removals okay so i remove n over two things okay so now we're kind of at a n over four fill rate i mean so we're using a fourth of the space okay and now great so you're saying rebuild okay so i'll stick everything in something that's now this is m i'm going to call this m and now we're sticking it into something that has size m over 4. sound good yeah yeah everyone okay with this oh okay so what you're saying is that we we actually want to keep some extra space back here right and why is that because imagine if we just allocated this amount of space and i removed the m over four plus one item here we resize down to this thing and then i want to do an insertion again right well then i have to re-expand out to something like this right and that's maybe not going to be a good thing right we might have to bounce back and forth a lot that's that's hard for me to think about what we're going to do right but if we always resize to a fill ratio that includes a linear amount of things on the end then i know that when i resize down you know i'll be doing either a linear number of deletions or a linear number of insertions before i have to rebuild again right so this charging argument again i have to do a linear number of cheap things before i have to do an expensive thing again okay so i resize down to b still keep a linear amount of extra space at the end right and with the double ended thing you can write the same kind of policy right with the extra space as your colleague was saying we can just resize down always to shift these things to be placed in the middle with a linear amount of extra space on the ends right does that make sense no questions all right that was a way in which we kind of had to redefine an entirely new data structure right we took the ideas behind dynamic arrays and we extended those ideas to make this thing have extra space on both ends but we kind of had to do that re-implementation all by ourselves right if we were doing code that would be kind of gnarly okay but what if someone just gave us a dynamic array right like what if someone gave you a python list right and you wanted this functionality right i don't want to re-implement a dynamic array but i want this behavior so how any way that i could do that by reducing to using a dynamic array this kind of running time no no no one no one thinks that we can do this this is impossible no no ideas no ideas how could i use some let's say i had i have a dynamic array right that's good on one side is there anything i can do to support dynamic operations on both sides of a sequence yeah are we able to just use like a second dynamic already i like oh that's supposed to be empty right yeah so what your colleague is saying yeah let's do that right let's have one pointing forwards one pointing backwards right this is the first of a certain thing right when we were doing just a dynamic array here where we had to rebuild everything it was important that we kept track of where the front thing was right so that we could do constant time indexing right we could as this thing changed we would now have to compute where our index was in this thing by adding it to where the front was right okay on this one we've got some similar problems so what i'm going to do is i'm going to divide the sequence i'm trying to store up into two sections right maybe about the same size right so each of these contains a linear number of items that's how i'm going to instantiate my thing with a linear amount of extra space on both ends okay so now as i insert on either side or delete from either side it's going to work just like a dynamic array right i have to do some arithmetic here to figure out where if i was trying to access these items i'd have to like subtract from wherever this thing was right i'd have to do some index arithmetic but you know that's tedious but you know you could do it right okay there's one caveat one problem that you run into in using something like this and what would that be yeah i'm not sure that you can't store things in the second half in here in here right so what i'm doing here is actually i'm thinking of this as two dynamic arrays but i'm viewing this one in reverse right so this is actually the last of this dynamic array does that make sense all right so if that's the situation i'm in is am i done do i do i have to care about anything else you guys are all like we're done and i would not give you full points why aren't we done uh well so okay so what your colleague is saying is we somehow have to merge these into one array so we're getting around that by kind of keeping indexes to here and being able to do index arithmetic to kind of simulate an array underneath right so we can compute where these indices should be okay anyone have another problem with with an underspecified data structure here yeah i see so what your colleague is saying which is exactly correct if i were removing things removing things removing things uh i have nothing else in here if i try to pop from this end again i'm gonna have to pop from the beginning of this thing which i don't really that's that's gonna break something of what i'm doing right it's not maintaining the invariance of what i want on my data structure and so the only caveat here is that when i reduce down to one of these is empty what do i do you could cut this thing in half move these elements over but that's going to leave these things in the middle here right the nice thing that happens here is i've done a linear number of options operations i have i i now have an amortized cost buildup that i can spend to now rebuild the entire data structure does that make sense right i can now once i get down to this thing you know take whatever the remaining things are split in half put it into two entirely new arrays copy them all over and now i've restored my invariant where i'm again a linear amount of operations away from having to do an expensive operation again does that make sense so while we were able to reduce to using these dynamic arrays for a lot of the cases right we actually had to do a little bit more work to make this work out that makes sense okay cool so that's that's two ways of approaching problem three okay in the last little bit we're going to talk about the last problem all right that makes sense i'm going to erase this picture if that's all right with you guys what's up it's not all right well too bad all right watch the video okay so problem four also a fairly uh accessible shall we say code in question okay what we're doing on problem four is we've got this nice little story at the beginning which is about this this woman jen and her friend barry who are trying to sell ice cream to elementary school kids they're basically lined up at jen's truck and she's like oh there's too many students here so she calls up for friend barry he has another ice cream truck parks at the end of the line and the students what they want to do is to make it more fair is they're going to take the last half of the line reverse it to make it more fair i don't know it's a stupid situation but the underlying thing is what we're doing is part a here is we have we're giving you a linked list a singly linked list right and what i want you to do this singly linked list all it has is a notion of size how long it is right it has a size and it has a head this list it has a size and it has a head okay and this head is a pointer to a node and the node has kind of just one two two things stored in it right it has who which the name of the child that's there right and the next pointer to the next node right that's what a singly linked list is so node has a an item key and a next pointer okay this next pointer points to the next node in the sequence okay and the question is asking if we give you a linked list that has two n nodes i want you to take the last n nodes and reverse their order and do this to the data structure you're not going to return a new data structure right you're going to do this you're going to modify the existing nodes and actually here is goes back to your question right is uh can what are we limited to in how we approach this problem what this uh problem says is your algorithm should not make any new linked list nodes or instantiate any new non-constant size data structures right so it's not like i can read through this whole thing find out where the n plus one node is read out all of those names store them in an array somewhere and then rewrite them back out right i'm not allowed to store more than a constant amount of stuff outside of this linked list and i'm not able to make any new nodes essentially i just have to probably keep these items where they are and move around the nodes yeah uh so if you're using non-constant space you're instantiating some kind of data structure whether it be in an array right or sure i'm wanting you not to do that yeah yeah any other questions so how are we going to do this problem anybody anyone have approach for how i might approach this problem yeah in order to get to the second half you have to do like oh then over two times so sure could you start like uh i probably start counting backwards so that you can get them in the back order and then meet it in the middle so then say interesting so there's there's a lot of things going so the let's let's break this down so a lot of times when we're asking you to construct an algorithm a lot of times it makes sense to kind of develop an outline or a game plan of kind of constituent parts that you might want to approach this problem with right like so the first thing that your colleague over here was saying was at some point we need to find out where the middle of this thing is right does that make sense so maybe the first thing we want to do to approach this problem is one find nth node okay that's the end of the first set of children okay then i have a second thing that i want to do what's the next thing i have to do i have to kind of reverse the pointers of everything after the nth note right okay so second thing reverse i guess next pointers of everything after the nth node right the nodes n plus 1 to 2n does that make sense and after i've reversed all of those things what do i have i have a first block this points like that and now we've got this thing and we've reversed all the pointers like this so that's after step two is that what we want yeah step three would be um you don't find the flat the pointer so this is my new end right i'm going to call this node a and this node b okay and this node c okay so tell me in terms of a b and c what i'm supposed to do yeah question how old we reverse the next pointer i mean i get what you're talking about like right to actually make that happen yeah so to actually make that happen this thing has a next pointer right it's pointed to some pointing to some node but i don't necess i'm needing to relink it to the thing before me right so i better remember what was before me so i can set you know node b dot next equals the thing before me instead of the thing after me does that make sense so that would be re-linking the point next it disconnects the link list possibly temporarily right and so therefore it still works out well we have to relink everything to make sure it's temporary right if we i mean it's very possible when you're dealing with linked data structures to unlink something and not have a reference back to it and now this thing is in memory that your garbage collector hopefully will pick up but if you're writing in a language that's not garbage collected then that's called the memory leak right that's no good okay so how do i relink these things right this is the picture that i have right now how do i make this into a linked list where it's here and then reversed yeah so i replace this pointer from a to b to make it point to c instead and then whatever my pointer is to b from b b is reversed right it's pointing to a let's set that equal to none right so basically the last step here is clean up ends all right and in a latex write-up right you'd want to specify what are the things that you're re-linking okay but this was a coding question and so we actually gave you code to work with okay so i'm going to see whether i can live code this for you in front of you okay so here was uh our code submission site from last term okay and what i have here is my template from last term pset one it opens this folder okay it's got a bunch of things in it the template the latex template that you have and then a bunch of these python files okay so i'm gonna uh where is it here okay so these are the files that are in my directory i've given you a version of this linked list sequence uh and then we have two more code questions a test file and a reorder student's file right so reorder students look something like this okay it has a template of the code that we're going to want you to write with inputs and outputs and you're putting your code here right and this function doesn't need to return anything all right and then we also give you this link list implementation which is what's in your recitation handout right i'm actually going to ignore most of this stuff really just that this thing contains a item in next in your node i'm not actually going to look at the items at all and a head and size in my linked list at the top level okay but this is just to kind of tell you what's in there right so that's what's going to be input to my thing and if i go here and i run the tests document that you gave me it fails because i don't have anything it didn't do anything to the list okay right uh and in fact if i go into here to the tests and uh you know i uh what is it it's reordering the students here i print the the linked list that you gave me i'm going to have a line break here what we can see is when i do this okay here are my test cases here's a linked list right and what's happening is it's just spitting out the same linked lists right i haven't done anything to it right all right so we need to do something to it how are we going to do that all right so let's let's implement this function and i'm going to get rid of this stuff because get rid of that all right so we need to reorder this student so i'm going to break this under the three parts that we have here we're going to find the nth node so how do we find the nth node well we have a saw this thing has a size on it so let's at least figure out what n is right so let's set n equal to uh i think i can use length right because i've implemented that on my thing and it's going to be whatever the length is over 2 and i'm defined by the problem statement that i'm only going to have even inputs okay and i'm going to set at first my a to be the starting place okay i'm going to just have a little temporary variable that's going to say this is going to be equal to the head of my list okay and what i'm going to do is what your colleague was saying is i'm just going to loop through end times until i reach the end thing actually how many times do i have to travel through next pointers to get to node a and minus 1 actually yeah so this is going to be 4. i don't care about this loop variable so i'm going to just use that n minus 1 times right what am i going to do i want to replace a with the thing it's pointed to right so i'm going to just walk down this thing a equals a dot next okay and now after the end of this loop what is a a is the nth node right i've now made it the nth node fantastic okay so and now i'm going to say that b is going to be the next one right i'm just just in terms of my write-up i labeled these things as a and b and c and so in my mind i'm going to want to use the same kind of notation here so that i can understand my code okay so b is going to be the next thing okay and now in this process as i'm going to flip things around what i'm going to do is i'm going to keep track of three notes i'm going to keep track of x which is the node that i'm going to be relinking and what else do i need to keep track of if i'm destination yeah where i came from and where i'm going to right because that's what i'm going to need to relink right in particular i'm going to have someone pointing to me which i'm going to call next previous right or no the x previous and the next thing when i'm going to uh label it it's going to be the next thing all right does that make sense so in in my first situation i'm my the first thing i need to relink is b right so that's going to be my x and the x previous is going to be a does that make sense so i'm going to instantiate those two variables x and xp are going to be b and a sorry that's right yeah maybe it makes more sense to have x previous and x equal a b all right that's in in the right order all right that's either way is fine and then i i want to go through a loop this i'm going to be doing in the loop way you can do it a recursive way if you want okay here's a loop way in which i'm just going to loop through how many times how many pointers am i going to relink as i go down this thing i need to re-link the pointers of all of these guys how many are there how many n there are n of them right so four i don't care about the loop variable here either i'm going to do this n times and what am i going to do i'm going to first figure out who my next guy is okay i'm going to set xn equals what x dot next all right so now i know who's next to me right so i can go there later after i relink my pointer i'm remembering that okay now i i don't care about what's stored in x dot next because i've stored it locally right that makes sense all right so now i am free to re-link that next pointer to my previous guy all right and now i can essentially shift my perspective over so the thing that i'm going to relink now is the next one okay so uh x previous and x now equals x x next does that make sense just re-linked things over okay so that's the end of step two now as i all as i got down this at the end of this for loop where is x what is x p x and x next or x n really i'm only keeping track of x and x p here right so what are x p and x at the end of this loop i've done this n times i started with b at x right so what is x yeah so we have a vote that x is c okay so this is a little interesting all right i agree i will tell you that c is either xp x or xn okay so we have one vote for x who says something else eric doesn't like x so any there are only two other choices just someone say something xp well i will argue that it is xp all right why because i'm at b there are eight n things i did n operations right and every operation i move one over right so when i've done n minus 1 things i'm at c the nth one now x is none because there's no pointer at the end of the list so xp is c so i'm going to set p equal to xp which is it's just for me to remember what these things are and i just re-link these two pointers right a dot next should be c and b dot next should be none right does that make sense everybody let's see if we did it right so we saved that thing and we run python on the test cases and it did the right thing apparently right maybe uh let's see ran five test cases okay all right so let's take a look at this we had this linked list lily sally cindy maisie sammy davey and what it turns into is lily sally cindy which is correct and then it reverses this last part of the list danny sammy maisie cool awesome but these are the test cases we gave you so let's try this against our code checker so i select the file where do i go i think i'm in my desktop here and session one and template and reorder students i submit it please work please please and a hundred percent and now we're happy and we can go party okay all right so that's uh the first problem session hopefully this was helpful to you uh we will release uh problem set one tomorrow uh and good luck on it you