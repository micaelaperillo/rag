so today uh we're going to continue in our discussion of uh dynamic programming I actually found this set of problem session problems to be easier than the previous one I think the fun there's a funny thing which is uh we learned in class about sort of pseudo polinomial time style Dynamic programs somehow that language is a little bit liberating in the sense that you're sort of using parameters that you really shouldn't uh when it comes to the runtime of your algorithm well I I suppose you should in the sense that it's it's allowed if you call your algorithm pseudo polinomial time but somehow makes it a little easier to formulate your dynamic programming algorithm because sort of all the numbers are staring you right in the face like you don't have to be so careful about what's a fair game and what's not uh when you when you post your algorithm so long as it's sufficient in the values that you care about uh and so uh today's problem session has five problems squeezed in instead of the usual four uh we'll see how far we get see that I usually talk too much anyway uh but I'll try to stay on schedule here and we'll see how well we do um any questions from our students about dynamic programming before we get started here cut one if you want we can cut one oh I I will gladly cut one if I run out of time yeah okay so without further Ado uh let's get started with uh coin crafting which is problem -1 here so I suppose it should be Keel nafy if I were to work uh through my spoonerism properly here um in any event we have a thief who's in desperate need of money uh as with many thieves or else of course they wouldn't resort to the world of crime uh and uh ke nafy here um has uh n identical coins I've been very self-conscious about the way that I write the letter I ever since Eric pointed it out and it's only gotten worse now it's inconsistent and and hard to read uh but in any event uh so we have uh n uh identical coins and of course you know these coins have very distinctive markings and so we can't possibly run away with them as is because if you take them to your standard Jeweler they'll immediately recognize that these markings are bad and stolen and and that's not so good so instead we can melt uh these coins into other objects so uh you know our sneaky uh Thief here has identified a potential buyer and uh the buyer has a few criteria here right so we have a buyer um and the buyer has the buyer has a very strange value system thing that apparently it's easy to take coins and make them into other things uh but but in any event the the the buyer what they care about is not the fact that the coins are made of gold but rather that they like particular objects better than others made out of said gold um so in particular they have a different rate uh for each object like a different price they're willing to pay um and so they have a list of um uh uh n objects that they're interested in uh and each one uh is associated with two things and objects uh they have a price so the amount that the buyer is willing to pay for that object which again is not just the weight and gold for some reason you know there's a value added tax uh in in in in this universe uh and uh it takes a different number of coins to manufacture right like so maybe maybe you know I can make like a golden chocolate fountain and that takes like 10 coins but I don't want two of those so if I make that then the next thing I have to do is like a figurine of of Eric and Jason to to put alongside it um and having more than one of those would also be like creepy and weird right so so I can only make one of each object uh and of course uh my goal here is I have end coins by the way the fact that there's end coins and end objects for the buyer doesn't really matter I mean it will for the runtime but like you could imagine this being n and M so I wouldn't be too hung up on that um and what you're trying to do is is of course maximize your Revenue uh subject to the constraints that uh you have end coins uh and you can't make two objects that are the same hopefully I've captured the essence of our problem okay okay fabulous so uh as with uh all of our our our dynamic programming problems in 6006 uh we have a paradigm for how how to approach them um which has a cute acronym which is sort bot uh and I think sbot is a totally relevant and straightforward approach to uh this problem here yeah so uh in particular let's let's give ourselves a bit of of notation right so we're going to number our objects between one and N uh just for convenience so we'll say that uh p i is the price of uh object I okay and uh we'll say that Ki is the what the problem calls the melting uh number in other words if I want to make object I this is the amount of coins that I'd have to me uh melt to to make that object okay so just a tiny bit of notation and in general so okay what do we do when we formulate our dynamic programming problems we want to identify interesting sub problems we could solve that are smaller uh and when we compose them all together uh we get the the final solution to our problem and this uh particular problem uh involving manufacturing objects out of coins I think is like a really classic one when it comes to dynamic programming this is the sort of thing where you know someday when you're trying to to to pay for your tuition by doing these like hacker contests online you know like this is the sort of thing that comes up all the time in in that Universe right um so in particular uh the two sort of variables here uh you know when I make new object is what object did I make and how many coins did I spend when I did that so sort of the two natural parameters to use uh when I solve my Dynamic uh programming problem yeah and and of course it's going to be sort of recursive in the sense that um I can either choose to make object I or not and it doesn't matter what order I make my objects in or similarly what order I spend my coins in which is usually a nice property to have in a dynamic programming universe so in particular oh this thing is my Nemesis um this is front I think this classroom is particularly tough for short people because I like I'm moving it up and down all the time okay uh so given our our observation here uh if we're doing sort bot uh right so uh what's our our s again let me ask myself that sub problems thank you uh Professor domain uh then uh essentially what we want to do based on what I sort of argued verbally is maybe Define our variable XI J the thing we're going to compute to be the revenue uh from using I coins uh and uh objects uh one to J okay so in other words you know I have I coins left in the bank and I'm only allowed to use the first J objects and we can already see that this kind of a sensible way to approach this uh dynamic programming problem in the sense that you know there's an obvious recursion here I choose to make an object I have fewer coins uh and I can sort of imagine there being a topological order in the sense that I could first decide about object one and then object two and object three and so on or vice versa depending on whether you're a prefix or suffix kind of guy um which I still get backward but the the the good news is that uh doesn't really matter what matters is is formulating the equation okay any questions about our our our definition of the thing that we're going to chase after here fabulous okay right so uh let's do uh let's continue sort bot so our next uh uh uh piece of our puzzle here is the r I believe R stands for recursion this is a new acronym for me too oh nope no relate but it might as well be recursion for for most of these problems uh right so the basic relationship here is that of course I can either use object J or I can not use object J uh and and in both of those cases right if J is the very last guy that I'm going to consider uh that'll be a totally reasonable recursive rule right so in particular um I have that uh XI J um essentially can take one of two values a parenthesis in case you're wondering um and and of course you're trying to maximize your Revenue uh so so let's do that okay so um so we have sort of two OB uh potentially potential options but we have to be a bit careful is there a case where I can't make object J yes class there is uh which is uh the case where I don't have enough coins left in the bank right so I want to make that really expensive Fountain but I only have one coin then I'm I'm sort of out of luck yep so uh let's do these two cases so first um you know if uh oops I got my cases backward that's okay um right so let's say that I choose not to uh make uh object J okay so what does that mean so so did I spend any coins no and moreover what is my maximum profit well it's going to be the same as the maximum profit using objects 1 through J minus one because I didn't use object J yeah so in particular that would be X um let's see I got it backward in my notes so we're going to do it live uh like that okay and otherwise let's say that I did choose to make object J well what happens so I did get some Revenue now right so I got man what on Earth did I write on these uh not um so I get the uh price of object J here as my Revenue but I spent uh some coins in the process so I have I minus uh K sub I which is the number of coins what was that oh thank you sorry K subj that's why we should be consistent with our indices when we write these things down um right so I spent K sub J coins uh making this thing uh object J uh and uh moreover I can still choose to make any of the previous object so it's still just J minus one but I have to be careful because I can't always do this in particular this it better be a positive number if I end or at least a non- negative number because if I end up with a negative number of coins well that that's not a physical universe that I choose to be in uh so in particular uh what we need in some sense is I minus K minus J KJ to be greater or equal to zero or equivalently I is greater than or equal to K so J I think you guys could all do that one at home okay and this is our recursion uh hopefully I've gotten it right because it disagrees with the crazy thing I wrote in my notes at 1 a.m. yesterday uh but uh I think it's pretty straightforward essentially either I can choose to use the last object or I choose not to uh and either one of those uh of course decrements uh J cuz that's the index of the object I'm considering uh and I either account for the price but have to pay in gold or I don't account for the price so implicitly there's a zero and I don't have to pay in Gold okay good all right so let's continue with uh sort bot we might later in the problem session relax going through every one of these steps because a lot of the arguments are kind of similar but for now we'll do one or two carefully so t uh I believe stands for topological order uh and here it's uh staring Us in the face because notice that um x i j only depends on um x i x question mark comma J minus one right so of course on your problem set you should write things more carefully uh but the basic Point here is that there's a clear topological order just by looking at that second index because you kind of if you think of all of your X's as variables in a graph which we've actually drawn in lecture so like maybe these are all the I's and then you know the J you know so like I goes down and J goes to the right then essentially this argument is saying that all the arrows kind of Point left in this graph um suppose the way I've drawn my arrows this isn't quite accurate but it actually doesn't matter the only thing that matters is that it goes from right to left um but I'm going to erase this so you don't remember it okay so in general just when you when you want to make your topological order argument I think a totally sensible one is like looking at the indices of your recursion and then just trying to find some number that decreases incidentally if you take a differential equation course uh that's roughly how you prove that a lot of those things converge too um so there's a a sort of a generic math trick that we use a lot you call that in in in od where you have some number that decreases I would call potential function potential function that's a perfectly sensible one there's the it's not lip shits it's some other mathematician anyway uh okay so let's continue uh sord bot so next we need B which is our base case uh so in this case uh is pretty straightforward if I if I don't have any coins I can't make any money I have a t-shirt that that says that at home uh and moreover uh if I can't sell anything I can't make any money uh so those are are pretty straight forward cases so we have that zero equals x of 0 comma J remember the first index is the number of coins you have so this is saying I don't I can't make anything if I don't have any coins and similarly equals x i comma 0 for all i j right so this is the coins and the uh objects okay so let's see I keep writing these problem sessions too big and then spending half of it erasing so let's let's try and fit this on one board here so we're going to do sort but then the second no the first o because there's no o in sort um is the uh the uh what the original problem that you want to solve so of course you start out with n objects and N coins uh so the original problem we want to solve uh is equivalent to Computing xn comma n and then finally we got to do our runtime T stands for runtime or time I suppose um so first of all how many many sub problems are there well there's x i j both I can go from 0er to n this is a great way to be off by one um so there's n + 1 squared sub problems uh and how much work does each sub problem do well it does boring work it's just a formula right so there's order one work per sub problem so the overall algorithm takes n^2 time so I promised to do something last in our last problem session then I didn't actually do it uh so I did think I would spend just a minute uh here sort of translating what this sbot thing would mean in terms of of code because I think that it's a little bit implicit here in particular I think this step here I mean you will'll see that it really clearly is going to give you an algorithm but I think it's kind of easy to like again just to to forget what what your code actually looks like and actually the coding problems on these problem sessions are almost too interesting and and and can obscure it a little bit so I thought we'd do a boring problem and show you uh that it's really not so hard to to do this and in fact uh we covered two different strategies in class for how to take sort bot and convert it into a piece of code although they might have uh kind of zipped past you in in this you know 2x speed uh thing that you can do now um so right so here are two options um one of them is called memorization uh and the other I don't know bottom up I guess is a reasonable phrase uh to describe and so I thought we'd do them both because they're both easy for this particular problem um okay right so um let's do that so let's uh so is this necessary on your homework strictly speaking no like if you've you've gone through sort bot then essentially everything that happens after that is sort of boilerplate in terms of converting these steps into a piece of code or an out algorithm but I do think just for understanding why sort bot makes sense uh it's worth thinking about for a minute um so option A here is memoization ironically I've taught and ta algorithms a few times and I never actually knew what memorization uh meant so I I learned something from from Eric's lecture the other day um which remember memorization the key thing and then what apparently is kind of a madeup word is memo like you know if you're back in the day you had a what a stopad and you were writing down stuff because that's where you solve problems with your slide rule um then uh essentially the idea is that if I compute xig for some pair I shouldn't compute it again I should just write it down on my memo pad um steno isation sounds better to me but I suppose we'd have to go back to the 19 what 40s and fix it um okay so let's uh actually write down I'm going to write down pseudo code that'll probably look more like mat lab cuz I'm that kind of guy uh so uh let's say that I wanted to make a function um which I guess is revenue of i j uh like that um and and and and this is the thing I wanted to compute oh that's actually going to be a problem because we're not be able to see okay right so in addition to this I I'm going to kind of pass in an array X um which is going to be like the my my memo pad this is going to be terrible coding practice but easy board coding uh practice so like if I were in C++ maybe I pass it by reference so that like when I edit it's a treble cleff but whatever uh you know when I edit X it actually persists when I when I recurse this is terrible coding practice and you shouldn't do it okay um but it's just going to be because I don't want to write too many lines on the board here um and maybe we initialize like we have some helper function uh to Let's see we want our Revenue to be big well actually no we'll just initialize it to like not a number so that like we know that we haven't computed it yet how about that okay so uh what should we do well if we're going to memoize the first thing we should do anytime that I call my Revenue function on on an AJ pair is check have already computed it yeah um so in my kind of goofy bad board coding style here what could I do I'd say well if I've already computed it then this thing won't equal Nan anymore it won't be not a number so I can say okay if x i j is not equal not a number so in other words it is a number um return and this like I think that this little line of code here it gets like a little loss but this is like we should put like sparkles around it right this is the magic of dynamic programming because I just killed recursive CS right like I even if I and J are like 17 and 23 if I already computed it I'm done right I I don't have to call my recursion again okay and otherwise what am I going to do um well otherwise I'll you know maybe call do I want to write it all down I don't want to write that all down um so otherwise I'm going to evaluate R where R is this formula over here notice that this will require um recursive calls right uh and I'm going to store it in x i j and then return x i j okay so B basically the only difference between like what we've seen in the first two3 of 66 and now is this beautiful line of code saying if I already computed this thing return it and this is the memorized version of our algorithm um I think this is sort of the easiest one to maybe think about but actually from a runtime analysis it's a little bit annoying um it's not in the sense that we convince ourselves that SB is okay but of course like if you're thinking about your recursion tree like what's happening is that you're sort of maybe convincing yourself that like this piece can be lopped off in your function calls um so you sort of have to do your counting uh carefully uh there's a different way to uh implement the same thing so this would be option b this is maybe more efficient maybe less efficient depending on your problem um but these are all within constant factors of each other for the most part not always but for the most part this would be bottom up and this is the idea of rather than just taking our recursive algorithm that we already know know and then just like checking a table to see like okay did I already do this in this in that case return it uh in the bottom up version I'm going to build up my array XI J um so there's no recursion at all um so right so what would that look like so in the bottom up case notice that in some sense memorization is a top down strategy right I would call it on N comma n here we're going to start from zero and work our way toward n right so we'll start with x 0 J equals uh x i0 equal 0 for all i j obviously I can do this with a forloop uh and now well remember if we think about our topological order x i j only depends on previous JS right so it makes sense to have an outer loop which is over J and now inside of inside of this out loop I can uh compute anything that I want in that J column of X and I'm in good shape because I'm building it up one column at a time right so in particular now we can do you know our Loop over I and then just have you know x j um and now you know evaluate our R step in our sort bot uh Paradigm and and notice that that's perfectly fine because by the time I get to Computing XI J I've already filled in x j for you know minus one which is all I needed to evaluate that formula so what are the advantages and the disadvantages here so notice that here our our our runtime is staring you in the face right we have N squ Sub problems order one work and you're done on the other hand there's some possibility like if you were an old school AI person that you might be able to do some pruning on on the the your left hand side uh that I can't do over here right so here I'm literally evaluating every entry of xij it could be the case it's not the case for this particular problem but maybe X only depends on x i j minus 5 right this strategy is going to still build up that whole table this one maybe can skip over some entry so in practice it could help on the other hand here I've got a bunch of recursive calls I put on the stack of my computer that here I don't have so I think actually because of the overhead of recursion typically the strategy on the right is is is preferred also for clarity but that's a blanket statement that I shouldn't make okay so anyway I think i' I've done this uh this problem to death uh are there there any uh questions here I just thought I'd fill in for something I promised last time and and didn't actually do okay fabulous so we'll go on to problem 92 um so this is continuing from last time in The Saga of Tim the beaver here so I forget what Tim the beaver was doing in our last problem session but today Tim the beaver is going to the career fair and as we all know the only real purpose of going to a career fair is to pick up free stuff um you know we joke actually you guys should all go to the career fair I I got my first job out of college by going to a career fair um and hanging somebody that picks our booth until they let me in uh but in any event um so Tim the beaver uh is not interested in getting a job but rather just wants uh swag just wants free stuff out of booths at the career fair okay uh so in in this particular problem there's n booths is it Boos certainly not boots um I don't know there there end booths Each of which has a swag uh and in particular each swag has a value Associated to it which is CI which is the coolness of object I uh it additionally has wi I this is the weight of object I and just to make this problem verbally difficult to communicate there's a w AI T associated with each object which is the time it takes to wait in line and pick up object I okay and and Tim the beaver like if there's some ridiculously cool object with like a low weight time he might just keep getting in line and and and and getting more of that object so unlike um ke nafy on our first problem uh Tim the beaver is perfectly happy to to have more than one of the same thing okay um in addition to this uh just to make this problem in my opinion slightly more annoying and and point losing um Tim the beaver also takes one minute to get in line at any booth um so we're just going to have to remember that when we account for our our time TI okay so uh let's continue adding some more constants to our our problem so each uh booth has an object which has coolness CI weight wi time TI um Tim uh is carrying a bag the bag uh has uh can can hold uh a particular weight B um so this is the max weight weight that Tim uh can hold in his bag at any given time uh and finally you know Tim is a a greedy Beaver but he also uh can go home uh you know or go back to his Dam I suppose uh and empty his bag right and so H is the amount of time uh to go home uh and back uh and and empty his bag in the meantime and again just to be annoying don't forget he encouraged plus one to get in the next line this is what made my answer wrong and I'm bitter so I'm going to keep complaining about it okay so of course uh what he wants is the max you know it's sort of a what would economists uh call this I I don't know but but for for Tim the beaver he wants the Max total coolness um or MTC uh which is of course a number that we're all trying to optimize um in K minutes like you might remember those old uh TV shows where you get like some like one minute in a grocery store to empty the shelves into your cart uh kind of thing um so he wants to do this uh and and uh the computation time that he's reserved for this is order nbk I know that was a big setup I tried to document all the different Conant um that are in this problem I don't think I missed any here okay fabulous so incidentally you know continuing on K uh K is the total amount of time uh that Tim the beaver has allotted uh to do his job fair uh uh Scavenging fabulous uh right any any other uh cool okay um notice that this is going to be an example of of a problem that was sort of not Kosher in last week's problem session in the sense that K is included in our runtime right but like what is K it's just a number K doesn't scale in the size of your problem in a linear way um so it's it's not going to matter for how we solve our problem but it is just a feature that's worth uh pointing out okay so how do we solve uh dynamic programming problems we use a sword poot um or a Senor uh BST uh if you are watching previous iterations of this course okay so uh right so let's let's do that see I'm trying to conserve board space this is not going to end up uh succeeding so again like what are all the different sub problems here well somehow what are what are the different things that are are limiting Tim the beaver you know what are what are his uh constraints well he only has so much time and somehow this is going to sound more philosophical than I intend but you know time always moves forward for Tim the beaver so it's a pretty good candidate uh in terms of of dynamic programming because there's not going to be some cyclical dependency remember that in dynamic programming we're all about trying to identify topological orderings in our sub problems and when you see something like time not only does it also begin with t uh but it's it's useful in the sense that time moves forward uh there's never a case where Tim the beaver you know purchases like a weird warp speed airplane and somehow goes back into in time um that that doesn't happen in this particular homework problem and and for Tim the beaver's sake I hope in in no homework problems um so instead of the so so this is a Long window way of saying that time is a pretty reasonable uh uh constraint to put in our problem or not constraint as much as index I guess moreover there's another thing which is uh limiting Tim the beaver which is the capacity of his bag remember he can only hold weight uh B but this one should give you the heebie jibbies a little bit because this problem as a Twist has allowed the bag to empty itself out right so it's not true that somehow you can come up with Sub sub problems where um Tim the beaver is just monotonically decreasing the weight of his bag however if he does choose to decrease the weight of his bag he has to spend time doing it so time continues to move forward for Tim the beaver and that's what's going to give us our our topological order yeah this is a little too philosophical I guess but in some sense this is a long-winded way of saying for our sbot Paradigm here um a totally reasonable thing to do would be to have x i j uh I don't think in this class we do this definition notation so just x i j equals um the max coolness um where he has I minutes uh and he has J weight let me glance at my answer to see if it's left in his bag or weight that he's carrying left in his bag either one would make a reasonable uh problem I'm just bad at looking at my notes and seeing them disagree with the board so I'm going to try and and and stay consistent okay so XI is the MTC but in I minutes with J weight left rather than in K minutes with B we which is going to be our base uh problem okay oh no I did it out of order like disregard that we'll get to the b in a minute okay okay so now uh so so that's our our our our uh sub problems so now uh let's do the r and sort hate this classroom so much I'm sorry so right so so let's say that that that Tim the beaver uh has has IM minutes left in the clock uh and he has J weight in his bag he's got a number of actions that he can take yeah uh and and let's think about what all those actions are by the way there's one thing that plausibly Tim the beaver could do but he doesn't really need to is is like do nothing now but then in 10 seconds do something like it just you could do account for that in this problem but like there's there's sort of not a reason right like he might as well stack up all of his actions and then leave all of his leftover time at the end um you convince yourself that that's sort of okay you know Tim prefers a compressed uh schedule um right so he's he's got a lot of energy this this Beaver it's what they say their nature is uh construction workers something okay right so let's think about all of our options so for one Tim the beaver could not do a damn thing he could just sit around for the rest of time and and that would be perfectly fine so another different way of putting that um is that he could give up how much coolness would Tim get from giving up zero that's right kids giving up makes you zero cool um so okay uh right so um Tim the beaver is trying to maximize uh he has a lot of different options one of them is zero meaning he gave up right notice he could recurse like X I guess what would be you know he could give up for one minute right and have that be X IUS one J or something um forget if I'm going to do i+ one or IUS one I minus one J but there's no reason like he can just give up and and stop like that would just be extra recursive calls for For No Good Reason okay the next thing that he could do is he could get in for a booth right um so first let's work out what happens uh then so for one um he gets coolness let's say that he gets into Booth K so he gets coolness CK when he does that and now he can recurse so first we have to account for the time so it takes I so it takes TK that's a t time or does it no because it takes an extra minute for him to get in the next line or to get in this line line I guess this is better um and moreover uh he needs to account for J minus WK like that can he always do this no he needs to have this much time remaining and he needs this much time in his bag or this much weight remaining in his bag um you guys can work out the inequality but since I only have a foot here I'll just say if applicable this is a great way to lose points on your homework uh but for Board Writing it's okay so so when I say applicable I mean these two numbers have better be greater than or equal to zero okay uh and you can do this for all K right so in other words he can choose to get into Booth K and Tim has the third option which is he can go home okay so what happens if he goes home does he is he cool when he does Tim the beaver get cooler when he goes home no I'm afraid to to to say so um in par but he does spend time yeah so how much time does he spend age what was that he should have lost coolness by going home no home is cool guys especially this semester stay home stay indoors um so he he uh right so he he loses home time H and one to get in the next line okay um but you know he's got a devil's bargain of sorts uh he he he loses time but he gains bag bagginess weight is the word that I'm looking for um B like that okay um again in this case remember that he still needs if I is greater than H right otherwise he's in trouble by the way I wrote this in kind of an annoying way this is a different way of saying that is IUS H minus one is greater than equal to zero which is really what's applicable in our recursive call but this is strict greater than sign that was another little thing that caught me up when I was reading the answer here okay and those are all the options for Tim the beaver yeah um notice that every one of our options either gives up completely or decreases time so we have our topological order which is again that the arrow of time always continues to move forward I'm going to prove that rigorously by putting a check mark next to the letter T again on your homework you should write out your answers uh what is our base case for Tim well how much coolness do you get if you have no time zero coolness that's how much um so we have this expression x0j equals z for all J incidentally um although it's perfectly fine to have this be your your base case you actually in some sense didn't need it because Tim the beaver always had the option of giving up um so you could I guess in this problem have no base case if you really wanted um would be okay but kind of weird um okay what's our original problem well he starts out with time K and weight uh capacity B in his bag so it's x k b and then finally uh we need to do our runtime analysis so how many sub problems are there well again I sub problem is basically just the number of indexes for for most of our our dynamic programming problems right so there's um so the first index is time the second one is bag size this is always between zero and B this is always between zero and K so there's order k b sub problems um how much time does each sub problem take well notice that I have to lose over all of my different options K here so I incur oh I'm noticing K is abused in our answer to this problem we should use K only once okay so here's here's here's where uh I made a mistake and I believe it's in the written solution but I'm not going to check now um there's K which is the total time that Tim the beaver has and there's the K that I use as an index here and those are are not the same I guess I can make this K Bar really fast there you go problem solve and I just noticed that because I was doing my runtime and it's not order k um it's the loop over all the K bars how many K bars are there well these are all the different booths and there's order n of those so this is order n time per sub problem which gives me a total runtime of order K BN um which I believe uh oh our desired run time was order nbk but I think we can convince ourselves that indeed those are are the same thing okay so my apologies for a slight uh uh overloaded uh character here but honestly it's kind of one of those things if you read the answer you probably wouldn't even notice but now that I'm saying it out loud I I am okay and that uh solves uh Tim the beaver's uh maximization problem he's a very cool Beaver any uh any questions about this one notice that both of these problems are are very similar in nature I basically just wrote sub Problems indexed by every possible thing uh and then enumerated every possible solution U I think this is totally sensible like I again I remember I had a math professor in college that always would use this phrase like it's important not to think here um and and I think this is is absolutely true uh for these dynamic programming problems somehow they look a lot more complicated than they are fabulous so problem three protein parsing ah yeah so this one this one also got me tripped up for a minute because the runtime they want is not the runtime of the obvious solution but it kind of sort of is after a little bit of uh uh fixing okay so uh Professor uh laric Ander uh has a laboratory and that laboratory processes DNA Tada um okay so let me go to my notes here because I think they're easier to read right so a of DNA as we all know because we're MIT students uh is is equal to basically strand of characters that are like a and g if you ask me to name what those stood for I I could make a stab at like one or two of them but I'm a failure of a like I did not have the G because I went to Stanford and this is why I'm apparently a poorly educated person according to a person in a faculty meeting um but in any event um right so we have a strand of DNA is basically a long string of characters that are one of four options I'm told that there's sometimes like a fifth and a sixth option but not too often this problem there's not um and uh moreover um so a strand can be cut up so I have this big long Strand and I'm looking for certain like markers in particular I have a list P of uh markers um which are really a sequence of less than or equal to K uh nucleotides by the way this really is uh something that the people do like like string searching really is applicable to processing the these DNA strands obviously I think in in practice these techniques have to be a lot more resilient to error um but really A lot of these algorithm recovering are not all that far off from from how people process these giant data sets which is pretty cool I think um okay so what are we going to do we have uh a string uh and then we're going to make a division um so we'll call our string s and our division D um which kind of looks like D1 to DM which are uh substrings uh that concatenate to make uh uh the full the full guy so if s is our our our input string then a division D is just like chopping up S into little substrings uh Each of which we can give a name Little D here so big D is the full uh division Little D is is all the little pieces you know there's that that old song about going through the Big D and do me Dallas I think it's for divorce I don't know um right so uh okay so the value of a division is the number of uh strands so strands are these little D's here um that are in our list uh P okay uh and so uh right so given S and P what we want is the max value and the runtime that we're budgeted is kind of a weird runtime and this should make us a little suspicious um so the the max value is Big O of I think I wrote it slightly differently in the problem but whatever I distributed a k like that so it's K mod P uh plus k^ s mod s right so so we have two terms here which somehow smells funny in dynamic programming okay so what are we to do well what I did is I ignored our desired runtime came up with a dynamic program noticed that it was a little wrong and then fixed it by wrong I mean it was it was correct it just wasn't fast enough okay so let's do version one here 1.0 that makes it more accurate um they're more precise right I always confuse those two uh so so here's a sort of thing that it's going to be a little bit funny because it's going to look like we're going to have an easy computational problem but then it's going to turn out that it's actually too slow so in particular uh in our s in sbot um what we could do is say XI is going to be the max value of a suffix if you're wondering I don't know the difference between prefix and suffix but I wrote the word suffix in my notes and checked it at home um s i comma colon see it's suffix because it starts at I and it goes to the end huh no comma in mat lab it would be a comma and that's a colon and that's an i okay thanks um I'm inventing my own programming language on the board as we go today all right so um and notice this is kind of a reasonable set of sub problems right because kind of obviously if I if I Lop off off you you know some some piece of my string then the max value I can get is just the the value of whatever remains yeah so spiritually this somehow feels like the right uh uh dynamic programming and indeed we'll see that it is but it it just requires a little bit of liptick at the end to to run in the right time okay so let's do our recursive call and this is actually straightforward um at least the sort of recursive call that you want to make uh is straightforward and then we'll see that there's an equivalent formula which is the one you'll see in the solution which looks more complicated but is is the same thing so I'm going to write it as pseudo code for a recursive call rather than as one giant formula because I think it's easier to follow not pseudo code I know that's that's frowned upon in this class a a a description of a set of steps for obtaining our recursive call rather than um a formula so in particular uh we're going to initialize XI to be zero uh we want to do a maximization problem so initializing a variable to zero is a sensible thing to do and remember what what can we do here so we're looking at a suffix I could go down my list P of all the different markers see if any of them matches the first couple characters of my string if it does I get some value and then I hop on to the next thing does that make sense um oops I'm realizing I have a slight mistake here um rather than initializing to zero I actually have one additional option that I forgot to account for which is I could just not use this character I could I could I could put it in its own little snippet and and get no value from it right so maybe initially I make a recessive call like that it would be okay to initialize it to zero and then do this but whatever notice we're already seeing the T in our sort bot start to kind of stick out at us we're going to only depend on bigger indices I okay but in addition to this this isn't enough right this would obviously just recurse the end of our list and and do nothing uh we get value if we can find a substring that's in our our our list so what we could do is um for each marker uh in P remember p is the list of things that we're looking for okay um um what could I do uh if the marker matches um s starting at I I'm going to just not even attempt to do python uh starting at I and ending at the length of the marker well what could I do I could get one dollar by by Mark you know by matching that object and then I have to hop forward the length of the string uh in my recursive call right so um well I could do that or I could not do that and I want to maximize right so I could keep my old value or um I could get one point by using this as my match plus x i plus um the length of the marker okay and this is actually in my mind the simplest possible Dynamic program you could come up with this is actually a totally fine Dynamic program we'll just see that the runtime isn't good enough okay um so does everybody agree this is a way I could solve this this problem and it would give me a correct uh answer um I'll do the tabbot yeah that's what we're going to do but we're we're going to maybe skip some parts of sort bot um so in in particular um what's the topological order notice that I always look to the right uh when I make a recursive call um what's my base case well in this case it's just uh X of of zero I guess because I'm looking forward oh I'm sorry my base case is X of of the whole length of the string which is going to return zero right because if I have no string I can't get any value out of it the uh original is X of zero meaning that I want the whole string and let's actually do the runtime analysis as as uh Jason suggests because that's of course the relevant computation here um so this is T2 because it's the second T in sort F okay so how many sub problems are there well there's I mean it almost looks like we should have a fast algorithm because our our sub problems are only indexed by I right um so there's one sub problem um for basically each character in the string so there's mod S Sub problems total but how much time does it take for each sub problem well let's be careful so there's a for Loop over all the markers in P so I know that I incur at least mod P work uh in my sub problem is that all the work that I incur kind of looks like it because there's only one for Loop and there's an if but how do I check if strings are equal I have to iterate over the length of the string so I incur a second cost which is checking if two strings are equal we know that our strings are at most well I didn't actually write it down but the problem tells us that our strings are at at most length K so I incur another factor of K in every one of my sub problems and that implies that our whole algorithm that I've I've outline for y'all above takes mod S k^ 2 oh I'm sorry that was a lie if I actually multiply these things together what I get sorry this is I need more sleep s PK and that is against the rules that's frowny face yeah uh because in particular I took two big numbers in some sense and multiplied them together uh and and and and that's no good so what what is a person to do you know I I tried to solve my problem I came up with by the way for from a partial credit perspective I think you'd be be doing okay if you got to to this point okay not great but okay um but of course the problem is is is asking you uh to solve this in this funny uh runtime which is KP plus k^2 uh uh s yep when I see a sum like this in a you know remember that there are two problems to solve there are two strategies for solving problems in algorith class there's one which is useful in your everyday lives which is to devise algorithms there's a second which is to psychologically diagnose your instructors um and I think that second strategy is actually pretty effective here I see two terms most of our dynamic programming things involve filling in a table where you would expect there to be a product so in general I would kind of squint at this and Think Like H maybe I have to do some pre-computation yep in particular um we got to do a lot of string matching in our problem and maybe we can make that more efficient yeah that that's sort of the the the main question here um right so so this thing is too slow and we're trying to fix it the way I'm going to try and fix it is to say like okay well I have mod S Sub problems if I look at these two terms how much work can I actually do in my sub problem something that looks like K squ maybe plus this amount of pre-computation see what I did there okay so let's uh let's do that so in particular here are the types of queries that I'm going to have to make there's a bunch of times in my code when uh here's a number that he falling apart that's what I get for sprinting across campus to get here uh I'm going to define a me a number m j and it's going to be one if the substring s i oh man 2J uh is in my list of markers p and zero otherwise by the way why is this enough like notice that I'm not answering which marker but the problem doesn't really care right like this problem just checks if there is a marker and if so then I I use it yeah so if I have this thing that's going to somehow make this for Loop a heck a lot easier because now I don't have to do string matching we'll return to that in a minute okay so my question is how can I compute this thing and by the way notice that I know how to compute this when the difference between I and J is bigger than K right because I know that all of my markers have length K or less that's going to be important because even though m is doubly indexed uh I don't actually need to do that in fact I could even store it uh using less memory than that if I wanted to by kind of just storing that that diagonal block okay uh right so the other thing which I think we saw in a previous uh problem session as well is that when we do a lot of string matching it often pays to put our strings into a hash table uh so that they're easier to look up later like does this string exist in in this thing or not right rather than matching every character every single time um so maybe we do that just for for for for fun uh and in general when you see a string matching problem I might and you have a list of strings I'd suggest thinking about hash tables just for for Fun and Profit yeah so in in step one here maybe I put all the strings in P into a hash okay um how much time does that take well I have to process every string right find its its code um which is going to take order K time there's mod P of them so this is K mod P time notice that that conveniently agrees with our first term here so we feel like aha we're in we're in good shape we're making progress here um and now uh maybe I want to fill in this M J uh object uh here how could I do that well for one I'm certainly going have to iterate over all possible eyes yeah so let's let's uh let's do that so we're going to do two by the way I mean like using ones and twos and as's and B's and whatever these are just ways to denote steps of things uh okay so let's say that I just want to fill in M um using a brain dead algorithm so I could go from one to the size of my strings for I careful now I can't incur an S squ but I know that my strings are always at most length K so I could do for J equals uh I + 1 2 I + K so this for Loop actually incurs K time not mod s time and now uh I can do two things right I can find the uh hash of the string from I to J right this is going to take order K time and I can uh search for it ah [Music] no uh um to see if it's actually in our uh hash table of p and if it is uh then I set m equal to one otherwise I set m equal to zero uh right and these are our sort of constant time operations at least in expectation so how much uh cost to it and and so this you can convince yourself uh fills in that array M how much times does it take well I have a loop to the size of s I have a loop of size K I have a second second Loop of size K here to compute the hash so this whole thing is going to take order k^ 2 mod s time like that notice conveniently there's chalk on the floor and this is uh the second term in our runtime so this is kosher we can fill in m and and and and and that's a convenient object to have around so the only thing that remains is to revise our R from above um to make use of the M that we have uh and that's pretty straightforward um so the trick is to not lean against this thing and to actually hit the stop button I'm I'm learning so now I suppose we had T2 for the second T So for our revised R we should have R Prime um what was that the Der that's that's right the derivative yeah we could do you know like christopal symbols like I J Prime semicolon K uh take 6838 if you want to learn what christopal symbols are um right so uh Now what is my recursive call for XI well I want to maximize uh well what can I do I can check every possible length of a string um that could be in P che check if it is using my array m um and and get that amount of profit so in particular I get M by the way I keep using the word profit here I'm essentially using that to mean increment in every single one of our our problems here I like to think of our problems as maximizing profit because I'm a greedy Professor so this is m i j which would be like one if I found a string there and zero if I'm not plus x i + J to account for the length uh uh here where J is in one to uh well either the length of the string or I get to the end of either the maximum length of a string in P or I get to the end of my array like that okay and this is our new recursive call the one thing we should double check is what is the runtime for actually filling in X now well there's still mod S Sub problems and now how long does it take well now I just have one Loop over K things this is mod s * K it's actually less than any of the terms that's in our uh runtime and so this is fine this actually is kind of a funny example where the dynamic programming part of our our algorithm once we've done all this cute pre-computation is actually insignificant um compared to all the pre-computation that we had to do uh in our final runtime sneaky all right any questions about uh protein folding or whatever it is that we just just did okay so as usual I'm talking too much cut one of yeah which one would you prefer to cut I have very few preferences okay so one of the problems um I would take a vote but with our audience there's a high probability of a split jury here um right so there's two remaining problems in the problem session as usual uh your instructor you can leave it there this is another problem learn about um uh right as usual I've talked too much and and and haven't gotten to the end I get the impression that in 66 this egg drop thing is a bit of a tradition anyway um so maybe we'll we'll cover that problem really fast do they do that in section some variation not this time even better okay so yeah so maybe we'll do uh this this egg drop thing mostly because the other one I think takes a lot of verbal setup the other one is is I would say from a dynamic programming perspective Maybe not super exciting but from like a interesting problem perspective is is is is kind of cool uh to think about um so I'd encourage you to leave it in there and you guys can can read it at home um from a coding perspective it's also kind of fun I noticed the solution didn't do what I would do which would be to use the the bits in the you know like assume that something wasn't too tall and use the bits in like an integer to store your binary variables but that's an old hack right that's sort of like you know this this old hack for computing the square root of a number that's apparently in the Doom the code for the Doom video game which involves like bit shifting and it happens to agree with square root for some magic reason that numerical analysts really hate um okay so right so uh let's do a lazy egg drop instead so that's problem four okay so we're in a building our building has n floors um and K eggs I guess it's debatable whether the building has eggs or the residence but uh in any event I have some set of eggs uh and maybe I'm in the state of Center or some other weird building so I don't have Heights of floors that are isotropic but rather each floor has a different height which could vary um so it's height of floor or I really want to write flower um but I digress uh and we're going to assume that that our our list is already sorted so in other words like the fifth floor is taller than the fourth floor uh and we don't have to like spend nlog end time uh doing that okay uh right so apparently in our our problem we have an egg with a mysterious mechanical property that we are trying to recover and all eggs as we know are identical so you know the only difference between eggs is like chicken versus Goose versus like struggling to think of a third category of poultry turkey thank you um right but assuming that I got all of my eggs at the same Stop and Shop and they all come from the same species then they have roughly the same mechanical properties actually the probably the better setup is that floors are very far apart relative to the size of an egg um and if I get high enough my egg when I drop them on the ground like that uh breaks didn't break but it could have broken uh and of course if I drop it from an even higher height my egg still get going to break however if I have a very low floor apparently a very low floor maybe this is a house for mice um you know when I drop my egg it actually stays intact uh and and the question um as all good scientists want to know is what is the highest floor in my building from which I can drop an egg and uh have it remain intact and the question isn't is kind of a funny one it's sort of like experimental design in some sense it's it's not asking like what is the you know like given this and like a list of experiments you know try and figure infer something about the eggs but rather it's saying sort of if I carefully design a sequence of floors to drop my eggs from from which upon I drop my eggs then um you know in sort of what is the maximum number of experiments I need to do to triangulate in on that that floor that critical floor above which my eggs break yep um so what I'm given are the heights of the floors and a budget of eggs in some sense the budget of eggs sort of doesn't matter more than just like putting a cap on the size of our our problem in some sense what really matters is I'd like to use fewer than K eggs to determine that because of course the remaining ones I'm going to use to make an omelet but notice the I can be a little sneaky in my experimental design that like what happens if I drop my egg from a really low floor in my building well it remains intact so I can slep down the stairs I can pick up my egg and I can use it for my next experiment and I have not paid an egg yeah um so the first question you might ask is like well why the heck wouldn't I just start on the first floor drop the egg if it's not broken you know go on to the next one and then drop the egg and so on that would be the most egg efficient plan and indeed that is the case because you'll only break at most one egg but you're spping up and down the stairs a bunch of times when you solve that right like every single time you got to go retrieve the The Unbroken egg you got to run down the stairs pick the thing up and then run up to the next floor and maybe uh in your optimization problem rather than trying to like minimize the number of eggs that you break you're trying to minimize you know the expense on your your your quads and and and so instead you're trying you know you you skipped your leg day or whatever and the thing that you're trying to minimize is the sum over the heights of the drops in your experiments right so you're trying to determine the um mechanical property of your egg uh by designing an experiment like like sort of a procedure that minimizes number of times that you need to to drop uh eggs because every time you do you got to run all the way back down the stairs and go look at the pavement and see if the egg broke or not that's a lot of work okay uh this is different from the sort of classic egg drop 66 problem which I encourage you guys to go uh seek out in previous uh iterations of this course uh let me see so so right and and so the the question is what is the minimum the minimum number of egg drops you need to do to ascertain that for any type of egg yeah so I give you a mystery back basket of eggs and you have to design an experimental procedure uh and bound the number of of of this this particular value here given a budget of of kxs okay uh and um the amount of time that we have to do that is order n cubed K apparently our building we have lots of eggs and not very many floors okay because our our setup uh make some sense here we're just trying to avoid running up and down the stairs that's the M the main takeaway okay so uh what are we going to do sort bot because that's all we know how to do yeah um and and in particular we're going to make one observation which is kind of Handy if I drop a floor o if I drop an egg from a floor you know in this deterministic universe where egg mechanics are very predictable um there's only one of two things that can happen either egg broke broke or didn't or I run into the board again um so let's think about our experiment remember at the end of the day we're trying to figure out the tallest floor in my building that I can safely from which I can safely drop an egg so if I think about kind of bracketing that height of that floor notice that I can always for one thing do I ever need a bracket that's like not a continuous or like a connected set of numbers the is no right it's never it should never be the casee that like I think that my eggs could be on Floors one you know like only the prime numbered floors in my building or something that really makes no sense right because if I convince myself my egg breaks at floor five then obviously floor 6 through n my egg also breaks in so I always can kind of just keep narrowing down some interval right uh so in particular here's kind of a clever s in my sort bot which is to say that I'm going to say that x i j e is equal to the minimum by the way this is I'm writing this as minimum total height so this is like the minimum total times I got to run down the stairs and check my EGS um or total height that I run down the stairs the number of stairs I run down uh assuming my stairs are one foot tall um where I have e eggs left notice the way that we've written the problem this time I might as well use all of my K eggs like that doesn't cost me anything what cost me is running up and down the stairs um and uh that I have floors I through J inclusive uh to check so in other words if I'm on a floor below floor I I've convinced myself my egg won't break then if I'm going to floor above floor J I'm convinced my egg will break okay so what do I do well remember that this is sort of an experimental design problem I can drop my egg from any floor um f which is in the range I to J right and of course there's never a reason for me to drop an egg from a floor below I or above J because we already know what happens in that case okay so what happens uh when we do that well if I drop it from floor F I have to pay uh in terms of my cost function right because I have to pay the height of F I got to run down the the the stairs okay um but in exchange for that I learned a little bit about my egg problem right I either get an upper or a lower bound of f depending whether the egg broke okay so let's uh let's let's let's let's form that mathematically so in particular we have x i j e well what do I get to control in my life and what do I have have to deal with what I have to deal with is the fact I don't know what's going to happen to the egg it might break it might not right and the Egg might be an adversarial egg like it wants you to run up and down the stairs and I have to account for that but uh I am the eggs adversary and get to choose what floor I drop it from so remember like uh we saw an example I forget what from class where there was sort of a game right one guy was trying to minimize the other was trying to maximize in some sense the egg is trying to maximize the amount of work you have to do running up and down the stairs uh uh to do your experiment a better way to put it is that we're trying to Upper bound uh the amount of work in your experimental procedure and I'm trying to design a procedure that minimizes my work right so let's say that I'm the player so I want to minimize um and the decision that I get to make the control that I have is what well it's what floor I choose right so let's say I choose floor F Well I have to go down the stairs so that takes me HF I suppose going up the stairs is probably what incurs the HF and going down is nothing um but I digress but now my I still am not done I've narrowed down into one of two cases right either f is my new lower bound my new upper bound and I have to account for both of those in my recursion and I have to take the max of those two in the sense that I need an every possible case that my AEG drop experiment Narrows down my floor uh to to to a width of of zero y so in particular this's actually a this is a Minimax problem there's a Max inside of a Min here um so what's either the egg broke in my experiment or it didn't right so if it did broke then well what happened well let's see here um if the egg broke then I got an upper Bound for my floor so my lower bound Remains the Same it's I my upper bound it's F minus one because it broke on floor F well what happens to egg eggs when they break I can't drop them from floors again so I lost an egg okay so this is uh my egg brow okay or my egg didn't break so in that case well my egg didn't break now I have a lower bound so I'm only unclear about floor is f+ one uh but uh the upper bound didn't change it's still J and how many eggs do I have well my egg didn't break so I can run down the stairs which is going to be tiring right I've accounted for that here but at least I can reuse my egg so I didn't lose anything okay okay and I get to choose so notice oops so do you guys see why there's a Max here essentially I have to account for every possible scenario when I'm when I'm designing my experimental procedure but I get to minimize in the sense that I can choose what floor at every step so um right so in particular uh my f here is in the range I to J like that okay and now we have our recursive formula for our our our egg drop that minimizes total height um so now let's uh finish off sort bot in four minutes it's actually not too hard so I think we'll actually make it for once by removing 20% of the problems I'm supposed to cover um all right so first of all what's our topological order so this one seems kind of annoying because I think usually we think of spending stuff in a lot of these uh dynamic programming problems but do we actually spend an egg not necessarily right because in this recursive call you know the number of eggs I had remained the same so maybe that's not actually a great way to establish a topological order but instead what do we know like what is in science the purpose of an experiment you know uh it's to improve our understanding of the world in this case our world consists only of eggs and floors of buildings um and in particular once I dropped that egg I learned something about my building and I narrowed down the range of floors that are uncertain for me so in particular I know that x i j e only uh depends on X I guess I prime J Prime e Prime um with what well my sub problems I always have a smaller range of floors than I did before so in particular J Prime minus I prime is going to be smaller strictly than J minus I and that'll give me my topological order cool uh and so that's actually to I think the sort of annoying part other than working out this Minimax expression here uh the remaining uh things are not so hard so uh what are our base cases well let's say I have zero eggs left but I still have a set of Uncertain floors that's bad news yeah so yeah so that should be infinity and the reason um is of course um I'm going to take the Min here right and so I obviously I should never choose Infinity as a as a Min um so in other words I I should never choose an option for a floor that could possibly lead me to an uncertain scenario um when I run out of achs yeah um in addition to that there's another base case here right so this is like I've got no eggs left but some FL us to check uh there's a second one I IUS one e so in this case I've got e eggs left and I'm done right i' I've narrowed it down to uh uh the bounce incidentally the way I wrote it in terms of inclusive versus exclusive might be a little fishy over here you guys shouldn't be off by one like your inspector often is um but in any event you're you're zero right there's no more floors left to check you you've narrowed it down to a range of one again something that I'm out of time so I'm not going to check carefully is if my bounds are inclusive should that be i j minus one I IUS one or just I I but I think you guys are all smart enough to work that out at home what should my original case be well now I have all the floors to check and all my eggs in my uh metaphorical basket here so I have um floors is one 2 N here uh and the problem tells me I have K eggs when I start and then finally I need to do my uh sub problems here I think you can actually simplify the the argument that that's written down a tiny bit um and just again look at your your sub problems so they're indexed by three numbers I'm going to do a really conservative estimate I think the problem actually works out a better estimate but then ASM totically it's the same um what's our bound on the first and second index well they're both just the index of floors um which which go between zero and and N yeah obviously you could do better than that because the lower floor is always less than the Upper Floor which is what the problem accounts for um but if I'm being lazy then you know well there's n squared uh sub problems to account for the two floors uh and the third index uh is is your eggs which you have MOS K of okay uh how much work um do we have per sub problem well uh let's see here there's a for Loop over f f is over floor again if I'm going to be really conservative right well there's a most uh n uh Flor is total my build and so that leads us to a runtime of n Cub K which is what we wanted at the end of the day okay um there should be a big O here because I think technically this is n plus one to account for floor zero okay and that uh that solves our our ACH drop uh experiment again I think this is a nice one and I think in my mind actually in terms of dynamic programming this is one of the harder things to get right which are these sort of Minimax games you could probably I'd have to think about it which in my negative -2 minutes I'm not going to have time to do I think in in lecture the way that we solved Minimax problem was we separated out the Min and the Max and we thought of there being two dynamic programming problems that were sort of interacting with each other you could probably write this one in that form as well I guess just by kind of pulling this term out and thinking of it as a different array um but this form is perfectly fine too either one's all right but in my mind these are are sort of the hardest things to get right in dynamic programming so I would choose whichever one jibes in your uh brain so uh in your thing should we choose to leave it alone there is a fifth problem here which as usual I haven't managed to uh get to where you're kind of building Walls by placing tiles this is an interesting one because your runtime is exponential um but the problem tells you that that's allowed but there's like some exponential things which are okay and some that are not right like essentially what you don't want is like product of two giant exponentials you'd like to just get it down to one um basically saying it's going to be polom if you a small height that's right or it's it's polinomial in everything except for the things that's exponential in and and and moreover the things it's exponential in are are small and and the problem say that so I I encourage you guys to take a look because it really does take some time to logic through it but the setup for that problem is I think longer than my glacially slow board uh writing can can handle um but with that uh we'll call for the day