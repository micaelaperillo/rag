All right. Welcome everybody. Everyone ready for the quiz? Quiz next week? Yes. I hope you all are here because you know that there's a quiz next week. Okay. So, what is this quiz about? It's about what we've talked about so far in this class, of course. What is this class about? Someone remember from my first lecture? What is this class about? What are we trying to test you in this class? Algorithms. Algorithms. Great. Also, data structures, right? That's what the first part of this is. But really, it's to get you to solve computational problems. That's the first thing. Be able to argue to someone else that that you actually did solve it, right? It's correct, right? That you chose something that's better than other things, that it's efficient, right? and that you can communicate those things to other people, right? Those are my big four that I try to get you guys to internalize. And so that's what our quizzes are going to try to evaluate you on. Okay? And so, uh, aside from kind of some mechan this nitty-gritty kind of stuff that we do at the beginning of the term like, uh, talking about our model of computation, right? our model and like asytoics as simpics. Is that right? Uh recurrences, right? Aside from these kind of basics, we kind of delve straight into algorithms, right? Uh these are kind of like uh you know almost definitions. We don't rely on these things very much. I mean we rely on these things all the time but it's kind of the mathematics that we use to talk about things right we how can we even say how long this stuff takes unless we can reason we can abstract away that this stuff is not on a real computer this is kind of in our minds in a computer and we're reasoning about these things based on the number of constant time operations this magical computer might have so that you know which is a pretty good representation of any of the computers you have right for certain assumptions right we're not going I mean there's not a lot of problems set questions. We had you talk about uh these things like specifically usually they were part of some other problem, right? You you had to describe the running time of this thing and you might have had to solve a recurrence and you might use master theorem, that kind of thing, right? Or you use asmtotics all the time or you need to remember in our model, oh, it kind of matters how big of an integer I can store and do arithmetic on in constant time, right? So for that pet 3 question you had at the end of your the coding question, right? Uh you you wanted to hash things and you want you need to argue that those things fit in a constant number of words so that it that could be done in constant time. A lot of you guys found canonicalizations basically mapping to things that were exponentially large. So may maybe multiplying a product of primes or something like that and that would not be a good representation. Okay. So the these things come up but they're not like the main focus of the problems we solve. What are the main focus of the how do we solve a computational problem in this class? I kind of gave you two ways at the beginning of the term. Do you guys remember we can solve how to how to solve a computational computational problem? One's the hard way, one's the easy way. Force. Brute force. Okay. So you're describing to me a technique for making your own algorithm, right? I can just, you know, design my new algorithm from scratch. One way I could do that is brute force it, right? Look at all the possible outputs and see which one works, right? Or I could reduce to something like divide and conquer or something like that. That's generally a hard thing to do to make your own algorithm, right? That's why we don't ask you to do it a lot in this class, right? It's an 046 kind of thing, right? So the first thing you could do is write design new algorithm from scratch. Usually it's not from scratch, right? Usually you're reducing to some kind of algorithmic design paradigm that you've maybe heard of. You talk a lot more about it in 046 and at the end of this term when we talk about dynamic programming, but generally that's a hard thing to do, right? B you're you're trying to think of a recursive algorithm, right? You're trying to prove that it's correct. All these nitty-gritty. We we've actually throughout the class in lectures have been showing you the algorithms, but we're not really expecting you to make those algorithms. What are we expecting you to do most of the time? Yeah. To reduce it to a problem that we showed you how to solve, right? I'm going to say thing here, but really what I mean is an algorithm that we've taught you to basically here reduce to a known thing. No to known thing. Uh usually that means there's a problem or an interface, right? That that we've given you. And in general, we've shown you multiple different ways to solve that problem, right? Or interface, right? So we've shown you many ways on how to sort things right and we've shown you many ways on how to implement sequence and set interfaces. Remember uh and uh a lot of times the the types of problems that we're asking you to do is to just use as a blackbox some of the things that we did but you need as a programmer as a as a computer scientist you need to tell me when I should use what when. Right. Yeah. Could you clarify what you mean by use as a black box? Use as a black box. Exactly. Right. Um, so this is a phrase that I use and a lot of people in computer science use. It's basically uh you import a library into your code, right? What do I have? I have a kind of an API. I have a way to interact with that code. I don't actually know what's going on inside of that library, right? I'm using it as a black box. I it's opaque to me. I cannot look inside what I mean I actually probably could look inside what their code is but I'm not going to. The thing that makes it useful to me is that it has this useful API that I trust it to do the things that you told me that it was going to do, right? And so there's kind of I'm going to jump around a little bit here actually because that's a great question. uh uh so here I think of there's kind of three different types of problems that we talk about that we give you in this class you might have seen this on the problem set right I I like to categorize them into kind of three different categories here one is you kind of have to understand the internals of a data structure and algorithm that we know right you have to be able to look inside and I don't know given a node in a balanced binary search tree, an AVL tree, right? How can I do a rotation, right? Or how do I do an insert or uh uh something about the structure of this thing, a binary heap, right? Where are the top k things in a max binary heap which is on your problem set, right? Those things require me to very much not blackbox these data structures. It's a white box, right? I need to know what's inside of that to answer that question, right? I need to know about the internals of that data structure, right? And there are other types of problems where it's like, oh, I don't need to know what the internals of this data structure is, right? I can just operate with knowledge of the API, right? And try to hook it in to the problem that I need. And that's what I call a reduction type problem, right? This is like how does the core material we presented to you in lecture work, right? This is like how do I apply that core material, right? And harder than both of those things, right? Is what I might call a modification type of pro. I mean, these aren't really good names. I came up with these this morning, right? But it's trying to get at the the idea here that it's possible that you kind of need to know what the API is and you kind of need to know what's going on inside to be able to answer the problem. Things like um adapting a divide and conquer algorithm, right? or uh making uh instead of using a dynamic array that's has extra space on one end maybe I have to put extra space in the middle or something like that right I'm adapting something that was from the core material it's pretty close but I have to modify it in some way augmentation right I have to take the vanilla set AVL tree that I might have given you right and put some other property on the nodes and you need to tell me how to maintain that right how how can I compute that subree property from its children. Does that make sense? Uh so kind of this is the harder of the things, right? If you can identify which one of these a problem that you look at on an exam fit under, maybe that can help you kind of conceptualize what should I use for a reduction type problem. We're going to talk about this in a sec second, but a lot of times it's useful to reduce it to uh a problem or an interface rather than an algorithm or a data structure. What does that mean? Does if if I can solve the problem by saying reducing to sorting, right? I can argue to you that that algorithm is correct. I just use sorting as a black box. No, it might not be efficient, right? my choice of sorting algorithm that I chose matters right for efficiency but for correctness it doesn't matter right for a a data structures problem I might reduce to using two set data structures and a sequence data structure or something like that right but uh and it will be correct if I reduce it to those things right I can define the operations in terms of those those interfaces I don't have to make that choice until I talk about running time, right? Until I talk about efficiency and the name of the game on the quiz to get points, we can't give you points for an incorrect algorithm, right? Or something that's pretty close to correct, right? Uh and we can't give you full points unless the correct algorithm you give us is efficient, right? And that you've argued things like correctness and running time and things like that, right? like your algorithm could be correct uh and efficient but you analyze the running time incorrectly so we mark your points off for there or you you mo most of the time what you do is you present us with an inefficient algorithm and then you analyze the running time as if it's the target running time that we gave you right that's bad on two fronts right okay so try not to fall into these traps okay so some general test taking strategies when you're looking at your quiz I really strongly urge you to read through the entire exam before you start, right? Because some of the problems will be easier for you than others. And if you're trying to maximize points on here, right, as all of you, I'm sure, are trying to do, uh, it's use useful to make that initial pass through the problems to see which ones are easiest for you, right? And then you can tackle them in the the order in which you have confidence. Now, in actuality, the average on say quiz one of this class tends to be around, I don't know, between a 60 and an 80. I don't think it's ever been 80, but right, uh, but, you know, it's it's not 100, right? So doing 50% of the problems well right is probably going to be better for you in terms of time management and you know those kinds of things than doing all of the like attempting all of the problems and not doing great on any of them right in terms of point man right you have to in computer science you have to be pretty close to a correct answer to get points right it it basically needs to be almost correct or you don't get if If you've seen how your problem sets are being graded, sometimes our problem set graders make mistakes. Sometimes they accept give you points for for uh an incorrect solution, right? It's really on you to take a look at your problem sets that you gave us and our solutions that we gave you. We spend a lot of time writing good solutions for you guys. You need to make sure that you know the material. Don't come up to us at the end of an exam and say, "Oh, I said the same thing on my problem set. It was marked correct and you guys marked it wrong." Well, yeah, the staff knows a little bit more about algorithms than your graders on your problem sets and we grade your exams. So, unfortunately, that's not an excuse, right? It's on you to know the material. Yep. So are most of the problems on the exam sort of like multiple part things where we need to like have a good understanding and do like the first few parts right in order to get even partial credit on the other parts or is it like yeah so the question is uh is it kind of are our questions built on top of each other right so that you're kind of at a wall if you miss the first part right we try not to design exams that way okay you can actually take a look at um the practice exam that's already been posted Right? They t our problems tend to be self-contained and if they are multiple parts, the parts are usually independent. Right? Usually you don't need to have done A correctly in order to do B correctly. Right? And that's how our problem sets try to be written as well. Right? For your last the coding question on P set 4, right? You had this problem where you had to design this data structure, right? But C said use that as a black box essentially and solve the problem. Right? So you actually don't need to show we've given you this interface. Right? You can just use that interface to be able to answer C the algorithms question without even solving the data structures question correctly. Does that make sense? And actually that was the algorithms question was the easier one there I think from what I remember. Yeah. Do we have to write code on the exam? Do you have to write code on the exam? Uh I've never given an exam where you've had to write code. I have written exams where you have to read code. Okay. So pseudo code or Python, right? Since Python's a prerequisite for this class, it's completely fair game that we give you small snippets of Python code and you have to to be able to understand what's going on. Yeah. Um you listed under the modification bar. So does that mean like if we're using an amortized like what I mean here right amortization certainly appears in here or here right these kinds of things right often times like if I'm using a dynamic array if I'm using a binary heap if I'm using a hash table right amortization will appear here in our running times right for those dynamic operations what I mean here in amortization I mean like if I'm asking you to generalize something that we've done like with dynamic arrays where instead of adding additional space at the end, I'm putting additional space in the middle or at the beginning or something like that. And you're having to do some kind of amortized analysis. Now, often it's unnecessary to do this, right? In in uh when we talked about a problem where we did do our own amortized analysis and making a double-ended deck, right? I mean, a double-ended queue. uh you could actually solve it by reducing to using two uh dynamic arrays. Right? So there there's uh there's a lot of ways in which you could reduce to using things but you might have to do some additional bookkeeping at the end. Right? But what this is saying is that these are more you're not using things as a black box. You're changing something about the boxes that we gave you. Right? Does that make sense? Yeah, if you tell us to write an algorithm that does something like log n time and we can think only of an algorithm that does something inefficiently like end time. Okay. Then is there any point writing that? Sure. So let's actually move uh on for a second. I actually there's I'm going to answer your question very soon. Okay. Uh but I'm going to get to it in a second. Okay. If I don't mind, if I don't answer that question in five minutes, please let me know. Okay. So, so the first thing when I'm approaching a problem on on the exam, I might try to ask some questions about the problem. Okay? It's going to help me decide what to use, right? Different than your problem sets, right? Your problem sets basically what do you use is what did we talk about in lecture that week, right? On a quiz, you have eight lectures that you've talked about. And so that this is going to be a harder thing for you to do, right? Because you don't know which of the eight lecture material is going to apply to this problem. And it could be a combination of them actually, right? And so I'm trying to give you ways of answering that question faster. Okay? So, uh, is this a mechanical reduction or modification type problem? That's just going to help me determine kind of the difficulty level of what this is. You might not be able to answer it, right? But it can give you a sense for what kind of problem it is. Is this a problem about data structures sorting both? Right. Uh if it's about data structures, do I need to support sequence type operations? So I need to store an exttrinsic order on something or is it a a thing where I I care about what the objects are? I'm trying to look things up by what they are, right? Or maybe both. Or maybe some combination, right? If I have a bunch of different types of keys that I might want to query on, right? I might have to use at least two set type of data structures, right? You could get very complicated with these things, but putting it in terms of well, I'm going to need to do this kind of operation on this these names, right? Then I can think, oh, I need a set data structure there. I'll think about how to implement that later. Should I use a hash table? Should I use a sorted array? Should I use a AVL tree? Right? But, you know, thinking about it first at the abstract level of I need a set data structure here, right? can help you compartmentalize correctness versus efficiency. Does that make sense? Okay. Uh if if you're stuck, this is your question. If you're stuck, right, write down a correct algorithm that's inefficient, right? We can give you points for a correct algorithm that's inefficient. At least it's a correct algorithm, right? As better than other things, right? Now if it's really if it's exponential time you might be limited to like 10 or 20% of the points right but if it's you know a log factor worse or linear factor worse maybe that's okay right on a data structures problem if any operation takes order n time that's probably not going to give you a lot of points because the whole point of the data structure is to make those operations fast right but you know if If it solves the problem, you'll get some some points. You won't get zero points. Yeah. Will we get any questions that are like, "How fast can you make this? Make this as fast as possible." Yeah. So, a lot of times we'll say, "Give us an efficient algorithm." Okay. It's like, "Whoa, I don't know if it's efficient or not." Well, that just means that faster running times are going to give you more points. Okay. So in in questions like that it's mostly uh trying to play this game of uh usually we'll put an efficient one in not in terms of a data structure because usually a data structures problem it's important in your implementation that these data structure operations be fast and we want to tell you that what how fast is right so dynam data structures uh questions in general uh there's usually a trade-off between this the the running times of these different operations and it's really important how they relate to each other and so for data structures problem it's kind of about getting those running times okay with an algorithms problem right where we ask you to do one thing right and we try to do as fast as possible you know try to get linear time right most of the time you can't get better than linear time if you have to read the entire input at some point right like if I want to find the things in my data Right? And if you can't think of a linear time algorithm, you know, think of an n squ thing or think of an n login thing, right? Maybe that's a little hard for you guys to think of right now, right? But that's why I'm saying start with any correct algorithm and then maybe you can optimize, maybe you can use a better data structure to make it more efficient. Does that make sense? Any other questions? Okay. Uh, moving right along. Okay. Here's some downsides, right? Okay. If you find yourself doing one of these thing three things, take a step back. You're probably doing something wrong. Okay? So, question yourself if you're trying to compute decimals, rationals, or real numbers. I can't store those things on a I mean, I can store decimals to finite precision, right? But if you're doing finite precision, you might as well round like multiply your numbers by that fixed precision and deal with integers, right? We only have taught you how to deal with integers in this class, right? We haven't even shown you how to efficiently compute on rationals and real numbers. We have told you if you have a denominator and a numerator of a fraction, I can take two fractions and compare them right in constant time by doing cross multiplication. But if I'm trying to actually do this division, right, to arbitrary precision, that's not that's not happy, right? Because I can't even represent that on my computer in finite number of decimal points for some of these things, right? Uh if you're trying to use radic sort for every answer, it's probably wrong, right? Uh one of the things that we try to do on our quizzes, right? that we're not just giving you a bunch of problems randomly, right? We probably are making problems that cover the material in some way, right? We do want to test you on all of the things, right? And so if uh if you find that you're using the same thing four or five times on the exam, that might be a sign that you're using it too many times. It's not all always the case, right? Sometimes hashing is super useful, right? So you want to use it all the time. But in particular, right, everyone tries to use radic sort when it's inappropriate, right? And they love, right, because it gets linear time, right? But if you if you write merge sort for something where radic sort will apply, you'll get some points because it's correct but not efficient, right? If you're and it's inefficient by a log factor, right? If you're trying to use radic sort in a situation where comparisons are the answer and you don't have a bound on the integers. If I don't have a bound on the size of the integers, then this may be taking huge amount of time, right? So, I'm going to I'm might not even think of that as being correct because, you know, it could be exponential time, right? Or it could I mean I don't know I don't know how big my word size is. It could be arbitrarily bad. Okay. Uh, and then if you're trying to augment a binary tree with something that's not a subtree property, right? Something that can't be computed from the augmentations of its two children, you're doing something bad. I every exam we have 30% of students say augment by my index in the entire tree, right? Or augment by here's one that's fun. uh augment by the things the size of my left subree. Okay, how like the number of nodes in my left subree? How can I how I'm not sure how I can maintain that with rotations and things like that? Uh let's see to in order for me to keep track of the augmentation of my left tree from the augmentation of my left tree, right? I kind of have to do a logarithmic walk all the way down the thing to figure out how many things were there, right? So that's not a maintainable thing in constant time. If I want to augment something of my left subree, just augment the thing itself and just look at your left subree and look at its augmentation. Does that make sense? Yeah. If you had say augmented it with a sub tree and then augmented again with left subree and then use you could do that still count as you could do that. Yeah. So you could do that in constant time by augmenting by subree size, right? Yeah. Then have another augmentation in the thing. You could have another augmentation because then you could just look at but then just look look at your left subree please. Yeah. No no reason to store it again, right? You just do one constant time look to your left, right? Okay. Don't do that. Okay. So that is cool. I'm not that far behind. Those are my tips on solving questions. Oh, there's one more page. Yeah. So like defining an augmentation to give a formula and like argue that it's exactly right. So the the idea is if you give an augmentation that's not uh stand like we're going to talk about our standard things you can reduce to in a second, right? If I if you're saying I'm going to take a set AVL tree, right, or a sequence AVL tree and like for example at the end of lecture, we were talking about how a sequence AVL tree could be modified to support priority Q operations in the same running times as binary heaps, right? And that was saying we store our subree maxes, right? The max thing in my subree, right? Uh, and so that's a different augmentation than what's already augmented on the sequence AVL tree. What's what what are the augmentations on a sequence AVL tree? Size. Uh, so count is the same thing as how many nodes are in my subree and height, right? Because it's an AVL tree, right? Uh so if I'm augmenting by max in my subree that's not part of my standard interface so you need to tell me that right even though we've done it before it should be very easy for you right just say I'm augmenting by my max can be computed as the max between me and my left and right subree if they exist done right but just do that right you have to tell me and and it takes constant time so it can be maintained in constant time when I'm doing my stuff does that make sense Okay. So, uh the last thing I guess especially on the data structures problems um I would suggest that you approach these things by by solving these problems just in terms of the interfaces first, right? Because then at least you get something that's correct, right? And then choose the algorithms or data structures that you use to implement those interfaces afterwards, right? one gets you to a correct algorithm, the other is for efficiency. Right? Decoupling these might help you in solving the problem. If if it doesn't help you, don't. Right? Right. If if you're like, whenever I see a set data structure, I'm going to probably use a hash table, that's probably fine, right? But if we're looking for worstase time bounds, that's probably not fine, right? So you just you I'm I'm ask I'm suggesting that you separate these things uh so that you concentrate on solving the problem first and optimize it later. Yeah. Just a question in regards to worst case time bound. Um so for our hash table given that it's like oh one expected like that also implies that oh worst case. So could you technically it doesn't imply that it is that right? So that I mean you could have a data structure whose expected time bound is constant but its worst case bound is n log n right it just happens to be the fact that for a hash table those worst case operations are linear right so but if I had we had a question uh up here beforehand right if I had a a running time bound that I did something to a hash table right in constant expected time right I did a lookup and then I I I queried an AV VL tree for the predecessor of a node or something like that and I did that in O of log N time what's the worst case running time of that O of N right what's the expected running time of this thing log N expected login right because it's possible that in the worst case it could be higher that make sense okay uh Uh so okay the second bullet is just setting up a data structures problem right there's a lot of moving parts we're going to do two data structures problem at the end of this session right describe all of the data structures you're using right including what they store right if you're storing a set data structure you better tell me what the things you're stored are keyed on right usually the things that we're storing contain a bunch of information. And if you just say I'm storing all of the toppings of my pizza, right, in a set data structure and that's all you tell me, I have no idea what you're talking about because I don't know what the semantics of your set data structure are. What is it keyed on? Right? I have to say, oh, it's keyed on, I don't know, the wise or something like that, right? Okay. And they're invariance, right? what how we're setting up these data structures problem usually how I solve these when I'm writing the solutions I set you up a state right of what this data structure could be at some instance right I'm going to say this data structure stores all of the things less than K with with key less than K blah blah blah right and this one stores the uh the exttrinsic order of the items based on blah blah blah right Okay, so actually me stating what they store in that way, right, is actually imposing some kind of invariant on these data structures that I'm wanting to maintain, right? But what I need to do to prove that this thing is correct is that based on the assumption that those invariants held before my operation, right? then I can prove that an operation is correct if all of those ma those those invariants are maintained at before then after the operation right that's kind of how I'm proving that this thing is correct and then when I'm querying I'm doing some kind of lookup on this data structure I can rely on those invariants I know that those things are good right those things have been maintained and so I can rely on those to look up uh what's the largest K of this thing does that kind of make sense abstract we're going get a little bit more concrete in just a second. Uh and then uh implement every operation. I you have no idea how many solutions we write read on the quizzes, right? Which we give you three operations to implement and you don't even mention one and it's usually the easiest one. It's like insert it into your data structure. It's like come on just say that right? We can't give you points unless you mention that operation. Does that make sense? Uh, and then it's going to help us re happy graders give you more points. Not not really, right? Like, but I if your solution is well organized and wellleled and things like that, then we're going to be able to comprehend your solution better and we'll be able to give you more points. Remember, part of this class is about communication. If your thing is correct, but we can't tell what you're saying, then it's not correct. Right. Right. Okay. All right. So, uh, now we get to any questions on that? Yeah. Question about the variance. So, what are the data structures that we've discussed in the past? Do you still like what the variants are like that tree? Right. So if it's the standard things we're going to talk about what the standard things are now uh then you don't need to reargue or restate all I mean you can you can basically say like uh because the set and sequence interfaces are defined that way these things are correct like almost like ob you can you can basically we you're trying to convince us that you know why it's correct right if you guys if you're correctly using a set or a sequence data structure in these data structures type problems then unless you're using it in a way that is unusual right uh usually you can just rely on the properties of the set and sequence data structures that we gave you I do want you to mention that you thought about correctness right right like this um this data structure is correct because right just write a sentence saying that right and arguing that you're you're basically maintaining the invariance of your data structure kind of at the upper level, right? What kinds of things are is this data structure storing? What what m uh things about the the global data structure are are we relying on to make query operations? As long as you are are convincing that uh after a dynamic operation where I'm modifying the data structure that those invariants stay the same that are are still satisfied then then that's really all you need to say right you these these invariants are are satisfied because of the definitions of a set and sequence data structure right like a lot of times it doesn't require a lot of thought for the we're not asking the the reason why we do reduction problems, right? Is so that you don't have to do a lot of work to prove to us that it's correct, right? We have these really nice black boxes. They are correct. We proved them to you that they're correct. And so you don't have to redo that work. Okay? So now we're going to go through uh kind of the core material I like to think about in this class. this class the the first part of this class aside from these you know mathematical uh uh tools that we developed at the beginning of the course is mostly about solving problems involving data structures and we motivated this problem of sorting by saying that a sorted array is a data structure that's actually pretty useful right but how do we sort those things uh well we showed you a bunch of ways to do that right and this is that nice table lots of stuff, right? Why do we show you so many sorting algorithms? Why don't we just give you one algorithm? H different run times. Better for different scenario. Better for different scenarios. Yeah, they each have their own individual components that may be better. Yeah, you'll notice in this table, right, there's not blue all the way across for any of these things, right? So, some of them are better for different scenarios. And actually these comments kind of list some special cases where these things might be better. Right? In in actuality this ultra blue thing is saying like this could be linear time that's better. Right? But in some cases this is worse than all the other things. Right? So be a little wary of this blue color here. Okay. Generally we're trying to get you down further down in this chart if you can. Right? And in general uh like for example merge sort, AVL sort these are really the same in terms of asmtoic complexity and kind of the way in which you interact with these sorting algorithms. Um but there are special cases where you might use insertion sort or selection sort. Actually I'm not sure about insertion sort. I there you had a uh in your recitation two days ago uh I think you guys showed how to do uh if you had a kroximate array where things are not more than k away from each other. Insertion sort actually runs in n times k and so if k is small then that's really good. That's kind of like linear. But you can actually do even better with a binary heap which you saw in recitation hopefully where you can get that down to n log k by keeping maintaining a heap as you go across and finding the max that way. Okay. Uh so insertion sort maybe is not so great but uh selection sort right the the name of the game there is that uh if my reads are cheap but my rights are expensive right uh selection sword actually does pretty well because I only have to do uh sorry my reads are cheap and my rights are yeah expensive right selection sort only does a linear number of swaps right it's looking down finding the max swapping it in and keep going right and so such cases that's actually better than any of these other algorithms that we've got. Yeah. Is he sort time um worst case or expected? This is worst case. Okay. So, it's a little hard to put there was a lot of moving parts to get to this bound uh in on in Tuesday's lecture, right? Uh basically what we did, we showed you how to think of an array as a heap, as a binary tree, right? Complete binary tree. It's not an AVL. I mean, it is an AVL tree, but like AVL trees are weaker than a complete tree, right? Height balance is a weaker property than a complete, right? The the the reason why we use complete is because it's unique for a number of nodes, right? That way I when I give you one array with a fixed length, I know exactly what tree you're talking about because there's a onetoone mapping there, right? If I I can't if I there was it some ambigu ambiguity on what tree I was talking about I wouldn't heaps just wouldn't work right so what what heaps sort does is it has this correspondence between arrays and binary trees uh and then what it does is uh provides these operations that kind of only do operations at the end right and then the in place uh uh optimization is that well instead of actually popping it or pushing it onto the back of an array. I'm just going to think of a subset of my array as a heap and then always kind of pooping the max out to the the end, right? Just leaving it behind and thinking of my heap as a smaller subset, right? And that's how we got it. It didn't actually use any amortization uh for for the timebound timebound. You could actually do this with the amortized basically dynamic array version of this. The timebound doesn't rely on that. The in place relies on you know key staying all within one array. Does that make sense that you're doing a bunch of amortized operations so that this actually does achieve worst case and login? Yeah. It seems that like the things we learn not like such a long time ago are they tend to be better. So assume that most algorithms you want them to be you know faster. Um it seems like we will not use as often especially in the exam as well insertion and selection right yeah so there are these special cases where they're good right but I mean uh you know generally these are better general data structures for most situations that you come across. I mean there are cases where those other things are good so you don't want to completely ignore them right but generally uh yeah you trying to be lower down in this chart. What I mean is that if I don't have any exam like I'm using them all except for like selection it won't there's too many things on here for us to test all of them on an exam. Okay. So don't be afraid if not everything is covered. Worry when things are covered 18 times on the exam. That's not good right. Um okay. So for radic sort there are situations where right you get linear time right it's when you're polinomially bounded is there are there times when I want to use radic sort when I'm not polomially bounded in my integers well if you're not polinomially bounded then that could take a really long time. Sure. Yeah. But like where's the uh this will be worse than n login when right it's definitely better than n login when u is polomially bounded right because it's linear yeah n to the n okay so if I put n to the n in here right I get an n factor that comes out here that gives me quadratic running time which is not great. Okay. But when will this be better than n login? Yeah. Uh n to the c is less than n to the c. Uh n to the c. So that'll definitely give us linear time, right? That's what this is saying. But we can actually do better than n login if this u is n to the c * log n, right? for some C, right? If it's if it's as like if it's N to the C log login log N, right? That's smaller than login, right? So that's a better algorithm, right? That's a faster alg. Do you guys see why we wrote these things this way is so that we give you a more precise bound. It's it's this is more important for you understand what U means here than that that this thing sometimes runs in linear time, right? We want to know you when it runs in linear time, right? Does that make sense? Or when it runs faster than merge sort. Does that make sense? Okay. So that's sorting. Uh we have sequence type data structures, right? We have linked lists, we have dynamic arrays, we have sequence AVLs. Sequence AVLs are great. I don't know why no one teaches it. They're great. They don't teach it probably because they're actually not that useful, right? They you don't actually use the insert in the middle a lot, right, in coding, right? So it's it you can usually get around with like shifting something to the end and doing dynamic operations there, right? And that's a lot of the games that you try to play. So you don't have to make your own data structures and you can just use the Python list that's in your in like native to your thing, right? But theor it has a theoretical interest because it gets these kind of balance bounds if you need to insert in the middle of this sequence. Right? Uh now some of you look at me and had a question before right that was like but Jason how does linked list operations on the end of a linked list why does that take linear time? It's because in lecture we presented you with what? A singly linked list, right? It just had pointers to the next thing, right? And if I only have pointers to the next thing and a pointer to the head, for me to find the end, right? I need to walk all the way down the list, right? Now, let's say I keep my pointer to the tail. then finding that end one is fine but removing it still takes linear time because I don't know what came before me right and so that's why in pet set whatever one two I don't remember uh you stored a pointer back to your previous one that gave you doubly linked lists yay right so actually expanding this table out you can reference a doubly linked list here and get this one as constant time does that make sense And uh this one still linear time, right? Okay. Uh but this one's still linear time. Uh we al actually also showed you how to do this in constant amortize. Do do you guys remember that? That was in problem session two or one. I don't remember remember it was whatever we talking about uh amortized stuff, right? We got we got actually both of these to one amortized using the concepts of a dynamic array. Right? And then we actually did it one more time where we got a good double-ended thing. What was that? Does anyone remember? We went to problem session three. Yeah. Oh, I'm probably wrong. This is like Q. So QDQ uh those are talking about double-ended things. uh those are implemented in a certain way right which is actually one of these things it's actually I think this one in Python uh but uh there's we used a different data structure to get something that had really good at right it had really good pop and append and first and last dynamic operations do you guys anyone remember problem session three space. That's That's what this was, right? Okay. We got one that had expected bounds. Does that help? Really? I heard someone say it. Hash table. Yeah. So, what basically you did you instead of you you this is a sequence thing. These things don't have keys, right? But I could identify with each item as I stick it in a key representing its index, right? And I could use a hash table that way. Now there was some difficulty, right? If I removed the first thing, right? Or right, because actually how how those all of my indices have now changed, right? But if I just store what the smallest index in my thing is, then then I'm golden because I can compute what that index should be, right? As I as I change things at the front. Okay. So there's actually three different ways we showed you of getting constant time at the front and the back of this thing. So actually you can think of that as standard material that you can reduce to. Okay, that's the like one exception of the things that I'm not showing on this chart, but is a bonus if you're watching this problem session. Yeah. So the so isn't a hash table a set data structure though it is right but it's we used it to implement a sequence data structure. So I will refer you to that uh problem session if you want to learn more about it. Okay. So any questions on sequence data structures? Yeah. Uh a different question. Uh should we be or yeah should we be able to like prove the tables that we're given? So, uh, I would hope I hope that if I gave you a blank table that you would be able to fill it out, right? That's how well I want you to know how these things are implemented. I'm we're not going to have that on the exam, right? That's a boring kind of question, but it is important to know. Yeah, I I would um you know, it's good for you to think like, oh, if I'm going to use an AVL tree, right, operations are generally going to be login, right? That's a really useful thing to or if I'm going to use a hash table, right? Dictionary type operations, you know, finding, inserting, and deleting, those are fast, doing order type operations on hash structure hashts is bad. That's hard to do because I have to basically look through all my things, right? Um, knowing that dynamic operations on a sorted array is bad, right? or knowing that uh you know you you have to think about here what we mean when we say linked list and dynamic array in this table right because sing you've yeah exactly we are implying singly linked here because that's what we presented to you in lecture and so those are the standard things that we want you to reduce to so the three modified standard things are the double list the double ended yeah basically you can assume that you have a doubly it's this one that you probably want to use Right? Because you get constant indexing, right? And then pretty good on both ends, right? But you know, if you need a double-ended queue, you can also reduce it to having two dynamic arrays back to back. One going this way, one going this way. And so there's lots of way. We're not going to give that to you as a standard method because there's literally like four methods we showed you how to do, right? So you choose one. Okay. Yeah. In the interest of like saving time on the exam like if we want to say like we do this thing with the sequence and it takes login time like do we have to like say the sentence like because it's a sequence AVL it takes long time because this or can we just like say like per the table that we yeah no if if you just if you told me that you're storing things in a sequence AVL right and you just say you basically say what you do to it and you say which takes blah blah blah time you don't need to say because it's a sequence AVL Right? Because you already told us it's a sequence of wheel. I believe that you probably wrote the chart on your cheat sheet and you looked it up. Okay. All right. Uh any other questions on this? No. Yeah. Just to make sure the double link list will make the insert and be all one. Is that the only change? Yes. That double link list gives this guy constant time. And actually there are two operations here. uh insert delete and I guess there's a find here as well right if I just store the tail pointer that gets the find to constant time right but it doesn't get the dynamic ones to constant time right I need to store the previous pointers as well at each node does that make sense okay uh lastly or I guess second to lastly set data structures there are a little bit more of these not so many more but uh But yeah uh we had a sorted array gets good find but is not dynamic right we set AVL tree which does pretty good find and is dynamic again you get this uh log n login overhead to build because essentially what you're doing with both of those data structures is to sort right but if I'm looking on a theory question Right? Like I'm not asking you something specifically about a sorted array. Right? If you have a choice between this data structure and this data structure, which one do you choose? Well, I don't quite know because it's almost like this one's better at everything except for this one, right? But can anyone tell me how to make this one constant time as well? Augmentation, right? I could just store in my sub trees the max or min, right? And I can make this one strictly better than this one, right? So in a theory problem, you probably just want to use this one, right? Uh here, hashts, direct access arrays, even better for these operations. That's great, but they suck at these, right? So if you need these, don't use these, right? And in actual coding, right? Especially if you're coding in a language that's not Python, something that doesn't automatically give you a hash table, right? If you're in C in a microcontroller lab in in at at MIT here, you're taking 615 or whatever, right? Like and you're doing assembly, right? Usually what you're doing is a direct access stuff, right? Because that's giving you the jumps that you need in machine language to actually go and access this and cause the time. That's generally if you have control over the keys that you're putting that you're putting in your data structure. You don't want this overhead of com running your keys through a hash function to look these things up. You just store the things in array, right? You use the hash table when you don't have control over the keys or your keys are like strings or something, right? So that's when you use the hash table. Now for our purposes usually you know a hash table is just as good unless we're asking you for worstcase bounds right and if we we're going to do this when we talk about the data structures problem if we give you a situation where we don't care if you achieve worst case or expected or amortized or any of these things. We'll just say make sure you state which one you achieve, right? And as long as you analyzed it correctly with respect to your data structures, then you're fine, right? But if we say you better do worst case here, I'm going to slap you around, right? Then please get those bounds, right? Don't don't use a hash table in that case. Does that make sense? Okay. Uh lastly, we've got priority cues, which we talked about. I'm not going to go through this one very much. It's basically just adding this to the thing. But act in actuality, you can get all of these bounds with a set AVL I mean a sequence AVL tree with max or min augmentation which isn't on this list because we didn't really talk about it but hopefully you can if you need these bounds without the amortization then then you could achieve them. Okay. All right. So those are that's basically everything that we've talked about in the class. Okay, we're going to spend the rest of the time working a couple data structures problem. I'm not there's there's a number of different types of questions you'll actually um see on uh on the quiz the practice quiz that we gave you from last term. there's some what I call mechanical type questions up at at the front right then usually some reduction type problems where you're reducing to using some sorting algorithms or some data structures and then usually the la latter ones are ones where you have to do some kind of something additional like some augmentation or some you know divide and conquer or something like that right okay uh so we're going to go ahead and spend the rest of the time working a couple of these problems uh these were from spring of 2019 on the exam. Uh uh and actually one of the TAs who's uh TAing for us now was also TA for us in spring 19 was grading problem number two here the rainy research problem and just hated me because no one did it right. So all right uh so let's try to solve these problems. So problem one, this is about restaurant store. Yes. Okay. All right. Uh so basically what's happening? Uh popular restaurant, criminal seafood. What's the reference? Legal seafood. Yes. Opposite. Does not take reservations but maintains a wait list where customers who have been on the wait list longer are seated earlier. Uh sometimes customers decide to eat somewhere else so the restaurant must remove them from the weight list. Okay. Uh assume that a customer has a different name. No two customers are added to the weight list at the exact same time. Right? So there's an kind of an ordering at which people are being added to this weight list. Right? Does that make sense? Uh design a database to help criminal seafood maintain its weight lists supporting the following operations each in constant time. Okay. So here we're we've refactored the running time up to the top. Uh and it said oh sorry I added the build here. I guess that's still constant time. That's fine. Okay. Yeah. State whether each running time operation is uh worst case amortize expenses. So when you see that statement you're saying okay I'm allowed to use a hash table if I want to right. I just have to make sure if I use one, I label my operations expected and amortized when they occur, right? Which which operations are expected? Basically, all of them. Which operations are amortized? The ones that changed what's in the data structure, right? Insert, delete. Okay, so we've got some operations building an empty thing adding a name. So, this name is X to the back of the weight list. What do I know about X? What do I know about the names per our assumptions in this class? They're all unique. So they can be a key. They're unique so they can be a key and they fit in a constant number of words by our assumption. Right? So I can compare two of them in constant or I can hash one in constant time. Right? That's kind of the assumption we make on these inputs. They're strings and I didn't assign you a a bound on their length. So you it's probably not something you need to worry about. Right? Okay. Uh remove a name, right? So already I'm feeling like I need to be able to find things by their name, right? Okay. Uh and then see it's the next person in line. Does that make sense? So what kinds of things do I need to maintain here? I I've I have people, right? They have names and they have kind of places, right? The time that they came in, right? But am I given the times? No, I'm not given times anywhere, right? It's not on the inputs to my operations, right? So, it's not like I'm going to be able to key on times. Does that make sense? What's the important part about the times? The order, right? And you're given that. Yeah. Basically, whenever I'm I'm basically trying to maintain a sequence on these guys, right? There's a front one and a back one and people in the middle, right? And I want to make sure that order stays the same or else people are going to get angry at me, right? because ah they came here after me and yeah right you've been in that situation. Okay, so uh we're trying to maintain some kind of sequence an exttrinsic order on these things, right? But we're also needing to be able to look up people by their name because I want to be able to change this thing, right? Does this maybe sound familiar to some other problem we had on this pro this terms problem sets? Yeah, I think there was a problem where uh the chat, right? Right. You had to store a sequence, right? But you also had this dictionary that you had to look things up, right? Now, the nice thing about that um situation, right, is that the things that you needed to look up on was static, right? And so what could I use for my dictionary, my my set data structure for that? Anyone remember? You could just use a sorted array, right? Because it's static, these things aren't updating all the time, right? And so it was fine for me to just use a static array. Right? Here uh uh and and we gave you lookup times that were worst case logarithmic. Right? Here I'm asking for constant time. Right? Sort AVL sorted array is not going to cut it. Set AVL is not going to cut it. That's what I'm going to use. A dynamic array or a hash table. Right? Now dynamic array might not be great because I don't actually have a numeric bound on how big these keys are. I just know that they fit in words, right? So I can't actually make a direct access array because those words while they fit in a constant number of words, I don't know if the integer representation of those are polinomially bounded. Does that make sense? Right? So I I do want to use hashing in this in this case. Right? And so what do I want to maintain? I want to maintain a sequence data structure uh on customers. Customers is there a U in there somewhere? No, this is right. Right. Okay. And a set uh mapping. So you this is usually how I do it. Like I want to say a set keyed on something. If it's just a set, then I just have it keyed, right? I can look up whether that thing is there or not. But when it's I'm I'm actually having it mapped to something else, I'll say, you know, mapping a key space to something else. Usually the item that I'm storing or maybe some property of the items that I'm storing, right? Does that make sense? Okay. So, mapping, what do I map here? Names, right? to oh to what do I want to map the time the time that they entered do I want to do that well we can't exactly do it with the time that they enter but the sequence and the customers will show what's next and yeah kind of I want to I want to store it to where it is in this sequence right so I'll just store the index where it is in the sequence and I can just look it up right that sounds Yeah. Is that what I heard? Indices change. Yeah. Indices change every time I add or remove things, right? Ah, yeah. Store a pointer, right? Pointer to place in sequence. Now, uh that's a little weird to say because I haven't told you how I represented this sequence, right? But you know conceptually I can say I'm storing a pointer to some place in this that represents where it is. I'll deal with the details of that later. Okay. Right. But generally I call this a linked data structure. Right? Because I'm linking between two data structures. Right? So that I can do a query in one say and find out where it is in the other. Right? Or do a query in the other. That kind of thing. Okay. So everyone kind of understands why I chose these things, right? How I approach this problem. Yeah. Um not sure how a pointer fixes the problem of just storing an index, you know, like the the place that the person is at in the sequence is going to change over time. Are we assuming that the pointer updates with that change? So, okay. So, let's say uh if if every time So, let's say I'm storing let's say I'm storing this sequence in a link list. Let's just say because I know that I'm going to have to be inserting and deleting things from the middle of this thing. Does that make sense? All right. So, I'm going to go ahead and say that this is going to be a linked list. Okay. And now I have this linked list. Okay. So if I said all right this set data structure in my set stores point or stores where it is in the link list right I say it's stored at at uh k right cool now if I see it's this guy right I stick him at his table right every index has changed right so for me to update the indexes stored in this set data structure, I have to change every single one of them. Yeah. Does that make sense? Yeah. No, this makes way more sense. Yeah. So, really what I want not to store a number here, but an actual pointer to the node that's containing this thing, right? Because the node isn't changing unless that thing left my data structure, right? the node, the address of the this thing in memory, the the the node is just a little container that contains an item and a next pointer. And actually, we're going to need a previous pointer here, right? We're going to need a double length list, right? Because what we're going to do when we remove something, we need to stitch it back together in constant time, which means we need to know what's the one front of us and the one behind us, right? Yeah. Okay. All right. So link list here we already said maybe using a hash table here right and so okay great this is basically enough for me to say this is my data structure these are the invariants what are the invariants it's storing all the customers right that's an invar I mean it's not a very strong invariant but it's I mean I I should say that right I'm storing all the customers because I'm going to have to make sure that I'm maintaining that when I do a query, right? Uh and then here set mapping names to pointers, right? That place in this thing, right? And as I remove things, I need to make sure that invariant stays the same, right? It's still mapping all the names of customers that I have in my thing to their nodes. Okay? So when something leaves, I better need to make sure that both of these things are updated. Does that make sense? Okay, so how do I maintain these operations? We've got a build. Build just sets up empty of these things, right? So you just say that, right? I build an empty linked list, doubly linked list on the customers and I build a a set uh a hash table mapping nothing to nothing right now. Right. Okay. So that's build. I'm gonna be precise here and actually write down the thing because I told you not to uh not to ignore a operation or else we can't give you points for it. The next one. Yeah. By empty by building an empty list you mean like it just has like the head and the tail are set to none but like it exists. Yeah. Right. It's it's a thing in memory that we store. It has a pointer to a head and a tail. Those are none right now but we will add things to it. Right? Okay. So the second one add name right. What do we have to say? We have to update this data structure so it maintains it to variance. Right? I have to usually I start with one of them. Uh I get to a point where oh I really should have updated the other one first. Right? So sometimes it's hit or miss. What do I want to do here? Well, I have no idea where in this sequence this is, right? So, I kind of have to go here first, right? Oh, sorry. Adding a guy I could do either way, right? I know where is he going to go? End of the list, right? So, I can just stick it there, right? So, add x to end of sequence. All right. So I already come to a trick that I like, right? Sequence set. Okay, in this instance I only have one sequence in one set and so calling them sequence and set it's probably fine, right? I'm not going to confuse the greater I'm not going to confuse myself, right? But when I have more than one of these things or even for brevity on an exam where I'm, you know, time constrained, give these things a name, right? Say this is a sequence uh C and M I don't know I see customer here I see map here so you know maybe I don't know right but just give them a letter and we can follow you much more clearly and you can refer to these things more precisely right so end of C okay uh then what do we have to do I fix this guy this guy's good now I have to fix this guy so I add x to the set and I map it back to that node that I just came from. Right? I could store it in a temporary variable, right? Add uh x to m pointing to in node v to v. Okay, cool. So I added my X to the end of C into a node V, right? I'm kind of hold I labeled it so I can reference it later, right? And kind of in code I would probably remember what that node was. Add X to M pointing to that node. Right? And now I've maintained my invariant. Great. Maybe what's next? Uh add key X or add add X to M having the key of X point to that note. Does that make sense? There's a subtlety there. Okay. Three, we have remove. I don't remember the name whatever. Okay. So here we have to do the order matters, right? I don't know where it is in the sequence, but I'm going to look it up in the set. I'm going to remove it from the set, and I'm going to look at whatever it points to and remove it from the sequence. Okay, I'm running out of time a little bit here, so I'm not going to write all that down, but you guys understand what that means. Here, we're using the fact that it's a doubly linked list so that we can relink things together. You don't have to tell me repoint the previous pointer of my next thing to the next the right you don't have to tell me how to relink those pointers because we did that already in problem set one or whatever right just in general is there any situation for where using non not a double link list like just a link list would be better than double link list because it seems like it always solves problems yeah double link list is almost always strictly better than a single link list in theory problems So yeah, use it. Okay. Uh and then seat last one. That's just take the front of the sequence, remove it, change the head around. But I I get that you can delete first, right? You're reducing to the interface that we had. You're deleting first on this sequence. Okay, but now we have a situation. I I deleted the first guy. How do I know who the first guy is? Well, I'm storing its name in there, right? I'm storing the names of these customers. So, I know who was at the front. I look in this set data structure and I remove that entry. Does that make sense? Because now I no longer need to maintain where he goes. Now, in actuality, I could just not update this set data structure. But if I do that then well my running times are still linear time right I'm not giving you a bound on space I'm I'm still constant time sorry so you don't actually have to do that removal but uh if that customer comes back and wants to get on the wait list again right you're right there there are things to consider right okay so that's that question next question last 10 minutes or So, uh, rainy research. This was a problem that people had nightmares about. Okay. So, basically, we've got uh Mother Wan. He's a weatherman. Uh, a scientist who uh studies global rainfall. Uh, and he's got a bunch of uh uh sensors everywhere. And each one can post to the cloud or something a measurement that's of the form a triple of integers R, L, and T, where R is a positive amount of rainfall, an integer, uh a latitude, uh an integer again, and at a time. Okay, so we got three things to deal with here. Yuck. Okay. Uh but they're all integers. And don't be like, "Oh, well, Jason, latitudes are pretty small, so I can assume these integers are small and these things take constant time, right? I'm not specifying to you a resolution at which I'm measuring these integers. So, and I haven't given you a bound between what that resolution is compared to the number of measurements that I have. So, don't play those games. Okay? Uh the peak rainfall at a given latitude since a particular time is the maximum rainfall at any measurement at that latitude measured at a time greater than or equal to that time. Does that make sense? Or zero if there aren't measurements at that latitude. Okay, just or after the time or before the time or whatever. Describe a data base that we can build it and cause the time. Right. uh is an empty one. I added this one because we weren't good about that last spring. Uh record data, we give you a triplet and then so record data for it to be correct, I just have to maintain that information. Right. Right. For these kind of updates, I don't I it's really hard for me to argue that this thing is correct. Right. Because I just, you know, I throw it at the database. The data basease doesn't have to give anything back to me, right? So the the important thing here about correctness is that peak rainfall gives it to me and it gives it to me in the time bound that I'm looking for. And peak rainfall is returning the peak rainfall at a particular latitude since t. Okay. So we have three things. Yep. Given that we never have to like return a single measurement is that we don't need to have a record of it. There's the potential that you don't need to store all of the information because all we're doing is giving you back RS essentially. Right? It's possible that you don't need to store the latitudes or times at all. Right? You don't even need to store the triplets. Now, in reality, I'm querying on the latitudes and the times. So, I I should store them somewhere, but I might be able to compress them. in particular, right? Many things could be stored at the same latitude, right? That's kind of the whole point of the query. And so we want I mean, we may only need to store that latitude once. Does that make sense? Okay, I'm I'm going to wait for questions until after because I want to get to a solution to this problem. All right, so uh what do we need to do? We need to be able to add things and I want to return. So return, I'm going to have to query something, right? And then I'm going to return something, right? So return peak rainfall at latitude L since time t. What do I care about in a particular query? I I only care about all the things at L, right? At a latitude L. So really I this isn't such an interesting thing, but I want to be able to have maybe many data structures, one associated with each L. Does that make sense? Right. And how can I find one in each L right quickly? put it in a dictionary. What's my time bound? Worst case log N. Right? So what data structure did I use for that set data structure? A set AVL. Right? So we're going to first have a uh set AVL uh say L uh mapping latitudes to well now we have more data structures right I want to store a lot of the things that have the same latitudes in another data structure right the ones is probably storing the times and the rainfalls of all those measurements. Yeah. Uh yeah, a hash table. A hash table. Okay. So, what kinds of query am I going to want to do on the things at the same latitude? Um you're going to want to get the times. I'm going to want to get the times, but more than that, I'm doing kind of a an ordered query, right? I need the things less than a certain time, right? Greater. Also, it's just just a second. You should do like an AVL for the time and an AVL for the rain. Okay. Do I care about an AVL for the rain? Do Am I looking up on the rainfall? No. No. Right. So, I'm going to go ahead and store these things in a time sorted AVL, right? To uh mapping latitude L to I'm going to call this data structure a time data structure, right? I'm going to say it's T of L. Okay, that kind of looks like a recurrence. So, it's a little irking me right now, but I don't have anything better. All right, so now each one of these time data structures, right, is a set AVL mapping time to the, you know, the rainfall measurement, right? All right. So that's going to if my query was return the peak rainfall, sorry, return the rainfall of the thing with latitude L and time T, we'd be done kind of, right? You you'd know how to support that query, right? I to insert things, I insert things into both data structures. I just look it up, right? The one complication here is that I'm not asking for what is the rainfall at a particular time. I want know what the maximum rainfall is up to this time. Okay, so max heap's good if I want to know the global max, right? But here I want to know the max bounded by a certain range. Okay, so I we're gonna you can ask me questions after this. We're running out of time a little bit. Okay. So, anyone have an idea for how? Yeah. You just augment the the with the max. Okay. You can just look at the right child and just look at the max of that. Ah, okay. So, what your colleague is saying, if we augment by the max R in my subree, maybe we can use that to figure out this query. Right? Because we're ordered on T, right? we have this nice monotonic property that everything that's going to be in my query, right? Everything to the right of a certain time, right? If if my time is uh in is above t, right, at a particular node, then everything in my right subree is also above that t, right? Because of the order of my set's data structure, right? Because I'm ordered on times, right? So there's maybe the possibility that if I look to my right subree, I can not do work all over here by just looking at the max in that subree. Right? So that's an idea of let's say augmented by subtree max r. Okay, you probably want to give this a name as well, right? So like v max, right? where V is a node in my sub in my thing, right? And I want to show how to support this, right? How I can compute that from its children. So, how do I actually support this query, right? I can think of it recursively, right? I have a couple cases. If I add a V here, I want to define a recursive function that's called uh, you know, peak peak rainfall of a given node. lower bounded by a t. Okay. So if I'm here, there's two cases, right? Either my t my time is bigger or small is in my range or out of my range, right? If it's out of my range, what do I do? Right? It's lower than my time bound. I can just recursively call this function on this node, right? because I know that any thing is going to be down here that I care about, right? And that's just one recursive call down the tree, right? And so if I only limit myself to one recursive call down the tree, I'm always going down each time. This is going to take logarithmic time, right? Okay, so that's the first case. That's the easy case, right? This thing is not in range. I return recursively the thing to my right. What's the other case? I'm in my range, right? Well, now I could return recursively call both sides, right? Because that's what this this peak is talking about. What's my peak rainfall? But if I do that, if I call it here recursively and I call it here recursively, that could take linear time, right? I might touch every node in my tree. So why did I do this augmentation? It's so I don't have to do work on this node. I just return the maximum rainfall in this subree, right? And then recurse on this side. So I I did constant work on this side. I did one recursive call down here which could go to the bottom. That's okay. I can afford to go to the bottom of the tree. Does that make sense? And if I don't have either subree, then I'm done. Right? If if at any time I don't have the node that I'm supposed to recurse on, right? I take the max of this subree myself and whatever the recursive return value is here, right? and comparing three values returning their max. Does that make sense? Okay, so that's what we call a one-sided range query. Okay, so uh in the I think problem session four that I didn't get to, it shows you uh a way to do this for a two-sided range query where I need to know like the maximum of all things between two things, right? But it's really no more difficult than this defining a recursive function that uses an augmentation so that you don't have to do recursive call on both sides. Does that make sense? Okay. Uh that's going to be it for now and I can take questions after. Okay. Thanks for coming.