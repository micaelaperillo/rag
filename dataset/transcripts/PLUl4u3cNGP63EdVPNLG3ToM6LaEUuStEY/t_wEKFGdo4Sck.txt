hey everybody uh welcome back this is our last uh quiz review for the term uh quiz three we'll be talking about which will be the last quiz until the final uh it's on dynamic programming which you guys have been studying in lectures and recitations and on your problem sets seven and eight um and lectures fifteen through eighteen so four lectures uh quiz one and quiz two material on uh essentially data structures and graph algorithms aren't going to be explicitly test or we're not trying to explicitly test it that material on quiz 3 but uh you know it is fair game uh the material is cumulative and so if you know you have to store some stuff in the data structure that's that's fair game but we're not specifically trying to test you on that material okay and really we haven't learned all that much new material in these last four lectures or this last unit uh so right so this is scope we've got uh you know we're mostly handling dynamic programming uh on these these four lectures and recitations and these two problem sets but really the focus is going to be on this recursive framework of solving problems with a focus on dynamic programming specifically now the recursive framework we've we have i think in previous slides we use this uh sort bot notation and i think there might be a space there uh in in previous versions i'm concatenating them together here but really it's it's a framework for solving breaking down your problem into a set of sub-problems that can then be related recursively and if that relationship depends on problems in a decreasing or in a smaller sense right there's a directionality to which subproblems i'm reducing to each time i make a recursive call and that dependency graph is acyclic then we can solve via dynamic programming by memoizing from bottom up or by calling things and remembering the calls that we've we've called before uh via memoization right and the basic idea here is this the recursive framework sort bot that we established is good for any recursive algorithm but in the special case where subproblems made may be used more than once may be used when computing other subproblems then we get this really nice uh speed up by recognizing that we don't have to do that work more than once and essentially instead of looking at it as a tree of recursive calls that may recall the same problems more than once we look at it by collapsing those nodes of the same value down into one we get a dag and dynamic programming is is when those sub-problems overlap okay so let's take a look about at uh our recursive framework here sort bot we have the s-r-t-b-o-t i remembered the space this time a sub problem you're going to define some sub problems you're going to relate them recursively you're going to specify a topological order of those sub problems that the relation satisfies uh you're going to list some base cases basically wherever you could solve the sub-problem in constant time without doing any recursive work stating how you solve the original problem which might involve combining many sub-problems but frequently is just you know finding one sub-problem and possibly remembering storing parent pointers to return an optimal sequence or something like that and then analyze the time now the last one isn't really important for solving a problem recursively but in this class it's really important because we want to tell whether the algorithms that we make are efficient so let's dive a little deeper into each one of these things so when we approach a sub-problem really what i'm asking you for is to describe basically set up a set of sub-problems basically i like to use the variable x but you can use whatever variable you want but basically you're telling us what's in your memo and how big your memo is right so we we usually have x as a function of some variables and you're wanting to describe to me what the meaning of that sub-problem is in terms of the parameters now if you have parameters in your sub-problem that don't appear in your sub-problem definition you're doing it wrong and you're probably not going to get points for the problem because i don't know what your sub-problem means now right even if it's a correct sub-problem and you do the rest of it right part of this class is about communication and if you're not communicating to us what this thing is doing it's really difficult for you us to for us for you to convince us that your algorithm is correct right so you really want to in words describe what the output of your sub problem is what will the memo return to me and how those return values depend on the inputs right the parameters of your sub problem right so that's what in words describe what a sub problem means so that's that's going to be a really important thing for you not to forget on a quiz then when making sub problems often what we're doing is we're recursing on different values of indices in a sequence or numbers in your problem right that's kind of what we got to in the last in lecture 18 i guess uh when we were talking about expanding subproblems based on an integer in a problem now actually an integer in our problem is the number of things in a sequence right and so really those indices are integers in our problem that we're looping over except those integers happen to be the size of our subproblem whereas other integers might be larger which is why you might get a pseudo-polynomial time bound okay but in general when i have a sequence of things that i might want to dynamic program over common choices for sub-problems are preface prefixes or suffixes if i can kind of locally figure out to do with one what to do with one item and then recurse or if i can't kind of localize it by one choice on one side if i have to make a choice in the middle or i have to make a choice on both ends then you might want to use sub right so basically contiguous subsequences of your sequence because you might need that flexibility when recursing downward if you need to take something from both the front and the back for example right and really what's the difference between prefixes and suffixes not much okay we've been concentrating on suffixes in this class because in some sense it's easier to think about what am i doing with the first thing in my sequence or my you know suffix and then i can recurse on what happens later now in actuality when you're doing this say bottom up right the actual computation that is evaluated first is where in that sequence right i may be calling at the top level what happens to my first element but i'll actually deal with that first element last right because i will recursively solve everything below me right in front of me before i figure out what to do with this thing right so in actuality when i'm solving uh my recursion i will start at the end bottom up right because that's my base case and then i'll work my way back to the front whereas with prefixes you look at it the other way what do i'm doing with my last element right if i look at what i'm doing at the last time i recurse on a prefix on the stuff that's before me and then when i do bottom up i start from the front and work my way up right it's just it's two different sides of the same coin and usually these are interchangeable we've been doing it suffix wise because uh when starting to learn dynamic programming it's it's a lot we read things from left to right and things like that it's a lot easier to figure out what's happening with the first thing and move forward conceptually it's actually exactly the same thing i could just flip my sequence do the exact same thing with prefixes it would be the exact same dynamic program right so there's these things are interchangeable it's just it's really useful when learning into dynamic program to be able to switch back and forth between these things we'll be working on suffixes today on the problems that we do but these are interchangeable and sometimes it's useful to be able to conceptually think about it in both directions okay so aside from dealing with subsequences of sequences in particular contiguous ones uh we also often multiply our subsets uh across multiple inputs like if we have uh multiple sequences we might take indices in each one of them to represent prefixes or suffixes and then we might have to remember additional information by maintaining some auxiliary information like am i trying to maximize or minimize my sum in a or evaluated expression in an arithmetic parenthesization or is it player one's turn or players two turn right uh or which finger where where was my finger in when i was playing piano or something like that right those are the kinds of things that we might expand our state on and in particular we might expand our state based on the numbers in our problem if we're trying to for example keep track of how much space is left in a knapsack or something like that right but in general if i'm trying to uh say pack a set of things it's useful to know how much space i have left to pack okay so that's subproblems this is really the key part about dynamic programming is the recursive part this is what makes it hard is choosing a set of sub problems and it's often you build sub problems to fit well with a relation so usually the building what these sub problems are is usual usually closely coupled with the next step which is relating the sub problems recursively and if i relate recursively i usually what i want is an expression a mathematical expression relating the uh definition of a of a sub problem you had in the previous section relating those in math terms to the other things this is it's really important that you write this in math because it needs to be precise to communicate this thing well now you can write it in words but i would suggest you write it as a mathematical expression because it's a lot more concise for us to see what's happening in your recursion so relate them recursively basically i'm going to write say that x of some set of parameters equals some function usually a maximization or a minimization or a summation or an or or an and or some some other combinator of a bunch of choices that you might make right so uh or a bunch of sub-problems that you might recurse on basically you're going to depend on some other sub-problems that are smaller in some sense now actually embedded in this the idea of a smaller sub problem isn't really well defined yet right we haven't told you an ordering of these sub-problems to be smaller but that's what's going to come in the third step right so kind of a strategy for figuring out what these recursive relations might be is to identify some question about the subproblem solution right uh what do i do with the first character in this string or um you know which cage do i put this tiger in right to to figure out what sub problem should i recurse on later i don't know the answer to that question but if i knew the answer to that question then i could recurse on a smaller sub problem because i've figured out what to do with that tiger right and so it will let me reduce to smaller subproblems and then what dynamic programming does is because i only have a polynomial number of sub-problems and i've assumed i've already computed what those those are i've already already memorized memoized what the solutions to those sub-problems are then i can just locally brute force over all the possible answers to that question and that's just one way to look at dynamic programming okay so then as we were talking about topological order arguing that relation is a cyclic essentially just defining what smaller means when we say we're recursing on smaller sub-problems what a smaller mean usually you're saying that some index or some parameter of my sub-problem decrease always decreases or increases sometimes that's not always the case some sometimes you have to maybe add a couple indices and see that that always increases because one may stay the same while the other increases or something like that but in general as long as you argue that the relations are acyclic then the subproblem graph is a dag and you can compute in a bottom-up manner and you don't get infinite loops in your recursion right okay the last thing uh the last couple things are kind of bookkeeping but if you don't write these on your exam we can't give you points for them so write these down uh base cases if if you don't tell us base cases then your algorithm cannot be polynomial time it can't even be pi finite time because your algorithm never stops right it just continues to recurse forever and ever and ever and so it's hard to give us points i mean we will give you some points if your sub problems in relation are correct but really if you write code without a base case it's going to be wrong right so base cases are really important basically for any anything at the bounds of your computation wherever your recursive relation would essentially go outside the bounds of your memo right let's say i'm i'm dealing with a subsequence and at some point i'm trying to point to a state where i have zero or negative elements in my sequence that's probably a bad thing and so i want to define how to compute those things in constant time so that my algorithm can terminate when it gets to one of those you know base cases so for it's really important that you cover all of those possible leaf locations where you want to be able to return in constant time and we'll we'll do some of that today uh state solutions for all reachable independent sub-problems where the relation breaks down essentially i would be going outside the bounds of my my thing or you know anything where like maybe if you've got one item left you might say well i have no choice on what to do with that item i have to pick it or something like that okay then for your original problem you show how to compute solution to the original problem from the solutions of your sub-problems so uh so that usually this is just here's a sub-problem it's the one that used all of the things and that's going to be my answer right that's not always the case right sometimes like in a longest increasing subsequence we had to take a max over all of our sub problems that we computed or max sub array sum we also had to do that right uh but uh but in general the output to our subproblems wants to be some scalar value that we're trying to optimize or a boolean or something like that right it's how we maximize or minimize uh what we're doing we're not storing the entire sequence of how we got there because there could be an exponential number of possible subsequences that got there that's the whole point of dynamic programming we're kind of isolating the complexity of one sub problem down to a single number right but in a lot of problems we might want to reconstruct say the placement of tigers into cages and not just uh how what's the minimum discomfort over all tigers or something like that right like you add in your problem set right so i actually want to know where to put tigers into cages and to do that every time i maximize a sub problem i can remember which sub problem or sub problems i depended on just like storing parent pointers in shortest paths and then using those parent pointers i can just walk back in my subproblem graph and and figure out which uh path to a base case lead led me to an optimal solution okay and then the last thing is analyzing running time generally you're just summing the work done by each sub problem because the assumption is you're calculating all of the sub problems you described to me uh and but but if the work per subproblem is bounded by the same value you can just multiply it out right so that's that's generally a a weaker bound but usually asymptotically equivalent to the stronger uh notion on the left uh and and that's basically how you do running time usually it's enough to how do i define to determine how many sub problems i have well i look at the possible values of each of my parameters and then i multiply those numbers together right a lot of people will maybe say oh i add them together no because i'm able to choose each of these independently and so i multiply those things together and then the the work done by each sum problem is usually the size of the thing i'm maximizing over or minimizing over or summing in my relation right it's going to be the size of that the branching that i have the number of sub problems i depend on and so the number of subproblems you probably look at your sub problem statement definition to find the work done by each subproblem you look at your recursive relation okay so with that we've got this really nice framework and we're going to use it to solve some practice problems happy days and these are a little bit longer in terms of uh description than our previous quiz 2 review so uh i'm going to go ahead and read them out for you this one's a little shorter okay tiffany bannon stumbles upon a lottery chart dropped by a time traveler from the future which lists winning lottery numbers and positive integer cash payouts for the next n days anyone get the reference here tiffany bannon biff tannen from uh some back to the future thing okay so this was actually i think it's the second back to the future movie where this happens um anyway tiffany wants to use this information to make money because she knows the future about the lottery but is worried that if she plays winning numbers every day lottery organizers will get suspicious and shut her down right so the idea here is maybe it's still suspicious but decides to play the lottery infrequently at most twice in any seven day period but an issue well she'll win right but uh it's infrequent enough that eh maybe that's by chance maybe not describe a linear time algorithm to determine the maximum amount of lottery winnings tiff tiffany can win in the next n days by playing the lottery infrequently now this was a particularly difficult type of pset uh or first pset on dynamic programming problem but let's try to do it together so this is problem one i'm gonna just call it lotto okay so how can we deal with subproblems here well i might wanna think about what do i do on the first day am i going to play the lottery or not and then recurse on the rest that sounds good right so some i might have something like uh well let's say that l of i is the uh winnings on day i this is kind of just like i this doesn't define me some notation on what the cash payouts are and so i'm making a variable to do that and for the sake of what's written down on my sheet i'm going to assume that these is one indexed i don't know why okay okay so i have days one to n i know what their lottery payouts are so i might when i'm doing my sort bot stuff i have sub problems right what i might want to do is see what happens on day one and recurse on what's later so i might have something like x of i is max winnings uh for i guess possible for days i to n okay anyone have a problem with this type of sub problem let's see let's kind of see what this type of sub problem would lead me to i can either in my relate step what are my choices i can either play on day i or i cannot play on day i right if i i'm i'm trying to maximize this thing maximize either if i play on day i get l i and then i can recurse on the remainder or i don't play on l i and i recurse on the remainder anyone like this recurrence why don't we like this recurrence i'm just always going to pick this thing these things are always positive i think it's just positive integer payouts yeah and so i'm always going to pick li and the problem here is that it's not obeying or dealing with this condition that i have which is i'm only allowed to play twice a week or not not quite twice a week it's not a fixed week-long period it's within any consecutive seven-day period which is a little confusing how can i remember what days i'm allowed to pick later on it seems a little daunting okay in a sense for me to know right like this is max winning possible for days i to n but in some sense it depends on which days i picked before right because if i picked i minus one right i can't pick another day for another six days right if i have uh right so i have let's do this precisely this is i minus one right i have seven day period one two three four five six seven right if i uh played the lottery here and i played the lottery here then i'm not allowed to play the lottery here i'm not allowed to play here not allowed to play here not allowed to play here not allowed to play here i am allowed to play here right so this is i plus 1 plus 2 plus 3 plus 4 plus 5 plus 6 i plus 6. so depending on what happened before me i might not be able to play until day i plus six but if i haven't played until since like way back here i could potentially play the next guy i don't actually know which of these i can play on next in some sense i need to remember which days i'm allowed to play on next and i want to be able to jet like at the beginning i have no restrictions i can i can just play on this guy next even if i if i played there but in general i need i i will be restricted in some way between being able to play on this guy and being able to play on this one guy and so what i'm going to do is i'm going to generalize my sub problems by storing additional information so that i can rely on that information when i look into the future and recurse okay so instead of uh i'm going to in some sense need to remember two days right where was the last two places i played i'm going to simplify that a little bit by saying that this sub problem max winnings possible for days i to n i'm going to say that i have to play on day i okay similar restriction as longest increasing subsequence right i'm definitely including this in my subsequence that's just going to make it easier for me to be like oh i definitely know i played on this day right it's going to be make it easier for my thinking so assuming play on day i and actually i need to remember what's the next day i can play okay so i'm going to expand this sub problem by another i guess this is a j okay assuming i play on day i and i'm allowed to play uh i guessed and next allowable play on day i plus j for what are my possible range of days for jay i can either play the next day but i never restricted past day i plus six right because the things before me further to the right because i haven't dealt with them yet right so i only have to deal with this from one to six well this is nice because it expanded my sub problems by a constant number right so i actually didn't lose anything asymptotically by remembering this information but i'm kind of i'm able to remember all the things that could have happened before me i compress it into this one number okay so now let's rewrite our relation i'm actually going to go ahead and use some more board space because i think that's easier than erasing all right so we're looking at my relation this is a pretty complicated relation but what's happening now now uh i'm assuming i play on day i that actually simplifies things a little bit because no matter what i get the winnings on day i okay now when i call this sub problem i better make sure that it's okay that i played on day i but that's that's for my caller right i am locally allowed to play on day i am playing on day out right that's the definition of my sub problem so x of i is i'm going to maximize over some choice right max of i guess i have l i no matter what so this could actually come out of my max and then i'm going to choose what am i choosing here i'm not choosing whether i'm playing on day i i'm choosing what my next day i play is so that then i can recurse on that sub problem so what day can i play on well i'm kind of restricted by this j parameter that i didn't add into my sub problem on what possible days i can play next right i'm going to split that into a kind of compress that into one thing so x i can play on i have a choice of the next day i play somewhere between j which is my next allowable play and sometime in the future right so i plus k this is going to be my loop that i'm looping over in terms of my max and then what am i restricted on in my play right it depends on how far i am from i right so if i'm here this is i if i choose k to be the next day i can't play for many many times so like the sub problem i'm going to rehearse on is uh this is i plus k i'm going to recurse on i plus k but i'm not able to j needs to be the max it can be right because i can't play uh until i plus six right so this i plus k plus six is going to be my thing so let's see so i'm going to put let's see if i can unpack what i wrote down here max of 1 7 minus k yuck oh i'll put it here 1 7 minus k okay if i if i pick k i'm not aggressive as toward these boards as justin is um okay so if i get if i pick a way down here right they're not restricted at all right and so the the most permissive option i have here is one right so i definitely can't be worse than one right but if i pick uh and then this needs to be some number between six and one right and so i can just check the other bound right if this is the most restrictive right then this should be uh six right so when k equals one this should be six and it decreases every time further back or further forward i choose this k right so that's what my sub problem is going to be and i'm choosing over k in uh from j j uh sorry i plus j so sorry j thank you until what that's the question until what do i have to loop over n if i loop over and i'm going to get a quadratic running time which is worse than what i'm allowed to do the assumption is that i only have to check a constant number of these and why might that be any ideas let's say i'm got my sub problem i'm recursing i've got i yeah i don't know where j is j is somewhere over here one two three maybe it's four or something like that let's say i pick some k down here what is this this is i plus so this is j is 4 5 6 7 8 9 10 11 12 13 14 15 15 way over here like two weeks later is it ever optimal for me to do that why not yeah i could play the lotto in the middle here right right i'm i'm within seven like from here to there that's a seven where i only played once and from here to here that's a seven day period where i only played once right so it's going to be more these are positive values so it's going to be more optimal for me to choose something in here to play right so how far i mean i could just use that would satisfy right because i've already argued to you that it's never optimal to i can check this it's not going to be optimal it's going to be more optimal to play sometime over here right but how far do i have to check well maybe i have to check up to seven does that work not quite so let's say i played here and i played here and i played here and i played here right i actually can't play here here here here here right i'm not allowed to play those i guess these should be o's i played there and i'm not allowed to play here one two three four five right but i am allowed to play anywhere in here so i basically want to shrink this until these x's collide with each other because then it it's possible that an optimal solution would require me to pick these two and then require me to pick these two way over there right so this is 10 things in the middle i only have to go up to at most 11. okay it's 11. now you could use any constant above 11 and get the same running time bound but that's that's my analysis okay so we have our recursive relation uh and so what am i doing i'm just looping over my choices of next day to play i'm recursing on this thing where i actually do play on that day right but i'm remembering the information about what i'm allowed to play next by limiting based on what my previous value was okay so that's the kind of key thing i'm remembering something further in advance or i'm remembering what happened in the past by describing it as a restriction of something in the future okay so this was a pretty difficult problem i think it was one of our first dynamic programming problems on that term it was probably a little ambitious okay yeah yes the recurrence goes up to 11 not ten eleven okay uh so we have our topological sort what's a topological sort for these subproblems anybody k is always going to be a positive number right because j goes from 1 to 6. so i'm always going to be increasing in this first quantity right so for x of i j i always uh or sorry depends on strictly larger i right so this i when i call subproblems it always calls subproblems with a larger eye now this is a little weird because i wanted me to depend on smaller sub problems smaller now it is smaller because i'm taking a smaller suffix but it's corresponding to using a larger number to me that's a little confusing but that's okay because we're kind of using things that are always monotonically going in some direction so this is corresponding to a smaller sub problem in some some measure right it's the number of elements that we're actually recursing on in some sense if we wrote this as a prefix we would have us depending on strictly smaller i and that would be more natural in terms of a recursing on smaller sub-problems but i digress okay all right then we have our original subproblem i'm gonna i can't move this board i'll just keep going because we have lots of boards okay our original subproblem now what could i do i have to start somewhere right here my sub problems assume that i'm starting at i but i don't know where i start i could start by taking the first element but i might not so i could just take the max over all you know i overall i of x i what the first one i'm not restricted on what i choose next so what's the most permissive version of jay one right i'm allowed to take the next today right so if i just take the max over all of these sub problems i'll get the solution now actually this is a little bit more work than i need this is looping over all n right it's definitely correct right because i have to start somewhere but will i ever start after the first i don't know seven no right so i could just take this max over the first some constant number and that would be fine but that's okay this is still smaller than the number of subproblems that we have yeah if i were being lazy during my exam and i looked over jay would that be correct if i looped over j for every possible thing took took the loop over this and j yeah that would still be fine why not it's just less it's it's it's more restrictive of sub problems it will never be better to do that but you could do that because it wouldn't change your running time uh could it change my running time if my j accidentally moved too far well j is restricted to be one to six so i'm not i i don't i don't think so but in a different problem in a different context it could okay so that's the original and then time here what do we got we have a linear number of subproblems number of sub problems we've got uh i actually like usually saying exactly how many subproblems i have oh we didn't do base case i missed bot i missed my b we'll do the original first and then the base case okay base case what do we have is our base case here well when i don't have anything to do right if i'm and actually if i have this situation for i equals say n right i've got my last thing i could potentially start looping over sub problems that are negative in terms of my index i'm not going to want to do that there's a couple ways i can deal with that i could set a value for all of my sub problems for negative ah that's one thing i could do but then i have to kind of remember or i have to figure out how far i go into the negative right that's one thing i could do and i give a base case for each of those cases i don't have anything so i get like a i don't know uh zero value for playing in the future right because i have negative things i can't do anything with that another way of handling that which i think i did in my solutions was restrict that k to only be i guess and restrict that i plus k is less than or equal to n and then i'll never go to negative sub problems i'll never a curse on these things but that means that when i call this on n right when i only have one lottery day left this set will be empty so what's the max over that thing max over an empty set i don't know i mean i could add on zero here that's one way i could do it or i could just say when i'm at n and that thing is empty right or you know whenever it's empty right we can say the base case x i j i guess we could put this at n equals zero or sorry equals l of i right l of n thank you because at the last guy i have to use ln so there it is right now in actuality if you write this correctly right i put the li outside and i union this with a zero i can actually get away with just having the relation and no base case because my relation actually reduces to a base case because i of the way that i wrote my relation but in general you'll want to write some kind of base case here to either acknowledge that your relation handles it or being specific about what happens when i can't do any more work right right so and the last thing time we've got n sub problems exactly times constant work per sub problem because i'm looping over 11 possible values actually it's up to 11 right because j could be six so this is order n work total okay so this is a pretty daunting first problem but what in in terms of what uh uh eric professor domain was talking about last uh lecture uh in terms of categorization of subproblem or categorization of azation of dynamic programs what do we got we've got a suffix subproblem where we expanded by some local information right remembering how uh when's the next time i can i can play so that's kind of a categorization of these sub problems the recurrence relation has constant branching but more than like two branching right and uh i'm combining a bunch of sub problems right in my original evaluation right and if i wanted to figure out what days tif should play on the lottery you can store parent pointers when i'm do evaluating this max right i figure out which subproblem x i recursed that gave me the max and i can walk back to see which choices i made to figure out which days i played the lottery does that make sense so any questions on problem one that's the most that was i i want to have the most complicated one first so that we could have an easier way to go in in a sense this is the most complicated version of this kind of actually pretty simple dynamic programming setup why do i say simple dynamic programming setup it's just suffixes and i'm just doing a constant amount of work local to me it's just a very complicated local setup okay but that's what i mean by simple when we're designing subproblems this is one that we could i mean when we're designing problems for this dynamic programming setup it's one of the hardest from a it's one of the easiest from a conceptual standpoint but one of the hardest to actually implement okay so problem two this one's a longing okay a wealthy family alice bob and their young son charlie are sailing around the world when they encounter a massive storm charlie is thrown overboard presumed drowned okay this is very colorful language for these problem set writers twenty years later a man comes to alice and bob claiming to be charlie having maybe been marooned on an island for that long okay alice and bob are excited but skeptical and they order a dna matching test from the genetic testing company 46 and the uh given alice and sorry given three length n dna sequences basically strings of cgta or something like that from each of alice bob and charlie the testing center will determine three uh their answer accessory as follows if charlie's dna can be partitioned into two not necessarily contiguous subsequences of equal length so basically i take i can take the if i have n is a length five right or at length six it's better be even i need to find three characters in order and then the other three characters must match to make some sub strings in some subsequences in alice and bob's dna okay so uh there's that's a little hard to parse so let's look at an example here for example alice's dna is aat bob's dna is ccgg if charlie's dna were c-a-t-g they'd be matched right because c g is a sub-sequence of charlie's dna and is a subsequence of bob's uh ba bob's dna and a t is a subsequence of charlie's dna and is also a subsequence of alice's dna and so we've partitioned them into two equal length subsequences these are not necessarily consecutive subsequences but just any subsequences such that uh that that uh they appear in alice and bob but if charlie would be found to be an imposter if his dna sequence were a g t c essentially it's easy to to realize that because g and c are swapped in terms of their ordering and g c the letters gc only appear in bob's dna and don't appear in that order right so it's easy to see that he's an imposter with these strings but you can imagine with longer strings this could be difficult to solve right so we want an n to the fourth time algorithm to determine whether charlie is a fraud okay so i actually shortened this last night this was like twice as long on the problem set so yeah anyway so how do we approach this problem yes no they don't have to be contiguous like in the example it would be matched if c and g is a subsequence not contiguous of c a t g yeah so that's an important part of this problem i'm just i'm not trying to figure out if there's basically there are only two sub contiguous subsequences of length 2n that this thing can be partitioned and i just look in the middle no we're looking for subsequences not sub strings so they kind of interleave like this in some way and there's actually a number of different ways i can partition that there's actually an exponential number of ways so that's a problem potentially yes is there a biological basis no there's no biological basis to this thing that i know of okay all right so how do we solve this problem what problem does this look like i mean it seems like string matching right so i might want to think it's something like longest common subsequence right but here i have three sequences instead of two sequences and we've got this other weird condition where we kind of need an exact partition of charlie right i need to use all of the letters in charlie but i don't have to use all of the letters in alice and bob right so let's just let's get some notation here you know a b and c are n length strings right so what could i do let's define some sub sub problems if i were to go via longest common subsequence i might keep track of an index of a suffix or prefix of each one of these strings right that kind of makes sense something like i j k where we're talking about the suffixes uh sorry that's prefixes i b j and c k right that seems reasonable at least right it's it's what we would do for longest common subsequence what's the problem here i mean i could match this guy with one of these guys or decide to skip it and match one of these guys and decide to skip it but if i do that i might get a subsequence but actually i always need to match all of c does that make sense always need to match all of c right so in a sense let's see let's see how can i do this uh i need to match all of c but i also need to make sure i'm using exactly n over two characters from c in blue and exactly n over two characters from c in a does that make sense how can i satisfy that condition now i understand why i used prefixes before and i swapped it to suffixes here but we'll make it work how can i remember how many characters i assigned from alice versus bob right as i'm matching characters in alice and bob i need to kind of remember where they point to or how many i've already used in in charlie so that i can give you up the remainder right in here oh actually this works in a different sense there's like 18 different ways we could do this so okay so i need to remember how many i've already used up so that i can be sure to allocate exactly that many characters in the future to either alice or bob right so how can i remember that i can just remember how many do i i'll do it the way that i did it before which is i can remember i can remember two different things here i can remember how many things i have left to match in alice in c where i can remember how many things i've already matched nc to alice okay if i talk about how many things i've already matched then i can index this thing by the sum of those things if i talk about how many things i have yet to match i have to do like n minus the things okay so those are the different parameters we can do we'll do what's in my notes and i'll try to fix it okay so what we're going to do is remember or figure out how many things i'm still needing to match in c to alice and bob right so i'm going to call this k sorry k i i is associated with a and b is associated with j and k j okay this is going to be the i have to write this down well okay so this is going to be what kind of output do i want to my sub problem i just want to know if these things are if he's a fraud or not so this is going to be a boolean right so true if can match k i length sub sequence of suffix a suffix is this guy and length uh kj i guess kj length subsequence of suffix b j i or bj suffix right uh to all characters in and now what is this in this is the hard part do i need a separate index for c to know where i am and see in a sense yes i need to know where i am in c how much i have to match right but if i need to match k i to kj to all of them then there better be ki plus j things left in c right so i in a sense i don't need to remember that information again it's not independent to my other parameters i can compute it right i can throw it in but i can determine it from the other parameters right so i want to match it with the suffix of c of length k i plus k j so i think this is the only part that is going to be annoying to me okay so this should be suffix of all of the things minus k i minus kj minus 1. it's just this and why is that okay if i've matched everything k i and kj are both zero and i should have nothing in c which should be n colon okay we're zero index yes we are i use whenever i use python notation i better be zero index okay does this make sense as a sub problem i mean it's confusing but hopefully it makes sense right what i'm going to try to do is i'm going to match some number of characters in this subfix which is hopefully longer than kj ki right otherwise it's i'm going to be in a base case where this is impossible right and some subsequence of this matched completely into this all right so that's those are my sub problems i'm going to try to relate them now we have x i j k i k j what is this going to equal all right well we've got booleans so this is and false otherwise okay that's it's a problem right so i just need some sub problem i recurse on to be true so what's the combinator for sum of a bunch of choices boolean cases any one of which may be true i want to combine a bunch of them i just want to see if any of them are true i'm going to or over them okay and i'm going to or over four choices okay what are my choices either the the first thing in a matches with c the first thing in b matches with c or i don't match with either right so those are my four tropes so if i match with a i plus one i recurse on a smaller suffix of a and a by adding oh this all just works great kj this is i if a i equals c i and a i is greater than zero right so if k i is greater than zero i need to match an i right so this this conditional doesn't even make sense unless i've evaluated this k i to be bigger than zero otherwise i'm trying to access i of n right so i'm just putting this conditional on there same with matching b i j plus one k i k j plus one if sorry this should be minus one i'm i have fewer characters that i have to recurse on so that's a typo in my notes uh b j equals c oh this is not ci what is this it's whatever that thing is so i'm going to just say question mark and kj is greater than 0. so i'll fill that in in the notes it's going to be some complicated expression that looks like that okay it's exactly that expression yes that it is so it's it's that thing okay then we have two more choices either i if i if i didn't match a i i may match bj in the future so i only want to reduce ai so x i plus 1 i leave everything else the same assuming if i less than n right i don't want to move off the end of this thing or x i j plus 1 k i kj if j is less than n okay so those are my four choices if i match the letter i'm great otherwise i decrease the size of my sub problem and i recurse okay so fun recursion topological sort right these subproblems only depend on what larger i not quite larger j not quite changing k or d don't even change here so we're going to use depend on larger i guess strictly that's kind of an important thing i plus j right because at least one of these two things is increasing and then the nice thing about that is it kind of tells us when we should stop right we should stop when either i or j get to n we should know enough at that point to be able to determine if we succeeded or not possible so we have our base case what's the easy base case when we succeeded when have we succeeded if we have nothing left in a and b and we have nothing left in c right i have nothing left to match so i have n n and i don't need to match anything else that's just going to be true right all roads point to this sub problem to get to a true solution right otherwise we have some false space cases if you set us as something up like this and you only give us a base case that's true and you're oring over the things your answer will always be true so you're not having any discriminatory power at all if you give us a true base case you better be giving us some false base cases or one at least so in the case where the first one is n and we have some i kj this is going to be false if what if we have nothing left in a i or i o but this guy is positive we got problems right otherwise this thing is zero and we'll just try to match everything up here and eventually we'll get down to this base case or something where this thing goes to zero and we've got a problem it's the same goes for the other side as well if we run out of things in b when the number of things we need to match in b is greater than zero okay so those are our base cases the original problem is what yeah it's just gonna be one of our sub problems n n and then n over two and n over two right i'm trying to match half of the things in c with half of the things right zero thank you uh because we're zero index yes again that's switching from prefix suffixes in the middle was fun so anyway and it better be the case that n is two or else it's obviously false or it is even or else this is obviously false okay and then the last thing which i'm not going to write down is we have a constant work here right because i'm just checking the value of four sub-problems and a conditional for each and i have how many sub problems i loops over n j loops over n k and k j loop over n over two so i get a quartic number of sub problems cortic running time as desired okay so i'm not going to write that down because i'm quite a bit late i'm probably going to do just do one more problem which is sad because the last one is about gokimonpo which is a fun fun problem gokimonpo basically relies on i'm trying to catch a bunch of pocket monsters just monsters i think is in this and you can either go to a location and catch that monster for free but that costs money because i have to ride share there okay or i don't have to go to that location and i buy it on my in in-app purchase but that cost me a different amount of money okay but buying it and i mean at purchase kept me at the location i was previously wherever i was and so the the point of that problem is i need to remember where i was last so that i know how far i need to travel to get to my next monster okay so that's going to be the last one that i'm not going to be able to get to number three is a problem about tapas okay so these all come from spring 18. 18 the first two came from a problem set uh these next two come from the final exam that year okay albert ratkins uh he's on a diet uh but he has a dinner at an upscale tapas bar where he got many he's going to order many small plates okay there are n plates of food on the menu where you know each plate has a certain information it has a volume a number of calories in that dish and a sweetness label basically zero or one whether it's sweet or not okay but he's on a diet and he wants to eat no more than k calories during his meal but wants to fill his stomach as much as possible because he wants to feel full right so he wants to maximize the volume that he fills even though he wants to reduce the number of calories like keep restrict the number of calories okay he also wants to order exactly s sweet plates okay so we've got this other condition where i need to make sure i'm eating a certain number of sweet plates it might be useful for me to remember how many sweet plates i've already eaten so i make sure that i eat that number okay without purchasing the same dish twice okay so here's a condition that's similar to the knapsack 0-1 problem versus a knapsack kind of general problem am i allowed to take more than one of these things or not here it's a restriction that i'm not allowed to take a plate more than once okay and i'm going to try to describe a order n k s time algorithm to find the maximum volume of food obert can eat given his diet okay so first thing i'm going to note here is the the one of the things that we talked about at the last dynamic programming lecture was is this a polynomial running time that it's asking me for right actually on your problem set eight you were asked on each problem to categorize whether the running time of your algorithm was polynomial or not and actually you don't have to solve the problem in order to answer that question if we give you the running time right if we give you the running time you can just take a look at that running time and be like oh is that polynomial in the size of my input and here it's is it all the ones previously were this one was the order n that was an order n squared because n was the number of things in my input the number of words it took to give you that input here what do i have i have a triple of numbers for each plate there are n of them so n is polynomial s is polynomial because s is smaller than n and it's positive number but k k is just some number in my input right is representable in potentially one word that's the assumption but it could have exponential size depending on the size of my word of my machine i don't know how big k is relative to n and so this is a pseudo-polynomial running time okay because k is just a number in my problem similar to subset sum similar to knapsack which you guys did in lecture and recitation and so if we ask you on an exam which we probably will whether certain running times are polynomial or not that's the logic that you go about it how big is my input what is my running time that i'm trying to evaluate and can i bound each of those terms in terms of the size of my input if not then you say it's pseudopolynomial okay all right so let's try to tackle this problem now already because we've got pseudopolynomial uh you're thinking maybe this is going to be knapsack-like or subset some like okay what do i need to i'm just going to go straight for sub problems here uh actually i should probably say what my things are meh this is fine i gave notation up there didn't i okay so we're gonna have sub problems i'm gonna i want to maximize the number the volume of food so that should probably be the output of my sub problem the max volume on some subset of dishes right i'm going to choose suffixes here i and some other stuff is going to be max volume of food possible uh for plates p i to p n i'm gonna assume one index here because why not but do i need to remember information along the way yeah just like with subset sum or knapsack i need i have this calorie limit right so it's going to be really useful for me to know how many calories i've already eaten or how many calories i have left in my budget right so let's say j uh using at most j calories right from the remaining dishes and i need to make sure that i'm eating exactly some number of sweet plates in the future and i need to remember as i eat a sweet plate the number of sweet plates i need to eat decreases and so i want to generalize that i'm going to put an s prime here to denote eating exactly s sweet plates okay so that's my sub problem let's i've got tons of board space i'm going to go ahead and use it relation we've got x i j s prime equals okay i'm trying to maximize volume probably i want to be maximizing over something right this combinator is kind of what i like to call it right usually what you're doing in dynamic programming is making some kind of choice or common combining combinating combining some number of sub problems and choosing which one's the best right if you don't if you just list a bunch of options here and don't tell us how to combine them that's going to be a problem because we don't know what your dynamic program is doing at all so it's really useful for you to be able to tell us how you're combining your sub problems here we're doing a maximization over the different volumes possible if we decide to eat the plate i then we get v i in volume we fill our tummies with vi and volume but then we have to recurse on using one fewer plate because we can't use that plate again and we've decreased the amount of calories in our budget and i'm going to say s prime minus s i because s i is one if it's sweet and zero if it's not so it's kind of nice that they kind of gave us this notation here i can just subtract it off if it's there i don't have to do this conditional or something and i don't ever want to go below these budgets so i'm just going to say if uh c i is uh less than or equal to j and s i is less than or equal to s prime okay so that's going to make sure that i never have these guys go negative okay otherwise i don't eat the plate and that's kind of the easy case because i just go i plus 1 j s prime these things didn't change i just have one fewer thing left okay so i'm maximizing over these things this one's an always it's not in it right okay so i just have two choices and maximizing over them topological sort order here i'm always recursing on a thing with larger eye depends on larger eye so a cyclic happy okay base cases what's the good case i get to the end i've reached the end of my menu i can't look at any more plates i'm stuffed and i've already forbidden myself from going negative on the calories so that should be all good but what do i want on the third parameter zero i better a i better have eaten exactly uh s plates so i want to get down to x m plus one because i'm one indexed j for any j zero that's gonna be zero right i get no calories there but it's a good thing it's a good place it's fine zero is good all right this is uh done i don't know okay there's another base case right what's the bad base case i get to the end i'm always increasing i and so i better be doing something on n plus one i got to the end j again is going to always be non-negative because we we're always going to be in our in our calorie budget but if this is anything other than s prime greater than z or if it's anything but zero what is that going to be minus infinity right i never want to be in this situation if i do my dynamic program and i get a minus infinity up at the top that means there is no path to this subproblem here where i'm happy i'm always sad and so i return that the maximum value volume of food obert can eat and maintain his diet is not possible essentially there aren't s dishes sweet dishes in the thing whose calorie budget are below my limit right and that's probably an easier thing to check then in this bound okay so we have our original sub problems now solution is given by what just one of our sub problems right it's just seeing what's the maximum volume i don't have to retrace my steps to figure out my thing i just i say one of the sub problems it's using all of the things on my menu using my entire budget k and trying to get exactly s things that that's going to be my output to my algorithm and this takes what time how many sub problems do i have i have n plus one sub problems for this uh parameter i have a plus one possible things for this parameter and i have s plus one possible things for this parameter so i get order n k s sub problems sub problems how much work per sub problem just a max of two things so constant work per subproblem yields order n k s time total okay so those are three nice practice problems for you one two that are polynomial one that's pseudopolynomial you have one more example in there which is the goku non-mon po problem which is a fun problem it involves remembering additional information that's not an not really a pseudo polynomial number in your problem but it's the location of where i was last or uh where i was going okay so take a look at that problem uh is another a kind of non-trivial way of expanding sub-problems okay and with that good luck on your quiz 3.