all right well uh welcome to problem session five of 6006 it's a pleasure to see all your smiling faces here today uh this week we're going to cover some problems in graph theory related to death for search and breadth first search which were roughly the topics that i guess we've covered in the last couple lectures and what's going to be on your homework uh and i believe this is basically the homework from from last year uh with a few revisions uh based on some typos we cut oh and i caught a spelling mistake that i'll bother our instructor about later okay uh so without further ado let's get started i guess we'll just do them in order for lack of creativity here um the very first problem has to do with some measurements on a graph uh which is actually a really interesting one to me so it turns out that in a lot of research in for some reason in computer science there's graph theory research and then there's networks research and these are two different communities for weird historical reasons that i don't totally understand but people in the network science literature often measure things like the radius of a graph and some other kind of measures that are trying to tell you something about like is a graph a long spread out thing like a line graph or something super compact like a star and so on uh and so this problem is kind of digging into the algorithmic aspects of how we might compute one of the measurements that i believe is is fairly common in in that community uh so let's uh kind of go through these problems as usual in 6006 we like to take actually relatively straightforward computational problems and then dress them up with a lot of language to make it annoying for you guys to parse and indeed this problem is no exception to that uh so in this problem we're given an undirected graph uh and as usual we will call him g uh and we define a particular number that we're trying to measure in this in in this problem right so uh in particular uh right if we given a given a vertex v uh then we can define something called the eccentricity of v which is the distance to the farthest away uh thing so in particular um we can define um is going to be given by the following which is the max over all the possible i'll try to make sure my notation oops i've already oh that's okay uh over all the other vertices of the distance from uh v to w right uh so i'm like standing at a point on a graph and now i like you know make a loud noise and the last person to hear me uh the distance to him would be uh the the eccentricity of that vertex and so uh this is some kind of notion of like radius or diameter but sort of planted at a point and then if we want to learn a property not of a vertex but of the entire graph one thing we can do is to find the radius and that is given by r of g is uh the min over all of the different vertices u of the eccentricity of u okay so i think this is one of these definitions that's really annoying to parse and think about so we should like draw a little bit of a schematic and see what's what's going on here because uh especially as a geometry professor this one's kind of nice because it translates directly to what you might do in metric geometry so um let's say that i have a circle here and i want the world's most complicated way of defining its radius okay so for any given point there's a point in a circle that's a circle in case you're wondering you know those are those internet contests where like they have people that just walk up to the board and draw perfect circles and then leave i unfortunately am not an expert at this matter um but anyway so if we think of a point like a circle as some analog of our graph and then i draw a point which might be the analog of a vertex right then what is the eccentricity well it's the distance to the farthest away point right so for this guy it might be the length of this line roughly uh because that's the distance to the farthest away thing right so for every different point that i draw you know each point has its own farthest away point in the circle uh so there's some positive number that's assigned to every single point in this domain and if i take the minimum of that positive number where do you think i end up that's right jason i end up in the center of the circle because if i think about it the distance to the farthest away point in this domain um one thing you can convince yourself is that that's sort of as small as possible so this is what we might call a minimax problem in in optimization because we are minimizing the maximum distance yeah um this also shows up in game theory all kinds of different places that solve this stuff but thankfully in this particular problem we're not going to need all that okay so uh right so this homework problem has two parts um the first is to give an algorithm for computing the uh the radius of a graph and then the second one is to give an algorithm for approximating the radius of the graph uh really quickly or more quickly than the first part um i actually don't know if there's a lower bound there but come back to that later okay so in part a right we're given g and moreover we're given one additional piece of information which we actually do need in this problem i think it's one of those words that kind of slips past us when we read graph theory problems but it's important to pay attention of course and that is we're given g and it's connected i suppose really it should be given connected g but that's okay um now what we want is to compute the radius of g in time that looks like the product of the vertices the number of vertices oops times the number of edges or the number of edges times the number of vertices your instructor struggles to speak and write at the same time but it's a skill that i'm working on and frankly handwriting is much easier with this little chalk okay so essentially you know i used to have a math professor in college that use this phrase all the time that you know this is like it's important not to think here um you know the the problem asks you to compute the radius of a graph and in some sense there's an algorithm that just like writes itself for computing the radius right because the radius is the min over all the vertices of the eccentricity the eccentricity is the max distance so what would be the simplest thing to do here well in some sense it would be to loop over all the vertices compute their distance to all the other vertices and and and and take the max for each one of those and then the min over all of the guys in the outer loop since i just said a sentence that i'm realizing doesn't parse particularly well uh let's let's sort of write down what i mean um which is to say we're gonna think of there being an outer that's why we don't use this chalk an outer for loop uh which is computing this min right so right well what are we going to do we can you know compute the the shortest path distance to uh all of the other w uh in in my graph you know take the max of w of the distance from v to all the other w's obviously we can kind of do these two at the same time and then if this number is bigger than my current max keep it and or oh yikes if it's smaller than the current estimate i have of the uh the radius then i keep it and if it's not then i throw it away right so maybe i initialize you know my radius at infinity and now let's call this number i don't know little r if little r is less than big r then just keep it around right and so if we think about it i don't think it's terribly hard to prove that this algorithm is correct because it's sort of just taking our definition of what the radius of a graph is and translating it into um a brain dead algorithm um so i think really the the challenge here uh is is proving the the run time uh in in this particular algorithm so what does our runtime look like so we have a loop over vertices right so i kind of incur a factor of mod v here uh and then uh well our graph is unweighted so one strategy for computing the shortest path distance would be uh breath first search i think that's what's in my notes yep uh and in general breadth first search if you recall from lecture takes mod v plus mod e time so the question is okay so if i multiply these things together what do i get i get o of v times v plus e like that time but like uh oh that's not the time that my homework problem wanted right because the homework problem asks you to solve this in just mod v times e time and somehow we've incurred an extra factor and now we have to figure out why this is actually okay or we have to fix our algorithm but in this case uh it turns out that this runtime is just inaccurate okay um what's our intuition here well i i kind of underlined it for you here our graph is connected in particular there's going to be a nice property of connected grass which is that the number of edges dwarfs the number of vertices here so really if we have v plus e you know and sometimes it's going to look like a constant factor times e plus another e here so this whole thing is going to be v times e time yeah so let's let's make that argument a tiny bit more uh formal here so in particular we know that g is connected um right and every vertex so in particular what can happen here is okay unless my graph consists of one vertex which is a case you could dispose of pretty quickly what i can't have is a graph that looks like this like one vertex and then an edge floating around there everything has to be connected together connected together okay so in particular uh what this means is that every vertex is adjacent to at least one edge again except i guess technically the one vertex case but i think we can convince ourselves that for any graph of constant size we're we're not terribly worried about it right it's just the asymptotics that matter in this problem okay so if every vertex is adjacent to one edge well and remember that every edge kind of by definition of an edge is adjacent to two vertices then what we can conclude is that the number of vertices is less than or equal to the number of edges divided by two there's a conservative estimate and so in particular what does that mean it means that v is big o of e this is a case where we have to be quite careful about big o being an upper bound right uh in this case typically v is much less than e um well depends how many edges like if you have a really dense graph or not um but in this case what does that mean that means that mod v plus mod e is really just big o of mod e right because this is big o mari plus big o of e and that means that our problem really runs in v times e time uh which is what we wanted in our problem are there any questions from our audience on part part a here cool yes understand why uh where you went from the first statement to the second statement there every versus one edge implies v is less than or equal to e oh yeah so i guess i guess there's sort of two things that matter here right uh every vertex is adjacent to one edge at most and every edge uh yikes uh every edge uh is adjacent to two vertices um i guess actually it's the second one that matters so you you can never have a vertex just floating by itself so one way that i can count my number of vertices by looking at the number of edges and saying that well every edge can touch exactly two vertices every vertex has to touch exactly well at least one edge um so if you put those together you can convince yourself that this bound has to be true if you want to be conservative about it you can just get rid of the divided by two here i guess it doesn't really matter any other questions from our audience all right so now uh let's take a look at part b uh so in in in part b here uh they ask us to basically do the some version of the same thing right they want us to now approximate the radius but we're given a smaller budget of time so now what we want in number b here is uh compute an r star such that uh i got yelled at in my textbook that st apparently should always be subject to i got an angry review of the textbook i wrote because of that which was puzzling to me but amazon.com is not a great source of useful data but in any event we want our star which is sandwiched between the radius of g and two times the radius of g um like that now notice so in other words we want to the first thing to notice is we want to upper bound the radius of our graph and already this should suggest to us how we might solve this problem right because if we take a look back at our definition of radius over here notice that the radius is a min right so what's going to happen if i returned epsilon of some other vertex well it's lower bounded by the radius because the radius is the smallest possible epsilon over any vertex that makes sense now when i was doing this problem um because uh you know i'm the dumb instructor of the three i said well okay but like you know maybe i need to be like somehow judicious about what vertex i choose like you know well in some sense what this suggests is that maybe i choose some other vertex and compute its its radius and return that as our approximation but of course the problem wants me to sandwich it between two values here so in addition to uh you know upper bounding r i want to be less than two terms are in other words my approximation is within a constant factor um i tried some some weird stuff like farthest point sampling and so on then i realized that you actually don't really need to do any of that one thing you can do is literally choose any vertex return its uh eccentricity and that's actually good enough yeah so here's our algorithm um great let me go back to my notes here i don't know why i'm following my notes actually through the soft top head but they make me feel better if i'm looking at them at the same time so in particular what i'm going to do is choose a u and v let me be clear here any u and v so if i'm using some data structure to store all my vertices i just take the first one whatever and two i'm going to return r star is equal to epsilon of u um now of course this isn't really an algorithm if you do this on your homework you'll lose points and the reason is that i haven't told you how to compute this value here so if you were to write out your answer for this problem of course you should tell us that like really to compute epsilon what do i do i use breadth first search to compute the shortest path from u to all the other vertices and then i guess i take the the max value here okay so i think you guys can fill in the uh the details of the algorithm uh the bigger challenge is going to be to prove that this is actually a good bound right uh and so in other words what we need to prove here i don't know like there's a claim there's a proposition there's a theorem so we're like somewhere on that axis i'm going to call this one a claim i'm going to downgrade it and that is that the radius of my graph is less than or equal to r star which is less than or equal to two times the radius of my graph okay so let's uh let's prove this uh this thing managing to use all of my boards on one problem here okay so uh in particular to prove this claim i need to prove two inequalities this is like two homework problems in one uh so let's number those off there's one there's two okay so let's do inequality one i think we can squeeze him into a relatively small space so remember uh what is the radius of my graph well just by definition right we know that it's the min over all possible u of epsilon of u so in particular what's the nice property about the minimum of something is that it's less than everything else or equal so this maybe let's call this u naught just to distinguish between that and the notation i have on the left hand side this is less than or equal to epsilon of u because i don't know because min yeah uh so uh that actually already uh and of course this is exactly what we chose to be our star so our first part of our proof is done here yep so this is the easy part and sometimes like this is sort of what inspired our algorithm so we expect this bound to be kind of straightforward okay but the other half of the problem is a little more tricky uh and actually there's a solution in the notes and then i decided just to make it a little more inaccurate to write up my own um so uh but actually i have i have an ulterior motive which as i noticed in this class we don't tend to use a tiny piece of notation that i like so for my convenience and future problem sessions i thought i'd introduce it now so we're solving a minimization problem the nice thing is that in this class everything we do is finite if you take my graduate course that's not going to be the case in fact actually in lecture two we're going to do like variational calculus but uh in in this course uh what does that mean that means if i minimize a function there's actually a vertex in my graph that achieves that minimum right this is different than like for example if i then i'll shut up but like if i wanted to minimize you know here's f of x equals 1 over x and i ask you for the minimum value well it's you know overall x greater than or equal to zero well the minimum value is zero right if i take x off to infinity but it never quite crosses zero right so you're kind of in this weird universe if you remember jason's lecture he talked about imps and supes as opposed to min's and max's but this can't happen in our problem because when we compute a min there's actually a vertex that achieves it and that vertex we call argument okay and so this arg here stands for for argument so one thing that i can do is say okay so remember that my radius is the min the min overall u of u epsilon of u that i'm going to define a vertex u naught to be the argument over u of epsilon of u and this is just fancy notation for saying give me the actual vertex that makes this value as small as possible yep uh the nice thing about this problem is that we're not worried yet about i will make runtime so i can construct this kind of thing and not worry about how i actually found it right okay so let's say that we did that so this is find me the vertex um that actually gives me the radius right so in other words i find that vertex and then i find his or her farthest away vertex and measure the distance and that distance is the radius of my graph okay um so let's actually do that so in particular then i can define a second vertex v naught well how does the radius algorithm work i find the central guy and then i find the one that's farthest away so we're going to make him the arg max over all v in my graph of the distance starting at u to any v right so if i think about my circle it's a circle right then u naught is like that center of my circle and then v naught is like that far away point this is a schematic right my circle is really a graph in this problem but i think i think the analogy actually works okay but in reality my algorithm was brain dead i didn't actually compute u naught i computed i just randomly drew sorry i shouldn't use that word i arbitrarily drew a vertex u and then computed you know the farthest away distance from that guy uh and of course what we have to check is that that thing is within a factor of two of what i wanted so okay uh if i have u then i'm additionally gonna define one more thing called v and that uh mm-hmm oh boy uh okay so i'm noticing i'm saying one thing and i'm writing another u naught is the center of my graph i just i think i said it i just forgot to write it and then this v is the farthest away guy from him so basically the subscript zero here means like is the platonic ideal of what i wanted in my problem and no subscript is gonna mean the other one so now um i compute the farthest away thing from the u that i actually chose in my algorithm that's some v bar right so again remember my algorithm just says okay i'm going to like choose some other point v and then return v's distance to some farthest away point uh oh sorry choose another oh boy choose a point u and return his distance to some far away point v i think i've managed to lose everybody uh nodding together using fees here okay so why did i introduce all of this notation um because this is what's going on in this problem right to actually compute the radius i want to find the most central point u naught and its distance to its farthest away thing v naught in reality i arbitrarily chose a point u and i returned uh u's distance to some point v and i want to show that those two things are within a factor of two of each other okay that summary makes sense even if i talked in circles for a little while okay so let's actually do that so remember that uh the thing that i'm going to actually return is r star and that is equal to the distance from u to v now because i just made all these definitions and now i get to uh use my favorite inequality um in fact this is sort of the only inequality we know in this class so far i think which is the triangle inequality uh which says that of course this is less than or equal to the distance from u to u naught plus the distance from u not to v right so in other words this is saying the shortest path from u to v is always upper bounded from the length of the shortest path from u to u naught and then u naught to v right this is drawing a triangle aha but take a look what is the actual radius of my graph well in my notation the radius of my graph is exactly the distance from u naught to v naught and this thing is bigger than the distance from u naught to anything else by definition for all of e right so if i flip this inequality backward well take a look this is the distance from u naught to something this is the distance from u naught to something so i incur two factors of the radius and i get the bound that i wanted yep uh and so this is a slightly more formal proof of exactly the same thing that's in the homework notes okay so the one thing that's remaining is to actually show that our algorithm runs in a reasonable amount of time so i think they give us a budget of order e time but notice that argument is precisely the argument that we just made right here uh just minus the v factor and the v factor just came from looping over all the vertices in in part a uh so now i think we're we're done with problem one as usual i've wasted too much time on the easy problem all right any questions about uh about this one excellent well now that i've written too much uh let's uh do the rest of it i spent time on this problem because i like it it looks like a geometry problem okay so now uh let's see in problem two which i noticed that this homework is kind of full of prototypical 606 graph theory problems in general like they just go down the list of things that people typically do in graph theory that are like useful tricks to know so i would suggest the students in this class even if it's pass fail uh look very closely at this homework before doing uh the current one i think the ordering works out that they can do that um because i think you'll get some good hints for how to solve all the the the current homework uh so you hear you heard you heard it here first guys okay so in problem two uh we're talking about internet investigation uh so in particular uh mit has a bunch of different routers that are connected by cables uh to one another and essentially uh what are we given we're given a bunch of different routers and we're given the length of the cable in between them and the latency unsurprisingly is proportional to the length of the cable that in my abstract understanding of how computers work kind of makes sense to me i'm not sure that's actually true but um that's sort of immaterial for 606. i assume our department has a networks class if you're interested in that kind of thing uh and essentially uh what we're trying to do is sum up the latency over all of the uh the router so let's let's write down a little bit of notation here while i continue to dance all over the room here keep losing uh losing my chuck i need like a holster i feel like that would be useful for for the chalk bucket okay so now we're going to do problem 2 here so we're given our routers and some of them are marked as entry points uh and now we have a bunch of bi-directional wires wi each of which has length l i uh and that's a positive integer value here yep and uh actually because of this so technically i think a lot of students in this class have encountered weighted graphs before but if you think about the narrative of of this course i think for the version of this homework we haven't really encountered weighted graphs yet but a better way of putting it rather than psychologically diagnosing your instructors uh is is that what we're going to find is that they're often problems that look like they're weighted graph problems but they really aren't and and this is a nice example uh where that's the case okay uh so we define latency uh as follows that it's at least proportional to um the shortest uh path to an entry point and now we have two additional assumptions that we need right one is that the total latency uh or at least the latency of every vertex which is the same thing latency uh is less than infinity what is this really saying by the way like when would the latency be infinity it would only be infinity if i like took a pair of scissors and cut a wire and would just connect it from the rest of the network yes uh every router is connected to some entry point that's exactly like there's some path from every router to some entry point doesn't necessarily mean the entire graph is connected i guess um but at least that you can always get to an entry point uh and then moreover uh and this one's the the real kicker here uh that there's uh at most a hundred r uh feet of wire incidentally r stands for routers i had like the problem the previous problem in my head was thinking radius a long time um so don't be like your instructor and actually read the entire problem before getting hung up on it but in any event the thing that you're trying to do is to compute the sum over all of the routers uh i don't know are whatever of the latency of of that router okay so that's our our problem here incidentally this little goofy exercise i just did of taking this paragraph problem and kind of writing in bullet points i find helps me a lot when i'm trying to solve these algorithms problems because i think it's really easy to just get like thrown off by a wall of text here okay so this problem is screaming out graph theory like we're practically like using the terms here we are using the terms right like you've got nodes that are kind of like routers and maybe edges or kind of like wires but there's a bit of a catch which is that your runtime right at the end of the day i think you want order r run time that's where things get a little funky initially um and so we have to think a little bit carefully about how to do it and here's going to be the the trick so this is starting to look like a shortest path problem but what would you maybe not want to do would be to iterate over every single router or every single vertex and every single router and compute the shortest path between every single pair because if you did that oh boy i'm i'm confusing my terminology there are entry points which is the thing that i need to compute the distance to uh and i need to iterate over every single router and compute its distance maybe to all the entry points and then take the min or something like that but if i had a double for loop then i'm probably not going to get order our time right because somehow you expect it to look like something squared or like the product of two terms supposed to be a little more sneaky than that and we're going to use a sort of a canonical uh trick in graph theory okay so let's uh let's follow the the toucan sam approach here we're gonna follow our nose and say that okay there's basically a graph that's uh staring us in the face in this problem but then we're gonna have to make a little bit of an edit because we'd like to use the kind of linear looking time search uh that that bfs affords us but it looks like we have edge weights in our graph right because the wires are associated to uh lengths right different wires have different sizes but we have this nice fun fact which is of the total amount of wire and our whole universe is less than 100r i guess the units of this 100 are kind of weird right it's like feet per router or something but whatever okay uh so in particular uh i'm going to make a graph with a node per router right so maybe here's a router there's another router there's router one and router two but since i want to use the sort of linear time advantages of breath first search uh when i'm when i'm computing distances i can be a little bit sneaky about this which is to say instead of having like 10 feet of wires i'm going to have 10 one foot wires yeah except now i'm additionally going to have you know little chains so here maybe the length l one two is equal to three right so i'm gonna put three edges in between um so in other words and i'm gonna i'm gonna connect them with chains of l i edges for each wire that makes sense so essentially i'm going to take my weighted graph problem and make it unweighted by just like repeating a bunch of well not really repeating but chaining together a bunch of edges uh so that the total length of this thing uh is equal to the distance from one router to another okay one thing we might as well do is bound the number of vertices and edges in our graph when we do that so first of all let's think about the number of vertices and we can be totally lazy and upper bound this stuff it doesn't matter well for one thing i have one node per router so we incur one factor of r there and now notice that we're kind of laying down cable one little piece at a time here in our chains and now i always uh tend to have a fence post style headache about exactly what the constant factor is here but if we're conservative about it uh you know we incur at most a factor of 100 are kind of additional edges because those are all the different pieces that we could lay together it's actually less than that because of the endpoints but whatever uh because r plus 100r is big o of r so the number of vertices in my graph here is big o of r similarly what's the number of edges well this is exactly the amount of cable uh that's inside of my network i believe yep right so this is exactly 100r well i guess the way the problem is written it's uh upper bounded by a 100r but whatever um so this again is big o of r this is kind of convenient so now we have one number that rules them all right which is r which tells you both the number of vertices and the number of edges up to a constant factor right so one thing i can convince myself is if i do bfs on my graph that's sort of okay remember that's vertices plus edges time uh but in this case uh those are the same okay so uh right so remember at the end of the day i'm trying to compute the latency this is like the length of the shortest path to the entry point nodes so here would be a braindead algorithm which is to say for all routers for all entry points you know compute i don't know let's call the router on i the entry point j i compute distance i j like using breadth first search or something uh and then i you know uh you know take them the men of these values um and add them all together right so i compute for every router i look at every possible entry point i compute its distance to the entry point i take the min over all these things and now i add that to my running cell there's a problem here which is i haven't told you the relative number of entry points to the total number of routers so at least the way that i've i've written this algorithm here how much time would this take well there's two different for loops and in the worst possible case at least in my brain diet algorithm i don't notice that you know if i am an entry point then i don't need to compute distances well this would take order r squared whoa r squared time right um at least right actually i shouldn't even write big o i should write uh what's slower bound oh god i'm a terrible algorithm professor omega of r squared time because i haven't even accounted for the amount of time that it takes to compute the distance right uh and this is a problem because i've only given you a budget of linear time for your algorithm right so so this is this is frowny face i tried drawing the turret emoji on my notes and it really it didn't work okay so we need a better trick uh and this is actually sort of one of these proto-typical uh uh tricks uh which is uh to do the following so let's construct a graph i'm gonna draw my graph in a particular way but notice that there's nothing about my algorithm that cares about the way that i drew it this is just to make my life easier which is i'm going to put all the entry points on the left and all the just the remaining non-entry point routers on the right because i can uh and so this is what my graph looks like so these are like my entry points you know here are my other routers my graph doesn't have to be bipartite like it could be that my routers are connected to each other whatever um and then there's some some you know edges that go from my entry points to the routers in the graph trying to make sure that my graph is connected okay right and so essentially what this problem is asking you to do uh is to say okay for every single note in my graph i need to compute the the distance to the closest entry point and then sum all those things together right that's the schematic we could have in mind so in some sense what we want to do is think about the set of entry points as like one giant node right because it doesn't matter which of these guys i choose for my shortest path uh to an entry point i just need to find one yeah and so here's the basic trick and this is one that appears all over graph theory which is i'm going to introduce one additional note to my graph and i'm going to put him on the left hand side he's really big because he is a super note which is a term of art uh this term shows up a lot and i'm gonna connect it to every entry point in uh in my my network of routers does that make sense class okay so here's the here's the kind of cool thing so first of all for every entry point what's the the shortest path from the entry point to the super node well obviously it has length one right i drew it for you here now here's the thing let's take the shortest path from the super node to any of the routers on the right hand side what do i know well clearly like maybe i choose this guy here well what is my shortest path it goes here and then there there's one property that matters here which is that it has to pass through one of these entry notes which one does it has to pass through shrek for shame well remember uh the justin's favorite inequality is the triangle inequality and what does it say it says that if i compute the shortest path from the super node to any node in my graph then every sort of sub piece of that shortest path is also a shortest path that sentence was hard to parse let's try that again so in particular if i have a graph from the super node to some router over here well we've convinced ourselves it has to pass through one of the entry nodes which one does it have to pass through is it ever something that is farther than the closest entry node well no because i could compute a shorter path in that case by choosing the closest entry mode and then going to the super node so uh this is a complicated way of saying that essentially what we really want is for every router the distance from that router let's call it i to the super node s is that quite right is that the distance to the closest uh entry point one you went one more inch too far i went one inch too far right because i went to the closest entry point and then i took an additional edge so we want to do minus one okay so what does this mean well that means that i don't actually have to have this inner for loop over all the possible entry points i just need to construct this new special graph with one additional node notice that's not going to affect my runtime and compute the shortest distance from the super node to every other node in my graph and then use that as my output yeah so in other words what is my algorithm going to look like well first i'm going to construct my graph right so what do i need to do i have uh if i were to write this out on my homework i would have to talk about how i've got these chains of edges between different pairs of routers in addition to that i'm going to make one additional super node uh and and insert an edge from that to every uh entry point uh notice that adding the uh entry point here just adds a one to the number of vertices and at most i guess an r to the number of edges which doesn't affect asymptotically the size of either of these two sets so that's a good thing now i'm going to do i'm going to use a bff to do a single source shortest path from my super node to all other vertices and how much time does this take well remember that in general bfs takes v plus e time in this case v plus e are both you know look like r so this is order r time okay uh and then finally i'm going to sum over router's i the value of the distance from the super node to the router i minus one to account for that that additional edge that i added okay and that's the solution to our problem okay any questions about uh number two here excellent go team okay so now uh let's move on to problem three am i yeah we're about halfway uh okay so in problem three right so we're doing um poetry harder and three wizard friends the number three here i believe is actually irrelevant um although like anytime you see a specific number in a problem like you should you know cash that in your bag of things to remember and in this case that was a that was a red herring um padre harder and um her three wizard friends uh are tasked with searching around a labyrinth yeah uh and and in particular uh there's some some some nice things to know about the labyrinth and patri-harder world which has really thrown off my dyslexia here which is the following um right so what do we know we know that there are n rooms uh in my labyrinth uh and that each of my rooms uh has at most four doors okay um so in other words uh if i think of building a graph out of my rooms which is like i don't think i'm giving much away about about this problem by like jumping to the solution a little bit uh what do we know about the degree of any vertex assuming my vertices are rooms in the labyrinth is it most four so that's kind of nice uh okay right uh and all the doors start closed so that seems like a useful piece of information to remember um but we have this kind of weird thing which is that some doors are enchanted and apparently uh pop oh my uh pottery harder uh can open up uh certain doors for free which are not the enchanted doors and then other ones they have to like you know do the blessing and the holy water and whatever it is that that happens in in in this universe uh and then opens up that door um but that costs them materials and and um heartache right and so we wanted to minimize that right and so what they're given is basically a map right and this includes all of the different rooms how they're connected to one another and which of the doors are enchanted and what i want is the minimum number of doors that they have to disenchant okay now this problem is like kind of sneaky uh and and the reason why is that there's like the the network that's obvious to build uh and that turns out to be not quite the right one and then you can start thinking about adding weights on your graph and going crazy with that but that turns out not to be the right direction and in fact in poetry harder world um apparently we're not worried about their physical fitness in other words like shortest paths are actually irrelevant in this problem do you see that because like let's say that i have a really complicated uh annoying problem so like you know maybe i have you know here's my labyrinth and um no we don't even talk about the entry point like where they actually go in but just for for fiction purposes let's say that they enter my labyrinth here uh and that just to be annoying the two doors that are enchanted remember we could make a graph where all the vertices or rooms and the edges are doors are like at these two endpoints of the t so i have a giant t and i enter right in the middle now what is what is patri harder to do here well obviously there's like since this graph is a tree there's only so much they can do right they maybe they they they enter here they walk over all the way to the end to disenchant the door over here uh and then they turn around they walk to the other end they disenchant that guy yep and now they can reach uh other rooms um yeah because that's their goal is to visit every room sorry i think i skipped that step now there's a few things to notice about this example which make it a little bit different from the typical graph theory thing which is once they disenchant this door right they walk over here and they open it well now they walk over to this other room just to you know it's like you know those gym exercises you like run to the other side of the room you like touch the floor and then you run back that's kind of what they did here right they ran to the this room they tap that vertex and now they want to turn around and walk to the other side they don't pay money again on their way out right so once they open that door it stays open right and and that's actually quite important um because this uh what it does is it makes this problem not look like a traveling salesman problem which wouldn't be so great um okay so right and moreover does the fact that they're like maybe i suffered by these edges i have a bunch of edges here that are all not enchanted does that matter like if i had like five billion edges here no right because they only ask in this problem for the minimum uh number of doors that you have to disenchant yeah so it might be the the harry harry harder walks really far along my graph but as long as they don't walk through an enchanted door it costs them nothing so what does that mean well that means that like in some sense the second that i enter a room i might as well walk to every other room that it's connected to through unenchanted doors and that doesn't cost me anything right so sort of as a policy uh i should do that right i enter a room and then i kind of just search around and enter every possible door that i can that doesn't cost me an enchantment because those are free and and my goal is to visit every room yeah okay so here's going to be the sneaky trick like what is that starting to smell like right i open a door and i want to explore all the other rooms that are that are connected to that one connected component yeah maybe a connected component there's a problem is it connected component in this graph well no like this whole graph is one giant connected component so the sneaky trick is we're actually going to remove the enchanted doors that was supposed to erase and it didn't happen um but the the point is that if we remove the connected doors these are like the chunks of my map that i can visit without incurring any cost right so if i think of my graph maybe there's like a bunch of vertices over here and then there's an enchanted door and there's a bunch of vertices over here and then like two more enchanted doors like that and like what goes on in here like if this is like a giant triangle or something it's actually irrelevant because once i touch any one of these i can now touch all the rest of them so that suggests an algorithm so our first step is to be construct a graph g where the nodes are the rooms are the rooms and what should the edges be well if i'm just trying to find these like little clumps of rooms that i can visit for free if i get to any one of them then the edges are the non-enchanted doors okay and so now uh in step two i'm gonna compute my number my connected components which we covered in lecture uh the connected components of my graph g how much time does that take well remember that there are two different algorithms we mentioned that can do this this is full b f s or d f s and both of them are going to take the same amount of time right what is that time linear in the size of the graph okay so initially right that could be problematic because i want order n remember their uh n rooms here but thanks to our degree bound thanks to knowing that every room has at most four doors you can convince yourself that both the number of vertices and the number of edges are order n which i should probably rush through because as usual i'm going slowly okay so now what do i have i have a list of all the connected components in my graph and each one is potentially connected to some other ones by enchanted doors so in some sense i could think about this not to say the solution to the problem but i could think about modeling my problem as making some new graph or like i put a giant vertex and every connected component and maybe i connect them by enchanted doors and i want a path that touches every one of these rooms but that's not quite the right way to go uh and and this is what what catches by the surprise because this starts sounding scary right if you've heard of the traveling salesman problem it like kind of smells like that but that's not actually correct here uh for two reasons one is that once i open an enchanted door i can go back through it like i can like hopscotch back and forth through that door as many times i want and it doesn't cost me anything only cost me something the first time i open it yeah and [Music] moreover i didn't ask you to actually compute me that path if you read the problem closely it just asks for the minimum number of doors you have to open so this is a really sneaky problem because it turns out there's additional one line of code that solves this problem that's step three which i'm going to write before steps one and two just to keep you confused and that is to return this number of connected components minus one that seems sneaky why is that well what's going on here uh is the following um which is the let's say that i walk along remember that my graph is connected so what i know is that i can always get from any one connected component to any other right and so let's just take whatever ordering notice that the problem hasn't actually actually asked me how to return an efficient path it just asked me for the minimum number of doors i have to open so all i have to do is convince myself there exists a path with this many doors i have to open i don't have to actually return it if i did it would be mildly more annoying to think about okay so my graph is connected so one thing that i could do is make the worlds like well how do i want to do this well let's see here i guess i could i could come up with an ordering um that looks like depth first search of my graph that should do it okay so maybe i started this guy i just started some arbitrary vertex i'm going to do depth first search but rather than on the full graph on this kind of metagraph where i've clumped together rooms that i can get to with no cost right so what i'm going to do i'm going to start walking outward toward this guy and then it doesn't research backtracking and then going back down and if you think about it remember that you know in depth research i have this property i never need to revisit a clump once i've got to it once well the total number of doors that i'm going to open is exactly the number of connected components minus one because as soon as i've done that my death first search is is done here yeah uh in other words that's the number of of nodes in my graph so if i took what would be a better way to to i'm noticing that in my head this was easier to articulate than in words um there'll be a way to do it uh would be uh maybe add some more enchanted doors to the ground maybe add some more enchantment ah that's true actually my problem is a little too easy so as long as my back my death first search backtracks along the path that's already found then i'm sort of reaching out into this tentacle and then reaching back and then reaching to a new place i'll never traverse an enchanted door that i don't need to uh because i've already already seen the location um is your traversing tree yeah yeah so i've got a shortest path tree that's going on here actually i guess a breath first search would be a better example um in fact here's okay let's be concrete about i'm sorry i should have thought about this more carefully than i did at home yesterday um one thing i could do would be to compute a shortest path tree from one vertex in this graph to all the other ones in particular that gives me the the shortest path and i could traverse that tree to one node and then turn this all the way back and then traverse it to a new node and then traverse it all the way back and so on this is not an efficient path from a walking perspective but from a door opening perspective it's extremely efficient because it's a tree right and remember that the number of edges in a spanning tree of my graph is exactly a number of vertices in my graph minus one which is exactly the property we have here sweating for a second there okay so now in our remaining uh 30 minutes here we've got two more problems which is more than enough time especially because the last problem is is largely combinatorial and less algorithmic so i think it's okay to focus maybe talk about that at a high level um and show a fun plot okay so for problem four uh we have an airline uh purity atlantic uh that's that's cute uh jason really um and it's owned by richard ranson did i get that right uh and purity atlantic uh has a cute uh sale this is not like a cute angle i suppose um which is uh essentially the following which is that you can book an itinerary where you have your home city and then you choose i believe three other cities that you want to visit and then purity atlantic um you know maybe you're on your honeymoon and you're not concerned with price uh but rather just the efficiency because you don't want to spend your whole time in an airplane that's particularly true this month uh then what do you want to do you want to minimize your total number of connections right because as we all know in um spring 2020 we don't want to spend very much time in airports yeah uh so right uh so how do we do that well you know we make a website where you tell purity atlantic the cities that you want to visit in your home city and they give you back an efficient itinerary that minimizes the number of connections okay and the question uh is how do you actually do that right how do you um compute the the best itinerary uh that minimizes the number of flights you have to take so what are our variables and sometimes it feels like the variables are all the different permutations of the cities you could visit right i could like go to i don't know cambridge uh boston and then cambridge in the uk maybe you're doing like a university thing and then yeah i don't know budapest and some other place or you do those in any other order um and that feels like it should be factorial which would be bad news but this is one of these problems which um i suppose a computer science theorist might call fixed parameter tractable but that's sort of an overkill uh term here but essentially as long as you ignore all the factors that make this problem hard then it's then it's easy um a different way to put it is that uh okay if i'm only visiting three cities what's the total number of possible orderings of my my my three cities class so i have city a b c i could do b c a i could do b a c listen up yeah fine jason uh i'll do that so this is what we call direct proof mathematically uh which are all the possible ways um to visit three cities and now by my direct uh proof i claim there are no other ways to visit three cities uh and in particular there are one two three four five six uh different orderings of the cities that i can visit notice that this is a constant in my problem i am not asking you to make a website that takes like the total set of cities that you want to visit as a couple and order them it's specifically three you might also notice that six is three factorial uh which is perhaps a more efficient way to get to that same balance okay so right so there's there's six different orderings of the cities and in each case uh what am i going to have to do i'm going to have to compute the sum of going from my source city to city the first one from the first one to the second one from the second one to the third one the third one back to the first one okay so what do i need well i need in some sense i want to be conservative about it just the cost of flying from every city to every other city but that's not quite right i only need the cost of flying from every city that you have specified as a city you're interested in to every other city that you specified that you're interested in yeah okay so in particular i go to my new one um right so in this problem we have c cities and f flights yeah um okay and initially it might seem that we have to compute a ton of shortest paths but like if i want to go from boston to budapest to london to i'm running out of cities paris and back to boston or whatever ordering i prefer do i need to worry about the shortest path from you know nebraska to california potentially not right like that could be relevant the only ones that i care about are those four cities that i've identified okay um so there's there's three factorial possible permutations at the end of the day well there's two times four choose two um if you're wondering this is 12 or big o of one pairs of cities um meaning that like uh uh for uh itinerary purposes itinerary okay meaning that uh if i always enter an airport in one of city abc or my hometown and i always exit through another one so then there's four possible cities i choose them two at a time notice that flights might not be ordered like i might be able to get from one city to another but then maybe the airplane has a connection or something so going back is a different cost but totally there's there's two times four choose two uh different pairs of cities that i could enter exit from okay so now what am i going to do well so i can compute the 12 different shortest paths that matter in my my graph so when i say shortest path what do i mean well i'm going to construct a graph g with one vertex per city right and one edge per flight and notice the the number of connections that i need to make the minimum number between any city and any other city is equal to the shortest path the length of the shortest path minus one right so like maybe i have you know like here's boston here's london here's paris b l p for short right then the length of my shortest path is two and the number of connections i have to make is one because i stopped through london yeah so what am i going to do well for every pair of cities um in in this uh oops no that's okay uh in the set of the source city and the three cities you want to visit i'm going to compute the shortest the length of the shortest path right so this is the minimum number of connections i need to get from any one of these to any other one uh in my graph g well how much time does this take well there's 12 such pairs we already argued that right and how much time uh does it take to uh actually do a shortest path say using breath first search linear time the size of the graph i think jason actually has a t-shirt that says that um well in this case remember that's big o of the number of edges plus the number of vertices but just to make your life a little more annoying the number of vertices is the number of cities the number of edges the number of flights right so this takes 12 times o c plus f time which of course is just o of c plus f time notice this is one of these things where we're being sneaky we told you that you specifically visit three places and that's where this number 12 came from right if we'd said that you wanted to visit m cities then this would be a very different homework problem this is one of those things you got to remember right where we've given you a few constants and you should use them okay so now uh what can i do i can iterate over every permutation of a b c right so this is like saying i go from my source to city 1 to city 2 to city 3 back to my source right i add together and compute the cost the cost of that trip and remember cost in this case is equal to the minimum number of connections and then i return the minimizer so i say like is it cheaper for me to go boston budapest to paris boston paris budapest and so on so a for loop over permutations which generally is frowned upon but in this case because we told you you're visiting precisely three places how many steps are going to happen in that for loop well we actually wrote them all out over here on our board it's exactly three factorial or six steps right three times two times one which is 6. okay so right so at the end of the day this for loop is going to take well order 6 time which of course uh is just order one so it doesn't really contribute to our runtime at all and our entire algorithm runs in c plus f time okay so uh right so this is one of these problems where you're really taking advantage of the constants that we gave you we said you're visiting three cities so use it incidentally as a computer science theorist if i said you're visiting exactly 17 cities well what would be our our numbers now i mean there would be 17 factorial and then like 17 choose 2. those are big numbers but they're still constants so for purposes of this class that would be okay but the second that i gave it a name like m then i got to think about those factorial things a little more carefully all right um so that's this problem so so the basic trick here um was that like yeah it looks like all pairs shortest path but it's not quite it's all pairs of things that you're actually going to travel between shortest path and since that number of pairs is finite this is 12 that's that's an okay thing to do okay how are we doing about 15 minutes perfect i didn't want to do the last problem and i think i've managed to get myself in exactly that position okay so the very last problem on this homework which again this homework really follows the prototypical 6006 breath first search depth research homework i feel like they all fall into a similar pattern again we all these resources are available to you guys you should look at them the uh you know we're not trying to hide anything um this problem involves uh solving a pocket cube which is like a little mini rubik's cube which is two by two um and and it looks like this uh ah there's actually here we go right so here's my rubik's cube looks like a cube which i'm having some trouble drawing uh uh and in particular it's two by two uh which makes it a little easier than your typical rubik's cube okay um and in particular we're gonna mark uh some faces sneakily they used a little geometry term here which is cute so here's face f0 i'm sorry you can't quite see that but the top face is f zero case we were wondering uh the left face which is f one and the front facing face here f two notice that we've identified these by like vectors that point ninety degrees out from the face these are called normal vectors if you want to define those rigorously you can take my my grad level class but for a rubik's cube it's not terribly difficult uh but in any event um i can talk about flipping this rubik's cube in a pretty easy way right which is that i like i'm gonna fix one corner of my cube so this is like the corner that i'm holding onto with my hands and now i can grab what the top the side or the front of my cube and i can rotate it clockwise or counterclockwise you can convince yourself those are all the possible ways that i could uh sort of mess with the state of my cube after fixing one corner okay uh right and so this problem basically is involving um sort of a very typical trick in fact a lot of the history of these different search algorithms breadth for search death for search a-star which i guess we won't really cover here um date back to what 20-30 years ago we would have called artificial intelligence um these days that has a very different meaning but back in the day ai was all about like solving board games and you know rubik's cubes and all these kinds of things uh using algorithms right and the way that they would do that is by searching the different spaces of configurations right so now uh if we think of every face of this cube as painted with a color right there are different configurations of my graph that i get by like flipping the three sides right so if we think of there being a vertex for each state of my cube where state here means like the coloring of every face on my my rabix cube then there's an edge for every move and in this problem we encoded a move as a pair j comma s where it's saying that i'm going to rotate face f j where j is between i get 0 1 and 2 in direction s and we can just index that as like plus or minus one to kind of say counterclockwise or clockwise right and so this is kind of a cute thing right where your graph has a bunch of vertices which are all rubix cubes that's cube and then their edges if i can get from one to another by doing one of these moves and this is a nice abstraction because if i want to solve a rubik's cube in the most efficient way possible one way to do that is to compute the shortest path from my current configuration to the you know the platonic rubik's cube right where all the colors are constant on the different uh faces of my cube yeah and so that's like a sort of basic uh identification that happens all over the place in search strategies where like i'm going to think of every vertex of my graph as being the state of some system and every edge as being a transition from one to another and then paths in this thing are kind of like different ways of solving my puzzle right so like a different one would be you know i don't know every vertex is a chess board with the pieces the chess pieces scattered on the chessboard and every edge is one chess move by one player or the other in that case you have to be a little careful because you want player one or player two to go back and forth from each other but i'll let you think about the reduction there okay so uh right this problem i think largely is mostly just fun like combinatorics rather than algorithms but there's a lot of algorithms hiding in here um so they want you to argue that the number of distinct configurations of this rubik's cube this two by two guy is less than 12 million this is nice because 12 million is a number that computers can actually cope with um and so there's a pretty straightforward uh argument there [Applause] right uh so in particular um here's a cube how many corners are in a cube eight thanks i i hid one back here in case you're wondering so uh let's say that i i fix the corner of the cube like we've done that right then every time that i rotate one of the faces of my cube clockwise or counterclockwise i'm essentially like taking one corner of my cube and like sticking it in another place right so in all seven corners of my cube can move and if i'm not worried about like you know it could be that like some of these permutations are not actually achievable by a set of steps like maybe i'd have to break my rubik's cube and glue it back together but if i'm being conservative about it there's of course less than or equal to seven factorial different configurations of the corners right so in other words every time i rotate my face one of the corners ends up in a different place so there's seven factorial different ways that that could have happened okay so that's part of my bound remember that i'm trying to bound the total number of configurations here and essentially what i've done so far is i've said okay well there's a bunch of cubes in my 2x2 rubik's cube so i'm gonna like unglue this entire cube take just this corner and stick it up here and there's like seven factorial different ways that i could do that but i still have to account for the fact that i pull this piece off i stick it in the top but i have to figure out his orientation i can still rotate it about this corner and in fact there are three different ways that i could rotate it right you can kind of you can see it right one two three yeah so in all so each corner can rotate three ways so that means that i have three times seven factorial uh different configurations as an upper bound and this number is wait for it one one oh two two four eight oh um the problem asks you to argue that your upper bound is upper bounded by 12 million and indeed it is less than or equal to 12 million is that three times seven factorial or oh i'm sorry um right because there are seven corners each of which can rotate three different ways it's actually three to the seventh power times seven factorial thank you student um okay right so uh let's see here really quickly move in here the next problem says state the maximum and minimum degree of any vertex in my graph first of all do i expect vertices to have different degrees this is kind of a goofy problem like what would it mean to have a vertex the the somehow has lower degree than another vertex would mean that there's some configuration of this cube for which there are fewer moves that i could do to change it than a different configuration of this cube and that's like obviously not the case right because when i when i flip one of the the faces of my cube all i'm doing is i'm moving the colors around i haven't like somehow changed the physics of how rubik's cube works right and so uh i think this was just intended to be annoying by your instructors the the min degree is equal to the max degree and in fact the degree of every node in my graph is constant here the one thing that's worth noting here what i haven't argued it turns out i think to be true but what i haven't argued is that like i couldn't rotate a face and actually end up in the same configuration like maybe for some reason i have like red all the way around the outside so when i rotate it nothing changed that obviously isn't true but i haven't argued it carefully but as long as i don't worry about my graph being simple like i'm okay with self loops then the degree is certainly uh constant yeah okay and in fact i don't think that can that can happen on a typical rubik's cube well i think the point is to say how what the degree was oh yeah indeed though so we haven't computed the degree but we've argued that they're equal to one another okay so now we actually have to compute what that degree is um and here's how to do it so of course uh well this i think is actually even easier than than the first part essentially remember we have three different options for faces that i can rotate i can work it at the top the front or the side here right so there's uh three faces that we could rotate uh okay and how many different ways can i rotate them i can rotate them counterclockwise or clockwise so there's two directions so in all there's degree six for every vertex right there's six different ways um in or out of a vertex here okay so the next part of the problem gives you a piece of code and then does breadth first search on this uh this graph and it's super super slow to give me the distance to all the other configurations and jason conveniently has run it on his laptop here i don't i'm nervous to touch your laptop i i don't care so much but i don't you know i i don't want to infect here yeah right so we have a piece of code that um explores the graph of all the configurations of our cube um by breadth first search and then sort of gives me the shortest path i think from the base cube uh where all the faces are constant to all the other configurations that are reachable and generates a plot uh right and so what they ask is to um figure out the total number of configurations that explores uh one thing that you'll find out um center down uh is that uh it explores pretty much a third in fact exactly a third of all the possible configurations of my cube i think we can see that here um so i guess uh it runs this whole thing you sell them all together um right oops that's okay um and so in fact uh the kind of fun fact that you can learn about the two by two by two rubik's cube is that uh there's actually three connected components in this graph so in other words there's sort of like three different rubik's cubes you can make modulo all the different flips that you can do to the uh to the faces and those correspond to three corner rotations of one of the corners of the thing okay so uh right so then the the next part of the problem asks you to state the maximum number of moves needed to solve any rubik's cube and you can see it in this plot so what this plot is showing you is the size of the level set of this uh this distance uh function for for every distance so i think technically it looks like zero but it's actually this is at a one here we just say there's one uh vertex at distance zero which is the source right and as we move farther and farther out our tree is expanding and we're seeing more and more vertices apparently most vertices are approximately distance what is that 11 or 12 uh 11 away from the original then eventually i explore the entire graph and i'm done and you can see that the farthest away vertex is 14 away meaning that the most annoying rubik's cube to solve can be solved in 14 steps for the two by two by two uh pocket cube i'm sure that jason probably knows that the the equivalent of this number for the three by three by three but i have no idea what it is um i'm impressed if he can calculate in his head like he looks like he was about to try uh but i digress uh right so in other words um this is actually a fancy term for uh uh you know we talked about the radius of your graph in the first problem now we've got the diameter which is well not necessarily two times the radius the way that we've defined it here but but actually almost um uh i think within some constant of that okay so uh right so notice that the vertical axis here is really big and this is explaining why this bfs code is so slow right because these are all the different configurations it has to hit um or more accurately if i take the y position of each one of these vertices and sum up its height those are all the configurations that are reachable and those are all the steps that bfs needs before it's done right and so that number is in the [Music] certainly in the millions yeah okay so then the last part of this problem which it conveniently looks like i'm low on time to solve but i'll refer you to the solution anyway is asking how we might do this faster and so in particular what it says is uh let's say that i have a total of n configurations for my rubik's cube in this case it turns out that that's like roughly 3 million i think okay and now i want an algorithm that gives me the shortest sequence of moves to solve any pocket cube man i'm really ravaging the chalk today um and i want to solve any cube uh in a number of steps that looks like to n to the ceiling of w over two uh where um let's see here the code provides sorry this problem changed on me this afternoon right so uh where n sub i is equal to the uh number of configurations reachable within imoves oh good i see what we did here right so like if this is my base cube then we've got like maybe like a six different one two three four five six different cubes that i can reach from those and then there's six cubes i can reach from all of those but of course some of those might be pointing backward um or to each other but this is the number of things that are reachable in eye moves and they ask for an algorithm that finds the shortest path in this amount of time by the way big n typically exponentiates in that subscript there this looks innocent but it's not um the basic trick here uh is to do i'm not gonna bother writing it down we'll just talk about it for a second and call it for the day no i'll draw a picture so the breadth first search algorithm that we've thought about so far chooses a vertex and then computes level sets outward from that vertex until it maybe reaches the destination uh that you want to hit that doesn't quite work here and the well i mean it does work but it's going to be quite slow because like let's say i had bad luck and i were in that 14 vertex right then somewhere in there i'm going to hit this big height which is sitting over the 11 before i can get to vertex 14. so the trick here is it turns out that i can do it by only ever getting to 7. and the way that i'm gonna do that is instead i'm gonna run bfs sort of in parallel for two different vertices right the source and the target so in this case my current cube and the cube i would like it to be like the solution to the problem i'm first going to compute the level set one of that cube then level set one of the next cube level set two level set two three three and notice that eventually they're going to intersect pretty much right at the midpoint and so the size of the level set i never need to compute a level set that's bigger than a half of the shortest path uh length i have to round up to be conservative about that and and that's where i get this factor here so this is a nice little trick for for reducing the search size this is another kind of standard trick if you look at some of the uh code people use for for solving board games algorithmically and so on i think they typically uh sort of search from the beginning and end state outward to and try and meet in the middle uh for exactly this reason which is that exponential growth uh as we all know can be quite problematic all right folks so i think we're just about out of time and i've certainly worn myself out uh so with that hopefully we'll see you next week and uh yeah i hope everybody's doing well