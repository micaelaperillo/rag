all right welcome back to double06 dynamic programming we're now in step two out of four gonna see a bunch more examples three more examples of that dynamic programming longest common sub sequence longest increasing subsequence and uh kind of a made up problem from w6 alternating coin game and through those examples we're going to explore a few uh new ideas things we haven't seen in action before yet dealing with multiple sequences instead of just one dealing with sub strings of sequences instead of prefixes and suffixes parent pointers so we can recover solutions like and shortest paths and a big one which will mostly be fleshed out in the next lecture is sub problem constraint and expansion this is all part of the sort bot paradigm remember subproblems relations topological order base case original problem and time here is subproblems and relations i've written down both what these things are and the sort of key lessons we got from the first dynamic programming lecture namely we want to split up our problem into multiple sub problems and if your input is a sequence that's the main case we've seen so far like the bowling problem for example then the natural subproblems to try are prefixes suffixes or substrings prefixes and suffixes are nice because there's few of them there's only a linear number of them in general we want a polynomial number sometimes you can get away with one of these they're usually about the same sometimes you need substrings there's quadratically many of those then once you set up the sub problems which it's easy to set up sub problems but hard to do it right to test whether you did it right is can i write a recurrence relation that relates one sub-problem solution to smaller sub-problems solutions and the general trick for doing this is to identify some feature of the solution you're looking for so you're trying to solve some sub-problem and you try to ask a question whose answer would let you reduce to a smaller sub-problem so if you can figure out what that question is and that question only has a polynomial number of answers then boom and you've only got polynomial number of subproblems then you will get a polynomial running time so i have i think another way to say this we just locally brute force all possible answers to whatever question we come up with as long as there's polynomially many and then each of them is going to recursively call the smaller sub-problems but because we memoize we'll only solve each sub-problem once and so in the end the running time will be at most the number of subproblems times the non-recursive work done in that relation for that to work of course the relations between subproblems must be acyclic so we'd like to give an explicit topological order usually it's a couple of for loops but this is a topological order in the subproblem dag which i defined somewhat informally last time but if i have to the vertices are are sub problems and i want to draw an edge from a smaller problem to a bigger problem meaning that if evaluating b in this relation calls a then i'll draw an arrow from a to b from the things i need to do first to the things i'll do later so then topological order will be ready by the time i can try to compute b i will have already computed a uh and of course the relation also needs base cases and then sometimes the sub the original problem we want to solve is just one of those sub problems sometimes we need to combine multiple we'll see that today so that's review of this framework and let's dive into longest common subsequence this is kind of a classic problem it even has applications to things like computational biology you have two dna sequences you want to measure how in common they are one version of that you might see other versions in recitation called edit distance this is sort of a simplest cleanish version where i give you two sequences i have two examples an example here so for example it could be a sequence of letters so my first sequence spells hieroglyphology study of hieroglyphs and second sequence spells michelangelo and what i'd like is a subsequence so remember sub string has to be some continuous range some interval subsequence you can take any subset of the letters in your sequence or any subset of the items in your sequence so you can have blanks in between you can skip over items and so what we want is the longest sequence that is a subsequence of both the first string the first sequence and the second string and if you stare at this long enough the longest common subsequence i'm not i don't think it's unique but there is a longest common subsequence which is uh hello hiding in there and that is a longest common subsequence so given that input the goal is to compute hello or whatever longest common subsequence is so we're given write this down carefully given two sequences let me name them a and b we want to find the longest sequence l that's a subsequence of both a and b so that's the problem definition and we're going to see how to solve it using dynamic programming and whereas in the bowling problem we just had a single sequence of numbers the values of the bowling pins here we have two sequences and so we need a new trick before we said okay if our sub-problems or sorry if our input consists of a single sequence we'll try prefixes suffixes or substrings now we've got two sequences so somehow we need to combine multiple input together and so here's a general trick sub problems for multiple inputs it's a very simple trick we just take the product multiply the sub subproblem spaces okay in the sense of cross product of sets and in particular from a combinatorial perspective so we have sort of two inputs the first sequence a and the second sequence b for each of them there's a natural choice or there's three natural choices we could do one of these i will choose suffixes for a and suffix is for b you could do some other combination but that will be enough for here and then i want to multiply these spaces meaning the number of subproblems is going to be the product of the number of suffixes here times the number of suffixes here okay and in other words every subproblem in lcs is going to be a pair of suffixes so let me write that down so for for lcs our subproblems are l of i j this is going to be the longest common subsequence of the suffix of a starting at i and the suffix of b starting at j and just to be clear how many there are i'll give the ranges for i and j i'm not going to assume the sequences are the same length like in the example so right lengths of a and less than b i like to include the empty suffix so when j equals the length of b that's a zero items in it because that makes for really easy base cases so i'd like to include those in my sub-problems so that was the s in sort bot now i claim that that set of subproblems is enough to do a relation recursive relation among them so i'd like to solve every subproblem l i j and uh relation is actually pretty simple but it's maybe not so obvious so the idea is because we're looking at suffixes we should always think about what happens in the first letter um because if we remove that first letter then we get a smaller suffix if you're doing prefixes you should always look at the last letter either one would work for this problem so we're doing suffixes so we look at a of i and we look at b of j that's the first letter in in the suffix a starting at i and the suffix b starting at j and there are two cases they could be equal or different i think the easier case to think about is when they're different so like in hieroglyphology and michelangelo if we look at the whole string say the first letter in the top one is h the first letter and the second one is m those are different letters so clearly the one of those letters is not in the common subsequence because they don't match i can't start with an h i can't well i can start with an h i could start with an m but i can't start with both one of those letters is not in the output in this example it's m and so but i don't know which one so i have this question i want to identify some question the question is should i do i know that the h is not in the answer or do i know that m is not in the answer the final final longest common subsequence we don't know which so we'll just try both and then we're trying to maximize the length of our common subsequence so we'll take the max of uh l i plus 1 j and l i j minus 1. so the intuition here is one of at least one of ai and bj is not in the lcs uh get this wrong plus one sorry thinking about sub strings already yeah these are the beginning points so i want to exclude the i letter so if if a i is not in then i want to look at the suffix starting at i plus one if bj is not in then i want to look at the suffix starting at j plus 1. so the indices are always increasing in the function calls and the other case is that they're equal so this one i have a little bit harder time arguing i'm going to write the answer and then prove that the answer is correct here i claim you don't need to make any choices there's no question you need to answer you can actually guarantee that ai and bj might as well be in the longest common subsequence and so i get one point for that and then i recurse on all the remaining letters so from i plus one on and from j plus one on why is this okay well we have a b we're starting at position i and starting at position j for b um and think of some optimal solution some longest common subsequence so it pairs up letters in some some way these this would be some non-crossing pairing between equal letters uh and let's say uh so first case is that maybe i and j aren't paired with anything well that's silly because if they're not paired with anything you have some pairing on the rest of the items you can add this pair and that would be a longer subsequent so that would be a contradiction if we're taking imagining some hypothetical optimal solution it has to pair one of these with something maybe it pairs eye with something else though well if we have a longest comb sub sequence that looks like that i can just instead pair i with bj that's still uh you know if i had this pairing i'm actually not using any of these letters so why don't i just use this letter instead so you can argue there is a longest common subsequence that matches ai with bj and so then we can guarantee by that little proof that we get one point for matching them up and there's no that we don't have to max this with anything okay so two cases pretty simple formula um and then we're basically done we just need to fill in the rest of sort bot so next is topological order so this i'll write as for loops because i'm dealing with suffixes we want to start with the empty suffixes and then work our way to larger and larger suffixes so this might seem backwards if you're doing prefixes it would be an increasing order there's all sorts of orders you could flip the i and j it's very symmetric so it doesn't really matter but anything that's generally decreasing in inj is good then we have base cases uh these are when one of the sequences is empty i don't care how many items are in b but if a has no items there's no common subsequence i mean it's empty and same for uh no matter how big a is if i've exhausted the b string i start from beyond the last item then i should get 0. then the original problem we want to solve is l 0 0 that's just longest common subsequence of the entire a and the entire b and time okay so for time we need to know how many sub problems there are it's a plus one times b plus one i'll just call that theta a b so these are non-empty subsequences so this is the number of sub-problems and then what we care about is how much time do we spend for each subproblem in evaluating this recurrence relation so we ignore the cost to recursively call these l's because they are smaller sub problems they're already dealt with when i multiply by the number of subproblems so i just care about this max computation and this equality check and we'll say those each cost constant time so this is quadratic time if the two strings are size n this is n squared general it's the product of the two string sizes and that's longest common substring so uh pretty straightforward this really doesn't other than this little argument and understanding the case when they're equal the easy case where they're unequal we just try the only two things we could do one of the uh one of a inbj is not in the longest common subsequence so what i like to say is we guess which of those is the correct one that is not in the longest common subsequence and if we guess that it's in a then we'll recurse on that side if we guess that it's in j then we'll recurse on by increasing j and then uh would i'd like to assume not really that we always make the correct guess that we made the correct choice whether it's irj now we don't actually know how to do that so instead we brute force we try both of them and then because we're trying to maximize we take the max okay just another way of thinking about it but overall very straightforward the only com added complication here is we had to deal with two uh sequences simultaneously and we just took the product of those so pretty pretty easy in general if you have some constant number of sequences you can afford to do this you'll still get polynomial but of course once you go to end sequences you can't afford this you would get like an end to the n behavior so that's kind of a limit to how far you could go two sequences is fine three sequences is fine but n sequences there probably is no polynomial time algorithm for this problem uh cool i want to show you an example i have an example here not i didn't i didn't want to try out hieroglyphology versus michelangelo so i came up with another example their habit is to say hi so the longest common subsequence of their and habit is h i um and i mean it's a giant well not that giant it looks kind of like a grid graph the base cases are out here because those correspond so uh when i say this each of these nodes is a subproblem and this corresponds to what is the longest common subsequence between eir and abbott and it should be i it's the only letter they have in common and that's why there's a 1 here to say that the longest common subsequence has a 1 has size 1. the base cases are when either there has been emptied or when habit has been emptied so those all have zeros on the outside and then the problem we care about is this one it's there versus habit uh claim is the length is two and what i've drawn in here are what i'll call parent pointers like we talked about with bfs and shortest paths and so on this is so we had this choice uh sometimes we had a choice on whether we recursed here or recursed here was the best thing to do and so i'll just draw i'll draw in red the arrow from lij sorry to lij from one of these in this case and in this case there's no choice but i'll still draw in red that arrow so uh these diagonal edges are exactly the cases where the letters match here h equals h um i equals i here so i draw this diagonal edge that's that first case where the letters are equal and so i recurse by increasing i and j that's why i get a diagonal edge there's also one over here where t equals t so for those we're getting a one plus you see this one is one larger than the zero this two is one larger than the one this one is one larger than the zero and for every other vertex we are recursing this way and this way uh we can see what those two numbers are and we take the max so this whole diagram is just filled in uh by for each uh position where they're not equal we look at the guy below we look at the guy to the right those are the slightly smaller substrings we look at those values we take the max as long as you compute this in a generally right to left and bottom up fashion whenever you're trying to compute a guy you will have the its predecessors already computed that's the topological order of this graph and then at the end we get our answer which is two and now if we pay attention to where we came from for example this vertex had to come from this direction the 2 is the max of 2 and 1. so i highlight the 2 edge and if i follow this path there should be a unique path to some base case we don't know which one and in this case the diagonal edges correspond to my matching letters so there's the h here and followed by the i here and so high is our longest common substring in general we just follow these pointers backwards the red pointers and we get our answer so not only do we compute the length of the lcs but we actually can find the lcs using parent pointers so this is and this is a concept you can use in most dynamic programs including all the ones from today okay any questions about lcs all right perfectly clear to everyone in the audience uh so we move oh uh yeah now we move on to longest increasing subsequence which did i lose a page here i just disordered them okay this problem has almost the same name but is quite different in behavior longest increasing subsequence l i s instead of lcs both famous problems examples of dynamic programming here we're just given one sequence like carbohydrate so this is a sequence of letters and i want to find the longest subsequence of this sequence that is increasing strictly increasing let's say so in this case alphabetically so i could go i could include cr for example but not cb that would be a descending subsequence and in general or in this example the right answer or a right answer is abort there aren't very many english words that are increasing but there are some and i looked through all of them because i just implemented this dynamic program we're about to to write down it take took me like two minutes to write down the dp and then more work to read the dictionary and look for cool examples so in general we're given some sequence a and we want to find the longest increasing subsequence of a the longest sequence that is increasing strictly you we could use the same thing to solve not strictly increasing but so here uh things are going to be a little trickier it's easy in that we just have a single sequence so again we think okay let's look at our chart here we could try prefixes suffixes or substrings i personally prefer suffixes jason prefers prefixes uh whatever you prefer is fine um but always i'll generally start there because there's nothing in this problem that makes me think i need to delete things from both ends one yeah question isn't the answer to this problem always 26. so if is the ques is the answer always at most 26 yes if you're dealing with english words so when i say sequence here this is a sequence of arbitrary integers word size integers so there you can have a ton of variety this is just for the fun of examples i've drawn drawn this but even if the answer is 26 finding that longest common subsequence is you know the obvious algorithm would be to take all sub strings of size 26 which is like n to the 26 so that's we're going to do much faster than that here and squared time and then if you remove the strictly increasing then it can be arbitrarily large okay so um let's try to do this uh maybe i won't be so pessimistic to write attempt here let's just go for it uh so i want some sub problems and i'm going to choose suffixes so i'm going to define l of i to be the longest increasing subsequence of the suffix of a starting at i okay that's the obvious thing to do uh and now i'm gonna leave myself a little space and then i'd like a relation on these so i'd like to say what l of i is and what do i have to work with well i have l of things larger than i those would be smaller suffixes uh but let's let's go back to what is a question that i could ask about this sub problem that might help me figure out what the longest increasing subsequence looks like so we're looking at a here's a from i on longest increasing subsequence is sub subsequence and we'd like to remove letter i now when we do that there are two choices maybe i is in the longest increasing subsequence or it's not in so the question i would like to answer is is i in the longest increasing subsequence of a of a from i onwards this is a binary question there are two options so again just like before and so i can brute force those two options the trouble and then i want the longest one so i'm going to take the max so i'd like to take the max of something like li plus one so in the case that i don't put i in the solution that's that's fine then i just look at i plus 1 on and recursively compute that and that would be my answer and the other option is that i do put i in the longest increasing subsequence so i do 1 plus the rest no i plus 1. okay if i if i close this brace this would be a very strange recurrence right because this is always bigger than this one so this there's something wrong here and there's something wrong is i haven't enforced increasing at all there's no constraints here it's just saying well i'll put i in and then i'll do whatever remains and i'll pray that that's increasing probably won't be because indeed if if i is a letter or as a number that is strictly greater than i plus 1 then this will be wrong so i really can't always do this i need to somehow know i could check whether i plus one is is in the answer but some but i don't know maybe i plus one so i can check whether i the letter i is less than the letter i plus one uh but maybe i put this in the longest increasing subsequence then i put this in the longest increasing subsequence and so i need to compare these two items but i don't know when that's going to happen things seem really hard and indeed there's no way from this sub problem definition to write down a relation but there is a slight tweak to this definition that makes it work so um the the trouble we have here and this is the idea of sub problem constraints or conditions the trouble we have is when when we recursively compute the longest increasing subsequence on the remainder we don't know the first item in that answer maybe it's i plus one maybe it's some guy over here if we knew who it was then we could compare that item to item i and so what we'd like to do is add a constraint to this sub-problem that somehow lets us know where the longest increasing subsequence starts so what i would like to say is longest increasing subsequence of that suffix that starts with a of i so in other words it includes a of i okay this was a separate question okay this is a bit of a funny constraint it changes the problem it's no longer what we want to solve if you think about the original problem before it was solving l of 0 we just want the longest increasing subsequence of the whole thing now it's not necessarily l of zero this would be l of zero means what is the longest increasing subsequence of the whole of the whole sequence a that includes the first letter of a and maybe we do include the first letter of a maybe we don't we don't know where the longest increasing subsequence starts here for example it didn't it started at the second letter but conveniently it's okay that we don't know because that's just another question we could ask is where do we start where might the lis start to start at the first letter second letter third letter there's only n choices and let's just take the max of all of them so before i get to the relation let's solve this problem i just want the max of l i for all i i guess we've been writing size of a here okay the maximum will beat the overall longest increasing subsequence so if i could find longest increasing subsequence that includes the first letter and or the longest one that's includes the second letter and so on so it starts at the first letter starts the second letter then this max will be the longest overall so if i could this sub problem is not what i really wanted but it's still good enough because it lets me solve my original problem and this is adding an extra constraint to my sub problem and doing this is challenging thinking about what the right constraint that would let you solve your problem is tricky especially in the beginning but for now let's just take this as a thing that works why does it work because now i can say well this this term was fine max so i'm trying to write longest increasing subsequence starting with the ith letter versus uh yeah actually no this is just going to be different okay so now i get to the central issue which is i i know by the definition of l i that i include letter i this is going to be in my longest increasing subsequence that's what i'm looking for by this definition but i don't know what the second letter is could be i plus one could be i plus two could be anything bigger whenever there's something i don't know i'll just brute force it right i don't care uh that i don't know i'll just take a max over all the possible choices let's say that the next the next letter included in the longest increasing subsequence i is j then i would like to look at l of j now i don't know what j is but i'll just brute force all possible choices for j so it's going to be i strictly less than j because i don't want to include the same letter i again and otherwise i would get an infinite recursive loop if i put less than or equal to here uh and maybe i don't do anything else up to n and uh okay not quite done now this is the interesting part i can enforce increasing because i can't just choose any letter j to the right of i also the the number that's or letter that's written in here has to be greater than the number that's written here that's the strictly increasing property so i can add as a constraint in this max to say a of i is strictly less than a of j and if you wanted non-strictly increasing you would add an equal there okay this is mathematical notation in python you would say max open paren of this thing for j in this range if this holds so i'm just doing the for loop but i only do i only look at the possible choices for j uh when uh the strict increasing property holds and then when that holds i put check this now this set might be empty i need to define what the max is when it's empty then i will just say oh i also need a oneplus don't i let me just do one plus so we're told that i is in the answer so we always get one and then the remainder is this or zero if there are no uh j's there if there are no aj's greater than a i uh then we'll default to zero and say that i is the only item in my increasing subsequence okay so there are a few details to get right but in general once once you figure out what these recurrences look like they're very simple i mean this is one line of code and then all you need in addition to this is the original subproblem and some other things we need the base cases but i should do them in order topological order is just the usual for loop because i'm doing suffixes it's going to be i equals length of a down to zero uh base case is going to be l of length of a which is zero because there's no letters in that suffix um and we already did o and then time okay this is a little different from the past examples so number of subproblems just like usual is linear length of a sub problems there's only one sequence we're thinking about now unlike the previous example but the work we're doing in this relation now is non-trivial work before we were just guessing among two different choices now we're guessing among up to n different choices this n here is length of a and so we have theta length of a non-recursive work that we're doing in each subproblem or you might think of this as choices that we're considering and for each choice we're just spending i mean we're just taking a max of those items adding one so that's a constant overhead and so we just get this product which is a squared cool so that's the longest increasing subsequence make sure i didn't miss anything else so we're using this idea of asking a question and guessing or brute forcing the answer to that question in two places one place is we're promising we're being we're requesting that the longest increasing sub sequence starts at i so then the question is well what is the very second uh item that's in the longest increasing subsequence that it starts with i uh we're calling that j and we're brute forcing all the possible choices that j could be which conveniently lets us check confirm that it's actually an increasing subsequence locally from i to j and then l of j will take care of the rest by induction the rest of the longest increasing subsequence starting at j will also be increasing and so this guarantees by induction the whole thing will be increasing then we also use this uh local brute force to solve the original problem so we added this constraint of starting at i but we didn't actually know overall where to start but that's fine because there's only eight choices so i should mention in the running time analysis so they're solving the sub problems that's fine but then there's also a plus whatever it costs to solve the original problem but that's okay that's length of a so this was all of this plus length of a is still length of a squared okay but if you're doing you know exponential work here that would be bad we have to do some reasonable amount of work to solve the original problem in terms of all the sub problems i have an example hiding here this is a little harder to stare at here i have empathy and this example is not doesn't have much empathy because the longest increasing subsequence of empathy is empty empty is one of the few english words that's increasing and you the hard part here is drawing the dag i mean it's almost the complete graph but we only draw edges from smaller letters to bigger letters so we draw from e to m from e to p from e not to a there's no edge from e to a from e to t not from e to h but yes from e to y and then we also draw from e to the base case which is there's no more letters that was that that uh edge to the base case is uh corresponds to the zero or i guess this n where we say ah let's just recurse let's just throw away actually maybe we don't need the union zero there in fact because we include l of n which is the empty substring then the definition of of l is a little funny what does it mean to say you start with a of n hm right a of n is not defined so that's not so nice so maybe i'll fix that and decrease equals case okay but i'm still going to draw an edge there conceptually say oh we're just done at that point that's the base case where we have no string left um cool and when i said from to two actually i meant the reverse all the edges go from right to left um and then what we're doing is looking for the longest path in this dag um longest path is maybe a problem we've talked about in problem session because it's a dag well longest path is the same thing as shortest path if you just negate all the weights there are no weights in this picture so if you just put negative one on all these edges and ask for the shortest path from the base to anywhere so single source shortest paths from this base then we would end up getting this path which if you look at it is e m p t y empty and so that uh shortest path is indeed the right answer what i've drawn here is the shortest path tree so also if you wanted the longest increasing subsequence starting at a then it is a t y just by following the red arrows here and how do you get that you just draw the parent pointers just like we did before i didn't mention this example can also be solved with shortest paths once i'd construct this graph you can do the shortest path from some base i don't know which one to here if you put negative one on all of the diagonal edges and you put weight zero everywhere else then that corresponds to the shortest path in that graph will correspond to the longest the path with the most diagonal edges and that makes sense because the diagonal edges are where we actually get letters in common and so in this case it's two so both of these dynamic programs could instead instead of writing them as a recursive thing with memorization or writing them bottom up as a for loop and then doing the computation you could instead construct a graph and then run dag shortest paths on it but the point is these are the same thing it's actually a lot simpler to write the dynamic programming code because it's just a for loop and then a recurrence which you're just updating an array you don't because you already know what the topological order is you don't have to write a generic depth first search algorithm take the finishing order reverse it and then run this run dag shortest paths with relaxation uh much simpler to just write down the recurrence once you've figured it out okay but they are the same in these examples uh in fibonacci for example you cannot write fibonacci as a single source shortest path problem but a lot of dps you can write as the shortest paths problem just a connection to things we've seen all right last example last problem for today we'll do more next week alternating coin game this is a two player game we're gonna find the optimal strategy in this game uh so an example is in general you have a sequence of coins and we have two players they take turns so given coins of value uh v zero to v n minus one so it's a it's a sequence they're given an order in some order for example 5 10 125 not necessarily sorted order and the rules of the game are we're going to take turns i'm going to take turns with you i'm going to use i and u to refer to the two players and so in each turn either one whoever's turn it is i get to we get to choose either the first coin or the last coin among the coins that remain so at the beginning i can choose 5 or 25 and i might think oh 25 is really good that's better than 5. i should choose that but then of course you're you're going next and you're going to choose 100 and you'll win the game you'll get more of the total value of the coins so in this example a better strategy is to take the five because then the hundred is still in the middle and so once once i take five uh you get to choose 10 or 25 at this point you probably prefer 25 because that's better than 10 but whichever you choose i can take the 100 and so i get 105 points and you're going to get 35 points okay good good example for me um and what we're going to do so that's easy for a simple example but in general there are exponentially many strategies here at each step either of us could go left or right choose the leftmost or the rightmost and we're going to give a dynamic programming algorithm that just solves this fast uh i didn't mention so this algorithm is quadratic time but it can be made n log n time it's a fun exercise using a lot of the data structure augmentation stuff we've done you can make this n log n this algorithm i think is going to be n squared time uh y so i won't write the problem exactly but i think you know the rules she's left most of rightmost coin alternating moves so i'd like to define some sub problems and this is a problem that's very naturally a substring problem right if i just looked at suffixes that would deal great with if i'm deleting coins from the left but as soon as i delete a and if i delete coins only from the right that would give me prefixes but i'll tell you now there's no dynamic programming where the answer is suffixes and prefixes you can do suffixes or prefixes but if you need both you almost certainly need substrings because as soon as i delete the first coin and then maybe you take the second coin that's exactly the optimal strategy here now you have an arbitrary substring in the middle okay but substrings are enough because we're only deleting from the ends we'll look at substrings so more precisely this is just the intuition we're going to define some generic x of i j is going to be what is the maximum total value i can get uh from this game uh if we play it on coins uh of value vi to vj so that's a substring so this is one way to write down the sub problems and is also a good way i mean you can write down a relation on this on this definition of sub problems but i'm i'm low on time there's there's two ways to solve this problem this is a reasonable way exploiting that the game is zero sum but i'd like to uh change this a little bit to give you a i think what's a cleaner way to solve the problem which is to add a third coordinate to my sub-problems so now it's parameterized by three things p here is uh only has two choices it's me or you okay and this gets at a point that's maybe not totally clear from this definition uh max total value that i can get uh from these this substring of coins but uh this is not obviously what i need so obviously at the beginning i want the whole string and i want to know what my maximum value is fine and i go first in this game i didn't specify but i do overloading i but as soon as i do a move as soon as i take the first coin for example it's now your turn and so i don't really want to know the maximum total value that i would get if i go first i'd like to say uh if player p goes first i'd really like to know what what happens in the case where you go first and so for some of the uh substrings i want to know what happens when you go first and for some of them i want to know what happens when i go first because as soon as i make a move it's your turn and so we're going to flip back and forth between p being me and p being u p u so you don't have to parameterize this there's a way to write the recurrence otherwise but this is i think a lot more intuitive because now we can do a very simple relation which is as follows so i'm going to split into two cases one is x of i j me and the other is x of i j u uh so x of i j me so i have i have some substring from i to j uh what could i do i could take the first coin or i could take the second coin what should i do that's my question should what is my first move should i take the first coin or the second coin so this is my question what is the first move there are exactly two possible answers to that question so we can afford to just brute force them and take the max for moving we want the maximum number of points we can get maximum total value of the two choices so if if i take from the i side the left side that would be x of i plus one j uh sorry and now crucially we flip players because then it's your turn and if i take from the j side that will make it j minus one this is what i accidentally wrote at the beginning of lecture also flipped players so either i shrink on the i side or a shrink on the j side oh i should add on here the value of the coin that i get and add on the value of the coin that i took sorry these are this is a an expression inside the max that sum okay and if i take the max those two options that will give that is my locally brute forced best choice of how many how what are the total value of coins i will get out of the remainder given that you start plus this coin that i took right now in the first step and for the two possible choices of what that coin is okay what remains is how do we how do we define this x of i j u this is a little bit funnier but it's conceptually similar i'm going to write basically the same thing here but with a me instead of a u because again it flips this is if you go first then the very next move will be me okay so this is just the symmetric formula here i can even put the braces in so far the same now i don't put in the plus vi and i don't put in the plus vj here because if you're moving i don't get those points so there's an asymmetry in this definition you could define it in different ways but this is the maximum total value that i would get if you start so in your first move you get some points but i don't get any points out of that so there's no plus vi there's no plus vj it's just you either choose the ith coin or you choose the jth coin and then the coins that remain for me shrink accordingly now you're kind of a pain in the ass you're an adversary you're trying to minimize my score potentially because you're trying to maximize your score this is a zero-sum game so everything that you get i don't get so you want to maximize your score if you want to maximize your score you're trying to minimize my score these are symmetric things and so if you think for a while the right thing to put here is min from our perspective we're imagining what is the worst case that could happen no matter what you do and we don't have control over what you do and so we'd really like to see what score would i get if you chose the ithcoin what score do you get if if you chose the jth coin and then what we get is going to be the worst of those two possibilities so when we get to choose we're maximizing and this is a general two-player phenomenon that when you choose we end up minimizing because that's the saddest thing that happened to us okay this is one way to write a recurrence relation um we have of course all of sort bot to do so the topological order here is in increasing length of substrings so the t is increasing j minus i start with empty strings so base case is that x of i i me is vi uh so here i i'm i'm inclusive in both ends in this definition uh so there is a coin i can take at the end but if you move last and there's one coin left then i don't get it so it's zero then we have the original problem that is x i j me sorry x zero n that's the entire coin set starting with me that was the problem i wanted to do and then the running time we get is the number of sub problems that's theta n squared because we're doing substrings times the amount of non-recursive work i do here that's just a max of two numbers very simple constant time so this is quadratic let me show you an example this is hard to draw but what i've described here is called solution two in the notes um so here's our sequence 510 125 in both directions and what we're interested in is all sub strings so over here i've written the choice for i so we start at one of these and if you start here you can't end earlier than there so that's why we're in the upper upper diagonal of this matrix and then there's two versions of each problem the white version and the blue version just down and to the right of it if you can't see what blue is this is the version where you start this is the version where i start and i've labeled here all of the different numbers please admire because this took a long time to draw but in particular we have 105 here meaning that the maximum points i can get 105 and that's the case because if we look over there it is the max of these two incoming values plus the vi that i get so either i go to the left and i take that item or i go down and i take that item so the option here is i went to the left and took well that's going to be tricky to do in time the claim is that the the best answer here is to go here with the hundred and take the five uh because going down corresponds to removing the last item if i went to the left that corresponds to remove sorry the first item if i went to the left that corresponds to removing the last item so my options are 10 plus 25 which is 35 versus 100 plus 5 105 wins so that's why there's a red edge here showing that was my better choice and in general if you follow the these parent pointers back it gives you the optimal strategy in what you should do first you should take the five is what this is saying because we just clipped off the five we used to start here and now we start here in this sub interval then our opponent to be annoying we'll take the 25 doesn't actually matter i think then we will take the 100 and then they take the 10 and it's game over okay all the numbers here how many points we get doesn't say how many points the opponent gets of course you could add that as well it's just the total sum minus minus what we get ah now let me come back to high level here what we're really doing is sub problem expansion and this is an idea that we will expand on next lecture uh and the idea is that sometimes you start with the obvious sub-problems of prefixes suffixes or substrings here the obvious version with substrings because we're removing from both ends if you don't know probably suffixes or prefixes are enough so we start there but sometimes that's still not enough sub problems here as soon as we made a move our problem almost turned upside down because now it's your turn instead of my turn and that was just annoying to deal with and so we could whenever you run into a new type of problem just build more sub problems as long as it stays polynomial number we'll get polynomial time and so here we doubled the number of sub-problems to just the b case and the u-case and that made this recurrence really easy to write in the notes you'll see a messier way to write it if you don't do that in the examples we'll see next lecture we're going to do a lot more expansion maybe multiplying the number of sub problems by n or n squared and this will give us uh it will let us add more constraints to our sub problems like we did in longest increasing subsequence we added this constraint that we start with a particular item the more sub problems we have we can consider more constraints because we'll just brute force all the possible constraints that could apply well we'll see see more of that next time that's it for today