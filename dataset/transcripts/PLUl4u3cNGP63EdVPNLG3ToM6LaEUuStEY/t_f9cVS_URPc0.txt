okay let's get started welcome to the 12th lecture of 606. uh this is our second lecture talking about weighted graphs and in particular weighted shortest paths algorithms last time we talked about weighted graphs this is a kind of a generalization of what we mean by distance uh in an unweighted graph instead of each edge having a weight of one essentially right we generalize that to be any integer and last time we we showed how to solve shortest single source shortest paths in a graph that doesn't have cycles even if it has zero or negative weights in linear time using an algorithm called dag relaxation we also showed in that lecture how in linear time if we are given the shortest path weights to all the things reachable in finite disk or with shortest path uh distance that's finite we can construct a shortest paths tree from those weights in linear time okay so this is motivating why we're not really going to talk about parent pointers uh for the next couple of lectures we're just going to concentrate on these shortest path weights right and so today we're going to be talking about our most general algorithm we'll be showing for solving single source shortest paths in particular in graphs that could contain cycles and could have negative weights okay so just to recap uh our little road map here uh single source shortest paths new linear time last time we discussed another linear time algorithm dab relaxation and today we're going to be talking about beltman ford which isn't limited to acyclic graphs in particular there could be negative weight cycles in our graph right if it has cycles and has negative weights the worry is that we could have negative weight cycles in which case there is if a negative weight cycle is reachable from our source then the vertices in that cycle and anything reachable from that cycle will potentially have an unbounded number of edges you need to go through there's not a bound on the number of edges for a shortest path because i could just keep going around that cycle as many times as i want and get a shorter path right and so we assign those distances to be minus infinity okay so that's what we're going to do today in bellman ford in particular what we're going to do is compute our shortest path distances these shortest path weights for every vertex in our graph setting the ones that are not reachable to infinity and the ones that are reachable through a negative weight cycle to minus infinity and all other ones we're going to set to a finite weight and another thing that we might want is if there's a negative weight cycle in the graph let's return one okay so those are the two kinds of things that we're trying to solve in today's lecture okay but before we do that let's warm up with two short exercises the first one exercise one okay given an undirected graph given undirected graph g return whether g contains a negative weight cycle anyone have an idea of how we can solve this in linear time actually in fact we can do it in order e uh no yes yes reachable from s i guess let's just save a negative weight cycle at all not in the context of single source shortest paths ah your colleague has determined uh an interesting fact about undirected graphs if you have an a negative weight edge in an undirected graph i can just move back and forth along that edge that's a cycle of length two or i guess three vertices back back to where we came from that is of negative weight because i'm just traversing that weight over and over and over again so the question of single source shortest paths of finding negative weights is not particularly interesting in the undirected case what i can do is just for every negative weight edge undirected edge in my graph i can just you know find the reachability from the vertices the endpoints of that edge and label them as minus uh minus delta basically if the connected component containing s has a negative weight edge then everything in the graph is accessible from a negative weight cycle so this is not such an interesting problem and so we're going to restrict our discussion today today to directed grabs uh so this is uh if and only if exists negative wait edge okay okay exercise two kind of a little preview for what's to come we're actually not going to show you an algorithm directly that meets this bellman ford running time v times e what instead we're going to show you is a an algorithm that solves single source shortest paths in so given an algorithm alg a solves single source shortest paths in order v times v plus e time okay what is that that's v squared plus v times e right that's close to what this v times e is okay that's what we're going to show you but if i had such an algorithm can anyone tell me a single source shortest paths algor how we can use this algorithm to solve single source shortest paths in v just v times e time okay show how to solve sssp in order v times e i guess we can put a dot there as well okay so this is a little tricky it's kind of related to the difference we had between the reachability problem and the single source shortest paths problem that we saw last lecture right this when are these asymptotically different in their upper bound is when v is asymptotically larger than e right but the connected component containing s can have at most e vertices or order e it can actually have at most e plus one vertices because uh otherwise it wouldn't be connected okay so what we can do if we had such an algorithm we could first when we're given our graph explore everything in the graph using bfs or dfs find all the things reachable from s and then just throw away everything else now i have a graph for which v is asymptotically no bigger than e and then we can use this algorithm to solve single source shortest paths in v times e time okay i'm not going to write all that down here you can see it in the notes yeah graph is it simple does this work if your graph isn't simple i haven't thought about it we are not going to talk about non-simple graphs in this class uh but probably not because you've got a lot of edges though in our class if we're talking about single source shortest paths if we have multiple edges between two vertices we can just take the minimum weight one because it's never better to take the larger ones that answer your question great all right so those are our warm-ups that's our goal we need to find an algorithm for single source shortest paths in general graphs graphs with potentially graphs and cycles and negative weights and solve it in this v times linear kind of time that make sense all right so first before we get to the algorithm we're going to uh discuss a little bit about simple short about shortest paths in general if we didn't the problem here is negative weights how do we find if we had negative weight cycles there seems to be these problems because we could have minus infinities in our deltas but if we didn't have negative weights i'd like to assert to you that our shortest paths even if there are negative weights are going to be simple they won't repeat vertices so that's the first thing we're going to show you find let's say simple shortest paths okay so claim i'm going to give my claims numbers today just because i'm going to have a lot of them if my shortest path distance from s to some vertex is finite meaning it's not infinite or minus infinite right some finite value there exists a shortest path a shortest s2v path that is simple and remember simple means not going through a vertex more than once all right how are we going to prove this well consider if this claim was not true right if every shortest path contains a cycle essentially right it repeated a vertex then my path looks something like this i mean there's some vertices along here and then i go to v so here's s and then there's this some cycle i repeat some vertex i'm going to call this cycle at c okay now what do i know about this path i know that it has it's a shortest path and it has finite weight right so in particular this path this delta distance is not minus infinity but if this is not minus infinity what do i know about the weight of this cycle yeah it can't be negative right because if it was negative i could keep going around this cycle and this would have a non-finite weight shortest path distance from s right so i know this is you know can't be negative so it must be zero or positive right but if it's zero or positive and this is the shortest path right went through this cycle then i could remove it and now i have a new path with one fury cycle i could just keep doing this to create a simple path okay so that checks out okay so that's interesting if it's simple what do we know about the number of edges in a simple shortest path how many could there possibly be how long in number of edges could a simple shortest path path be if i can't repeat vertices right i can have at most v vertices on my simple path which means i can use at most v minus one edges right fence posting right so simple paths have at most v minus one edges that's a nice little thing i'd like to to box off that's a really nice property right so while uh a shortest path here could have an infinite number of edges right if the shortest path distance is finite i know i only have to check paths that use up to v minus one edges in particular this is finitely bounded in terms of the number of paths i have to consider it's exponential potentially right but at least it's finite okay the other the other way i i potentially had to check every possible path of which there could be infinite if there's cycles in my graph okay so i have an idea okay what if i could find shortest path by limiting the number of edges i go through right so not the the full shortest path distance from s to v but let's limit the number of edges i'm allowed to go through and let's talk about those shortest path distances just among the paths that have at most a certain number of edges i'm going to call this k edge distance and i'm just going to provide a little notation here instead of having a delta i'll have a delta k here that that means how many edges i'm limited by okay so from s to v is shortest s to v path using at most k edges short weight weight of a shortest path shortest s to v path using at most k edges okay and the these notions seem somewhat symmetric right if i were able to compute this thing for v minus 1 right then it for all the vertices then if the distance is finite then i'll have successfully computed the real shortest paths because of this statement right now that doesn't mean that if it's if this is uh it doesn't mean the other way right if this is minus infinity right if the shortest path distance is minus infinity it doesn't say anything about what this is right it just says the shortest path using at most v minus one vertices using it at most v minus one edges uh would be whatever this is but really the shortest path length needs to consider an infinite number of edges right so it doesn't really tell us much about that but for the finite ones it does it works well and so if we are able to compute this thing for k equals v minus 1 in a graph that doesn't contain negative weight cycles we'd be done right i claim to you a stronger statement that if the shortest path using at most v edges from s to v is less than strictly less than delta of v minus one right this is all in the subscript here right basically this is the sh shortest path distance of any simple path right and possibly ones that also contain cycles but definitely it includes all this the simple paths right if there's a shorter path to my vertex that goes through more than v minus 1 edges that this path can't be simple right because it goes through a vertex more than once otherwise it would be included in this distance set right so if this is the case and i found a shorter path to v that uses v edges but yeah that uses v edges that path can't be simple which means that path or some path there contains a negative weight cycle okay so if this is true then i know that the real shortest path distance from s to v must be minus infinity right i'm going to call such a vertex a witness right if if we can find a vertex that has this property i mean i haven't shown you how to compute these things yet right but if i were able to find a vertex v and these are capital v's if you uh having trouble these this v is different than this speed this is cardinality right if we can find such a vertex v that certifies that there's a negative weight cycle in r graph so i'm going to call v is a witness okay so if this property is true it's a witness and it definitely has this is it possible you think i'm going to claim to you that it's possible that a vertex could have minus infinite distance but not have this property hold okay there's i could probably give you an example i don't have one off the top of my head right now but that's possible you could imagine there might be no path going to a vertex on a negative weight cycle that goes through v exactly the edges right it might go through more edges a shorter one right so this equation would be an equality and would not certify that this is true right but i claim to you if a vertex has this property if it's its shortest path distance is minus infinite then it must be reachable from a witness okay so that's the claim if delta sv is minus infinity then v is reachable from a witness reachable from a vertex that has this property that has this property and if it's reachable from something that has minus infinity shortest path weight then i can take that path go to my reachable vertex and that's also a minus infinite path right okay so how do we prove this well let's consider let's let's i'm going to state a somewhat stronger statement uh that will prove instead okay it suffices to prove that every negative weight cycle contains a witness if we were to prove that right then every vertex with this property every vertex with this property has uh is reachable from a negative weight cycle by definition okay so if we can prove that every prove every negative weight weight cycle contains witness right if we can prove that every negative weight cycle contains a witness then every vertex reachable from one of those witnesses in particular reachable from the negative weight cycle has is uh has shortest path distance minus infinity and that should prove the claim right uh is this thing has to be reachable from a negative weight cycle uh and so if we prove negative weight cycles contain witnesses then all of these vertices are reachable from a witness okay great great confusing myself there for a second okay so let's consider a negative weight cycle in g okay this is a directed negative weight cycle recall okay this would be my negative weight cycle c right all the sum of the edges in this thing the way the weights has negative weight and i'm going to have a little bit notation if i have a vertex v here i'm going to say that its predecessor in the cycle i'm just going to call it v prime okay that's just some notation all right so if i have computed these path distances to every vertex in my graph shortest path distance going through at most v vertices and the shortest path distance going through at most v minus one vertices then i know the following thing holds delta of v going from s to v for any vertex in my cycle can't be bigger than delta v minus one from s to u plus the weight sorry knight u v prime its predecessor plus the weight going from the predecessor to my vertex why is that why is that because this is the weight of some vertex this is the way the shortest path distance to my predecessor using one fewer edge and so this in particular is the weight of some path that uses v edges so if this is the shortest such path distance this has to upper bound it right at least at most yeah that's that is a statement of the triangle inequality thank you all right so yes this is just by triangle inequality okay now what we can say is let's take this equation summed over all vertices in my cycle okay so i'm just going to add some summation here of all vertices in my cycle of this whole thing okay i'm going to do that out a little bit neater okay summation of delt delta not d delta v s v i guess i don't need this open parenthesis equals or less than or equal to sum of v and c of delta v minus one uh v prime okay and here i'm summing over v and c and this is just my notation for it's the predecessor right and then i'm going to sum over the weights in my cycle v in c right these are the sum of the weights in my cycle well what do i know about this cycle right this is just the weight of c right weight of c that's awful handwriting c what do i know about the weight of the cycle it's negative right so this is less than zero which means that if i remove this this needs to be a strict equality right but if this if the sum of all of these is less strictly less than the sum of all these we can't have none of the vertices in my graph satisfying not satisfying this property right right if all of them are not witnesses then this thing is bigger than this thing at least as big as this thing for every vertex in my cycle which is a contradiction right so the claim holds if we have a negative infinite shortest path distance then v is reachable from a witness so it suffices for us to find all the witnesses find all the vertices reachable from the witnesses and then mark them as minus infinity does that make sense okay so now we finally are able to get to our algorithm all right bellman ford and what i'm going to show you today is a little different than what is normally presented as bellman ford the original bellman ford algorithm does something a little different and because it does something a little different which we'll talk about at the end it's a little hairier to analyze i'm gonna show you a modification that is a little easier to analyze and has this nice property that we're going to be able to use the algorithm to give us a negative weight cycle if it exists okay so we're gonna say this is a maybe a modified bellman ford and the idea here is to make a vertex associated make many versions of a vertex okay and i want this version of the vertex to correspond to whether i came here using zero edges one edge two edges three edges i have a different vertex version of the vertex for each one of these uh for for uh a path going through at most a certain number of edges okay so this is an idea called graph duplication idea graph duplication and this is a very common technique for solving graph related problems because essentially what i get to do is i get to store information right it's i'm rep i'm i'm if i'm having different versions of a vertex i can have that vertex correspond to reaching that vertex in a different state okay so that's what we're going to do here the idea here is make the plus one levels basically duplicate vertices in our graph where vertex v k in level k represents reaching vertex v using at most k edges okay so this definition seems similar to what we're doing up here right if if we have vertices that have this property then their shortest paths in this new graph might correspond to these k edge distances and really what the name of the game here is to compute these two for every vertex because then we can con then if uh d is finite delta is finite then this guy will be the length of our shortest path and if they're different that'll be a witness and we can explore from it okay so and if we connect edges uh from one level to only higher levels basically levels with a higher k then this graph is going to be a dag oh that's cool why is that cool because we saw how to solve single source shortest paths in a dag in linear time now this graph that we're going to construct is going to have v plus 1 levels so could have our our graph kind of explodes v times right we're going to do that in a second i'm going to be more precise with what i mean there but if we're multiplying our graph v v plus 1 times then the size of our graph is now v times larger that doesn't that's not so hard to believe but if we made our graph v times larger and we ran a shortest path algorithm in linear time with respect to that graph then that graph has something like size v times v plus e size that looks familiar maybe that's this running time right so if we can find an algorithm that runs in that running time we can get down to v times e okay so let's try to do that here's the transformation i'm going to show you i'm going to show you first with an example okay here's an example of a directed graph that does contain a negative weight cycle okay can anyone find it for me b c d right has weight minus four plus three minus one it has a minus two total weight right so that's a negative weight cycle okay so if i were to take shortest paths from a right i will want to say at the end of my algorithm this better be zero and all of these better be minus infinity right so that's what i want in my in my algorithm so what's my algorithm going to be i'm going to make v plus one copies of this graph and i'm going to kind of stretch it out right okay so here i have v zero one two three four there are four vertices in my graph so this is one two three four five copies of my graph i have a version of vertex a for each one of those copies a version of vertex b for each of those copies c and d etc okay so i have this nice grid of vertices and i'm not going to put any edges within a layer within a level right because then i mean this graph has cycles right and i don't want cycles in my graph right what i'm going to do instead is for every edge in my original graph for example the edge from a to b i'm going to connect it to the the b in the next level right so a0 is connected to b1 with an edge weight of -5 just like in the original okay and i'm going to do that for every edge in my graph and i'm going to repeat that down all the way okay in addition i'm going to add a zero weight edge from a0 to a1 or from every vertex all the way down the line these are all zero weight edges corresponding to i'm not going to traverse an edge i'm just going to stay at this vertex okay that's going to allow us to simulate this at most k edges condition now if you take a look at paths in this graph from a0 our starting vertex clearly none of the other vertices are in that level are reachable from a zero right just as we want right because the shortest path distance to any of these vertices using at most zero edges should be infinite right i can't get there in zero edges okay but then any path in this graph using at most k edges is going to correspond to a path from 0 a0 to a vertex in that level the corresponding level so for example if i had a if i was looking for paths to be right using at most three edges right any pat a path from a0 to b3 in this graph would correspond to a path in this graph that uses it most three edges right so let's find such a path okay so going from a0 b1 stay at b1 stay at b sorry yeah that's a that's a path using fewer than three edges or at most three edges okay but there's another path here where is it going from a a a to b okay that's not such an interesting one that's the same path so i might have more than one path in here corresponding to a path in there but my claim is that any path in here corresponds to a path in here okay so what's a what's a path of length three that's non-trivial yeah a to c to d to b okay so a to c to d to b yeah that's a path right and i basically because i constructed this so that the edges always move from level to level as i traverse these edges i always change levels yeah but my original graph doesn't have these self loops yes my original graph doesn't have an edge from a to a that's true right i'm using these edges to correspond to i'm deciding not to take an edge right it's not that i'm like doing any work here i'm just staying there for a state okay and that's what's going to allow me to get this at most edges all right so this is the graph we construct hopefully you understand that we made these v layers right this is v right and a vertex we made v copies of every vertex and connected them using edges in this way okay so first step of bellman ford is construct this graph uh so bellman ford construct construct g prime as described above it has how many vertices v times v plus one right v times v plus 1 vertices and how many edges well i have one edge for outgoing edge for each vertex corresponding to just staying in the same place right so that's v squared vertices i mean edges and then i have one edge for every edge in my graph i have k sorry i have a v minus one sorry just v i have v edges for every edge in my graph okay so that means so this is the number of vertices and v times v plus v times e this is v v plus e all right cool so that's how many edges i have so we construct it in that way it's a dag right if we only have edges going to increasing levels then this thing can have cycles because otherwise that would mean there would be an edge pointing backwards right and we didn't construct any of those all right so we construct this graph g prime we can do that in linear time with respect to these things i just go through all the edges i make these edges and i make these vertices it's it doesn't take anything i just do it naively right i can do that in time v times v plus e asymptotically okay now i run dag relaxation our nice algorithm we had last time from in there it was a0 i'm going to say it's s0 our source our source vertex single source shortest paths so that i compute delta of s0 to vk for all k in what is it zero to v right that's what single source shortest path does right it computes for me this distance from my source at some source right to every other vertex in the graph and so in particular i get these right well that that is all of them then for each vertex v set the thing i'm going to return uh d value uh s to v equal to the shortest path distance i got from dag relaxation to a particular vertex uh v v minus one all right why do my why am i doing this right i'm setting it to be the shortest path distance to the guy in the second to last row here or column in my modified graph the hope is that this distance in my dag corresponds to this distance in my original graph right uh the distance to v using at most v minus one edges right so that's the claim that's the claim we're going to prove in just a second i'm going to write it down just so that we have just to continue our train of thought claim delta s 0 v k equals delta k the k edge distance from s to v that's that's what we want to claim that would then what would that mean then that would mean that i'm correctly setting the shortest path distance here for all vertices whose distance is finite great i mean i i set values to things where they're not finite where they're minus infinity also but in particular i set the ones correctly if they're uh finite okay so the last thing we need to do is deal with these minus infinity vertices right but we know how to do that right we just look at the witnesses because we've computed this value for k equals v and k equals v minus one and if that claim over there is true then those shortest path distances are the same as these k edge shortest path distances and we can just for every vertex we compare these things if this is satisfied we got a witness right okay so for each witness you envy you know where delta s naught u v is less than strictly s naught u v minus 1 that's the definition of a witness here close the parentheses then for each vertex v reachable from u set del uh sorry d d is what we're returning d of s v equal to minus infinity so that's the end of the algorithm basically i'm looking for all the witnesses for each witness i find all the vertices reachable from it and set it to minus infinity just as we argued before okay so it remains to prove this claim how do we prove this claim well we can induct on k right is this true for k equals zero yeah right we kind of already argued it over here when we are talking about our initialization step or what what dag relaxation does it'll set this to be the shortest path from this guy to all these vertices these aren't reachable from here and so these are infinite and that one's zero okay so the base case so induct on k base case k equals zero check right that's all good now we induct in our inductive step let's take a look at the shortest path distance from zero from s zero to v of k prime for some k prime and the assumption is the inductive hypothesis is that this distance is the k edge distance for all k prime less than k i mean all k less than k prime right well kind of by definition of a shortest path this is the minimum over all incoming vertices of the shortest path from s zero to u of k prime minus one plus the weight of the ed of the edge from u of k prime minus 1 to v k prime for all u k prime minus 1 in the adjacencies the incoming adjacencies of v k prime okay what does this mean right i'm just saying in my graph g prime a shortest path to this vertex needs to go first through some vertex in the layer before it which is one of these and in particular i'm only connected to things uh adjacent to me that's all this is saying right i have to go through that vertex and take some shortest path to one of those previous vertices now in actuality these adjacencies i constructed them to be similar to the adjacencies in my original graph in addition to one edge coming from my original vertex right from from vertex v so this is the same as the minimum of this set delta s naught same thing plus wuv for all uh u in the adjacent incoming adjacencies of my original vertex in addition to one more term what is that other term these are all of the things corresponding to my incoming edges in my original thing but i also have that one edge coming from the v before it right so this is i'm going to union union union this with delta s naught v of k prime minus 1. awful i think there's another one here this is s naught v of k prime minus one okay i'm not going to rewrite it okay then by induction this thing and this thing must be the edge shortest paths using k minus one vertices and then that's just the statement of what the shortest path should be using at most k prime edges going from s to v okay so these things are the same as we clamped yay check all right and then it's not such a triv it's it's kind of a trivial leap then to say that at the end of bellman ford these guys uh sorry the things that we return these guys are the shortest path distances because here if they're finite we set them to their true shortest path distance and if they're minus infinity that invariant means that these things correspond to exactly this claim over here it's a witness and then finding all the vertices reachable from those witnesses we said all of the infinite ones to be minus infinity as desired okay so what's the running time of this thing well we have to construct this graph so we had to take that time okay we ran dag relaxation that takes the same amount of time right for every vertex we did order v work and then for each witness how many could there be at most v checking the reachability of each vertex that can be done in how long order e time right because we don't need to consider the things that aren't connected to x or aren't connected to the witness right so this thing takes order v times e work so we're upper bounded by this the time it took to construct the original graph and by the claim we had before that takes v times e time okay so that's bowman ford i'm just gonna leave you with two nuggets first the shortest uh shortest path if for any witness let's say we have a witness here do i have any witnesses here uh i didn't constru i didn't fill in all these but is there a vertex on this cycle that goes through uh who has the shortest path that goes through four vertices that's smaller than any other right okay i can go from a to c to b to d to b to c and you can work out this algorithm i have it in the notes that you can take a look at this will actually have a shorter path for vertex sorry it'll have a shorter path for vertex b a to b to c to d to b thank you that's a path of length four of four of edges that has shorter path than any path that has fewer edges in particular there's only one other path to be using fewer than four uh there's two other paths one path of length that has one edge that has weight minus five and one path this path that has weight nine minus one is eight right whereas this path minus 5 minus 4 3 minus 1 has minus 10 plus 3 is minus 7 which is shorter than minus 5. so b indeed is a witness right and if we actually take a look at that path through this graph going from a to b to c to d back to b we see that there's a negative weight cycle in this graph b to c to d to b and indeed that's always the case for our witnesses okay you can see a proof of that in the notes and you can see in recitation a little space optimization to make us not have to construct this entire graph on the fly but actually only use order v space while we're going okay so that's bellman ford sorry for running a little late