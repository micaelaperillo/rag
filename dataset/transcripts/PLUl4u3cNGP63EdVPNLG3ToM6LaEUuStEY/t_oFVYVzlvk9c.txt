okay team Let's uh get started for the day uh it's a pleasure to see all of you guys uh in case you don't remember I'm Justin I'm the third instructor of6 that you probably forgot about uh but you're going to see a lot more of me in the graph theory part of our course because that's the part of algorithms that I like if I were reincarnated as a theoretical computer scientist I would probably go into this area hey guys okay uh you know we have our our PhD admit visit days coming up for the next uh couple days so I'm working on my like Camp counseler cheerleader voice so you know don't make me uh wake all of you guys up for the day you're not going to like it uh but in any event uh right so in in 66 if you look back at the course outline we're officially starting part two of this class uh there are a few corollaries uh to that fact uh so unless there any questions about that we'll get started with our our new unit in 66 which is a graph theory if you're wondering there's a graph on the the the screen here uh but of course we'll fill in uh a little bit more information today uh throughout our lecture when I was learning how to teach which I'm still doing um one of uh actually my PhD adviser told me like if you want somebody to learn something you have to write it as big as possible and so I'm I'm really leaning into that that approach today uh in our our slides so in any event uh right so today we're going to have our first lecture on on graphs which I think will somewhat be a review for many of you guys and if it's not that's cool too uh because we'll start from the beginning and kind of build up all the Notions that we need to understand and process graphs and hopefully by the end of lecture have some style of algorithm for computing the shortest path from one vertex to all the other ones so in case we forgot a little bit terminology a graph some people call this a network but sometimes that term is overloaded with a few different kind of variations on the theme uh is a collection of two things right that's what this this parenthesis notation means there's a set of vertices and a set of edges right and the edges uh like you can see in the sort of third point on our screen here are a subset of V cross V now this is fancy notation for something really really simple right because what is this telling me this is telling me that an like in the picture that we see on the screen here it's just something that connects two vertices together right so if I think of there being a pair of vertices like the from and the to right then that is a subset of the cross product of v in itself right so hopefully the notation in that third line on the screen makes some sense this is just fancy notation for edges or pairs of vertices but of course inside of that notation there are two special cases that we care about uh in this this class uh one is is when you have a directed graph and one is when you you have an undirected graph gu I said them in opposite order from what's on the screen right so in an undirected graph I guess we still think of an edge like a pair of vertices but really I should have notated this slightly differently in fact maybe I'll I'll revise it in the slides before uh they go into ocw where instead of writing E equals uh W comma V I should write in fact equals V comma W and notice that there's a slight difference between the notation on the slide and what I've written on the board which is this set notation here what's the difference between parentheses and squiggly lines is that this guy is unordered this is a set of things and what's on the board it's ordered right or or what's on the screen rather and of course in an undirected edge there's no such thing as an edge from W to V being distinct from an edge from V to W those are the same thing right they're undirected it's just is a notion of connectivity whereas in a directed graph now we're going to use that parenthetical notation to say that the Edge from W to V is different than the Edge from V to W that's going to make a big difference so for example uh in the graph on the right let's maybe redraw it uh on the board here so we have four vertices I drew this last night and I'm hoping that this example actually works uh uh like that can I get from the upper right vertex to the lower left vertex following edges in this graph I heard one person everybody on three one two three no right because if I wanted to I mean maybe I think of drawing this path here but of course if I go from the upper right to the lower left this is like the ugliest thing I've ever drawn I'm so sorry uh you notice that the edges are pointing in the up Direction here so I'd have to go kind of against the stream of the water but that's not allowable in the directed graph case of course I'm already anticipating the notion of a path which we haven't really defined yet but I think intuitively that's sort of the the the big difference between a directed and undirected graph does that distinction make sense to all of yall or have I managed to lose you in in in four minutes or less excellent so I flipped things a tiny tiny bit from the course notes because I figured we'd Define what a graph is first before telling you what the applications are uh but in in in any event I think it's really not a big stretch of the imagination to say that grass are like literally everywhere in our our everyday life right anytime that we come up with a network of stuff connected together implicitly the right abstraction often in in the back of our heads uh is to think about a graph right so some simple examples that I think would all come to mind for us would be like computer networks right so the nodes or the vertices of your graph uh in that case maybe are computers and then the edges are roughly the the cables connecting them together in my very coarse understanding of how networks work uh or or maybe in a social network you know the nodes are uh people in your social network and the edges are like friend relationships or like you know friendy relationships or or or whatever uh in fact I think you could think of both directed and undirected uh versions of that particular uh network uh you know in Road networks maybe you know I'm I'm working for Google and I want to tell you the shortest path between your house and MIT of course uh in order to do that and essentially behind the scenes we're solving some version of computing the shortest path between two vertices in a graph that's a tiny bit of a lie in the sense that there's a lot of structure in that problem that we're not going to leverage uh in this course right a road network is a very special type of graph uh and if you take an advanced course maybe you'll say like well if I know a little more about my graph I can do better than the general case we'll talk about here uh but the basic algorithms that we'll talk about in 66 are certainly relevant in that case and are really the building blocks for what goes on and in in the tools that are used every day on your phone when you open Google Maps or ways or or whatever and of course there's there's many others right so for instance an example uh that maybe is a little bit more subtle would be the set of states and transitions of of a discrete thing so think about like a Rubik's cube right so I could make a graph where the node is every configuration of my Rubik's cube right like every rotation and then the edges are like can I get from this configuration to that one by making one simple transition like one F flip I don't actually know the terminology in Rubik's Cube I have a feeling you do uh for one rotation twist thank you and of course there are many other places so for instance uh you know my in my my day job here at MIT I typically teach computer Graphics courses and actually graph Theory although we talk about it very differently appears in that world constantly uh because of course what's sitting behind any 3D model on your computer is a giant network of of triangles this is called a triangulated surface like this Taurus we see here uh and this is nothing more than a graph and in fact if you squint at the algorithm that we cover in 6838 you'll see that they're roughly just graph algorithms in Disguise uh in fact if you take my graduate course one thing we'll do we'll spend a lot of time doing differential geometry and then we'll step back 10 feet and notice that exactly the algorithms we were using for like Computing all you know curvature and bendiness on on triangle meshes just looks like a graph algorithm and can be applied to to networks in exactly the same way so it'll be a nice kind of fun reveal uh there and of course as one uh last kind of fun application um I actually was gone the last couple days at a conference on political redistricting and the funny thing is most of the discussion at that conference was about graph Theory uh and and and the reason for that uh is sort of a theme that shows up a lot in Geometry World which is if I take my state in this case I think these are the voting precincts in some state or another uh and I look at adjacency relationships then maybe I put a node for every Precinct and an edge anytime that they share a boundary with one another well now I have a network and and maybe a region on my graph is like a connected piece of of of this this network uh and so anyway this is one of these examples where graphs and networks and connectivity and so on just show up literally no matter where you go they're totally unavoidable uh and and so that's what we'll be spending quite a bit of time on uh in this class here now you could easily take I would argue at least three entire courses on graph Theory uh here at MIT uh and you could easily build a PhD uh a doing nothing more than really simple problems on graphs uh of course in this class we're we're we're limited to you know some some just a few lectures out of many uh so we're going to make a couple assumptions both on the problems we want to solve uh as well as on the graphs that that we care about uh so in particular uh one simplifying assumption which actually really doesn't affect many of the algorithms we'll talk about here but is worth noting uh explicitly is that we'll mostly be thinking about a particular type of graph which is a simple graph uh and in fact often depending on how you define your graph you kind of accidentally made your graph simple uh even if you didn't intend to so for example uh we wrote that our edges were a subset of V cross V uh which maybe means that I can't have uh multiple edges that uh you know sort of trans Traverse the same pair of vertices so let's see an example of a graph that is not simple so sorry I haven't actually defined it a simple graph is a a graph that has no self Loops so I can't go from a Vertex to itself and every Edge is distinct so let's uh make the most nonsimple graph we can think of like let's say I have two vertices uh so maybe uh if I want to make my so there's a graph right two vertices in one Edge this is simple if I wanted to be annoying and make it not simple maybe I'd take this Edge and I'd like duplicate it three times just for for fun uh that violates the second assumption and now to make it even worse I could violate the first one by adding an edge that goes from this vertex to itself this is not simple I don't know what you would call it actually General graph I guess complicated because it's not simple I don't I don't know uh yeah a multi-graph I always thought of that as something anyway it doesn't matter uh but in any event in this class we're not going to worry about this particular uh circumstance and of course in many applications of graph Theory that's totally reasonable assumption to make any questions about definition of a simple graph okay so from now on whenever we think about a graph in the back of our head we're going to think of our graph as simple there's one nice property that a simple graph has which I've written in really big text on the screen here which is that the edges are Big O of of of v^2 and in fact let's uh let's expand that formula just a tiny bit so there's sort of two cases uh right one is when my graph is undirected the other is when my my graph is is directed yeah um so if I have a directed graph well let's think about how many edges we could possibly have right so an edge is a pair of a from vertex and a two vertex right and I can never repeat it twice right that's that's sort of like the uh the second assumption here right so in particular what do we know know we know that mod e or rather the number of of edges in our graph is upper bounded by what well I can take any pair of of vertices like that but I have to be a little bit careful because my graph is directed right so from and to matter here so this is is V choose two is saying that I can take any unique pair of vertices but I have to put a factor of two in front of it uh to account for the fact that the source and the target can be flipped back and forth and of course if I want to do the undirected I don't have to worry about that right we'll get e here is less than or equal to just mod V choose to right so this is just a fancy uh way of saying that every Edge consists of two vertices and my edges are unique and one thing if you just write down the formula for uh our our binomial coefficient here as we'll see that both of these things oops oh yeah s our at worst mod V uh Square here and that makes perfect sense right because of course an edge is a pair of vertices you kind of expect there to be a square yes I'm so sorry I can't hear you sorry so the two comes from the backr it's from the swamp yes exactly so the the the two uh for the directed case comes from the fact that an edge from V to W is different than an edge from W to V right so remember that the binomial uh coefficient here is just counting the number of ways that I can choose two things from a set of size V but it doesn't care about ordering yeah any other questions fabulous so why is this going to matter well these sorts of bounds I mean they might seem a little bit obvious to you but we're going to write down graph algorithms and now when we analyze the runtime and the space that they take we now have like sort of two different numbers that we can think about right the number of vertices and the number of edges right and so for instance if I write down an algorithm whose runtime is proportional to the number of edges maybe then generically I could also think of the algorithm uh as having a runtime that looks like the number of vertices squared unless I put some additional assumptions on my My Graph right and so there's some connection between all these different constants and it's useful to kind of keep that at the back of our head that sometimes you'll see a bunch of different expressions that really are encoding roughly the same relationship just in different language of course that also means that we can be more precise right so sometimes uh a graph is what we would call sparse so in my universe almost all graphs that I deal with in my day-to-day life are extremely sparse this is a consequence of of topology uh and and because of that an algorithm that scales like the number of edges might actually be much preferable to an algorithm that scales like the number of vertices squared because in practice often there fewer edges than like every single possible pair right uh and and and so that's the sort of reason why is worth thinking about these numbers okay so let's continue making boring uh definitions here uh so some other ones that we should think about uh involve the uh topology or the connectivity of our graph uh in particular thinking about neighbors right so in general we kind of think about uh pairs of vertices as being neighbors of one another uh if there's an edge between them we have to be a little bit careful uh because of course uh when we have a directed Edge we have to be careful who's on the sort of giving and the receiving end of this this neighbor relationship yeah so let's draw a really really simple graph so here's vertex zero here's vertex one here's vertex 2 and maybe we'll have an edge going up Edge going down and then a cycle here okay now we can define a lot of different Notions of neighbors like the outgoing neighbor set the incoming neighbor set uh and and the basic idea here is that we want to keep track of edges going from a vertex and edges pointing into one yeah so for instance the outgoing neighbor set which we're going to uh uh uh notate as adj plus here what is the outgoing neighbor uh set of uh node zero here well if we take a look notice that there's one Edge going out of node zero and it points to node two so of course this is set which just contains one other node and similarly the incoming neighbor set of node zero well notice that there's one incoming neighbor from vertex one so that is a set like that now of course in an undirected graph uh the sort of distinction between these two uh things doesn't matter so if you look at our final uh bullet point here uh often in the undirected case we just drop that plus or minus superscript because it sort of doesn't matter yeah uh in any event there's one additional piece of terminology that matters quite a bit which is degree and this is nothing more than just counting the size of this set right so the out degree is the number of edges that point out of a Vertex and the in degree is the number of edges that point in so notice in in this case both of those numbers are are one uh let's see an example where they're not so in node one notice there's two edges that come out so the out degree of of node one is two there's one Edge that points in so the in degree is one okay so often why why are we going to do this well we're going to write a lot of graph algorithms that like have a for Loop over the neighbors of a given vertex uh and then this this degree number is going to come into play um is worth uh bounding these things just a tiny bit so uh in particular one thing we could think about I write too big and I'm going to run out of space really quickly here um is the following so let's take a look at all of the possible uh nodes inside of my graph and now let's sum up all of their degrees right so like I'm going to let's see if I look at this graph you know then notice there's you know there three Al uh three edges adjacent to this vertex here three edges adjacent to that one two adjacent to this so I sum them all together so is a convenient bound to have around uh is to sum these things because we're going to have algorithms that look like for every vertex for every neighbor do something so we might as well know kind of roughly how much time that's going to take um let's think about this so what do we know in an undirected graph every Edge is adjacent to two vertices right so if we think about how we account for degree what do we know well we know that an edge sort of contributes to the degree of two different vertices right so if we think about it uh carefully here what we're going to see is that uh if our graph is undirected oh oops sorry is that right wait I'm backward again so if I have a graph with two vertices and one Edge and it is undirected notice that the number of edges here is is one what is the the sum of the degree well it's 1 + 1 equal 2 yeah so there's a two here if uh my my graph is undirected and E if my graph is directed if what I'm counting is just the outgoing degree that Mak sense I think I managed to totally botch that sentence so maybe let's let's try that again so if I'm counting just the number of edges pointing out of every vertex and I count that over all of the possible vertices then there's two cases right one is directed and one is undirected right so in the undirected case you get a two here because essentially every Edge is simultaneously ingoing and outgoing whereas you get a one as a coefficient in the directed case that make sense I'm sorry I botched that for a second okay excellent okay so that's going to be a useful Bound for us uh later on now we think about graphs of course we just spent the last couple weeks thinking about data structures we should think about how to store a graph on a computer and there's many different options uh in fact uh really one thing that you can do is sort of pair just like when we talked about sets uh right there are many different ways to store sets and and one way to think about it was depending on how we're going to interact with that set we might choose one data structure or another to sort of optimize the uh types of of of interactions we're going to have with that set and make them as fast as possible there's exactly the same story uh for a graph right so for instance the world's dumbest representation of a graph would be to just have a long list of edges right so for example uh for this graph uh up here maybe I have you know 01 that's an edge and then 0 two that's another Edge and then one two and then 2 one there's a big list of edges really set I don't care about the order first one is one Z One Z oh you're right I'm sorry yeah the edge points up thanks Eric or not Eric Jason okay so let's say that I have a graph algorithm and I'm going to have to do something like check whether there exists an edge from V to w a bunch of times how long is that going to take in in this data structure well if I just have like a hot mess disorganized list of edges and I want to know does there exist an edge from V to W All I Can Do Is Write a for Loop that just goes along this set and says like is this Edge what I'm looking for no is that the edge I'm looking for no right so every single time I want to find an edge it's going to take me time proportional to the number of edges in my graph which could potentially be up to to V squ yeah so this is not such a great representation of a graph on my computer right so if we're thinking back at our our data structure we might say okay so an edge list is probably not the way to go although notice that the way we notated like what is a graph kind of looks like an edge list uh but in any event uh the the the more common thing to do is to sore something like an adjacency list so uh right so the basic idea of an adjacency list is that what I'm going to store uh is a set that Maps a Vertex U to everything adjacent to you right so in other words I'm just going to keep track of all the outgoing edges from every vertex and now I have to decide how am I going to store this object and often times we're going to have to answer queries like does there exist an edge from V to W right so how could I do that first I would look up V and I get back sort of a list or set of of all the things that are adjacent to V and I have to query that thing and I want it to be pretty fast so maybe what I do is I store uh the set of adjacent stuff as something like a uh direct access array or a hash table um to make that look up uh fast so for example uh how long would it take I see I'm going to finish the sentence here uh how long would it take me to check if an edge exists in my My Graph well what would I do I would first pull out this object and then I look inside of here right so if I stored this as a hash table than an expected time I would have order one look up right because this is order one and then you have another order one look up there so we went from v^2 to to one with one simple trick yes that's a great question um so there's a design decision here I'm sorry in my head I think a lot about undirected graphs and I'm going to make this mistake a lot and I'm glad that you caught me um there's a totally reasonable thing to do which is maybe just to keep track of the outer edge the outgoing edges for every vertex this is a design decision for an algorithm maybe I want to keep track of the incoming edges what whatever I just have to make sure that it aligns with what I want to do with my graph later yep excellent point sorry as as a geometry person we rarely encounter directed graphs uh but it's important to keep remembering that not everybody works on the same problems that I do okay um now if I wanted to be totally extreme about it uh as as just a third example of representation which actually in some sense you could think of like an adjacency list be an adjacency Matrix where now I just keep like like a giant v byv array of like does this Edge exist Does that edge exist um now it's really really easy to check if an edge exists but now let's say that I make a graph algorithm that's going to have a for Loop over all the neighbors of some vertex right so here that if I wanted to Loop over all the neighbors of you I could do that in time proportional to the number of neighbors of you but if I just have a big adjacency Matrix just a bunch of binary values like for pair of vertices are these vertices adjacent yeah or nay if I want to iterate over all my neighbors now I have to iterate over all the vertices and check is that number one and then do something so actually that can incur some additional time and additional space does that make sense so in any event that's a sort of the Lazy Man's graph representation I use it a lot when I'm coding uh because adjy matrices are easy to work with but it does incur a lot of additional space uh and it's not always the most efficient thing even if you have the space because iterating over neighbors is actually can take quite a bit of time okay so the the real point of our lecture today uh is to start introducing sort of the canonical problem that we all worry about on graphs which is Computing paths in particular shortest paths uh so the first thing we should do is is of course Define what a a path is on a graph so we're going to think about our graph like a road Network right let's think of maybe every node here as an intersection right so this is a roughly Kendall Square see it's a it's a square um but in in in any event uh let's say that I want to find uh maybe question one would be you know does there exist a way to get from vertex one to vertex 3 and then a better question to ask would be does there exist a short way to get from vertex one to vertex 3 then of course the first thing I have to do is Define my enemy I have to Define what I'm looking for which is a path so a path is nothing more than a sequence of vertices in a graph where every pair of adjacent vertices in that sequence is an ed I think it's all with our intuition of what a a path is in a graph so for instance here's a path P equals V1 V2 V3 so notice that there's an edge from V1 to V2 and also an edge from V2 to V3 so it satisfies the assumptions set forth on our definition what would not be a path in our graph would be like V1 comma V3 right because there's no Edge there okay so if we talk about paths uh then there's a very natural uh notion which is the length length I guess you could think of like the number of vertices in your path minus one or uh the number of edges that your your path traverses those are the same thing right so for instance the length of the path P here is two everybody see that a very common coding bug that I encounter a lot is adding one to that number by accident um because of course there's one more vertex in your your path than there are edges okay and and there are many different uh there could be potentially more than one uh path between any pair of vertices so let's say that I have an undirected graph uh that looks like the following so it's just a square plus a diagonal so here are nodes right so then a perfectly valid path from the lower left to the upper right be to go one over and one up but of course there's a more efficient way to get from the lower left to the upper right which is to go across the diagonal and so when we talk about the shortest path is nothing more than the length of the path that has the fewest number of edges or vertices in it between any pair of vert uh vertices in My Graph okay so this is our enemy this is what we're after is Computing the shortest uh uh path between vertices in a graph uh and and this is a thing uh that that we'll be talking about quite a bit in this course because of course it's a very practical matter right like when I saw want to solve routing problems I want to like move packets on my network I prefer not to well unless I'm doing tour I'd prefer them you know not to hit too many uh computers in between uh then maybe I want a a shortest path or or uh you know on a Surface maybe I want to uh you know move information in a way that's not too far away but of course there's sort of many variations on that theme when we talk about uh shortest paths or even just existence of a path right so these are three sort of model problems that we might solve on a graph right so the first one uh which in this course we're calling single pair reachability would the idea that I take two vertices s and t on my graph G and I ask you does there exist a path between s and t so what would be the sort of extreme example where uh uh this gra this problem may not always give back the answer yes right like in somehow in our head I think we think of all graphs as being connected right but a perfectly valid graph the way we defined it would be like 10 vertices and no edges right this this function would be very easy to code if that were the only graph you ever cared about uh but but in any event uh the existence of a path uh is already a query that that takes a little bit of algorithmic thinking we haven't we haven't figured out how to do that yet right now another problem we can solve be the shortest path right given a graph and two vertices we might say well how far apart are these vertices in My Graph uh if I I want to use the shortest possible distance from one to the other notice that I can use the second problem to solve the first one right because what's the shortest the length of the shortest path between two vertices that don't have a path between them infinity or shrug that's actually a totally valid answer yeah um that's right so how could I implement the reachability code well I could call my shortest path code and it gives me Infinity then I return no it's not reachable and if it gives me not Infinity I return yes right so remember that a key idea in algorithm's class is this idea of reduction that I can like use one function to solve another right so in this case if we can solve shortest path then we can certainly solve uh the reachability problem by calling that that piece of code and then finally we could talk about single Source shortest path so notice now that there's only one input node here s so what this problem is saying is give me the length of the shortest path from s to every single other vertex in my graph that make sense so like maybe I return a big array with all the information every single shortest uh distance so can we solve single pair shortest path using single Source shortest path absolutely right I could you know take s in my single pair shortest path problem compute the shortest path from s to literally everything else and then throw away all that information except the shortest path to T and and and and now I'm good now I haven't Justified that this is the fastest possible way to solve that second problem but at least it shows that if I can solve problem three I can also solve problem two if I can solve problem two I can also solve problem one so uh in today's lecture we're just going to worry about uh problem three in other words these things are sort of listed in in increasing order of their their difficulty okay so in order to think about the single short Source shortest path problem we're going to make one additional construction uh and this is an idea uh called the shortest oops the shortest path tree I got lazy drawing PowerPoint slides at 2 a.m. yesterday and and instead uh thought i' I'd draw a picture on the board so uh let's uh draw a graph so here we have a a b I'm going to use letters instead of numbers to refer to nodes from now on because I don't want to confuse the length of the shortest path of the index of my uh my node uh so here's a b c I'm going to match my notes Here d e f here's a graph again undirected because your instructor likes to think about undirected graphs but I know I'm going to get feedback that I shouldn't have done that later uh but in any event uh let's say that I want to compute the shortest path from a to everything else or the length rather so first of all even without talking about an algorithm I think it's pretty easy to guess what it is right so clearly the shortest path from a to a has length zero the shortest length from A to B is one from a to c is two right because I can follow these guys now it gets complicated it branched you know so the next uh shortest path has length three and then four like that does everybody agree with me that the numbers I've decorated here are the length of the shortest path from a to everything else but what have I not done I haven't told you how to actually compute the path I'm just giv you the length of the path right so I might want a piece of code that in addition to doing single Source shortest path length also gives me single shortest single Source shortest path so initially when I think about that I might think about well how do I even write down a data structure that can store all of those paths right well every po path could have like V vertices in it right like it could be the for whatever reason my there's like a lot of branching in My Graph and all the paths are super long actually I guess I have to think about whether branching would make them them longer or shorter uh but but in any event I could have a really boring data structure that just for every single vertex keeps track of the shortest path from a to that vertex how big would that data structure be well if the only bound I have on the length of a path is that you know certainly most it takes all the vertices in My Graph right then any One path will take V Space so that would take v^ s space total that wouldn't be so good right because somehow I have an amount of information on my graph currently that's linear right it's just the length of the path if I want to actually reconstruct that path initially it sort of spiritually feels like I need way more space to do that um but the answer is that we actually don't that we're going to only need linear space and the idea for that is to store an object called the shortest path tree yes [Music] so the question was about recursion we haven't actually written down any graph algorithms so we're going to defer on that and until until we actually recurse uh and then we'll think about it more carefully yeah but it's a totally reasonable question there are plenty of recursive graph algorithms out there uh and and and then we'll have to uh do our our accounting very carefully for sure right so uh instead uh we're going to Define an object called the shortest path tree and the basic trick here is to say well how did I get from a to c well there's always a Vertex which is its predecessor on the shortest path and shortest paths have this really beautiful property right which is that the shortest path from a to c if I truncate it right so like it goes A to B to C then the truncated one is also the shortest path to that previous vertex right so so let's think about that a little bit because that sentence was as usual poorly phrased by your instructor so let's say that I have the shortest path from a to d which is is is very clearly A B C D I think we can all agree and now I take like this subl list I just look from a to c is there ever a circumstance when this is not the shortest path or a shortest path from a to c no right because if it were right if there existed a shorter path from a to c I could like splice it in here and find a shortest path from a to d you see that so based on that reasoning rather than storing like this giant set of shortest paths sort of actually applying in some sense this recursive uh uh uh suggestion uh instead I can just think of the one vertex that's before me in my shortest path I'm going to trace backwards so let's take a look at our graph here essentially the object to keep track of of is like a predecessor right so what is the predecessor of f on the shortest path it's actually either D or E it doesn't matter in this case so maybe the the predecessor is e for fun right what's the predecessor of e well clearly the previous Edge or vertex on the shortest path is C similarly for D now we have b and a have a bunch of arrows that point this way right so for every vert I'm just going to St an arrow pointing toward the previous vertex on the shortest path I'm not going to store the whole shortest path just the very last Edge so first of all how much storage does this take takes V Space do you see that or the size of the vertices space because every vertex just has to store one thing which is the previous vertex on its shortest path yeah now what is my algorithm for tracing shortest paths it's really simple right I just start walking along these edges all the way until I get back to a now this object is called as shortest path tree notice I snuck in one additional word which is tree why is that can I ever have a cycle in this graph wouldn't really make any sense right these are shortest paths you should be able to kind of follow the gradient back to the uh original uh vertex okay so in other words uh I'm going to basically decorate my graph with one additional thing we'll call it P of V which is the previous vertex on the shortest path from my source point to my vertex V and what I think I've I've tried to argue to you guys today is that if I have this information that's actually enough to reconstruct the shortest path I just keep you know taking P of v and then P of P of v and then P of P of P of v and so on which sounds more complicated than it is uh until I I trace back to my original vertex and this object uh conceptually is called the shortest path tree any questions about that yes I had an edge I connected a to d okay ah okay so the question was let's say that uh our colleague here added an edge this is a great question you know somebody was evil like my adversarial neural network STI an edge here because it was adversarial and it wanted my shortest path code to fail and now somehow the the tree that I gave you is is no longer correct and my answer to that is yes why is that well by adding this edge here my the length of my shortest path changed right the the shortest path from a to d is now one so this tree is no longer valid I need a new tree so now what would be the uh the previous like P of of of D here well rather than being C it would be a yeah so that's absolutely right and it actually is reflective of an really annoying proper property of shortest paths which is if I add one Edge to My Graph the length of the shortest path to every vertex can change well I guess with the the exception of the source vertex yeah uh and and uh that's actually a really big headache in certain applications so uh for instance and then I'll shut up about applications and and do math again um I work a lot with 3D models and there's a big data set of 3D models of like ballerinas and ballerinas are really annoying because sometimes they put their hands together like that and then suddenly the shortest path between your fingers goes from like your entire body to like zero and so incremental algorithms for computing shortest path can can fail here right because I have to update like everything if I accidentally glued together uh fingers like that yeah um so anyway I'll let you think about how you might fix that problem and if you if you want to know more you should take 683a yes if you change your Source node the shortest paths would change again yeah so this is going to be one of these really boring things I'm going to keep answering like anytime I Chang anything about my problem I changed my source I changed my edges I have to just recompute all the shortest paths there are obviously algorithms out there that don't do that uh but we're not going to think about them yet okay so as usual I've talked too much and left myself about 10 minutes to uh do the actual algorithm that's interesting uh in in the lecture here although actually it's really not so complicated so I think we'll we'll do okay which is how do I actually compute chtis paths yeah and the basic thing we're going to do is is sort of build on this this tree analogy here we're going to Define one more object which I really like actually I I enjoy this from from Jason's notes because it looks like calculus and I I enjoy that um and and that's uh an idea of a level set and so this is a whole set of things L subk and these are all the vertices that are distance K away from my source right so for instance if my source vertex in in this example is the vertex all the way on the left then l0 obviously contains just that vertex right L1 is the the next one L2 is the third one but now L3 is a set of three vertices right because those are all the things that are distanced three away from the source that's what i' I've labeled in pink here okay so that's all that this uh this notation uh here means oh oops I've made a slight typo because in this class distance is Delta and not D but whatever the shortest distance the shortest distance that's absolutely right so for instance I could have a very long distance from l0 to L1 right I could just flip back and forth between l0 and L1 maybe go over to L4 and then go back uh that that wouldn't be a terribly helpful thing to compute that's absolutely right yes ah the red background is the set l so for example L3 contains these three vertices because they all the things that are distance three away from the left I got a little too slick drawing my uh my diagram like late last night I'm kind of proud of it okay so essentially if I wanted to compute the length of the shortest path from vertex all the way on the left to all the other vertices um one way to do that would be to compute all these level sets and then just sort of check what level set I'm in right uh so we're going to introduce an algorithm called breath ver search which does roughly uh that so uh breath ver search the way we'll introduce it today uh is going to be an algorithm for computing all of those level sets L subi uh and then from that we can construct the length and and even the uh the shape of the uh the shortest path so now I'm going to move to my handwritten notes okay and here's what our algorithm is going to do I'm going to write it in a slightly different way than what's in the course notes and on the screen but but only slightly um so first of all one thing I think we can all agree on is that level set zero oh that's cool this chalk bifurcated uh it contains one node what should that node be the source right because the only thing that's distance away zero away from the source is the source node yeah okay uh and uh in addition to that we can initialize the distance from the source to itself everybody on three what is the distance from the source to itself 1 two three zero thank you see you're waking up now it's it's getting it's almost 11 12 what time is it almost 12 okay and then finally uh well maybe initially we don't really know anything about the array P so we just make it empty right cuz P of of the source is somehow doesn't matter right because once I've made it back to the source I'm I'm done Computing shortest paths so we're going to write an algorithm that computes all the level sets and fills in this array p and fills in the distances all in one big shot we're going to call it breath first search Okay so let's do that so we can use the notation uh here and notice that there's basically an induction going on right which is I'm going to compute level set one from Level set zero level set two from Level set one and so on until I filled in My Level sets does that make sense uh so uh here's a slightly different way to uh notate the same thing I'm going to use a while loop which I know is like slightly non- kosher uh but that's okay um so I'm going to initialize a number I to be one this is going to be like our counter I'm going to say while the previous uh level set is not empty meaning that potentially there's a path that goes through the previous level set into the next one right because as soon as one of my My Level set is empty notice that all the like the LI for even bigger I are also going to be empty there's like never a case when there's something distance not distance I but then distance like i+ 5 okay so now what am I going to do well let's think back to our graph right so like now I know that this guy is distance zero away that's what I started with so now I'm going to look at all the neighbors of this vertex I'm going to make them distance one away that make sense and similarly here this guy's distance too and eventually I'm going to get in trouble because maybe well what's a good example here I won't even try to draw uh I could run into trouble if I don't want to add a Vertex twice to two different level sets right once I've I've put it in Li then I don't want to put it in like Li I + 5 because I already know that it's just since eye away does that make sense okay so what I'm going to do is I'm going to iterate over all the vertices in my previous level set and now I'm going to look at every vertex that is adjacent to you because what do I know I know that if I can get to U in I minus one steps how many steps should it take me to get to any neighbor of you ey steps right because I can go through the path which is length IUS one add one additional Edge and now get to that new guy right so what can I do I can iterate over all V which is in the adjacent uh set of of of U but I have to be a little bit careful because like what if I have an edge backwards so like for instance here I have an edge back to the source I guess this is yeah that's a valid example like I wouldn't want to add the source to like the third level set because I already added it in a previous guy right so I want to get rid of the Union of all the previous level sets of uh does that make sense so in other words I'm only going to look at the adjacent vertices that I haven't visited yet in My Level set computation algorithm and now all I have to do is update my arrays right so in particular I'm going to add vertex V uh to level set I CU I haven't seen V yet I'm going to set the distance from s to v um equal to I right because uh I'm I'm currently filling in My Level set I uh and then finally what is p of V what is the previous vertex to V in my shortest path from my source it's you right because that's the guy in the previous level set that I'm building my path from right going to say that to you and then sorry I ran out of space but I also have to increment I okay so what does this algorithm do it's just building one level set at a time we go back to our picture right so it starts by initializing l0 to just be the source vertex then it looks at all the edges coming out of that in that case just one makes that length one and so on right and so this is just incrementally building up all these level sets now there's a pretty straightforward proof by induction uh that this uh algorithm correctly computes the L's the P's and the Deltas which is all the information that we need uh uh uh to compute the uh the shortest path I think you guys can do that in your recitation if you still need a little bit of pro uh induction uh proof uh practice here um and the final thing that we should check is what is the runtime of this algorithm I'm going to squeeze in there just at the last second here so let's take a look so first of all I did something a little oh oops uh no that's okay um in my algorithm actually in Step Zero I had to make an array which was the size equal to the number of vertices remember that in in 66 how much time does it take to allocate memory yeah it takes the amount of time proportional to the amount of memory that I allocate right so already that's I see your hand but we're low on time so we're going to make it to the end um already we've incurred V time right because our our shortest path array takes V space but in addition to that we have this kind of funny for Loop where for every node I have to visit all of its neighbors now first of all do I ever see a node twice here no right because I'm going in order of distance and the second that I've seen a node in one level set it can't be in another right that's sort of our our basic construction here well conveniently for you guys we already proved exactly the formula that we need and if I'm lucky I didn't erase it yeah here we are if we take a look here this is exactly the scenario that we're in right because what did we do we iterated over all the nodes in our graph and then we iterated over all the neighbors of those nodes and that's the basic computational time in our algorithm so that for Loop or that while loop rather in my code is incurring time to the number of edges so what is the total runtime for for breath first search well we need to construct that array even so just in Step Zero we've inquired V uh time and then we have to iterate over something that takes at most the number of edges so overall our algorithm takes big O of mod V plus mod e time now notice that this is you might view this is kind of redundant by the way in this I have a little bit of equal with Jason but in this class we'll call this a linear time algorithm because it's linear in the space that you that you're using to store your graph I think that's a little fishy personally because this scales could scale quadratically in V but I digress um in any event uh right why do we need both of these terms here well notice that you know if I had no edges in My Graph right now this term is going to dominate uh but as I add a just to My Graph this thing could go up to v^2 right so this is somehow a more informative expression than just saying well at worst this is v^2 time does that make sense this is a slightly better formula to have okay so with that we just squeaked into the Finish Line we have an algorithm for computing shortest paths uh and I'll see you guys again I guess on Tuesday