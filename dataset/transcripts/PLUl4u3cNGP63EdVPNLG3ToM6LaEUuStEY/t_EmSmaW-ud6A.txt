welcome everybody to our lecture 14 of 6006 this is our last lecture on uh graph algorithms in particular the last lecture we'll have on weighted shortest paths uh but we're going to talk about a slightly different problem today uh different than single source shortest paths we're going to be talking about all pairs shortest paths okay but first let's review our single source shortest paths algorithms we had bfs dag relaxation dijkstra which we saw last time which you know gets pretty close to linear right v log v plus e is pretty close to linear it's much closer to linear than the general algorithm algorithm we have for solving single source shortest paths namely bellman ford which is a little bit more like quadratic this is like the difference between for sparse graphs this is like the difference between sorting using insertion sort and n squared and merge sort in n log n for example right we're going to get a actually quite a big bonus for large input sizes by using dijkstra when we can okay today we're going to be focusing on this new problem called all pair shortest paths it's not really complicated instead of having a single source we are essentially wanting to give in an input is our weighted graph where we've got a graph v e and we've got a weight function from the edges to the integers right this is our general weighted graph we want our output to be something like the shortest path distance from u to v for every u and v in our vertex set right that's what we want to return now there's one caveat here that if if there's a negative weight cycle in our graph in other words if any of these delta uvs is minus infinity there's a negative weight cycle in our graph so unless i guess or abort if g contains a negative weight cycle okay so we're not actually going to worry about negative weight cycles in today's class if we have a graph it could have negative weights right these are any integers could include negative weight edges but as long as all of our path distances are you know bounded from below none of them are negative infinity we don't have any negative weight cycles then i want you to output all of the shortest path distances now in particular this output could any of these outputs needs to have size theta of v squared right because for every pair of vertices i need to return to you a number or infinity or minus infinity or something like that but we are not dealing with the case with minus infinity the output could have size this is a theta here it does have size v squared right but in particular it's at least v squared because i need to give a number for each pair of vertices and so we couldn't hope for linear time in the size of this graph for this problem right single source tortoise paths for certain versions of the problem we need to read the graph and so we need to use linear time but in this problem our output has quadratic size in the number of vertices so in a sense we can't do better than this right we can't do better than quadratic and it actually what's one way we could solve all pairs shortest paths by using stuff we've already done in this class that's why i put this slide up here right yeah we could just solve a single source shortest paths algorithm from every vertex in my graph you know that's seems like a stupid thing to do right it's almost brute force on the vertices but it's certainly a way we could solve this problem in polynomial time right and we could definitely solve it in order v squared e time using bellman ford right we just take the steps of bellman ford and deal with a graph on any set of vertices right we can do better than this we can do better than this for graphs that are special in some way right we can do v times v plus e v times linear if our weights are positive and bounded we can use bfs v times or if our graph doesn't have cycles we could use dag relaxation v times or if our graph had non-negative edge weights we could get basically v squared log v plus v times e right and that's actually not bad in sparse graphs this is what bellman ford would give us but if we had dijkstra's for example if we had all positive net edge weights or non-negatives sorry we could get v squared log v plus v v e time this is v times dijkstra okay so how do these running times compare this is v times bellman ford this is v times dijkstra in a spot let's let's just get a feel for this separation here if if we had a sparse graph where v is upper bounded by the number of vertices this one looks like v squared log v this one looks like v cubed and we need to spend at least v squared time right so actually this is really close to linear in the size of the graph just off by a log factor just like sorting would entail and this one would have a linear factor right in the sparse graph this would be a a linear factor worse than this instead of a logarithmic factor again this linear to log separation we don't want to have to do this running time if we don't have to right that's the name of the game and really all we're going to do in this lecture is try to solve how we can make this running time faster by doing something a little bit more intelligent than running a single source shortest path algorithm from every vertex okay uh how are we going to do that well we could let's see what are we doing right the idea here if we had a graph uh should my graph be directed or undirected i'm not sure let's see if we can make a directed graph okay so here's a directed graph why do i not care about undirected graphs can anyone tell me yeah it's because i don't care about undirected graphs because if i had an undirected graph i could detect whether it had negative weight cycles in in constant time all right sorry in in linear time i could just check each edge see if it has negative weight because a negative weight edge undirected edge is a cycle of negative weight so i could just if it has any negative edge weights i could return in linear time that it does and i can abort or it has only positive weights and i can still use dijkstra so that's all good so we're only concerned about needing to run bellman ford on directed graphs that potentially have negative edge weight okay so here's a graph let's see is this a graph that i want sure let's say we've got that direction and this direction okay say we have a directed graph like this and let's say this is s this is our source okay and we have weights being 2 sorry weights being 4 1 1 2 2 2 2. okay so this is an example of a graph we might want to run all pairs shortest paths on maybe we also have negative weights in this graph okay in particular this has a negative weight cycle i don't want negative weight cycles so i'm going to make this zero okay so this graph doesn't have negative weight cycles great that's true great all right so here's an example that we might want to compute shortest paths on there's no s in all pairs shortest paths but i'm going to be talking about a couple shortest paths from s in my next argument so i'm just labeling that uh vertex as s okay the claim the the approach we're going to do we're going to try to take a graph that has negative edge weights directed graph we don't know if it has negative cycles or not yet but we want to compute all pair shortest paths not in this running time but in this running time how could we do that well maybe it's possible that we can change the weight of every edge so that they're all positive but shortest paths are preserved so basically if a particular path like okay the shortest path from s to t here is one two three right i could change edge weights uh in this graph say for example if i changed 1 to 0 here that would still make this a shortest path right i haven't done i've reweighted the graph shortest paths have to be the same in this graph but now uh sorry yeah this is not a shortest path i'll make that minus two and then these both two and i think and this four man i really should have done my example beforehand okay so this still doesn't have negative weight cycles it has a negative weight edge but this path is longer than this path so when this was one this had length of three which was shorter than this path that is length four okay cool so this is the shortest path from s to t i could change weights in this graph for example changing two to three and one to zero that changed weights in my graph but shortest paths remain the same so maybe there's a way i could re-weight my edges so that shortest paths stay the same shortest paths are preserved okay so i'm going to put this back to where it was all right so idea make edge weights non-negative while preserving shortest paths okay in other words just re-weight the edges here so that shortest paths in g this is g after we rewrite we'll go to some graph g prime with the same combinatorial structure just different edge weights and we want shortest paths we want these weights to all be non-negative and we want shortest paths if there's a shortest path in g it continues to be a shortest path in the re-weighted graph that's the goal for today if we can do that transformation and this is non-negative then we're done right we're done because we can just run dijkstra v times on that new graph get the shortest path distances construct the shortest path tree from those distances and then traverse that tree in the original graph and compute shortest paths along that tree so that's that's the claim claim we can compute distances in g so we're going to restrict g prime to have with non-negative edge weights if we have such a g prime with non-negative edge weights we can compute distances in g from distances in g prime in v times v plus e okay which is smaller than our dijkstra running time right this is our dijkstra running time and this is smaller than that so that would be fine right what do we do we have our new graph g prime it has all positive edge weights so we run all pair shortest paths in here by just running dijkstra v times and then for each vertex s we have some shortest path tree to all the things that's connected to right we can look at that path in g this is the same combinatorial graph just with different edge weights we can look at that same tree i'm not going to be able to draw the exact same tree here okay but what i can do is i can just bfs or dfs along this tree and every time i have an edge because each one of these is a shortest path in this tree i can just compute every time i traverse an edge what its shortest path distance is in g in linear time for that vertex for that particular s i do that over all s's and i get this running time okay so that's the goal here all right so we first wanted to find we were wanting to make edge weights non-negative while preserving shortest paths because if we could do that we could solve our original all-pair shortest paths problem okay so this is the proof sketch but how can we do this but how it doesn't even seem like this could be possible generally right how can i just re-weight the edges and maintain that the shortest path trees are the same that seems like hard to do and in particular if there are there's a negative weight cycle in this graph it's impossible to do right so claim not possible if g contains a negative weight cycle okay the exclamation point is just my comment here so if g contains a negative weight cycle then in particular the shortest path distance or a shortest path in g right if this is g say we have a negative weight cycle directed cycle c here in particular the shortest path from this vertex on the cycle to this vertex on the cycle what is its shortest path it's infinite a shortest path is infinite around this cycle you just keep going around the cycle over and over and over again because it has negative weight right weight of c is less than zero strictly right that's what a negative weight cycle is okay so the shortest path a shortest path from s to t has infinite length and in particular is non-simple however so so shortest path from shortest path from s to t is non-simple but as we proved in the last lecture shortest paths in a graph with non-negative weights are what are simple right because they're exist shortest path trees so that's a contradiction so this is not possible okay so given a graph with negative weights but no negative cycle it's still not clear how we could find such a re-weighting of the graph can we do this well we're going to exploit a little idea here how can we transform the weights of a path well how what's a a silly idea i have this silly idea if i don't want negative edge weights in this graph uh this is messy in the back we got edge weights 1 minus 2 0 1 4 5 and 1. there's only one negative edge weight here what if i just added a large number or in particular the the negative of the smallest edge in my graph to every edge in my graph then i'll have a graph with non-negative weights fantastic why is that not a good idea well in particular if i did that to this graph if i added 2 to every edge the weight of this path which was the shortest path changed from weight three to weight nine because i added two for every edge but this path which wasn't the shortest path in the original graph it had weight four increased only by two now that is the shortest path or it's a shorter path than this one so this one can't be a shortest path right so that transformation sure would make all the edge weights non-negative but would not preserve shortest paths right in particular if i added the same edge weight to every edge i will bias toward taking paths that have fewer edges not just smaller weight okay so that first idea doesn't work right idea add large number to each edge this is bad uh makes weights non-negative but does not preserve shortest paths so this is a not a good idea bad idea is there any way you can think of to modify the edge weights in a graph in any way that will preserve shortest paths so here's a an idea for you which is kind of this critical step in johnson's and a lot of graph transformation algorithms if i have a vertex say this middle guy say v every path from v goes through an outgoing edge of v and every path going into v goes through an edge going into v i haven't said anything it is i've said very stupid things but that observation is critical here if i add a number or let me see if i got this right in terms of adding and subtracting if i add a number to all outgoing edges from a vertex and i subtract that same number from all uh from the weights of all of the incoming edges to that vertex then every path from v is changed by the same amount because every path from v goes through one of those outgoing edges and any path going into v has also changed by the same amount in particular it's changed by a negative whatever we added to the outgoing edges so such a transformation adding a number from all the outgoing edges from a vertex and subtracting that same number from all the incoming edges preserves shortest paths that's a claim idea this is a better idea given vertex v add i'm going to put this on two lines add weight h to all outgoing yeah outgoing edges and subtract weight to all incoming edges so that's the idea and the claim is this transformation you know shortest paths are preserved preserved under this transformation and why is that it's kind of the exact same argument that i had over there right proof consider any path in my graph right either if the path path could go through v many times or it could go through v net not at all if my path if i if i have a path in my original graph g then with pathway w of pi right this is my path it goes through uh v some number of times okay so i'm gonna say this is going from s to t if it crosses v if it never crosses v if it never it touches v the vertex that i transformed then i argue that the pathway is the same right because i didn't do anything to edges that are in this path alternatively this thing goes through v sometimes if it goes through v in the middle how has the weight of my path changed well it hasn't right because i added a number to all outgoing edges so there's an outgoing edge here with weight i've changed by way h and there's an incoming edge here that i've changed by weight negative h so these cancel out and you've got zero right so passing through a vertex doesn't change the weight of my path the only way i could change the weight of my path is if v is the start vertex or the n vertex right so it's possible that s is my vertex or t is my vertex well for any vertex for any path leaving v i will have increased the weight of that that that path by h right because i added away h to all outgoing edges so again while the path weight has changed since all of the paths leaving the have changed by the same amount a shortest path will still be a shortest path and same goes for t if t the n vertex is v i'll have subtracted h from all of my incoming edges which means that any path ending at t any directed path ending at t also changes by the same value and so shortest paths will must be preserved so shortest paths preserved so that's pretty cool transformation i can assign for any vertex such a transformation which affects all of the edges surrounding it right by by this h additive factor either added or subtracted so maybe and i can do this independently for every vertex right if shortest paths were preserved by me doing this to one vertex then if i do it to another vertex then shortest paths are still preserved and let's let's prove that real quick okay what i'm going to do is i'm going to want to do this to give me flexibility for changing all the edge weights in my graph to have this property i'm going to set or define a potential function h that maps vertices to you know integers so this is the potential h of v okay and then we're going to make a graph g prime based on above transformation for each vertex in v okay so i'm going to set a number an h for each vertex these are independent now and i'm going to add that potential to all outgoing edges and i'm going to subtract that potential from all incoming edges this transformation is going to preserve shortest paths let's let's actually be a little bit more rigorous that that's the case when we do this multiple times okay so claim shortest paths are still preserved all right well that's again not so difficult to see let's consider a path from s to t passes through a bunch of vertices i'm going to label these as v 0 to v k so that i can kind of number them all right this is v one here this is a directed path okay v one two three four four all the way up to k okay there are k edges in this graph right i claim to you that any path from v 0 to v k any shortest path from v 0 to v k remains the shortest path after i we everything in this way okay so let's say this is path pi and so it has weight w pi which is really just the sum of all of the edge weights from v i minus 1 to v i for i equals 1 to k right this is poor notation this is the weight of the edge from the i minus 1 to i right and we've got my indexes from 1 that's the first edge 2k which is the last edge right so that's the weight of my path the weight of my transformed path i'm going to do it down here it's a little iffy the weight of my transform path i'm going to say is the weight in this new re uh weighted graph g prime okay this weight of that same path right it's the same path is just going to be the sum of all of the re-weighted edges so i equals 1 to k of my original weight of my edge so from 0 i minus 1 to v i but what did i do this edge is out going from v i minus one so it's outgoing so i add that weight that that potential sorry but that edge is also incoming into v i right so when i reweighted the thing i got a subtraction of h v i okay now what happens here in the sum this term if i just took the sum over this term that's exactly my original pathway right so that's good but you'll notice that this sum has k terms and this sum has the subtraction of k other terms but most of these terms are equal right along the path all the incoming and outgoing edges cancel out right so we're left with only adding the potential at the starting vertex and subtracting the potential at the la final vertex right so we've got add h v 0 minus h v k and why is that good well that's good because every path from v 0 to v k starts at v 0 and ends at v k that's just that's how it is that's how we've defined paths going from v 0 to v k but every such path we transform the weight of that path by adding a con by adding a constant associated with the start and adding this value associated with the end and so every path going from v 0 to v k changes by the same amount right and so if this path p pi was shortest it's still shortest in the re-rated graph because i've just changed all paths between those two vertices by the same amount it's this is kind of like a telescoping argument here uh in in that kind of proof right so we have uh the weight changes right it could change but it changes all paths between these two vertices by the same amount which means that shortest paths are still shortest awesome okay so the name of the game here is now we have this really flexible tool right we have this tool where we can add or subtract weight from various edges but we have to do so in a kind of localized constrained way right we have to do the same thing around each vertex but it seems like a powerful transformation technique that maybe we can get this this thing that we want which is a g prime a re-weighting of the graph where all the edge weights are positive or non-negative so does there exist an h such that the weights are all positive what does that mean w prime uv right the weight in my new graph in g prime i want these modified weights right this modified weight of my graph i want each of these to be non-negative so does there exist such a thing huh well if i rearrange this equation a little bit this side i get something that looks like this h of v needs to be less than or equal to h of u plus the weight of some edge from u to v huh what does that look like that looks like almost exactly the definition of the triangle inequality right shortest path from some vertex here and the shortest path distance from the same vertex here this is just a statement of the triangle inequality right so if we can set these h's to be the shortest path distance from some vertex and those shortest path distances are finite and none not minus infinity then this thing will hold by triangle inequality and in particular if we were to re-weight the edges based on those values of h then we get new edge weights that are non-negative awesome okay but there might not be any vertex from which we can access which is which we can reach all vertices in the graph right in particular my graph might not even be connected right if i want this property i need all of these i don't gain any information if these things are infinite right i it's it exhaustively true infinity is i i don't even know how to compare infinity and infinity plus a constant i i don't know right so i need all of these things to be finite so how can i make those things finite so here's the next idea add new vertex s with zero weight edge to every vertex v in v right we take our original graph we add a new super node or auxiliary vertex s with a zero weight edge to every vertex in my graph right what does that look like this is like there's my original graph and now i have this vertex s but it has directed edges into all of the vertices with zero weight that's our picture and this new thing right i'm going to call maybe my s graph now all right and the claim is well now if i run some shortest path algorithm single source shortest path algorithm this time from s to compute the shortest path distance to all of the vertices the shortest path distance to each of the vertices can't be positive right because there's a zero weight edge so a minimum weight path is going to be no bigger than zero if it's finite then there's a finite length shortest path if it's minus infinity then there's a negative weight cycle in my graph and i can stop right okay so there are either two situations if delta sv equals minus infinity so i guess this is run single source shortest paths from s and really because this graph could contain negative edge weights and could contain negative cycles we can't really do better than running bellman ford here right from s to compute these paths if there exists in this new graph this gs if there exists a vertex that has negative infinite weight in the re-weighted graph sorry in the original graph g g hasn't been reweighted yet if there's a negative weight distance from s then it then there was a negative weight cycle in the original graph why is that well if this was set to minus infinity then there is some negative weight cycle in the graph right the worry is that that negative weight cycle was added to my graph by adding this vertex s but what do i know about vertex s it has no incoming edges right so no negative weight cycle could go through s right so any negative weight cycle was in the original graph and so i can abort abort yay otherwise what do i do well i know these shortest path distances here would satisfy the triangle inequality right so if i re-weight with h of v equal to delta s of v right if we set our potentials in our reweighted graph to be the shortest path distance from our super node s it satisfies the triangle inequality right and because there's no negative cycles all of these values are finite and then this re-weighting will lead to a graph with strictly or not strictly uh strictly no negative weights or uh non-negative weights okay great so that's basically it that's the idea behind johnson's algorithm it's really a reduction problem a reduction algorithm we're reducing from solving kind of signed all pair shortest paths graphs where their weights could be positive or negative and we're reducing to creating a graph that has the same shortest paths properties but only has non-negative edge weight so we're reducing from a signed context to a non-negative weight context right so johnson's algorithm what are the steps construct g s from g right just as up here right i make a new vertex s i put a zero weight directed edge from s to every vertex okay so that's the first step second step compute d s v for all v in v i e or e g i guess really it should be ie because i don't really have another option here but by bellman ford this is a single run of bellman ford here compute and then there are two possibilities if there exists a delta sv that's minus infinity then abort else make our we re-weight the graph according to this re-weighting scheme right by re-weighting each edge in my original graph to have weight our new weight which is our old weight plus our transformation now our transformation is now going to set hv to this delta sv right so i'm going to add delta s u and subtract delta s v that's our rewaiting scheme i'm just identifying hv with this shortest path distance here okay and i after i re-weighted that i can just solve all pairs shortest paths on g prime with dijkstra and then compute g shortest path distances from g prime shortest path distances right compute these distances from the other using this algorithm up here can compute distances in g from distances in g prime in linear time or sorry v times linear time linear time for each s for each vertex in my graph okay so that's the algorithm it's basically correctness is trivial right we already proved the whole part of this lecture the interesting part of this lecture was proving that if we had a transformation based on a potential function that changed outgoing edges in a symmetrically opposite way as incoming edges then that preserves shortest paths and then realizing that the triangle inequality enforces this condition that edge weights will be positive or non-negative under this re-weighting so we find shortest path distances from some other arbitrary vertex and set our potential functions to be those shortest path distance weights we do the re-weighting because that re-weighting preserves shortest paths which we already argued right then we can do then then this has positive edge weight so dijkstra applies and then computing this takes a small amount of time okay what is the running time of this algorithm so this part reconstructing this thing this takes linear time right i'm just adding i'm just making a new graph of the same size except i added v edges and one vertex okay computing doing bellman ford on this new modified graph that's just i'm doing that once that takes v times e time doing this check that that just take i'm looping over from my vertices that just takes v time otherwise doing this re-weighting i change the weight of every edge so that takes order e time and then solving g prime solving all pair shortest paths on the modified edge weight graph with dijkstra takes v times dijkstra right that's uh use a little bit more board space here that's v times v log v plus e time right which is actually the running time that we're looking for right i wanted to reduce to not using more than this time we used this amount of time let's make sure we still didn't use even more after that we compute these paths as proved before in v times v plus e which is smaller than that right and so summing up all of these running times this one dominates and so johnson's can solve signed weighted all pairs shortest paths signed all pair shortest paths not in v times bellman ford like we had before up here but faster in nearly linear for sparse graphs just without this log factor so we got a quite a big improvement right so that's the nice thing about all pair shortest paths is that really we don't have to incur this this big cost uh in the context of negative weights essentially we just run bellman ford once to see if there is a negative weight cycle in my graph if it is i save a lot of work by stopping early okay so that's johnson's that's the end of our graphs lectures we'll be having a review and problem session about how to solve problems graph problems using this material but we've we've talked about a lot of different things so far we've talked about graph reachability connected components detecting cycles detecting topological sore orders of a dag we've talked about finding negative weight cycles single source shortest path algorithms and now finally today all pair shortest path algorithms with a new algorithm that's really not a an entirely new algorithm right we didn't have to do any proof by induction here really the heavy work that's happening is we're reducing to using either dykstra or bellman ford to do the heavy lifting of finding single shorts shortest paths efficiently right so johnson's is really just glue to uh transform a graph in a clever way and then reducing to using some of these shortest paths algorithms faster okay so that's our unit on graphs our next lecture will start talking about a general form of not presenting you with an algorithm but how to design your own algorithm in the context of dynamic programming okay so see you next lecture