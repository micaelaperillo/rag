good morning everybody my name is jason kuh i'm going to be teaching uh this class in uh introduction to algorithms with uh two other instructors here uh faculty in the department uh eric domain and justin solomon uh they're excellent people and so uh they will be working on uh teaching this class with me i will be teaching the first lecture and we'll have uh each of them teach one of the next two lectures and then we'll go from there yeah so uh that's this is intro to algorithms okay so we're going to start talking about this uh course content now what is this course about it's about algorithms right introduction algorithms really what the course is about is teaching you to solve computational problems but it's more than that it's not just about teaching you to solve computational problems so solve goal one solve computational problems but it's more than that it's also about communicating those solutions to others and being able to communicate that your way of solving the problem is correct and efficient okay so it's about two more things uh prove correctness argue efficiency and in general it's about communication communication i can't spell by the way uh communication of these ideas and you'll find that over the course of this class you'll be doing a lot more writing than you do in a lot of your other courses it really should maybe be a ci kind of class because you'll be doing a lot more writing than you will be coding for sure so it's really imp of course solving the the computational problem is important but really the thing that you're getting out of this class and other theory classes that you're not getting in other classes in this department is that we really concentrate on being able to prove that the things you're doing are correct and better than other things and being able to communicate those ideas to others and not just to a computer right to other people convince them that it's correct okay so that's what this class is about so what do we what do i mean when i say solve a computational problem what is a problem what is an algorithm right i know people make fun of me because i start with this question but i mean anyone want to answer that question no what's a problem computationally no okay so it's not such a stupid question yeah something you want to compute okay yes that's that's true right but kind of a little bit more abstractly what i'm going to think of a computational problem being and this is where uh kind of your prerequisite and discrete mathematics should come in right it's a problem is kind of you've got a set of inputs inputs okay maybe i have uh one two three four five possible inputs i could have to my algorithm okay then i have a space of outputs okay outputs and maybe i don't know maybe i have more of them than i do inputs but these are the possible outputs to my my problem and what a problem is is a binary relation between these inputs and outputs essentially for each input i specify which of these outputs is correct right it doesn't necessarily have to be one right if i say give me the index in an array containing the value five there could be multiple fives in that array and so any of those indices would be correct so uh maybe this guy maps to that output and maybe this guy maps to i don't know two or three outputs right this input goes to one two i don't know there's a there's some kind of mapping here these edges represent a binary relation it's kind of a graph a bipartite graph between these inputs and outputs and these are specifying which of these outputs are correct for these inputs all right that's really the formal definition of what a problem is now generally if i have a problem and a computational problem i'm not going to specify the problem to you by saying okay for input 1 the correct answer is 0. and for input 2 the correct answer is 3 and so on and so forth that would take forever right usually what we do when defining a problem is specify some kind of predicate saying that oh we can check if i give you an input and an output i can check whether that output is correct or not that's usually how we define a problem is if i i'm checking for whether this index contains a five i can just go to that array look at index five and say or that the index you gave me and see if it equals five right so usually we're putting it in terms of predicates because in general we don't really want to talk about small instances of problems so let's say i had the problem of among the students in this classroom do any pair of you have the same birthday okay all right well probably if there's more than 365 of you the answer is yes right right that by what pigeonhole principle right two of you must have the same birthday right but so let's let's generalize it a little bit say that i don't know i need a bigger space of birthdays for this question to be interesting maybe i tack on the year maybe i tack on the hour that you were born and that's a bigger space of inputs and i wouldn't necessarily expect that two of you would be born in the same year on the same day in the same hour right that would be a little less likely in fact as long as that space is larger than something like the square of the number of you right then i'm less likely than then than even to uh to have a pair of you that that's a kind of a birthday problem you may have seen in uh 0-4-2 potentially right but in general i don't i don't i'm not going to mess with probability so much here i want a deterministic algorithm right a way of checking whether two of you have the same birth time let's say okay so uh in general in this class we're not going to concentrate on input such as is there a pair of you in this class that have the same birthday that's kind of boring right uh i i could just say well uh i i could do a lot of different things but what we we do in this class this is first a fixed classroom of you i want to make algorithms that are general to any classroom right to go to your recitation i want an algorithm that will apply to your recitation an algorithm that not only applies to this classroom but also the machine learning class before you right i want an algorithm that can change its it can accept an arbitrarily sized input right here we have a class of maybe 300 400 students right but i want my algorithm to work for a billion students right like maybe i'm trying to check if there's a match of something in the facebook database or something like that right okay so in general uh we are looking for general problems that have arbitrarily [Music] sized inputs right so these these inputs could grow very large but we want a kind of a fixed size algorithm to solve those problems okay so what is an algorithm then i really can't spell i told you okay i didn't lie to you um so an algorithm is a little different than a problem of problem specification i can state to you what this graph or i can tell you what this graph looks like an algorithm is really i don't know what the outputs are i don't know what these edges are but i want to i want a fixed size kind of machine or procedure that if i give it an input it will generate an output and if it generates an output it better be one of these correct outputs right so if i have an algorithm that takes in this input i really want it to output this output or else it's not a correct algorithm similarly if for this one it could output any of these three outputs but if it outputs this guy for this input that would not be a correct algorithm right and so generally what we want is a an algorithm is a function it takes inputs to outputs right an algorithm is some kind of function right that takes these inputs maps it to a single output and that output better be correct based on our problem okay so that's what our algorithm is uh it solves the problem if it returns a correct output for every uh problem input that is in our domain okay and the example for uh does anyone have a possible algorithm for checking whether any two of you have the same birth time as specified before i'm going to let someone else have a try sure just ask everyone one by one ah great so uh what your colleague has said is a great algorithm well essentially what it's going to do is i'm going to enter i'm going to put you guys in some order okay i'm going to give each of you a number one through however many number of students there are in this class and i'm going to interview you one by one right i'm going to say what's your birthday anytime we'll write it down right i'm going to put in in some kind of record okay and then as i keep interviewing you i'm going to find out your birthday i'm going to check the record i'm going to look through all the birthdays in the record if i find a match right then i return yay i found a pair and i can stop otherwise if i get through the record list i don't and i don't find a match i just stick you at the end of the record right i add you to the record and then i move on to the next person i keep doing this okay so that's that's a proposed algorithm for this birthday problem for birthday problem what's the algorithm here maintain a record interview students students in some order and what does interviewing a student mean it means two things it means check if birthday in record and if it is return a pair so return pair otherwise add a new student to record and then at the very end if i go through everybody and i haven't found a match yet i'm going to return that there is none right okay so that's a statement of an algorithm that's kind of the level of description that will be looking for you in the theory parts of this theory questions that we ask you on your problem sets right it's a verbal description in words that you know it's maybe not enough for a computer to know what to do but if you said this algorithm to any of your your friends in this class right they would at least understand what it is that you're doing yeah does an algorithm have to be a pure function mathematical pure function in the does a an algorithm have to be a pure function in the mathematical sense uh as in it needs to map to a single output so we're talking about kind of a functional programming definition of uh of a of a of a function right this is um i am talking about the mathematical i have a binary relation and this thing has an output for every input and there is exactly one output to every input that's that's the mathematical definition of function that i'm using for when i'm defining an algorithm yeah so basically is an algorithm like uh like a plan yeah an algorithm is a procedure that somehow i can do whatever i want but i have to take one of these inputs and i have to produce an output and at the end it better be correct right so it's just a procedure you can think of it as like a recipe you can think of it it's just some kind of procedure right it's a a sequence of things that you should do and then at the end you will return an output okay so here's a possible algorithm for solving this birthday problem okay now i've given you what i argue to you or i'm asserting to you is a solution to this birthday problem and maybe you guys agree with me and maybe some of you don't right so how do i convince you that this is correct right well if i had you know if i was just running this algorithm on say the four students in the front row here right i could argue it pretty well to you i could go through every you know i could assign these for people birthdays in various combinations of either their none of them have the same birthday some two of them have the same birthday i could try all possibilities and i could go through lots of different possibilities i had to check that this algorithm returns the right answer in all such cases right but when i have i don't know 300 of you that's going to be a little bit more difficult to argue and so if i want to argue something is correct in mathematics i want to prove something to you for some large value what kind of technique do i use to prove such things yeah induction right and in general what what we do in this class what we do is as a computer scientist is we write a constant sized piece of code right that can take on any arbitrarily large size input right if it's if the input can be arbitrarily large but our code is small then that code needs to loop or recurse or repeat some of these lines of code in order to just read that output right and so that's another way you can arrive at this conclusion that we're going to probably need to use recursion induction and that's part of the reason why we ask you to take a course on proofs and and inductive reasoning and discrete mathematics before this class okay so how do we prove that this thing is correct we got to use induction so how can we set up this induction what do i need for an inductive proof sure base case we need a base case uh we need some kind of uh a predicate yeah but we need some kind of statement of a hypothesis of something that should be maintained right and then we need to have an inductive step which basically says i take a small value of this thing i use the inductive hypothesis and i argue it for a larger value of my well-ordered set that i'm inducting over right okay so in uh for this algorithm if we're going to try to prove correctness what i'm going to do is i'm going to what do i want to prove for this thing that at the end of interviewing all of you that my algorithm has either already it has returned with a pair that match or if we're in a case where there wasn't a mat it wasn't a pair somewhere in my set that it returned none right that would be correct right so how can i generalize that concept to make it something i can induct on right what i'm going to do is i'm going to say let's say after i've interviewed the first k students right if there was a match in those first k students i want to be sure that i ever returned a pair right because if after i interview all of you i've maintained that property then i'll be sure at the end of the process i will have returned a pair if one exists so here's going to be my inductive hypothesis sis okay if first k students contain a match algorithm returns a match before interviewing say student k plus 1. okay so that's going to be my inductive hypothesis now if there's n students in this class right and at the end of my thing i'm trying to interview student n plus one oh student n plus one is not there if i have maintained this then if i replace k with n then i will have returned a match before interviewing the last student or the when i have no more students left and then this algorithm returns none as it should right okay so this inductive hypothesis sets up a nice variable to induct on right this k i can have increasing up to n starting at some base case so what's my base case here my base case is the easiest thing i can do sure two that's an easy thing i could do i could check those possibilities but there's an even easier base case yeah there's an even easier base case than one zero right after interviewing zero students i haven't done any work right certainly the first zero can't have a match right and so this predicate this inductive hypothesis is true just because this uh initial predicate is false right so i can say you know base case zero check definitely this predicate holds for that okay now we get to go for the uh the meat of this thing right assume the inductive hypothesis true for k equals say some k prime okay and we're considering k prime plus one right then we have two cases one of the nice things about induction is that it isolates our our problem to not consider everything all at once but break it down into a smaller interface so i can do less work at each step right so there are two cases either the first k already had a match right in which case by our inductive hypothesis we've already returned the correct answer right the other case is the it doesn't have a match and we interview the k plus one student the k prime plus one student if there is a match in the first k prime plus one students then it will include k plus k prime plus 1 the student k prime plus 1 because you know otherwise there would have been a match in in the things before it right so there are two cases if k contains match k prime if first k contains match already returned turn turn it by induction right else if k prime plus one students contains match the algorithm checks all of the possibilities k prime checks cape against against all students essentially by brute force it's a case analysis i check all of the possible possibilities right this check if birthday is in record i haven't told you how to do that yet but if i'm able to do that i'm going to check if it's in the record if it's in the record then there will be a match and i can return it otherwise i have uh re-established the inductive high policy hypothesis for the k prime plus one students does that make sense guys yeah okay so that's how we prove correctness this is a little bit more formal than we would ask you to do in this class all the time but it's definitely sufficient you know for the levels of arguments that we'll ask you to do the bar that we're usually trying to set is if you communicated to someone else taking this class what your algorithm was they would be able to code it up and tell a stupid computer how to do that thing okay so any any questions on induction you're going to be using it throughout this class and so if you're unfamiliar with this line of argument then you should go review some of that that would be good okay so that's correctness being able to communicate that the problem the algorithm we stated was correct now we want to argue that it's efficient right what does efficiency mean efficiency just means not only how fast does this algorithm run but how fast does it compare to other possible ways of approaching this problem right so how could we measure how fast an algorithm runs this is kind of a silly question yeah yeah just well i mean just record the time it takes for a computer to do this thing right now there's a problem with just re coding up an algorithm telling a computer what to do and timing how long it takes why yeah it would depend on the size of your data set okay we expect that but there's a bigger problem there yeah it depends on the strength of your computer right so i would expect that um you know if i had a watch calculator and i programmed it to do something right that might take a lot longer to solve a problem than if i asked you know ibm's research computer right to solve the same problem using the same algorithm even with the same code right because its underlying operations are much faster right how it runs is much faster so i don't want to count how long it would take on a real machine i kind of want to abstract the time it takes the machine to do stuff out of the picture what i kind of want to say is let's assume that each kind of fundamental operation that the computer can do takes some fixed amount of time okay how many of those kinds of fixed operations does the algorithm need to perform to be able to solve this problem right so here we don't don't measure time instead count kind of fundamental operations okay we'll get to what some of those fundamental operations are in a second but the idea is we want a measure of how well an algorithm uh performs not necessarily an implementation of that algorithm right kind of an abstract notion of how well this algorithm does and so what we're going to use to measure time or efficiency right is something called asymptotic analysis anyone here understand what asymptotic analysis is probably since it's in both of your prerequisites i think uh but we will go through a a formal definition of uh asymptotic notation in uh recitation tomorrow and you'll get a lot of practice in comparing functions using an asymptotic analysis but just to give you an idea right the idea here is we don't measure time we instead measure ops and like your colleague over here was saying before we expect uh performance i'm going to use performance instead of time here we expect that to depend on size of our input right if we're trying to run an algorithm to find a birthday uh in this section we expect the algorithm to run in a shorter amount of time than if i were to run the algorithm on all of you right so we expect it to perform differently depending on the size of the input and how differently uh is how we measure performance uh relative that input usually we use n as a variable for what the size of our input is right but that's not always the case so for example if we have a an array that i give you an n by n ray right that we're going to say n but what's the size of our input how much information do i need to convey to you to give you that information it's n squared right so that's the size of our input in that that context right or if i give you a graph it's usually the number of vertices plus the number of edges that's how big how much space i would need to convey to you that graph that information okay so you we compare how fast an algorithm is with respect to the size of the input right and if that we'll use the asymptotic notation we have big o notation which corresponds to upper bounds we'll have omega which corresponds to lower bounds and we have theta which corresponds to both right this thing is tight it is bounded from above and below by a function of this form okay now we have a couple common ways a com a couple common functions that algorithms their running time we have a couple common functions that uh relate an algorithm's input size to its performance some some things that we saw all the time does it can anyone give me some of those say again sorry sorry so like a function i'm not asking this question well but has anyone heard of a linear algorithm a linear time algorithm right that's basically saying that the side the running time of my algorithm the performance of my algorithm is linear with respect to the size of my input right yeah say it again like putting something in a list okay so that's there's there's a lot behind that question that we'll go into later uh this week uh but that's an example of if i do it in a silly way i stick something in the middle of a list and i have to move everything that's an operation that could take linear time right okay so uh linear time is is a type of function we've got a number of these i'm going to start with uh this one does anyone know what this one is constant time okay basically no matter how i change the input the amount of time this running time the the performance of my algorithm takes it doesn't really depend on that okay the next one up is something like this this is logarithmic time okay we have theta n which is linear and log n right sometimes we call this log linear but we usually just say n log n okay we have a quadratic running time in general if i have a constant power up here right it's n to the c for some constant this is what we call polynomial time right we're as long as c is some constant and this right here is what we mean by efficient in this class usually right in other classes right when you have big data sets maybe this is efficient right but in this class generally what we mean is polynomial and as you get down this thing these are things are more and more efficient okay there's one class i'm going to talk to you about over here which is something like uh let's do this 2 to the theta of n right exponential time this is some constant to a function of n that's say super linear uh that's going to be uh you know pretty bad why is it pretty bad if i were to plot some of these things as a function of n right let's say i plot values of up to a thousand on on my n scale here okay what does constant look like maybe this is a thousand up here too what does a constant look like looks like a line right it looks like a line over here somewhere it could be as high as i want but eventually anything that's an increasing function will get bigger than this right and on this scale if i use log base 2 or some reasonable small constant what does log look like well let's let's do an easier one what does linear look like yeah this right that's what i saw a lot of you doing okay that's linear that's the kind of base that we're comparing everything against what does log look like like this okay but on at this scale right at this scale really it's much closer to constant than linear and actually as n gets much much larger this almost looks like a straight line it almost looks like a constant so log is almost just as good as constant right what does exponential look like it's the exact inverse of this thing right right it's almost an exact straight line going up right so this is crap this is really good almost anything in this region over here is better right at least i'm gaining something uh i i'm not i'm i'm able to not go up too high relative to my input size so quadratic i don't know something like this and n log n is something like this and log n after a long time really starts just looking linear with a a constant multiplied in front of it right okay so these things good that thing bad okay that's what that's trying to convey all right so how do we measure these things if if i don't know what my fundamental operations are that my computer can can can use right so we need to define some kind of model of computation for what our computer is allowed to do in constant time in a fixed amount of time right in general what we use in this class is is a machine called a word ram which we you know use for its theoretical brevity all right word ram it's kind of a loaded term what do these things mean it means i have what can some does someone know what ram means random access memory right it means that i can randomly access different places in memory in constant time that's that's the assumption of random access memory basically what our model of a computer is is you have memory memory which is essentially just a string of bits it's just a bunch of ones and zeros right and we have a computer like a cpu right which is really small it can basically hold a small amount of information but it can change that information right it can operate on that information and it also has instructions to randomly access different places in memory bring it into the cpu act on it and read it back that makes sense but in general we don't have an address for every bit in memory every zero and one in memory we actually does anyone know how modern computers are addressed okay so so we're gonna get there actually what a modern computer is addressed in is bytes okay collections of eight bits so there's an address i have for every eight bits in memory consecutive eight bits in memory and so if i want to pull something in into the cpu i give it an address it'll take some chunk right and bring it into the the cpu operate it on it and spit it back okay how big is that chunk this goes to the the answer that you were asking which or saying which is it's some sequence of some fixed number of bits which we call a word okay a word is how how big of a chunk that the the cpu can take in from memory at a time and operate on okay in your computers how big is that word size 64 bits right that's how much i can operate on a time when i was growing up when i was your age okay my word size was 32 bits and that actually was a problem for my computer because in order for me to be able to read to address in memory i need to be able to store that address in my cpu in a word right but if i have 32 bits how many different addresses can i address i have a limitation on the memory addresses i can address right so how many different memory addresses can i address with 32 bits 2 to the 32 right that makes sense well if you do that calculation out how big of a hard disk can i have to access it's about four gigabytes right so when i in my day all hard drives were limited to you know being partitioned even if you had a bigger than four gigabyte hard drive i had to partition it into these four gigabyte chunks which you know the the computer could then read on to right that was very limiting actually that's a restriction with 64 bits what's my limitation on memory that i can address byte addressable turns out to be something like uh 20 exabytes to put this in context all data that google stores on their servers on all drives throughout the world it's about 10 right so we're not going to run out of this limitation very soon right so what do we got we've got a cpu it can address memory what are the operations i can do in this cpu i have binary operations i can compare two words in memory and i can either do you know integer arithmetic kind of logical operations bitwise operations but we're not going to use those so much in this class and i can read and write from an address in memory a word in constant time those are the operations that i have available to me on most cpus some cpus give you a little bit more power but this is generally what we analyze algorithms with respect to okay but you'll notice that my cpu is only built to operate on a constant amount of information at once generally two words in memory an operation produces a third one and i spit it out right it takes a constant amount of time to operate on a constant amount of memory if i want to operate on a linear amount of memory end things how long is that going to take right if i just want to read everything in that thing it's going to take me linear time right because i have to read every part of that thing okay so in general what we're going to do for the first half of this class mostly first eight lectures anyway is talk about data structures and it's going to be concerned about not operating on constant amount of data at a time like our cpu is uh doing but instead what it's going to do is operate on store a large amount of data and support different operations on that data okay so if i had a record that i want to maintain to store those birthdays that we had before i might use something like a static array right which you guys maybe are not familiar with if you have been working in python as your only programming language okay python has a lot of really interesting data structures like a list and a set and a dictionary and all these kinds of things that are actually not in this model there's actually a lot of code between you and the computer and it's not always clear how much time that interface is taking right and so we're going to do starting on thursday is talk about ways of storing a non-constant amount of information to make operations on that information faster so just before you go i just want to give you a quick overview of the class to solve an algorithms class in algorithm problem in this class we essentially have two different strategies we can either reduce just to using the solution to a problem we know how to solve or we can design our own algorithm which is going to be recursive in nature we're going to either put stuff in the data structure and solve a sorting problem or search in a graph and then to design a recursive algorithm we have various design paradigms this is all in your notes but this is essentially the structure of the class we're going to spend quiz 1 the first to eight lectures on data structures and sorting second quiz will be on shortest paths algorithms and graphs and then the last one will be on dynamic programming okay that's the end of the first lecture thanks for coming