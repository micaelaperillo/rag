uh welcome to our fourth problem session uh we're going to be talking about binary trees mostly today we'll talk a little bit about binary heaps which is a topic we won't cover until next tuesday but it will appear in a very small ways on your problem set four which will be due next friday so i'm going to go over a little bit of that material today but it's mostly concern the the subject material for today is mostly uh binary trees specifically being applied to set data structures and sequence data structures as uh professor domain talked to you earlier this week um but for now uh actually as of yesterday you've seen all of the data structures that we're going to cover to imp that that will implement the set interface and the sequence interface right those uh those nice tables that uh professor domain has been showing you right uh those are now complete right we have uh some data structures that are really good constant time operations for some operations so we might choose them for some uh applications and this week we've been describing to you trees which achieve like really pretty good for any type of query operation on my sets or sequences pretty good meaning logarithmic time not quite constant but for our purposes log n is i mean on your computer practically right not asymptotically but practically log n is going to be at most what on your computer something like 64 right any input that you're operating on with uh and machine words as your input right uh you need to be able to address all those machine words right in in your input and on your computer the size of your machine word addresses is 64 bits right and we assume that the word size is at least log in the num the size of your input so that you can address the input right right so for your purposes on your computer log n is going to be no more than 64 which means you get a maybe a 50 times overhead or you know for smaller instances it could be more like 10 right if you've got like a thousand things that you're working on right it's not that bad right it's a constant it's not a constant factor for theory purposes but for your purposes log n is much better than a than a polynomial factor right another factor of n okay so uh you've seen all the code you've seen implementations of all of these set and sequence interfaces right so i went ahead and wrote a little i compiled all of that code from your recitation notes of all of the different interface implementations and what i did was i wrote a little test program to see how they ran on a real machine right so i have a little test code here um right so i have a little folder that lists you know an array implementing a sequence a binary tree implementing a sequence a dynamic array implementing all these kinds of things right then set things a sorted array being a set and a binary tree and a hash table right these are our implementations i'm not using python dictionaries for hash tables i'm using the implementations that are in your restation and i'm going to run this little test efficiency python code that basically is just gonna for each one it's gonna do a bunch of these different operations and measure to see how much time it took right i'm just logging how much time it took it's not an asymptotic analysis but you know hopefully we see some separation yeah so i'm going to press that it runs a bunch of tests so let's take a look uh okay so i got a bunch of sequence operations right we got build set at get at insert delete at the various places right and i'm giving these are the actual timings to some scale right to some resolution that i had for these data structures and you can see build actually build on this machine just allocating some array and clearing it is a really efficient thing that's python's going to do for me and so that's actually it's miss labeling that as log n right uh but uh you know these other things get out and set act really really fast right that's constant time and then these other things i essentially have can't do better than loop through the thing and so it takes linear time and again sequence uh stuff setting at and getting at is slow but deleting and removing from the first thing i'm just re-linking the pointer right dynamic arrays again set at get ad is fast because it's just dynamic it's just regular arrays and then inserting and deleting last that's getting the essentially constant time now i'm actually when i'm running these tests to deal with averages i'm actually running these things a lot of times and testing their performance and so i'm not seeing the worst case happen here right i'm averaging over all of the things which is exactly what amortization means and so that's why i'm getting good performance here uh a hash table again really uh oh so this is what we talked about in problem session last week right implementing a uh kind of a double-ended queue with a hash table uh this is that implementation i just want to show it to you but it's actually pretty good this is what javascript uses for arrays and then a binary sequence represents a binary tree right a balanced binary tree this is our avl code that i had and you know all the other things have been really pretty bad at insert at and delete at but this one does comparable to all the other things now you see these are a little bit more you know machine cycles than the other things but you know not so bad actually uh and then on the set side of things again we had a sorted array uh sorry this is a set from an array basically it's an unsorted array i'm just looking for all the things that's very bad times sorted array does these fine operations great but inserting deleting is poor right that's why we need binary trees hash tables you know get good kind of dictionary operations but really bad order operations right and then the binary search tree right a set binary tree uh again does quite good on all of these things in fact it's getting really quite good it's getting better for some reason than these the sorted array even did so uh i don't know why our implementations are not optimized at all but it does pretty well asymptotically yep um could you explain again why the in the first day of surgery was blog this is just labeled based off the timings right it happens to be that probably there's a c intrinsic underneath python that allocates this thing and so it does it really fast and so my program that's looking at these numbers and trying to guess what the asymptotic running time is these are just labels based on these things ranges i just it's it's mis characterizing actually building it at any time yeah well i mean in in actuality if it was c code right if all of this stuff was in c probably we'd see that that bar be longer because it's actually having to go through and touch all that memory it's still doing that here but all the python stuff is super crafty right it's like 100 times slower than anything that c does and so you're seeing that that disparity here does that make sense okay so i just wanted to show you that uh we might release this for you to play around with but i just wanted to give you a taste of that okay any questions you move on how do i turn this off up and off shut down [Music] yes okay so what all right so moving on to problems working some problems uh so you have your set of problems here uh the first one is we're going to look at a sequence avl tree right this is a sequence abl tree how do i know that you don't necessarily but these things are certainly not in sorted order of the things i'm storied in them right so it better not be a set avl tree right is it an avl tree is it balanced height balanced yeah yeah basically actually if you take compute the size of each subtree right the left and right sub-trees on all these you can confirm for yourself are balanced right there they're within plus or minus one of each other actually this is about as far away from balance as you could get for this many nodes uh while still maintaining hype balance maintaining avl property which is why this is an instructive example it's kind of at the limit okay and uh what am i going to do this is a see what's missing in this picture if i'm claiming this is a sequence avl tree any ideas what's missing what is the sequence avl tree store that i'm not showing in this picture what counts and it's a sequence avl tree heights right so it's a sequence avl trees different than set available trees are augmented by two things right because i need to be maintaining balance during rotations and so i need to store heights i need to be able to tell what the heights of these sub trees are in constant time when i'm walking up the tree fixing things and the sequence requires me to store their subtree the numbers there right so i don't know i'm not going to draw it for all of these things but how about for number 4 what's its height one two three that's the longest path from the sub the root subtree of that so this is you know height equals uh three that came from height equals two and height is one let everyone see that yeah and then the size here how big is that that's one two three four five six seven right so this is i'm gonna put size equals seven here right and that's coming from this guy one two three four and this guy is two right so how do i compute the subtree size it's my left subtree size plus my right subtree size plus 1 right and my height is taking the max of the 2 plus 1 right all right so we did all that yesterday so i'm just labeling these things and what i'm asking of you is to perform a delete operation is a sequence uh tree so i'm i'm finding things by their index in the tree right so i'm going to ask you to delete the eighth thing in my sequence okay so what is the eighth thing in my sequence yeah all right just to clarify is not delete a number correct well delete at eight do you see that it's a sequence operation yeah so this is very important that you differentiate between sequence and set semantics right if i'm dealing with the sequence i better not be looking up intrinsic things on this data structure right because it's not an intrinsic data structure it doesn't support that so if i wanted to support find the say the index of key 8 or something like that right then all i could do is it's similar to like an array i would just have to loop through the whole sequence and tell me if the thing's in there right can't really do better than linear time this data structure is not designed for that what is it designed for it's designed to find things by their index in the sequence right so uh how do i find the eighth index well i mean i'm looking at the tree and i can just you know count along the in order traversal what's the inorder traversal right zero one two three four five six seven eight okay found eight but what does a sequence avl tree do right it i'm storing subtree sizes and when i'm here i don't know what index i'm at right how can i find out what index i'm at from the root i look at my left sub tree see how many it is right there are seven things here uh one two three four five seven eight right yeah because i'm looking for the ninth item by index eight right so this is saying that i'm the eighth item right and the guy at index seven does that make sense because i'm looking at the subtree size here so what do i know i know that the index that i'm looking for is to my right right so i go down over here and i happen to know what am i what index of of am i looking for in this subtree zero right i want the first thing in this sub tree my search index has changed now right because i essentially dealt with all of those eight items right so here i'm looking for the zero thing in my index i look to my left if i didn't have a left sub tree i would be the zero thing right and i would return me but there is stuff in here so i'm looking for the zero thing in here right which is just him and i return it okay and actually what i'm doing is i'm deleting it right so i delete it yuck what's the problem here i'm not high balance weird what's not height balanced here um the lug subtree is earth so this guy's not height balance right right this guy's subtree is not height balance right this guy's two this guy's one okay so how do we fix it we do some rotations right this is actually the bad case that with the third bad case that we talked about yesterday right if i tried to just left rotate this guy what would it look like it would put 12 here it would put 10 here and 8 would be attached to that now it's height balance wrong in the other direction right that's no good right so the way to handle this case where i'm badly skewed to the right but my right subtree is badly skew is skewed to the left i have to do a rotation here right rotation and then do a rotation so that's that's the formula okay so here we first do a right rotation at okay which gives me something that looks like 8 10 okay well obviously this is uh not better than what was before but it's an intermediate step so that we can fix it right we right rotate here and then we left rotate here right the default is that we would left rotate here but because this had the skew in the wrong direction i need to right rotate this one first and then we can do it so now i rotate all of these guys over right and put 12 down here 8 here 10 here done everyone see that that's what a rotation looks like okay it takes a little while to get your mind wrapped around what the transformation is but hopefully you guys all followed that transformation there was a little magic while i was trying to draw yeah i still don't feel like this tree is high balance it's not good observation why is that this thing still has height three what is the height of this thing one right this is height one and actually when i was doing that rotation i needed to update all these augmentations right how which augmentations did i really need to which subtrees have changed during those things i don't remember what the thing looked like what did the thing look like 10 10 had eight in its subtree so its subtree definitely changed right eight sub tree changed twelve didn't change eventually okay so there's the case analysis that's in your lecture notes and was done in recitation right it tells you that these a b c d kind of sub trees right the ones that could change in these things those sub trees don't change the only sub trees that change during one of these fixed operations when you do one or two rotations is either two nodes or three nodes that whose subtree has changed here uh it could have been the case that three sub trees have changed right but in the easy case only two nodes x and y i think in the notes could have changed and so when i do that i have to recompute their augmentations from their augmentations of their children but uh it's only a constant number of those so i just recompute them because i the sub trees below me haven't changed right okay so we have a height mismatch here yeah should be where eight is right so uh originally in the picture 12 has a bunch of things in its subtree right 10 and 8 and we just deleted seven right so its subtree definitely changed there used to be three oh no sorry it did right yeah so here three node sub trees have changed but uh that's the actually the most i'm showing you the worst case right only three nodes possible in doing one of these double rotation things could have changed their sub trees and so we just have to fix the augmentation of those three things in the easy case it's just two things okay all right we have a uh on balance how can we fix this i could have been mean right i wanna be able to right rotate here right to rebalance i could have been mean and switch these two right if i switch those two then i'd have to do two rotations to fix this thing because the middle one is heavier than the left one against what i'm doing right but i'm not that mean so i'm going to right rotate how do i do that well right rotate at 6 is going to bring all of this down below 4 right and stick this subtree as the left child of 6. does that make sense yuck that's going to be fun to draw i'm just going to redraw it that makes more sense right uh eleven three two one and then six five nine eight twelve ten that's the right rotation at six is everyone cool with this the rotation my x is 6 my y is 4 right i have a b c sub trees right what i'm doing is kind of switching which of x and y is the root here right so now y is the root and b and c sub trees here now become the children of x underneath y and notice that hopefully through all that process my inorder traversal has not changed we had to update our augmentations along the way but you know it's a constant every time we walk up the tree and we walk up the tree only a logarithmic number of times yeah yes so every time we do a rotation we just like update the augmentation immediately afterwards before we do any other routine exactly second part updating documentation just means like updating like the count and the height just the properties and stuff yeah basically what we did we define when we augmented uh professor domain yesterday defined for you what a subtree property is right it meant a property that i can compute only by looking at my children the augmentations of my children recursively right so here uh instead of trying to increment or try to think about locally what this augmentation should be i'm going to throw away my old augmentation and just recompute it from my children because those recursively better be correct does that make sense yeah so just looking at how the rotation works so basically you're swapping four and six so that way four becomes the parent node and six becomes the right note i'm gonna draw this picture just it's just something you gotta memorize it's this is x b [Music] c and a can you see that picture okay yeah it's in your notes it's not a big deal right but if you've got this structure where x has a left child right and these sub trees may be empty or not doesn't really matter what i can do is i can move from here to there has the same in-order traversal order right but it's got a different shape and in particular subtree heights have changed which means it can help us rebalance the tree and that's that's the whole point of avl does that make sense and that's the right rotation this one is this is a right rotation this is a left rotation any other questions so as i'm walking up the tree every node i might have to fix with the rebalance but that rebalance does at most two rotations and there's at most log n ancestors that i have because my tree is height balance right at 2 2 log n or something like that right which means that at max i might have to do four log n rotations right because each one could do two rotations so that makes sense now in actuality you can prove that in a delete operation it's possible that you have to do a logarithmic number of these rotations up the tree this was a that bad case this is called the original tree i gave you is called a fibonacci tree it's the fewest it's the highest uh height balanced tree you can have on a on a given number of nodes um uh that's it's yeah the fewest nodes for a certain height i i you can think of it either way and if you generalize that to a large enough thing then that thing will take a logarithmic number of rotations going up now actually with an insertion you can actually prove you can go through the case analysis uh an insertion operation will always rebalance the tree after one after one rebalance operation which could include two rotations does that make sense yeah so in right rotation this guy becomes a right child yes depending on whether you have a child yeah so if i didn't have a left subtree can't perform rotation a right rotation there yeah so a right rotation necessitates that i have a left child so if you're doing it and you'll see our code actually checks to make sure you have a left child right uh that's that's a an assertion that you might want to fire before you ever do one of these rotations anything else yeah so an insertion may take two rotations at most to fix a constant number of rotations and the deletion could take a logarithmic number of partitions now that's not something you need to know it's not something i'm proving here to you uh just just something that's interesting there are rebalancing schemes like in in clrs right they they introduce a a red black tree to to introduce balance and that those trees actually have a weaker bound on it's not as is tightly height balanced as as an avl tree is it allows higher than skew to right uh and because it's kind of a weaker restriction they get away with only doing a constant number of rotations that they can afford that before they fix the tree uh but you know a little more complicated very nice okay any questions on this okay so uh now so this is more of a mechanical question you'll get on your problem sets and now we get more onto the uh the theory type questions these are going to be reduction type questions uh okay so this first problem uh thick nuri uh this is anyone nick fury right so it's a an avengers reference uh so basically what happens in this thing he's got a list of superheroes uh that each have an opinion on whether they should go fight santa's okay and uh their opinion can be strongly positive or strongly negative and so what uh fick is trying to do is find from among his revengers uh what their what the log n most extreme opinion revengers are so that you can talk to them right he doesn't want to talk to everybody he wants to talk to a you know logarithmic number of them okay it's kind of whatever all right so uh basically we have a uh a classified situation where you're given as a read-only input data store of these things in an array okay and i want to find the log n ones with the strongest opinions does that make sense and i want to do it and the first problem is in linear time okay so you actually don't know how to do this yet you'll know how to do it with material that you cover in uh well they teach you one way to do it in o46 but we're not going to get you there right now uh we'll teach you another way to do it uh in uh on tuesday right which is via binary heaps okay binary heaps are an interesting thing that implements a subset of the set interface okay really it just you can build on some iterable x okay i collect a bunch of things these items have keys right it's a key data structure in the same way it's implementing what we call a priority queue interface i can build these things i can insert things but i'm not going to do that here all i really need here for this situation is a delete superlative kind of operation in this case probably max delete max okay so this is like a i got a data structure right i'm calling these things does that make sense yeah that's a priority yes a priority queue is essentially something that implements these two things actually there's a third one where i can insert a new thing right but i'm not going to need that right now so that's what a priority queue is and actually a set this is a subset of the set interface right right the nice thing about a heap which i won't show you how it's done right but what a heap can do so if i had both of these operations implemented using a set avl tree how long would these things take me how long does it take to build a set avl tree and log in right because essentially i'm getting a sorted order out of this thing right if i'm inserting these things one at a time right or i could sort them and then put them in a tree in linear time like you saw a couple days ago right in recitation but i have to sort them at some point right i'm kind of i need to take at least n log n time because if i'm going to be able to return their order their traversal order in linear time and i have this lower bound of m log n on sorting i kind of needed to spend and log in time here right and how long would this delete max take i started so long log in right so it's a set avl tree where is my max it's the rightmost thing i can just walk down the thing take it off maybe i have to rebalance but you know that's a login operation right it's the same as like insert last in my substrate right so for a set avl tree this is n log n this is uh log n right now there's another data structure that does better for one of these operations and the same for the other one that we've learned earlier anyone remember said avl tree didn't actually give us anything over a sorted array in a dynamic array okay so what that did right was we have a we could sort it in n log n time using merge sort or something like that and then we could just pop off the last one end times right that would be an amortize i mean if i didn't care about taking up that size i could do it in worse case constant time i just read off the first the last one i don't need to resize the array ever right i can just ignore that does that make sense okay but that's okay if i had a data structure that implemented these two operations can someone tell me a uh an algorithm to generate fixed list don't worry about running time right now but that just uses these two operations yeah um so we built the data structure it's ordered from least to greatest for absolute value so don't don't don't worry about uh where things are ordered or anything like that i don't tell you how these things are implemented right all i'm saying is i can i can accept a bunch of these things and i can remove the maximum and return it okay yeah anyways just build it but make sure that you build it such that the opinion levels are the absolute value of the opinion levels sure okay so that's that's a nice thing what i'm going to do as your colleague is saying is i'm going to look through all of the things in my input i'm going to copy it over to some writable memory store okay right that read-only thing is not relevant to this part of the problem right what i'm going to do is uh right sorry i'm thinking about your problem set that we're writing and mixing it up okay so uh we copy it over to uh our new uh like linear size array right and but instead of putting their values there i'm going to put the absolute values of their values that make sense i just check if it's negative it is i put the positive thing there right okay and then and then i stick that array in this build right i put that there right so that'll take some whatever this build time is and then i can delete max k times or i can delete max some number of times however many things that i need right that the if i if i want log n highest things i can just do that log n times right so for this if i had such a data structure i could do this in one run of this operation and log in runs of this operation does that make sense i can solve this problem reducing to this data structure right now for a sorted array or a sat avl tree right this operation kind of kills me already takes m log in time right the nice thing about a binary heap is it does this operation in linear time you will see that on tuesday and it does this operation in login time okay so how what's the running time if i use a heap to binary heap to implement this data structure order of n times order log n times log n how big is log n squared log squared n compared to n is smaller right so if i add those two running times together it's still linear right okay so that's how you solve the first problem okay i didn't have to tell you what a binary heap was or how it did what it did all i needed to tell you was that it did this operation in linear time and it did this operation login type okay yeah all right the magic will be shown to you on tuesday part b says now suppose fixed computer is only allowed to write to at most log and space well okay that's a problem here right because we before we copied over the entire array filtered it out right and then did some operations but we couldn't even afford this if we couldn't store the whole thing externally in writable memory right okay so we can't do that so in some sense this is a more restrictive environment right i can do less things than i could it's a uh it's less powerful than my previous situation where i had as much space as i wanted to use right so it kind of makes sense that i maybe couldn't get the running time bad that bound that we had before right maybe i have to sacrifice something because i'm in a more restrictive computational setting right okay now this is something you could solve with binary heaps but you don't have to you could solve it with uh scent adl trees as anyone have an idea of how you could solve this using a set avl tree i'm limited by my number of mice my my space is at most log n yeah all right so how much space does this indial tree take right space right there's constant number of pointers for each one of these nodes right and i'm storing in nodes and space right basically every data structure we've shown you takes space the order of the things that we're storing right it's not using additional space it might take more time to do certain things but the space is you know takes the number of items we're storing plus maybe a constant factor right right so i'm going to draw my input here which i can only read i can't write do i give it i'm just going to call it a okay so this is my list of all the revenger opinions okay i can only read it but my computer can only write to this logarithmic amount of space what can i put in that space well i can i can certainly put log n things in there okay so if i'm given that restriction i probably want to build a data structure of that size right you know containing that number of things that make sense because what else are you gonna do right okay so i i gave you an idea maybe we could use a set avl here right i see a logarithm in my answer right it's very possible that we might have you know sorted arrays right or set avl things those those things give me a log somewhere in my running times right so kind of makes sense that i might have maybe a set avl tree here why why why would a set avl tree be helpful for me yeah because it started and you know you have the direct russell order you can calculate the traversal order and insert like anxiety sure i can do all those things but in particular it's going to help me be able to find a large one quickly right if i if i kind of uh have a set of things it's going to be and i and i'm maintaining this data structure by adding things incrementally to it right i can find out what the biggest one is or the smallest one pretty fast right and log in time right so if i have log n things in a in a tree here right what's the height of that thing log log n that looks familiar so what can i afford i can afford a linear number of op set avl tree operations on this data structure right okay you had a question okay i'm sorry yeah um for there'll be an avl tree does it have to be a bts tree it's uh bts bst right so when i talk about uh someone likes korean k-pop okay uh so uh bst but in natural kind of in the lingo that you're probably used to hearing in other contexts what we mean in this class is a set adl tree right now sometimes what people refer to as a binary search tree doesn't have balance semantics right so we might call in this class a set binary tree right but really they're useful because they're balanced so we're going to usually just assume that we're talking about balance things here now a set avl tree has these binary search tree semantics where the keys are ordered these items have keys and they're ordered it's a set interface right whereas we also presented to a sequence interface right for which these these things don't even have keys how could i store set semantics there right so but that's the distinction that we mean when we say uh binary search tree versus really a set avl tree versus yeah so if we're going to make an avl tree out of this would that mean that like we when we make a node we tell it like we are keying on the absolute value okay so when you're uh making a set to avl tree you got to tell us what if you're storing objects you got to tell me what their key is right if you're just storing some numbers like what i'm doing here right now this isn't a set avl tree right but if i'm just storing numbers i have to tell you the items that i'm storing are the keys okay and then everything follows right but if you've got an object that you're trying to sort like the students in this room you got a lot of properties right i want to all the uh the people with phone number right maybe i want to key you on phone number for some reason that's going to help me find out where you live i don't know this is getting i don't want to go there okay so but if i if i give you a set to avl tree i got to tell you what it's keyed on if i give you a sequence avl tree right it's obvious what my traversal order is going to be because i'm giving you a sequence right that's what the input gate was right does that make sense all right so i've got this set avl tree of size log n what should it be keyed by absolute value of their preference right or of their opinion i don't remember what this is called so but i what log n things do i put in here i don't know i i don't know anything about these things what makes one better than another right let's just put the first log in things that make sense all right what could that tell me now i've put this thing in it how long did that take log n times log log n time right but that's much less than our running time right so that we're looking for so i don't really care right i mean i want you to say how long it took but for my purposes i know that it's lower than the running time i'm looking for so and i did that operation once i don't really care about it anymore okay yep how did you get log n because the number of things i'm storing in this thing is log n and so if i pattern match the build time of an avl tree and i stick log n in there right then it's log n times log log n gotcha okay so is that for one iteration well right now i've just built this thing right maybe i uh well i just built it once uh i'm asserting too that maybe i don't need to build it again right what could i do instead so right now i know i haven't filtered my data at all right i'm just storing these things in sorted order in some way right what can i do to maybe start processing the rest of the data yeah well i didn't like try to scroll through the list a and try to like remind someone that's bigger than like try to keep the maximum ah kind of sweep this guy over inserting things and always maintaining you know if i do that and i keep sticking things in i'll have this sorted thing at the end and now i can just read off the biggest k things right however as i'm inserting things across here my thing's growing i'll just delete this oh delete small is fun i like that idea right basically yeah basically replace it right so what i'm going to do here's a proposal we're going to take the next guy stick it in awesome which one don't i care about now the smallest one there so kick the smallest one out now this one that i stuck in may be the smallest right so i just kind of passed it through this thing but how long did that take me it took me the height of this tree what's the height of the tree log log n right so i put one in i pop one out that's the smallest right and i keep doing that all the way down the thing how long did that take yeah i'm processing n minus log n things which is basically n right and each one of those operations took me height of the tree time so that gives me the running time that we're looking for and log log yeah it's like recognition of like a slide yeah it's a kind of a sliding window technique you may have been using one recently okay everyone okay with this yeah let me just remember the context that we're talking about is log log n like tree and like what where so this thing the size of this thing is log log n yeah i mean sorry log n and the height of this thing is log of the size in relation to like our little like login size like right there sticking this full of small log log entries or like like no so sorry i'm taking this stuff there's no intermediate data structure here i'm just sticking all these things into a via bsta i mean a set abl yep into one set avl right of size log n i'm sticking a guy in popping the worst guy out right going through all the things i need to make sure when i'm sticking it in i'm you know keeping track of which revenger it is and that i'm taking the absolute value and all those you know nitty-gritty kind of things but that's the basic idea right i'm just taking this i'm sliding the window in putting something in taking something out that may or may not probably is not the same thing and at the end of this procedure right the invariant i'm i'm maintaining here is that my thing always has the k largest opinions of the ones that i've processed so far right that's obviously true at the beginning when i build this thing and when i get to the end i've processed all the things so and this has size log n and so i have the log n largest like highest extremist opinions and then i can just do an inorder traversal of this thing and read and return does that make sense and i've only used logarithmic space okay yeah so i don't get it are all the opinions in that uh are all the opinions in that avl tree all of these opinions are in the abl tree and at ever at some point i will insert every opinion into this abl tree but i'll be removing the ones that i don't care about as i go does that make sense i'm always maintaining the the invariant that this thing before i insert something has exactly log n items in it and then i'm maintaining that invariant by sticking one in taking one out oh okay so then which one are you always the min right because i'm wanting the the largest ones and the mid by absolute value but yeah so i'm keying by the absolute value of these opinions total run time here right it's bookkeeping right so it took me a log n times log log and time to build this data structure at the beginning right plus n times log log n i did you know basically n operation asymptotically and operations this way it's actually n minus log n operations right and each one of those operations tree operations you know doing one insert one delete each one of those took the height of the tree time and so this is that good yeah if instead of blind we just insert and do we do a comparison and then so the in inserting and deleting uh a set avl tree is actually doing comparisons within its data structure just compare with the name sure you could do that right right so you could i could do it the other way right i could remove the smallest element here to start with right and then i compare it with this guy and then whichever is bigger i stick it back in same thing right it's just am i doing the delete first and then then the insertion or i'm doing the insertion first and then the deletion any other questions lots of questions all right well i'm probably gonna have to skip the problem uh we're gonna move on to uh c s so now s c l r all right what's the reference here yeah clrs right so these are four academics who wrote a popular textbook in computer science uh okay this is the same kind of k kind of thing okay they found k first editions and they want to auction them off uh people can go on to their website they have a bitter id it's a unique identifier right and they can place a bid for one of these books right and they can change it during the bidding period but you know at the end of the bidding period the academics want to know who the uh you know what is the expected revenue i'll get by selling to the k highest bidders does that make sense yeah okay so note that before i build this data structure i know what k is k is a fixed thing right right because my my running time of this get revenue depends on this k it's not an input to that operation right so k is kind of i don't know what it is a priori it could be n over 2 it could be log n right it could be 1 right but the data structure i build needs to satisfy these running time properties no matter what choice okay that the academics told me does that make sense okay so what i need to do is as as time is going on people are placing new bids and updating their bids right and you know those updates can take longer time but as soon as i close the window i want to be able to tell in constant time right what the k highest bidders are any ideas on how to do this what are the operations that i have to do i have to be able to place a new bid right i associated with a bidder is an id and a bid which is also an integer right how many dollars i'm going to pay for this book uh update the bid in some sense i need to find whether that person placed the bid before right in my data structure so at some point i'm going to need a find on bidder id does that seem possible right so i might want to have some kind of dictionary on bitter ids right when i say that i want to have a dictionary on something right i'm not specifying to you yet how i'm going to implement that dictionary right what are my usual options a hash table but what if i need worst case time a set avl tree right that's going to be your go to for a dictionary right because that's going to give me log n time to find things by a key right it's the only thing except for assorted or sorted you could also use a sorted array right but that's going to not be dynamic and here we're updating who's in my data structure all the time right people are going in and placing bids right new new people placing bids so my set of things that i care about is changing all the time so that's probably going to steer me away from sorted arrays because they're not good with dynamic operations okay so i'm going to need some kind of dictionary on bitter ids but i'm also going to need to maintain the the sum right of the k highest bidders does that make sense right and so in some sense i need to keep track of an ordered notion of the bidders right the bids that are in my data structure does that make sense right so order is going to be important on the bids i'm going to need to look up on bitter id and that's about it right okay yeah just checking so something yes correct yeah so uh that's a very good observation right if it runs in worst case time it also runs unexpected that time right because there's essentially no randomization that i'm talking about here right yeah it's so there's a stronger notion which we want you to specify which that actually there is no randomization here we're not using a hash table right in this class that really that's the only situation where uh that's going to be an issue right uh so uh but if it is uh what this problem is saying uh for each other state whether your running time is worst case expected and or amortized what we're really trying to get you to say is what's the uh evaluate the running time of your algorithm with the proper qualifications right if it took worst case i want you to say that it took worst case if it took if you use the hash table i want you to say expected and if these operations i were sometimes really bad but on average they're really good if i did a lot of them that's that's amortized right right or if i reduce to using a dynamic array right or if i reduce to using a hash table those dynamic operations would still be amortized right okay so the dynamic ones uh nice thing about linked data structures is that dynamic operations aren't amortized right so we're gonna get be able to get now for this problem we can actually get worst case bounds so we're going to try for that you can also do it in expected using some hash tables for that that dictionary right okay so when you approach a data structures problem in this class you want to tell me what it is you're storing first off right tell me what's supposed to be in those things right some invariants on this data structure to you know make sure that when i do queries later right that these things are being maintained right so that uh you know if i have you know if i'm maintaining a sorted array right and i'm supporting an operation to find the maximum i better anything i do to this data structure better be maintaining the invariance that these things are in sorted order and the last thing has the maximum item because my max return thing is going to look there and return that does that make sense so i want to tell you you want to tell me what is being stored at you know a generic point in time during your data structure right what is being maintained so that when i support a dynamic operation or a query right in a dynamic operation where i'm inserting and deleting things from this thing i need to make sure that i'm maintaining those invariants and when i'm querying i can actually rely on those invariants to to answer my query does that make sense okay so for this problem this is okay uh any ideas i have two two kind of keys that i might have to deal with one's a bid id and one's a a bid right so how could i if i have two keys right that i might want to maybe order on one and look up on another how many data structures do you think i'm going to use two that's a pretty good guess okay so one of them let's just guess right like i need to be able to look up on bid right so let's store these bitters right in some kind of dictionary that's going to be able to look up those things fast right so you know two data structures right one is a a dictionary on a keyed on bitter id okay what else am i going to want what's up the other way around a dictionary stored on the bids is a dictionary what i want here i want to maintain order somehow right because i want to maintain the k biggest things that i've seen so far right now if if i had at some point in time right what's going to happen right if i'm maintaining the k largest at any point in time it's possible that one of those bidders maybe decreases his bid right so it's no longer in the highest i'm going to also need to keep track of the other guys to see who i should add back into that set for example right so here's an idea i'm going to keep not just one other data structure but two other data structures maybe this is a leap you don't have to do this there's a way to do it with just one another but i'm going to store two more one is a kind of a data structure to store with uh store the k highest bidders and a data structure to store the n minus k highest bidders does that make sense so this separates my problem quite nicely right if every time someone does an interaction with this data structure right i can check to see whether it's bigger than the smallest thing in here right if it is i can do the same kind of trick i did before right i can remove it and stick my new one in there right and where do i but i removed it i have to maintain this property right so i stick it in here right there's another case what's the other case it's smaller right in which case i don't do anything to this data structure and i just stick it into here that makes sense right so what are the operations these data structures need to maintain finding the minimum or the maximum of these two sets does that make sense and actually not really the where are those operations i don't have them anymore but they were the priority queue operations they had uh delete max right and also insert where things that it did well on right so any priority queue right anything that can deal with maxes and mins right is good right and and what what's a data structure you know that can deal with maxes and mins pretty efficiently the set avl right so instead of data structure here i'm going to say set avm and obviously it's going to be keyed by bid right because that's the thing that i'm going to want to find max's and mins over okay everyone following the logic here of why i mean i'm maintaining these things so this is this is the level of an invariance that i want to maintain because when i go to for example do this query get revenue right i can just run through and sum all of these things oh wait how much time do i have do i have k time no i don't have k time so i don't i can't afford to sum up all of these things at the end of my right i have to i have to return it to you in constant time any ideas yeah just compute you know update a song right along with this data structure i'm going to keep a fourth thing which is just total of their bits right i'm going to call it like a t okay and that's something i'm maintaining it's part of my data structure right it's you could think of it as i'm augmenting this thing with a number right and the point of augmenting this thing with the number right is that i can just if i need to know what the total of this stuff is i can just look at that number does that make sense all right so now i think you know we're almost done we're basically done right how do we do this uh someone walk through to me how i would get revenue with this data structure i just i basically kind of told you look at this number return it right because that's the invariance that i've maintained on my data structure i'm relying on this invariant now i better make sure this is good when i do dynamic operations right i make sure i maintain it but if i by induction are ensured that all of this stuff is good and when i do a dynamic operation all that stuff is maintained then i'm all good right so get revenue after i kind of did all this extra work right it's very easy i just look at this number and return it okay so when we're grading a data structures problem usually we give you some points first for setting up your data structure separately from the operations and then we give you points per operation that you successfully deal with and then some points for correctness and running time yeah you have a question so would total be like a thing that we update whenever we um like mess around with the highest bitter tree and then and minus k highest bigger tree sorry say that again so like are we treating like the total like of like an augmentation that we update every time we do something yeah yeah so it's just a one number it's not really a data structure it's just one number that i'm storing with my my database right okay all right so how do i implement a uh new bid operation yeah can we assume that the bids will also be unique can you assume that the bids may be unique no right so that's actually something that is a really useful observation we've been talking about set data structures as requiring unique keys right how can i deal with non-unique keys it actually turns out that you know hash table it's really important that these be unique keys right because i i need to check whether it's in there i'm looking for that single key and when i find it i have to return right if i had multiple things with that key i might not return the one that i'm looking for right it doesn't even make sense right but you can generalize the set uh uh kind of infrastructure right to deal with multi-sets how can i how can i do that well with each key right again i'm storing unique keys with each key i can link it to a sequence data structure or any other data structure right and what i'm do is i'm going to anything that has that key i'm going to stick it in that data structure right so instead of storing one item there i have the possibility of storing many things there now i have to change the semantics here right if i'm saying find on this key well now i could say i'm going to return all of the things with that key or i'm going to show our some thing with that key right but you get the idea all i have to do is map it to some other data structure to maintain those things like maybe i want all the things with that key i want to find the one with this other key right so maybe i link to a set data structure that can search on other things right but the idea here is we maintain this uniqueness key property right i have to relax my semantics so that i'm storing multiple things at that key location does that make sense yeah why does it matter whether you've said the entree or not uh it does uh so it's going to matter here right because i have bids right and the bids could be non-unique right two people could have the same you know uh bid and by our definition of a set data structure it had to have unique keys so if i stuck in all these things keyed by bidder you got a problem right now in actuality we can get away with that by storing basically a linked list of all the things with that key and we'd be fine right and then whenever i want to return one i could just do but actually a binary tree right actually is flexible enough that in most implementations you can just store a bunch of those things but actually our run times do worse then right what does it mean to find next in my sequence right what does it mean to find the to return the next larger thing above this key doesn't really make sense because there could be multiple ones which one do i return and if i repeatedly do find next on this data structure right i might not loop through all the things right so some stuff breaks down in our interface right so i would prefer you use unique keys in this this kind of situation next tuesday i think with binary heaps uh we'll deal with non-unique keys that's fine but if you're gonna use non-unique keys in here you just gotta be a little bit careful about the semantics okay yep uh so you get the same uh running time you the you have to change the semantics on what you mean by find something right i just want to return anything with this key right what if everything has the same key then it takes constant time i just returned the first thing it's i mean these are special cases that you know you have to think about right uh i don't like thinking about them right so i just like having unique keys and if i want a situation where i have non-unique keys i'm going to basically put collisions at that key into a new data structure right it's just easier for me to separate out my head on what's happening because all of the running times that we proposed you know very strong definitions for unique key you know when you're dealing with a multi-set it's a little bit more problematic any other questions i we really need to kind of move on here right uh dictionary ketone bitter we still haven't implemented any dynamic operations new bid what do i do uh what am i going to need for my update i'm going to be able to need to essentially find in each of these data structures where that bidder is right and if i just have a thing keyed on their bid right the interface doesn't tell me what their old bid was it just tells me what their bidder id is right so if i just had their bidder id and their new bid how the heck am i going to find out which of these dash or where in these data structures they are right what i can do is i can store in this dictionary which i can look up in some amount of time right a pointer to where it exists in these things does that make sense this is called cross linking you may have done that a little bit in problem set two or something like that yeah are we storing a pointer to a specific figure yeah exactly right so the the invariant we have is that all of the bidders we've processed so far exist in these data structures right in one of these data structures and because we've used a set avl tree right in particular exists in a node of one of these data structures right what we can do is in this thing maintain pointers right mapping each of the bitter ids to their location in these data structures and why is that going to be a useful thing right uh say i mapped this dictionary right what could i use for this dictionary to get the running time we're looking for i could use a hash table or a set avl right if it's set avl i'm going to get logarithmic time worst case with a hash table i'm going to get constant time but it's expected right so it could be linear time in the worst case right so we're going to use a set avl tree right because that's what we do right now and that's going to give us worst case okay so what i'm going to do is for each one of these things i'm going to store that pointer so what i'm going to do is first i'm going to do that operation we had if i'm adding a new bitter right i'm going to take the you know the d and b right these two values that object that's that that bitter object or whatever i'm going to look at the smallest thing in this data structure right see if it's bid is bigger than my my the the thing i'm inserting right if it is then i'm not going to touch this data structure i'm just going to insert it in here and now after i insert it in here i know exactly where it is in the data structure i just inserted it right right so now holding that in my hand the node right i can go and insert that bitter into here right by bit id right so it's going to take logarithmic time and now i can store with that node my pointer to this data structure does that make sense and in the other case i kind of do the same thing right if it's bigger than the smallest thing here i pop that smaller thing out stick it in there and i stick my new guy in here cross-linking each of those pointers along the way does that make sense hopefully kind of kind of okay yeah and for update very similar right if i want to update a certain bidder i look in this data structure finds the bidder traverse that pointer to wherever it is in one of these avl trees right if it's in this if it's in this one i just remove it from the tree right or i remove it from the tree and then i reinsert right with whatever the new bit is right and if it's in this one again i remove it from the tree reinsert and whichever these things is and then i might have to you know swap a constant number of things back and forth here to maintain that this has the k highest right and when i do those dynamic operations i'm always removing some constant number of nodes in each of these trees and and adding back in a constant number of things and while i do that i just make sure to update this total as i go right his total was the sum of all of the bids in here and if i insert a new bid in here i have to add to that total and if i remove one i have to remove from that total but again it's a constant number of things i'm moving in and out of these data structures and so it can update this in constant time that makes sense now the look up here and the insertion and deletion into here those each took logarithmic time worst case but i did a constant number of them so again longer than time does that make sense that's that's essentially this problem it's a little it's difficult right there's a lot of moving parts here right but if you just break it up into describe to me and like you really do a good job on this part describe well to me what your data structure has then those descriptions of those algorithms can be pretty brief actually right so you know in this one you tell me these three data structures you tell me this guy's mapping to its location and these things i'm maintaining this guy right and then you just maintain those things with dynamic operations and then use those things for query operations that make sense okay wow we have 10 more minutes i'm going to briefly do four or four okay for you okay receiver roster we've got a coach she's got a bunch of football players receivers and wanting to start on our team the uh some number of of players that have the best the highest performance okay and by performance we mean the average number of points they've played in games that they have logged in their system right but actually their data is incomplete right they don't know which games and how much they scored in all these things there could be errors right and so these interns they're up they're constantly updating this database with queries like uh oh uh you know never mind this person didn't play in this game or actually they did and they scored this number of points right that's the clear and record things right and then at some point in time right like when we start when we want to play a game right i want to be able to return the the jersey with the k-th highest performance and log in time okay this is kind of a kind of a rank query right right the kth highest okay uh now in actuality i might want to return all k highest players so that that might be my my roster right but this is you know a more generalized query it's more specific more it's it's not really comparable but you get an idea for why that might be useful to the coach i don't know maybe not okay so what's the idea here we have a lot of different things floating around we got games they have ids unique ids we got receivers they have unique ids and each receiver could play in many games right oh that's kind of worrisome and many receivers could play in the same game these kind of many-to-one mappings are a little confusing and then we've got each player receiver having a certain number of points per game and we're trying to sort them kind of by their performance which is a rational number right which has to do with the number of games they've played and the total number of points right now i see rational number i can't compute that right that's what we were talking about last problem session right but what i can do is i could store the total number of games they played and the total number of points they had right and you could imagine by augmentation similar to this right every time i add a game right one of these small operations i can update that information for each player right right if i'm just if one of these these dynamic operations is affecting only one receiver i can you know update whatever it is in in constant time probably right if i just store with the player what their total number of games is as recorded by the database and how many points they've scored then if i have a data structure that needs to sort the receivers by their performance so i might be able to find the kth one right the k largest then i can't compute that performance but what can i do i can compare two players based on their performance using cross multiplication right right because i have the numerator and denominator of each of these rationals and i can cross multiply and figure out whether one's bigger or smaller and as long as i have a comparator i can do set jbl stuff does that make sense okay so that's the i'm just going to outline kind of the the components of this data structure okay well first off uh i'm gonna need to record a receiver and a receiver could have a lot of games but the important this is kind of a receiver centric kind of problem does that make sense to you guys right i'm not ever wanting to filter on all the receivers playing a game right i'm never like removing i'm never removing a game from the system i'm removing a receiver from ever playing in a specific game does that make sense so if i'm storing a receiver and each receiver has some games associated with them kind of makes sense i might want to have a nested data structure right where with maybe i have a a dictionary on receivers and for each one i store all the games that they've played it in some other data structure right with each receiver i store another its own data structure containing all its games so that makes sense okay so that's the idea right we have some kind of i need to be able to look up receivers right because uh you know i'm i'm clearing them or i'm recording them right so i'm gonna have a you know a dictionary or you know here i'm looking for worst case login time so i'm going to you know skip the dictionary abstraction and go straight for the set avl avl uh uh keyed on receivers i before c e except after c it is i e i okay that rule never works okay uh set avl tree on receivers and each one of those nodes right with each one of those receivers i'm going to store for each [Music] store a set avl on games okay why do i store a set avl on games why don't i just store a list of all the games because if i want to remove this game from a receiver i need to do that in login time and here what we're saying is that n is the number of games but the the number of receivers on the team is always less than the number of games so right if i search in this avl tree and i search in its avl tree i can be assured that those two searches was only login yeah because i might i need to remove a game right so there you go then what am i doing i'm returning the k highest performance well i need for with each one of these guys i also store what was this augmentation the sum of the points stored in these games right sum of points and uh what was it number games because if i store both of those things in constant time i'm going to be able to compute their performance right where i'm going to be able to you have the data i need to compare performances yeah so you just don't have variables yeah yeah it's just numbers right these aren't data structures this is data structure these are just numbers okay i'm storing that with each receiver right but that's not going to help me find the kth highest player right none of these things are sorted by performance right so i need the last data structure five i need to store something dynamically sorted by performance so yeah set avl storing receivers keyed on performance now when i say keyed ketone performance you want to mention something about the cross multiplication right like i'm storing with each one of these things this augmentation and when i'm comparing two things i'm using cross multiplication but other than that then we can abstract it away right you've abstracted that function call and i can imagine comparing two keys i can do this right this is a theory thing i'm not asking you to implement that right but that's sufficient for me as a reader of your solution to be able to say yeah you know what you're talking about okay all right so how do i connect these things right the thing is i'm going to need to be uh i need to update this these things right when i insert or remove a game right so how do i know where these receivers are in this thing i store a pointer into this data structure right so up here i store a pointer right to where it is in the data structure right again i'm storing all the receivers this has the same size as the number one data structure up there has the same number of receivers right but we're not quite done yet because i'm not wanting to know like who has the the best performance right i want to know who has the kaith best performance ugh how do i find the kate best thing in this treat right i've got a tree right set avl tree it's mapped on performance right i know where the last one is but if i want to find the kate one from the end how do i do that it's an avl tree a set avl tree all i'm storing is heights is there an operation that you've thought about you're not storing the size of each ah a set avl tree by default does not store sizes right that's what a sequence does but you think maybe that would be helpful in this situation right yeah so actually if i decided to augment by sizes also i could do the exact same kind of sequence find at operation right and i could be able to look up the n minus k item right in here using the exact same function for subtree at that i had in the sequence avl tree stuff right so actually in clrs they don't even bother with sequence avl trees right they go straight to if i wanted this rank find functionality on a sorted order of things right then i could augment with subtree sizes right but it's actually a much more useful general property so we decided to present it to you in the in the context of sequence abs juice because then i can just basically reduce to it when i get to here okay so that's kind of a structure of the data structure that'll work on this problem i leave it to you as an exercise to implement all of these operations for yourself or take a look at the solutions the last one um is going to be put online the solution uh it's pretty complicated it's what's called you can think of the size augmentation finding rank as a one-sided range query it's basically how many things are to the right of this value right what the last problem does is walks you through a two-sided range query right where i want to know how many nodes are between these two values okay so it's a walk-through all right thanks guys