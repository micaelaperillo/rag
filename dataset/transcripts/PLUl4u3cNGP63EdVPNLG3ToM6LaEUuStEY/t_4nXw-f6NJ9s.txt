hi everybody uh welcome to the last lecture of 6006 last lecture we talked about summing up this class and talking about future courses in the department that use this material um just as a pointer to some of those classes i have a little slide here i didn't get to uh at the last lecture talking about kind of what i was talking about the end of last lecture about different models uh different specialized classes on different aspects of o6 material for example more graph stuff different models of computation randomness uh complexity all of these things have their own specialized classes in the department uh as well as a lot of applications uh for this material in subjects like biology cryptography and in particular for your instructors uh the the realm of graphics and geometry okay so all of all of your instructors this term happen to be geometers and have uh be interested in geometry related problems um me in particular i didn't start out in computer science i started out in mechanical engineering uh and the thing that was my passion um coming into mit was origami and so here's a couple of uh pieces that uh i designed um origami pieces one square sheet of paper without cutting here's a a lobster and here's a you know a copyrighted dinosaur from a particular movie of the year that i designed it um i uh when i was young in high school i started designing my own origami models and what i didn't realize was the procedures that i went about designing these models was actually algorithms right i just didn't have the mathematical language to to understand exactly what i was doing but i could gain some intuition as an origami artist and design these things by using some of those algorithmic techniques it wasn't until grad school as a mechanical engineer that i started talking with uh our other instructor here professor domain about uh using algorithms in computer science to design not just origami uh which we both do but also uh folded structures that can be used for mechanical applications like space flight um uh deployable bridges in in like um in times when you you can't you need a temporary bridge or shelter or something like that deployable structures where you might need to make folded structures transformable structures that can have different applications for different purposes need to reconfigure the dream being that we have these powerful devices in our pockets right now cell phones uh which uh you know are really powerful because we can reconfigure the bits in them to make software of all different kinds right there's a there's a exponential number of different programs that we can write and that's part of why you're here is to write the next best one right so that's how to how to make uh kind of a universal a device uh at the electronic level what if we could do that in a material from a material standpoint what if i could reprogram the matter in my phone so that not only uh could i reprogram the app that's on your phone but instead of having the say the iphone 10 or whatever that you have and and you want to go buy the iphone 11 instead you you download a software app that then reconfigures the matter in your phone it folds or reconfigures into the next generation iphone you you don't have to throw away that old one you can essentially recycle the material that you have uh to potentially uh save material save cost and be better for the environment potentially so uh i started moving into computer science because i found that it was a really good way to model the world and solve some really interesting problems uh about folding that i i really enjoyed so um the the three of us today are going to spend some time talking a little bit about how we can use algorithms 606 material and beyond in our own research and we're going to start off with professor domain and then professor solomon sweet so why don't i just jump into uh computational origami and geometric folding algorithms is sort of a broader umbrella for folding related things which is encapsulated by this class 6.849 which is happening next fall so you should all take it 06 should be a reasonable background and in general we're interested in two kinds of problems one the big one is origami design or general folding design where you have some specifications of what you'd like to build in this case i wanted to make a logo for and i imagined extruding that text into third third dimension and then i wanted an algorithm to figure tell me how to fold that structure and so there is an algorithm which i'll talk about in a moment that gives you a crease pattern and then currently you fold it by hand the dream is we'll eventually have folding machines that do it all for us um and so that's the origami design where you go from the the target shape back to the um to the crease pattern the reverse direction is sort of foldability if i gave you a structure like this and i wanted to know does it fold that's a problem we call foldability in general a class of problems and sadly most of those problems are np hard jason and i proved that foldability is hard for a general given a crease pattern like that telling you whether it folds into anything it turns out to be np hard so that's bad news so we focus a lot on the design problem because that actually tends to be easier we can solve it with algorithms like that one you're seeing um and so a long time ago we proved that you can fold everything if i give you a square piece of paper and you take any polygon you want to make or maybe the paper's white on one side black on the other you you want to fold some two color pattern like a zebra or in general some three-dimensional surface like these guys there is a way to fold it from a large enough square of paper and it's actually really easy to prove that with an algorithm i have a sketch of the two pages of proof that we go over in 6849 but i'll just hand wave a little bit uh if you take a piece of paper like my lecture notes here the first thing you do is fold it down into a very long narrow strip much longer and narrower than this one wasting most of the material and then you take your strip and you just figure out how to turn it in some general way and then you just sort of zigzag back and forth along the surface so it's very cool in that you can prove with an algorithm in a very short amount of time to someone you can actually fold everything of course it's a terrible folding because in the very first step we throw away all but epsilon of the material but it's a starting point and then that was back in the 90s late 90s one of the first results in computational origami and in modern times we look for better algorithms that are more efficient that try to minimize the scale factor from how big of a piece of paper do i start from to how big of a model do i get um and one of the cool ways these days which was invented by tomihirotachi and then analyzed by the two of us it's called orgamizer it's free software you take a 3d model and you can it makes it into a crease pattern that you fold from a square in this case it uses 22 percent of the area which is pretty good um similar to these guys in terms of efficiency but very very different kind of folding than what you would get from more traditional origami design which uses different algorithms which i'm not going to talk about but you should take the class jason gives a lecture in the class that you can learn from him but the you know the vision is we can take any sheet of material that can hold a crease like this sheet of steel that tomohiro is folding i was cut by a big laser cutter at mit and this is him in this data center several years ago folding it into a steel bunny and so this is like a totally new way to manufacture 3d objects and you can make particularly interesting objects that either collapse flat for uh transportation uh or transform like jason was talking about but i'm just giving you a flavor uh the i think the first paper we wrote together was on maize folding so this is an example of folding a maze from a rectangle of paper and you can all try this out you just google for our maze folder you can generate a random maze and this 3d structure can be folded from this crease pattern that's a really hard one so try maybe try something smaller you can also write your favorite message and fold this maze extruded graph from this crease pattern might want to start with something smaller but that's the general idea and it's actually quite easy to prove this algorithmically if you have a really good origamis like jason on your team what you do is design how to fold each type of vertex this is just a graph on a grid so there are you know some constant number of different ways that each vertex could look it could be degree four it could be degree three uh in as a t it could be degree two either as a turn or a straight and you design little gadgets little crease patterns that fold into each of those little structures and if you can do it in a way that these boundaries are compatible then to fold the whole thing you just sort of glue together those crease patterns and that's how that software works and so that was this is particularly interesting because you can fold an arbitrarily complicated graph uh arbitrarily complicated maze m by n with a constant scale factor as long as the height that you're extruding that maze is constant then this is one family of shapes we know how to fold really well in general we're trying to understand you know what makes this lobster a nice shape in that it can be represented with a not too large piece of paper and we don't have general answers to that that problem i think that was a whirlwind tour of computational origami i also play a lot in the in algorithmic sculpture one of the leading edges in comp in origami and origami math is understanding how curved creases work and one of our favorite models is this one where you fold concentric circles alternating mountain and valley cut a circular hole out and it folds into this kind of pringle shape as a nice physics equilibrium thing and then you can turn it into fun sculptures like this these are done with my dad martin domain who's also here at mit or this guy this paper has been printed with a pattern according to getting burned by glass and then it gets folded and then put inside glass also made here at mit uh and so we use sculpture to try to explore and understand intuitively how curve creases work and then we get better and better understanding of the mathematics of even we don't even know whether this surface exists whether it's possible to fold in this way although getting close to proving it uh so that was sort of in the top level of this hierarchy computational geometry is a bigger umbrella which is represented by another class 6850 that's being taught this term and then i talked about geometric folding within that branch let me briefly tell you about another world of geometry very different in terms of model of computation oh i'm jumped ahead a little bit uh rewind let me show you one more fun demo which uh if i find my scissors so if i take a rectangle of paper and i fold it flat and make one straight cut what shapes can i get this is called the fold and cut problem hundreds of years old here for example i get a swan here i get one straight cut i unfold and get an angelfish tough audience today i keep going i've seen all these before this is this one is um a particularly difficult one to fold only full and to cut yeah okay hopefully that works well this is the mit logo yeah go mit all right so um that's that's actually the first problem i worked on in computational origami it's a lot of fun and there's a really interesting algorithm here also for computing the crease pattern how to fold your piece of paper to align in fact any graph you draw on a piece of paper you can align all those edges and nothing else so you cut along the line you get exactly what you want cool all right now i want to talk about something completely different which is self-assembly a fun thing you can do with dna which we all have just pick out some cool dna strands and design them in a clever way so they fit together to form a kind of square with dangling ends which i'll call glues and each of those dangling ends can have a particular pattern and only identical or complementary patterns will attach to each other and so you can use this to design your own self-assembling system like biology does but engineered for example to build a computer this is an example of taking a bunch of these square tiles and building a binary counter this thing is roughly counting in binary along the diagonal it's a little skewed so it's hard to see but the general model is you have squares this is sort of the computational model with four different glues and you can build any square you want but you don't have very many of these different glues ideally and then if you have two tiles with complementary glues they'll want to match together but it depends how strong this glue is how much affinity there is for how long those dna dangling ends are and also the temperature of your system if you have really high temperature nothing will stick together low temperature things will stick together even if they're not supposed to and so you can if you tune your system really well you can design uh a system so that maybe these guys these glues are really strong and so let's i don't know right e here eric and so these tiles will always glue together but only when all three of these are glued together can this tile which has c complement and f complement then it will if you set the temperatures just right only because both of these edges match will this style be able to come in and that's the basis for that building that binary counter and so this is a very different model of computation from what we're used to in this class where you think of instructions and they run one at a time here the model of computation is geometric it's these squares that are just floating around and gluing together and so your program at any moment is some conglomerate of squares and so i just wanted to mention it because it's a really fun model you can prove cool things in this model like how to build any shape by a sequence of pores mixings between tiles that you can execute in parallel and so it only takes log n time in parallel steps a linear number of different mix operations to make an arbitrary shape even using a constant number of different glues which is cool and may be practical you can also use it to build a replicator where you're given an object like this that you don't know the shape of like we don't know whether this exists and we can't model it mathematically very well and you would stick it in a vat and all these tiles would attach and basically build a mold and then start photocopying in 3d that mold and you can build that with a system with only two steps i believe and a constant number of tile types and it does all of that in this model in constant time in reality you'd have to feed this machine and wait for it to print out all these things and and these experiments take hours if not days to run but in theory it's really cool and you get some really fun models and very general results you can also use it to build a miniaturizer or a magnifier and other other fun stuff okay um so that was a brief tour of computational geometry i work mostly in four different areas of algorithms geometry data structures graph algorithms and what i call recreational algorithms i think i made up that term and let's go into data structures which is represented by this class 6851 all of the classes i mentioned have online video lectures so especially for those watching at home on opencourseware most of these classes are on opencourseware and if not they're on my webpage so 6851 advanced data structures is an extension of the sorts of data structures you've seen in here in 06 and the ones you will see in i thought i'd give you a flavor of one such result which is a problem we've seen in this class done better so suppose you want to store a dynamic ordered set so this is the set interface dynamic in the sense that i have insert and delete and ordered in the sense that i want to support find next and finds previous okay so exactly which subset of the set interface you choose influences what what data structure you've seen we've seen for dynamic sets you want to use hashing if you don't care about find next if you just care about find then hashing is great constant expected you can prove stronger things about hashing we do in that class but if you want dynamic and ordered you cannot do constant time for operation you can prove that which is cool but and so what data structure have we seen that solves this problem pretty well set avl trees which solve everything in log n so log n one competitor yeah i am interested in this in the word ram model which is the only model we've seen in this class this happens to work in a stronger model um and we can do better than log n in the following it'll take me a while before i get better but here's at least a different bound we can get log w uh this is via a structure called venom nubos who's a person avl is two people ben under both i've actually met so log w remember w is our word size so this is a bit of a weird running time it's great if w is like log n then this is log log n and we know w is at least log n but it could be bigger we don't really have a sense of how big w can get maybe it's even n maybe it's big and then these are the same maybe it's bigger than n and then this is maybe worse but for most w's this is actually pretty good and indeed optimal but it's not strictly better in any sense yet on the other hand there's another data structure which runs in log n divided by log w this is called fusion trees this was invented around the time that cold fusion was in the news and so they wanted data structures to represent and so we can achieve this bound or we can achieve this bound and this bound as good is if w is large this bound is good if w is small and so you can always take the min of the two whatever's better and in particular the min uh the min of those two things is at most i think it's square root log n over log log n if you want to bound just in terms of n then the crossover point between these two is this place and so you're always at most this which is quite a bit better than the log n of avl we've got a square root and we've got a slight thing in the denominator pretty tiny but the big thing is the square root and that's kind of cool and it turns out that's pretty much optimal in terms of an n bound this is optimal the min of these two in general is roughly optimal up to like log log terms i for fun i threw up the actual formula for the right bound uh which is tight up to constant factors there's matching upper and lower bounds which we talk about it's min of three things four things uh including log of w over a divided by log of log w over a over log of log n over a uh that's the last term that i just read is messy uh surprisingly that is the right answer for this very particular problem a very natural problem uh a is the log of the space you're using so it's the address size uh good question um if you throw so it depends if you have a polynomial space data structure then basically these are optimal and this is generalizing to beyond that maybe you have a little bit more than polynomial space cool um so that's data structures i'm going to jump ahead to graph algorithms which if you want to take this class i recommend a time travel device go back to fall 2011 it may never get taught again but it has videos so you can watch instead of time traveling if you don't want to watch it live you can just watch the recorded version it was taught by a bunch of postdocs that were here uh and and myself uh and so what i like to do with graphs is the world of planar graphs or near planar graphs so we've talked a lot about this class algorithms that work for arbitrary graphs and the algorithms we've seen in this class are pretty much the best we know for a lot of problems for for arbitrary graphs but if your graph has some structure like it's a road network and there aren't too many overpasses you can usually draw these graphs in the plane without crossings that's the meaning of planar maybe not exactly maybe just a few crossings there's a generalization of this which i won't get into but let's just think about planar graphs planar graphs have some nice features like they always have a linear number of edges they're always sparse so you can immediately plug that into our existing bounds but even so you know dijkstra uh this would take in this such a graph would take v log v time for planar graphs you can do the equivalent of dijkstra meaning i can compute single source shortest paths with non-negative edge weights in linear time no log okay not that impressive but remove a log more impressive is we can do the equivalent of bellman ford uh which is single source shortest paths with arbitrary edge weights in a planar graph in uh sometime almost linear time v log squared v over log log v okay so there's a couple log factors here but for the almost linear time whereas bellman ford would take v squared time so this is a huge improvement over what we've seen in the class these are quite complicated algorithms but they're covered in that class if you're interested in them then the the area i work in a lot is approximation algorithms for planar graphs and let me just give you a fun flavor using something we know which is uh breadth first search so breadth research you can think of as building these sort of rings around a single root node and there's this general approach as introduced by baker in 1994 we've used for lots of different problems you want to solve some np hard problem on on a graph so just run breadth first search from an arbitrary vertex and decompose your graph into these layers you could number them you know zero one two three these are the levels and let's just like delete some of those layers let's say let's delete every fourth layer so maybe i delete this one i delete all the vertices in that layer and then i delete all the things in layer 8 and layer 12 and so on guessing i don't know which one to start with but from i'll just try them all and then i delete every fourth layer after that so i've deleted on average about a quarter of the graph and it turns out for a lot of problems that you care about like choosing where to place fire stations in this graph to minimize uh you know travel time for if there's a fire somewhere in the graph this happens you know fires and graphs then this will only hurt your solution by like a factor of uh one plus a quarter uh so you'll get a solution that's uh within 25 of the optimal for a lot of problems um and uh that works for any value of four so i could do it for ten and then i'd get within ten percent of the optimal solution uh okay but how do i actually solve the problem once i delete every fourth layer well then your graph has this extra special structure which is a constant number of layers let's say a constant number of breadth first search layers if you just look at this portion this connected component or this connected component in here you can your graph is almost like a cycle it's like four cycles kind of stacked up together with some connections between them and it turns out that's something you can solve with very fancy dynamic programming like the stuff we've seen before in this class which focuses on just a single path or a single cycle if you just have a constant number of cycles with more work you can still do everything in polynomial time and so this is a very general approach for getting arbitrarily good approximation algorithms we call these one plus epsilon approximation for any epsilon but the larger the epsilon the more time you take it's something like two to the order one over epsilon times polynomial and n so as long as epsilon's constant this is polynomial time this is called a p-tess anyway those graph algorithms last topic is recreational algorithms which is maybe best encompassed by this class 6892 is its latest name it changes names every once in a while and i mentioned it in the hardness complexity lecture because this class is all about hardness proofs analyzing fun games and puzzles we saw the tetris np hardness in that lecture but you can also prove super mario brothers is hard or portal is hard or mario kart is hard or the witness some modern video game is hard or one of our latest results is that recursed that game in the top right is undecidable there's no algorithm to play that game perfectly so and you can even download the level and an example of the level and play it if you if you dare um so uh that's a lot of we have a lot of fun in that world of hardness of different games and puzzles uh where do i want to go next uh okay next topic is balloon twisting totally different this is recreational but not about hardness so this is an octahedron twisted from one balloon i mean another one on a stick and so each of these is made from one balloon what graphs can you make for one balloon well you should read our paper and you can characterize how many balloons you need to make each each polyhedron and some of these problems are np hard and it's a lot of fun [Music] cool i think that's the end of the slides uh the last thing i wanted to show you is a problem a puzzle slash magic trick comes from the puzzle world called the picture hanging problem so imagine you have a picture you want to hang it on a wall so you invested in some nice rope and you hang it and then if the on a nail if the nail falls out the picture falls and you're set so you invest in two nails like i have here and maybe you hang your picture on both those nails now if one of the nails falls out you still have a crookedly hung picture the other nail falls out okay it's gone i want to hang a picture on two nails such that if i remove either nail the picture falls so jason pick a nail left or right left we remove make sure this doesn't fall off and boom the picture falls same wrapping you can check you can rewind the video make sure i did the same wrapping okay take out the right one good choice uh then also the picture false uh and so this is a classic puzzle but you can generalize it so let me do it to for three nails which is all i have here this nail sagging a little bit uh y x and y inverse x inverse okay i think that's right uh so this is one way to hang a picture on three nails such as if i remove any of the nails picture falls uh just justin uh one two or three two two okay yeah i wanna get out of the way make sure make sure i don't go over the edge here yeah it's a lot easier to make this one work but you can see boom picture falls there and of course imagine infinite gravity and the picture falls tada and so you can generalize this to do essentially any it's called a monotone boolean function on any set of nails i mean you can make any subset of the nails cause the picture to fall and any collection of subsets of nails to make it fall of course if you remove more nails it's still going to fall that's the monotone sense but otherwise you can do an arbitrary pattern which is fun that's actually result with ron rivest and a bunch of other other people um i think i'm approximately on time so that was a quick tour and there are obviously various classes here you can take 6892 the hardness class was just offered last semester so probably won't be for a while all these classes are online watch the videos feel free to ask me questions and now we have justin i left you space here for your outline you don't have to but i'll put your name out thank you so jess justin is also a jabiter yeah we've got a lot of geometry people in double six this semester thank you okay you know it's like i can't help but share that on our instructor chat eric was texting that he was going to be he was somehow nervous that the applied guy would have all the like the cool stuff to show off and now i feel totally boring uh right yeah so yeah we have three different geometry instructors uh in in this class we have many different flavors of geometry that are kind of represented in this this room here from mechanical engineering to theory plus lots of other cool stuff to uh whatever it is that i do um all right so i'm a professor also from brazil and lead a group that studies slightly more applied geometry problems in some sense in seasonal we kind of cross a lot of boundaries actually closer to the math department than to the theory group in computer science which i would argue is largely a historical artifact rather than anything interesting about computer science or math um so continuing in our whirlwind tour of interesting geometry classes here at mit uh i have some more fun things to to add to the list and we'll introduce some of the ideas in the next couple slides here uh so uh normally every fall i teach uh which is the introduction to computer graphics course in fact my background was was working in an animation studio for a little bit of time and and uh got one movie credit out of it until they changed the standards for movie credits and then that stopped happening uh but but in any event uh if you watch what's that movie up with the old man if you hit pause at just the right moment you can find me right above the list of babies that were born during uh production uh but in any event um although computer graphics might not sound like an algorithmic discipline i'll try to convince you guys that in some sense you can take just about anybody in our department have them teach 606 and give a similar talk that like the material that you've encountered in this course is going to be relevant to your life uh the other course that i teach that might be of interest uh and actually is a little more theoretically flavored uh that i teach is a six eight three eight so since eric so kindly put my board my name on the board here i guess i can draw a picture so the main object of interest in six eight three eight is a particular thing called a simplicial complex so um usually uh in 606 we spend a lot of time thinking about graphs so let me draw you a graph so i'm going to take a square and subdivide it and now let's say i put edges diagonally like that now and pick from the most important thing is a bunch of notes can connect my edges in fact if i took this edge and i like moved it down or something it would be the same graph uh but of course in a lot of uh computer graphics applications this thing also looks an awful lot like a square uh and the reason is that of course the graph here contains triangles inside of it uh and so for instance um maybe i think of my graph as a collection of vertices clutching edges this is the sort of notation we've seen before and then i add a third thing to my trip uh to my description which is a set of triplets uh that's a set of triangles here right and we can take a lot of the algorithms that we've talked about in this class and extend it to this case so for example um here's a deceptively annoying one uh let's say that i want the shortest path between two vertices on my graph yeah so we certainly have learned dijkstra's algorithm as one technique to do that and indeed common practice in computer graphics which is shameful uh is on your triangle mesh if you want the shortest path between two vertices run dijkstra's algorithm on the edges and let's see if that works really quick so let's say that i want the shortest path between and by the way i'm going to assume the lengths of my edges are like the lengths as i've drawn them on the board here so it's like 1 1 square root of 2. okay so let's say i want the shortest path between the bottom left and the upper right for run dijkstra's algorithm we're in good shape right we could uh you can i'll let you do the computations at home you'll get the path that is these two edges but here's a really annoying thing let's say instead i wanted the shortest path from the upper left to the lower right if i run dijkstra's algorithm on this triangulated square what's going to be the shortest path yeah in fact there's a bunch of them one of them might go all the way down and then all the way to the right what's the length of this path one two three four is that the length of the shortest path well probably not well we'd like our shortest path to do something like that but graphs don't know how to talk to triangles and this is going to be a problem in fact it wasn't until history terms that we were able to kind of work out the correct algorithm for a shortness of a triangulated domain like this um that's the runtime that we would expect this is called uh mnp i'm guessing eric and jason could do a better job describing it than i can but the basic idea of the mmp algorithm actually is a really happens to be a nice extension of the way that we taught uh dijkstra's algorithm in 6.06 because they really do keep track of these sort of level sets of the distance function but now the level sets have to like oops i have to window an edge like that when i uh compute short its path which is a giant headache this is one of these algorithms that was known in theory about 10 years before anybody bothered to implement it in a way that they could convince them themselves really random n log n time uh and nowadays is a cottage industry in in computer graphics research papers to implement this and then speed it up in different ways and sadly the reality is that a different number we cover in 6838 called fast marching which doesn't actually give you the shortest path but some approximation thereof uh is faster easier to use and basically indistinguishable um so in any event um in 683 we kind of have an interesting we'll talk about a lot of algorithms that look like what we've done in whatever this class it's uh 6.006 um but at the same time start to have a more geometric flavor and we don't worry quite as much about uh so in our computation model oftentimes we're kind of okay with real numbers because that's not where the headache is and of course when you write your code in this class you use double precision floating point if you're more responsible like in in jason's previous lecture you should probably keep track of the number of operations to make sure that your error is bounded but no i'm not sure that we really bother with that um in any event this allows us to kind of have two different mindsets right there's one mindset which is discreet there's another mindset which is smooth right so we think about understanding geometry like these triangulated domains as an approximation of a smooth surface and then we might want to do stuff like compute curvature and so on which is really associated with computing derivatives which of course we don't have on these kinds of special objects and that leads to this really fun area of math computer science whatever called discrete differential geometry which sounds like a contradiction in terms um and it's something that we cover in quite some detail in this course so we build up all of calculus the only calculations you're allowed to do are on the vertices edges and triangles of a triangle mesh uh and get pretty far including some some constructions of topology like the durant complex and so on i would argue actually if you take our course and then the differential geometry courses in that department somehow some of the indices and headaches that you often encounter in that world are much more concrete when you try to make them work on a mesh in any event i think i've already spent all of my time i can tell you a little bit about uh research uh in our group um so i leave kind of a weird extremely broad group where some of our students are essentially theory students what's your keyboard i'm sorry it was a reflex um but it was fast uh all right so we have some students whose background is not other ones that like we're in autonomous driving industry and decided to come back and uh uh work in research and so because of that we have this extremely broad set of research problems everything from the sort of classic machine learning problems you might encounter in in geometry world like if i have a self-driving car and i want to identify pedestrians and other cars on the road in an efficient and accurate fashion um by the way part of that is machine learning and deep whatever but there's another part which is algorithms because actually what comes into your lidar scanner is on the order of like thousands of points and some minuscule fraction of time and time complexity of your learning algorithm actually is really critical to get right and something that there are a lot of open problems right now because it's really not compatible with the hardware architecture that these cars often use uh we also look at geometry problems like if i give you data can i find a geometric structure uh so a sort of classic example of natural language processing where we use words like near and far you know in terms of semantics and meaning all the time the question is can we actually find an embedding of our you know word data into a geometric space to facilitate the kind of statistical algorithms that we care about and of course we apply geometry to lots of practical problems everything from meshing and scientific computing which i think is sort of a classic uh one in fact i think we're the first group that sort of enumerated all the cool things that they happened to draw matches um which is the sort of bottom finger here i should share this with you because there's some fun things to look at there um to uh other practical problems like taking a you know eric took a zebra and folded it we can take a zebra and move its texture onto a cat or a pig or actually off the side of the screen but if you download the paper is it all for the 3d scan of one of my gratitude um so in any event in uh my five minutes remaining here i thought i'd dig into a little bit of a detail of two or maybe one application depending on when jason and eric get bored uh uh and essentially my message for you guys is of course you know it's not broken i'm not really a central cs theory group member here at mit uh but unfortunately for you guys 6.06 is unavoidable even if you want to go into deep learning statistics whatever data science you're going to encounter the material that you've seen in this course and in fact it's really the bread and butter of just about everything everybody does here in this data center so i thought i'd give you two quick examples one of which lifted from my teaching one for my research so uh if you continue with me next fall uh we'll teach 6837 which is the intro to computer graphics course one thing that's always amazing to students is these algorithms that produce these images can fit in about 10 20 lines of code um so a really this is totally facetious because if you want those beautiful images and you use those 20 lines of code you'll be waiting until the universe to actually compute these things but in any event uh one nice one for rendering so drawing a bunch of shapes on your screen something called ray casting um or it's better known cousin ray tracing typically the difference is whether your rays can bounce off of the surface and have a secondary thing uh right so here's the raycasting algorithm let's say i have a scene built out of spheres and cues i'm gonna have a for loop over every pixel on the computer screen for every pixel i got to discover what color that should be so i shoot a ray from my eyeball through that pixel and find the first object that it runs into it's not so hard to intersect a line with a sphere or a line in the cube so what is that algorithm well i've given it to you on the screen here not too bad to think about and i think you guys are all extremely well equipped to analyze the runtime of this which is roughly the uh number of pixels times the number of objects right because for every pixel i gotta decide what object the ray out of my eyeball hits first so i need a for loop over every object make sense cool so let's uh look at sort of a basic uh rendering problem in fact eric already uh secretly stuck this one in here so there's a very famous 3d model called the stanford bunny um the stanford bunny is actually a great example of a simplicial complex it's in fact a manifold one triangulated surface um actually i'm not sure it's manifold in its original form but but usually it is uh and this uh innocent looking extremely famous 3d model uh is actually quite uh pernicious it's composed of 69 000 triangles and if i wanted 1080p like you know a high def uh rendering of my triangle then of course there's there's two million pixels on the screen so if we look at our big o expression roughly our computation time scales like the product of those two big numbers uh so just to render this ugly gray bunny it takes me a pretty large amount of time yeah and in fact uh the real by the way the bunny is like this famous test case in computer graphics so if you take my class you'll be rendering bunnies all day um you know the reality is we don't want just like gray flat shaded bunnies we want bunnies that are transparent and reflecting stuff and you know i shoot my bunny with a bullet and it shatters into a million pieces and all these cool things so of course that raycasting algorithm and each one of these new graphics features i add only adds the time complexity of of the technique uh that i implemented so pretty quickly and indeed if you write your own ray tracer at home which i strongly encourage you to do what you'll discover uh is that a teleslope would be the technical phrase uh so what is our way out of this well if you take uh a37 you'll see that our way out of these problems and graphics is data structures and algorithms it's completely unavoidable so for instance obviously we spent quite a bit of time in this course uh talking about avl trees uh in age seven we'll spend a big chunk of our tours talking about space partitioning trees uh so here i've actually forgot what kind of tree this is i think it's a kg tree doesn't matter um in any event uh one thing i could do is take all the uh triangles in my bunny and i could put the entire bunny in a giant cube right then with the property that the cube is outside of my let's say i cast a ray and the ray doesn't touch the cube can the ray touch the bunny no right zing's right pass it right so suddenly i just saved myself a lot of computation time right i don't have to iterate over all the triangles inside of the bunny to see whether they hit the ray or not because i already convinced myself by this conservative test that i didn't hit even the bounding box of the whole body yeah well that's sort of a nice order one speed up but depending on how big the bunny is relative to the size of my rendered image that might not be a super useful uh efficiency test but of course what could i do i could take the box containing the bunny i could slice it in half and i would say it does my you know does my ray hit the front or the back of the bunny or maybe both that's where you got it that's where things get done um and and so on so now you have this nice recursive tree structure where i keep taking the box containing my bunny and chopping it in half and placing uh in some sense usually the the triangles maybe not the leaves of my tree but that's exactly that that's probably good enough and you get a structure like what you see on the uh the screen here and why should you do that well remember it takes sort of pn time to render my image of my bunny normally well now the picture is actually misleadingly suggestive but you might think that maybe it takes roughly remember and as the number of objects in my scene p login time to render my bunny now because i can kind of traverse this tree of objects in my scene of course notice i put a question mark here and and the devil's in the details here in fact i think computer graphics people often believe that the rendering algorithm takes p log in time that's often not possible although kind of there's an interesting question which is that the heuristics they use for building these sorts of trees often do on average give them lock-in time and so there's something about their data that's making this problem easier than it might seem so we'll dig into that a little bit in the graphics class of course you're not going to prove as many pounds as you might in a theory course um but we're certainly building on the intuition that you've seen in this class to build up practical data structures and these data structures appear everywhere in computer graphics so for instance directive a6 black directed acyclic graphs appear all over the place in computer graphics literature to describe 3d scenes so for example this classroom is a stark reminder of why we need dags and computer graphics because we have all of these empty seats here and they're all copies of one another so would it make sense for me to store however many like 100 3d models of the same chair probably not right so instead what do i do i have i store one instance of a chair and then some instructions on how to tile it into my entire scene so one way that i can do that is to think of there being a node which in a graph which knows how to draw one chair and now i can have a bunch of different nodes in my scene for all the instances of the chair that store like a different transformation for each one so what if you think about the graph structure here each of those is going to point into the same 3d model of the chair for rendering and that makes a direct and acyclic graph structure um called a scene graph which we'll spend quite a bit of time talking about in a37 how to traverse construct all that good stuff um and there are lots of different models of computation in that universe as well um your graphics card is a very specific kind of parallel processor that's kind of like lucille ball on the conveyor belt you know hammering at the same object over and over again but if you ask it to do anything other than one thing it knows how to do it's a bunch of data at a time uh then all of your computation grants for health this is called single instruction multiple data parallelism sim d numerical algorithms matter a lot for things like fluid simulation in approximate approximation algorithms are quite critical too um in computer graphics the the complexity is kind of interesting because of course your eyeball is sensitive to about 29.97 frames per second worth of material um you can choose that time to do like really well rendering one object but then you take out of the time rendering something else so there's kind of an interesting conservation law that you have to balance when you solve these kinds of problems which is an interesting balance now between like complexity and runtime of your algorithm and perception like what things can you get away with when you draw a scene and maybe like i can do tons of extra computation to get that extra shadow but it's just not worth it so i'll quickly sketch out another uh completely different application of uh the material that we've covered in 6006 from my own research uh again just like eric i guess in a funny way both of our groups i think are kind of raw in terms of subject material like rather than some of our colleagues have like really laser focused on one topic or another um another research area that i sort of backed into uh is the area of political redistricting um this is relevant in the united states uh recently i've been reading some proposals about other countries which is really interesting how they do this stuff so in the u.s when we vote for people uh in congress by the way not necessarily for president this is a common uh misconception but uh certainly for for congress um your state gets divided into little regions each of which elects one member of the house and this there's sort of a subtle problem if you're not used to thinking about it or one that's like staring you in the face and screaming depending on on how often you read the the news uh in politics which is an issue called gerrymandering where your legislature draws the lines for what area on the map elects a member of congress and depending on how you draw the lines you can engineer different results for who's likely to get elected so for instance maybe there's some minority i can cluster them all together into one voting district then they'll only get the opportunity to elect one person but maybe if i divide the space where they live into two i could manage to engineer two districts with a high probability of electing somebody with their political interests in mind so it turns out that uh political redistricting in a broad sense is a great problem computationally even if you're a totally heartless theorist there's some really fun problems here um so for example the state of iowa we all pick on iowa because it has a unique law which is that your districts have to be built out of counties which are much larger than the typical census unit so computationally is easier but even in iowa um which is a giant grid with the exception of one shift in the middle which is fascinating um i know a lot of times this is a fun fact like literally people were making the map of iowa and they work from the bottom up and the top down and it meets in the middle and their grids were shifted and now we're stuck with that and it has an interesting effect on the topology of your graph because it looks like squares although there's triangles in the middle uh but in any event um even though there's only 99 counties in four districts there's approximately quintillions of possible ways you can divide that state into four contiguous districts that satisfy the rules as they were at least if you read them kind of literally in the uh the the law um so it seems like computers are useful but unfortunately it's a little subtle how right so for instance there's no single best districting planner out there um i can't think of a single state with a law that gives you an objective function you know similar to you know whatever cute you know characters that we've had in 6706 you know they often have very clear objectives in life but unfortunately redistricting uh that's very rarely the case you know you have to balance continuity population balance compactness all these different things uh reality check number two is that even if somebody did give you an objective function for just about any interesting objective function it's very obvious that generating the best possible districting plan is empty hard um and by the way it doesn't even matter because the law doesn't say that computers have to draw the best district right so even if p equals np you really could extract the best possible districting plan using an algorithm um it doesn't mean you have to use it at least the way the law is written now interestingly this is not true in certain parts of mexico where they actually make you compare your districting plan against the computer-generated one which is philosophically really interesting although practice it doesn't work terribly um right so uh our research has studied analysis of distributing plans instead so instead of writing a piece of software that takes in your state draws your districts and then you're done uh instead we ask statistical questions about i propose a districting plan and what does it look like relative to the space of the uh possibilities um so that of course begs the question of what are the possibilities so these are like connected graph partitions meaning you have a graph and now you take the vertices and you cluster them together in a way where they're connected to one another the one thing that we all agree on actually philosophically it's questionable why um is that you should be able to start at any point in your district and walk to any other one without leaving these days with the internet it's not clear that that's actually the best criteria but that's a lot that i think is never going to get passed in in your future so anyway i think i'm out of time so i don't think i'll walk you guys through the the theory here um if maybe i'll leave it in the slides uh there's a very simple proof that can show that at least the very simplest thing you might think of for analyzing your districting plan which is to say you propose a plan and now i want your plan to be at least as good under some axis that's just a randomly drawn one from the space of all possible connected partitions all possible ways i could draw the lines well then it might be useful to have a piece of software that could just randomly draw such a thing so in other words to draw something where the probability of any one partition is one over the number of partitions um this seems innocent in fact actually there's a number of papers that claim to do things like this but it turns out that it's a computationally uh difficult uh assuming that you believe that p doesn't equal np so i'll maybe leave some suggestive pictures uh in the slides and we can if you guys text me or during if we have a you know professor student chat i'm happy to sketch it out to you then um there's a very nice easy proof uh that reduces the hamiltonian cycle um and shows you that maybe you shouldn't trust these tools uh as much as they're argued about literally the supreme court a couple months ago by the way it was it was pretty fun like our uh expert report was referenced in the descent of the the case last summer um and when you read the discussion like you can see the judges trying to talk their way around complexity and um it's an interesting if somewhat dry uh read so in any event that's just the starting point for our research which says that of course these sampling problems are really hard and the question is what can you do like you throw the baby out with bath water or not um but the uh the real message here is of course the this course is unavoidable even in these extremely applied problems showing up in court cases or on your graphics card uh you're still complexity and algorithms and data structures are going to come back to play um so with that uh find our other two instructors up here for our final uh farewell suitably distance so algorithms are everywhere i hope you enjoyed this class it's been a lot of fun teaching you and having you as students even though you're not here physically in the room we still feel your presence and uh i look forward to seeing you all soon thanks for being a part of this fun thing i want to thank our to uh my co-two co-instructors for an awesome time this semester it's been a lot of fun teaching to you guys and thanks for uh spending 006 with us this term yeah thank you and hopefully we'll see you again soon bye you