good morning everybody how's everybody doing nice uh long weekend we just came from i'm doing well i'm actually getting over a little cold uh oh yeah unfortunately uh but after this i i don't have anything else this week so that's good um okay so last time last week we talked about how we looked at the search problem that we talked about uh earlier that week and showed that in a certain model of computation where i kind of could only compare two objects that i'm storing in my that i'm storing and get some constant number of outputs on what i could how i could identify these things like equal or less than or something like that then we drew a decision tree and we got this this bounds that if i had n outputs right i would require my decision tree to be at least log n height and so in this model i can't find the things in faster than log n time but luckily we are in a model of computation which has a stronger operation namely random accessing and if we stored uh the things that we're looking for that we have unique keys and those keys are integers then if i have an item with key k i if i store it at index k in my array then i can find it and manipulate it in constant time right that's pretty cool that's what we call the direct access array a direct access array really not different than a regular array except how we're using it when we're talking about sequences is we are giving kind of extrinsic semantics to the slots where we are storing these things basically i could put any item in any slot right where it was in my array had nothing to do with what those things were here we are imposing intrinsic semantics on my array that if i have an item with k k it must be at index k right that's that's the the thing that we're taking advantage of here and then we can use this nice powerful linear branching random access operation to find that thing in constant time because that's our model of computation okay then what was the problem with this direct access array anyone shouted out space right so we had to instantiate a direct access array that was the size of the space of our keys right in general my index location is could go from zero to some positive number right if i have very large positive numbers if i was sorting if i was searching among your mit ids i'd have to have a direct access array that was that spans that space of possible keys you could have right and that could be much larger than n and so the rest of the time we talked about how to fix that space problem we can reduce the space by taking that larger key space from 0 to u which could be very large and map it down to a small space now in general if i give you a fixed hash function there that's not going to be good in for all inputs if your inputs are you know very well distributed over over the key space then it is good but in general there would be hash functions with some inputs that will be bad right that's what we kind of argued and so for the the rest of the time there we talked about hash families choosing a hash function randomly from among a large set of hash functions which had a property that if i chose this thing randomly and you generating your input didn't know which random numbers i was picking the expectation over my random choice me i'm the one running the algorithm not you giving me the input that random choice my algorithm actually behaves really well in expectation in particular i got constant time for finding inserting and deleting into this data structure in expectation we did a little proof of of of that the chain lengths where we stored collisions in our hash function in our hash table sorry those wouldn't be very long and so if they were constant then i don't have to search more than a constant number of things when i go to an index a hashed index location does everyone remember what we talked about last week and we then uh i didn't show you this chart at the end but i'm showing it to you now essentially what we had was we have a bunch of different ways to deal with this set interface and last week we talked about the sorted array and then we talked about this direct access array in this hash table right which do better for these uh uh dictionary the find and insert and delete operations or at least better in an expected sense right what's the worst case performance of a hash table if i have to look up something in a hash table and i happen to choose a bad hash table hash function what's the worst case here what n right it's worse than a sorted array right because potentially i hashed everything that i was storing to the same index in my hash table and and to be able to distinguish between them i can't do anything more than a linear search right i mean i could store a another sets data structure as my chain and do better that way that's actually how java does it they store a data structure we're going to be talking about next week as the chains so that they can get worst case log n but in general that hash table is only good if we're allowing okay i want this to be expected good but in the worst case if i really need that operation to be worst case right i really can't afford linear time ever for an operation of that kind then i don't want to use a hash table and so on your pset 2 everything we ask you for is worst case so probably you don't want to be using hash tables right okay yes what does the subject e mean that's great in this chart uh i have putting a subscript on this is an expected runtime right or an a meaning this is an amortized runtime at the end we talked about how if we had too many things in our hash table then as long as we didn't do it too often right this is a little handwave argument but the same kinds of ideas as the dynamic array if whenever we got a linear we were more than a linear factor away from where we were trying uh basically the fill factor we were trying to be then we could just completely rebuild the hash table with a new hash function randomly chosen from our hash table with a new size and we could get amortized bounce and so that's what python how python implements dictionaries or sets or even objects when when it's trying to map keys to different things uh so that's hash tables that's great the key thing here is well actually if your range of keys is small or if you as a programmer have the ability to choose the keys that you identify your objects with you can actually choose that range to be small to be linear to be small with respect to your items and you don't need a hash table you can just use a direct access array right because if you know your key space is small that's great so a lot of c programmers probably would like to do something like that because they don't have access to maybe c plus programmers would have access to their hash table any questions on this stuff before we move on why is it expected right when i'm building i could insert i'm inserting these things from x one by one into my hash table each of those insert operations i potentially have uh i'm looking up to see whether that an item with that key already exists in my hash table and so i have to look down a chain to see where it is however if i happen to know that all of my keys are unique in my input right all the items i'm trying to store are unique then i don't have to do that check and i can get worst case linear time is that does that make sense all right it's a subtlety but that's a great question okay so uh today instead of talking about searching we're talking about sorting okay last week we saw a few ways to do sort some of them were quadratic insertion sort and selection sort and then we had one that was n log n and this this thing and log n seemed pretty good but can i do better right can i do better well what we're going to show at the beginning of this class is in this comparison model no and log n is optimal and we're going to go through the exact same line of reasoning that we had last week so in the comparison model what did we use when we were trying to make this argument that any comparison model algorithm was going to take at least log n time what we did was we said okay i can think of any model in the comparison model uh any algorithm in the comparison model as kind of this some comparisons happen they branch in a binary sense but you could have it generalized to any constant branching factor but for our purposes binary is fine and what we said was that there were at least n output really n plus 1 but you know at least order n outputs and we showed that or we argued to you that the height of this tree had to be at least log n right log the number of leaves it had to be at least log the number of leaves that was the height of the decision tree and if this decision tree represented a search algorithm i had to walk down and perform these comparisons in order reach a leaf where i would output something so i i need if if the minimum height of any binary tree on a linear number of leaves is log n then any algorithm in the comparison model also has to take log n time because it has to do that many comparisons to differentiate between all possible outputs does that make sense all right so in the sort problem how many possible outputs are there what is the output of a sorting algorithm what what's up a list in particular given my input right like some set of uh items a that has size n right what i'm going to give you is some permutation of that list right so for each index say i could tell you where it goes right another way i could say is where does the first item go to where does the second item go to where does the third item go to blah blah blah like that right so how many different choices of a permutation are there well how many choices do i have for the first thing of where it could be in the final sorted array it could be in any of the places right so it's n how about this one the second one well it can't go to where this one went right but it can go anywhere else so it's n minus one and since these are independent choices i'm making if i multiply them all together i get n factorial permutations that are the number of possible outputs that i have to my sorting algorithm right so for me to have an output to my sorting algorithm be correct i need at least n factorial leaves does that make sense okay the nice thing about doing this last week is this is really just the number of leaves and this is really the number of leaves right so what's the number of leaves is theta n factorial here it's actually n factorial but i'm just going to put it there and here we get an n factorial i think this is i see so it's at least omega n factorial does that make you happier theta here thank you has to be at least so this was right okay so at least this many i i could there are there are algorithms that if it got to it could take two different routes to get to the same output right so this is a lower bound on the number of leaves okay so what this argument is saying is that if i just replace the number of leaves n here with n factorial i get a similar comparison sort lower bound now so what is log of n factorial this is familiar from p set one maybe so one thing i could do is i could put in sterling formula right and that'll give me something of the form n log n but what's another way i could lower bound n factorial well i have a bunch of things here that's n factorial half of these things these half and over two things are bigger than or equal to n over 2. that makes sense so i can certainly lower bound this thing by n over 2 to the n over 2 that's a little easier thing to take a log of right if you take a log of that that's asymptotically n log n so what we're getting here is any sorting algorithm here takes at least n log n comparisons and so merge sorts the best we can do okay that makes sense everybody we're just piggybacking on the analysis we had about decision trees leaves with the minimum height of any binary tree on that number of leaves and just replacing n with n factorial nothing super interesting here yeah yeah sure you can just plug in sterling formula but i i did this so i might as well clarify there are n terms here in the product right half of them are at least n over two does that make sense so i can replace i can lower bound this product by something smaller than half of the terms the product of that and that'll be fine right so i'm taking n over two of them and i'm multiplying n over two all together n over two times does that make sense okay it's just providing a lower bound right i just need something that's smaller than all of these terms and multiply them all together and that'll give me a lower bound okay so we can't do better than n log n in the comparison model but what we did last week was use random access and a direct access array to do better okay so how can anyone think of how to use that idea to sort faster and i'm going to give you a caveat here i'm going to let you assume that the keys of the things you're trying to sort are unique okay and say they're in a bound in a small range so how could i use a direct access array to sort faster any ideas uh-huh okay so what your colleague is saying is exactly correct it's something that i like to call direct access array sort we won't really call it that because there's something more general that we'll talk about in just a second but what your colleague was saying is instantiate a big direct access array direct access array sort right i'm instantiating this big direct access array of this the space of my keys right and what your colleague was saying was i take each one of the items in my the things that i'm trying to sort i look at each one of their keys and i stick it in the direct access array exactly where it needs to go right in constant time that's great now i gave you this caveat that all the keys were unique so i don't have to deal with collisions here right but then after i'm done with this all of these things are now in sorted order and what i can do is i can just walk down this list a lot of these cells are empty potentially right well some of the keys might not be there but what i can do is just walk down this list pick off every item that does exist stick them in an array i'm done right so what's the uh stick a key into here and then so all right uh make direct access array store items uh item x in index x dot key walk down [Music] direct access array and return items seen in order does that make sense to everybody all right how long does this step take building a direct access array order you okay so this is order u long does this take how many items do i have to insert order n or just n and how long does it take to insert each one of these things into my direct access array worst case constant time right so this is n [Music] times worst case constant time great how long does this last one take anyone of you also right because i'm walking down the entire length of you so this algorithm takes in total n plus u time this is great if u u is bigger than n because we assumed distinct keys right but if u is on the order of n then we now have a linear time sorting algorithm yes what's up i'm sorry you have to speak up uh how do i attach keys to my inputs in my so uh in for a set data structure that we've been talking about all of my items have keys that's just something that we impose on our input each of the keys is in this case it has to be a number right so it's a that's a nice point right we do this to uh kind of talk about sorting items generally so that uh we don't have to deal with potentially if these keys have values associated with or other stuff associated with put them on that item and they'll still be there but in general if you just wanted to sort integers you could say that dot key is points back to the object itself if you want to just sort some integers does that make sense it's a good question though okay so that gives us a linear time algorithm when u is small right and under this condition that i have unique keys when i want to sort right those are fairly restrictive so we might want to generalize this a little bit okay so that's direct access array sort what if we had a set of keys that was a little larger right instead of enforcing so let's say u is theta n implies implies linear time sorting that's great okay so now what happens if we expand that range a little bit say u is less than or equal to n squared maybe just less than okay okay this is a bigger range right and if we instantiated a direct access array of quadratic size we'd have a quadratic time algorithm this is not helpful right anyone have a way in which we could sort integers that are between zero and n squared maybe using the stuff that we had above your colleague is saying exactly the thing that i'm looking for which is great which is maybe we could break this larger number into two smaller numbers right any uh integer that is between zero and n squared can be written as a key can be some a and b where a is essentially the higher kind of n and b is kind of the lower n this is kind of weird okay so what do i actually mean by this i mean that let's let a be k when i divide it by n integer the floor right key integer to divide by n right and b equals k mod n so this is a number that's less than n and this is a number that's less than n does that make sense and actually i can recover k at any time by saying k equals a n plus b i've essentially decomposed this into a base n representation of this number and i have two digits in that number this is the kind of nth n digit and this is the ones digit does that make sense all right so now let's say i have this list of numbers um 17 3 24 22 12. how i could here i have five numbers so what's n in this case five okay not so interesting n is five here and i'm going to represent this as five pairs of numbers that are each within the bounds of zero to four right does that make sense so what is my a b representation of seventeen three two okay so yeah so there are three times 5 plus 2 that's good that's 17. yeah i think i your colleague did that right uh i have all of these written down so i'm just going to write it out and i hope i did it correctly okay three two zero three four four four two two two okay so now i have a bunch of things that i want to sort based on this function that i have right these are no longer just integers that i need to sort i need to sort by this transformation of this thing into a number does that make sense so anyone have any ideas on how we could so by the way these are both in uh constant time operations on your computer as long as it's an integer division right and this is mod python also has a nice thing i think in uh in its uh standard operations which is div mod of kn is that right yeah so if you want to use that you can okay so how do we sort these tuples these are tuples right you guys are i'm sure very familiar with tuples by now okay how do i sort these tuples what's the most important digit of this thing if i had to sort one of the digits and get something that's close to sorted what's more important the ones digit or the ends digit and okay we have discrepancy here who says one who says n someone who said n tell me what oh you all think that way for no reason yeah sorry this is a little confusing this is the ones digit this is the ends digit this is the ends digit this is the ones digit in how i'm writing this does that make sense yeah exactly yeah so what your your colleague is saying is exactly correct i could very be all i want right with the same a if i change a by one it doesn't matter what b is it's going to be bigger right does that that make sense right the the k is much more sensitive to a than it is to b right so a is more important than b does that make sense so if i just wanted to get some linear time algorithm i could just sort by their bigger digits and hope they don't don't differ very much on the smaller things i've kind of sorted these things does that make sense okay what if i actually want to sort these things any hands yeah i need to i need to sort on both in some sense in particular i like to think of what i'm going to tell you right now is is an algorithm that i like to call tuple sort but you can also think of it as like excel spreadsheet sort right i have an excel spreadsheet of a bunch of data i have a prioritization on how important the keys are to me the columns right and if i have a very important column and an order of the columns of how how important they are to me i can repeatedly sort on the columns until they're sorted based on my preference that's something that you may have done now if i have an ordering on the preferences of my columns do i start by sorting all of them on the most important thing or the least important thing what who says most who says least there's discrepancy here all right let's try it out all right tuple sort let's start by sorting these things by least significant first and then no most significant first and then least significant that was the first thing i asked you right all right so these are the most significant things the first ones and these are the less significant things all right instead of writing it as tuples i'm going to write them as 32 0 3 44 42 22 is everyone cool with that this is just base 5 representation okay all right so let's start by sorting all of these things by the most significant thing right which is by this guy this guy this guy this guy and this guy okay so how do i do the first one is o3 second one is 22 the next one is 32 uh 42 and then 44. maybe 44. i don't know does it matter the order in which i put these things i don't know i'm just going to keep it the same order for now all right so i've sorted it by the least significant or the most significant sorry the leading term and now i'm going to sort by the least significant so what's the least significant here 22 then 2 is also this is also 2 this is also 2 this is 3 and sorted list voila why did that not work yeah so what happened is i did take into account the significant digit sort but when i did the less significant thing it erased all of my work from up here does that make sense in the case of ties we want the more significant thing to take precedence so we want to do that thing last does that make sense so the right way to do this this is uh most significant first add okay not good all right least significant first let's try that uh so least significant here is two okay so i see a uh 32 42 22 03 and then 44. okay sound good least significant first now i do most significant i sort the most significant thing okay so what's the most significant thing zero three 22 32 most significant 4 44 and 42. cool we're sorted right i did what you told me to do i sorted by the most significant thing what's what's the problem here what did i do wrong you wanted me to put 42 here and 44 here right because 42 came first in the input and 44 came second right okay if a sorting algorithm maintains this property that if they have they are the same thing right then the output maintains their order from the input to the output their relative order that's what we call a stable sorting algorithm right and so if we have a stable sorting algorithm when we're doing tuple sort when we're sorting on different keys or columns of a set right we really want to be using a stable sorting algorithm does that make sense because otherwise we may mess up work we did before in a previous sort of the less significant things and so yes we want a stable sorting algorithm here because then we will end up sorting our thing does that make sense yes so what your colleague is saying let's sort by most significant then look at all of the things with one of those that that are the same and now sort that that's something we could do okay how long would that take well let's say i didn't use half of my more significant set of digits right say i'm only using n over two or that's not quite quite going to get what i want say say again yeah so what we're going to do if we have direct access array sort if i then go into each one of these digits and try to sort the things that are in there that's going to take time right it's going to take time for each of those digits now each there might be at uh a ton of collisions into one of the things and so i might take more time to sort that than linear does that make sense so i would prefer to do this tuple sort kind of behavior sorting the smaller thing sorting the bigger thing and because i only have a constant number of things in my tuples this is important because i only have two things i'm worried about here i only have to do two passes of a sorting algorithm to be able to sort these numbers however can i use direct access array sort here what was the initial stipulation i had on direct access array that the keys were unique that's exactly the opposite of what we have here we have things that could be the same so we give up can't do it what do we do instead we yeah you've already said the thing that i'm looking for so that's great your your colleague said why can't we just put more things at a key right why can't we put a list there that's exactly what we do this is called counting sort and what we do here is we still have this direct axis array a space u minus 0 to u minus one but instead of have storing one thing here at each key k we store a pointer to a chain this sounds like hashing right but the important thing is that i need to make sure as i'm inserting things in here then i'm maintaining the order in which they came in right i can't just throw them willy-nilly or else we have this problem up here that we had before right so i need what i would say is a sequence data structure right something that will maintain the order that i the extrinsic order that i had when i'm putting these things in right so as i have multiple things with k right i'm going to put them in the order i can basically i can put have a pointer to a dynamic ray or a linked list where i just add things to the end and then at the end of my algorithm when i read off the things i can just look at anyone that has a non-empty data structure under here and read them off in the order that they came does that make sense so for this example i'm just going to do this last step here from the first row to the second row i'm going to have this direct access array with 0 1 2 3 4 on the slots right so how am i going to do this counting sort now i have 32 42 22 03 and 44. i'm going to take the first one 32 i'm sorting by the most significant thing i stick it here 32 and then 42 4 okay 42 sorry 42 22 all right this is not so much different yet then dynamic array direct access array sort but when we get to this duplicate uh right 44 here we now have two things in this thing and because we are keeping them in order in this sequence i'm appending to the end then when i go and read off the different things then i'm returning them in a stable way in the way that i want them to be does that make sense and it's not overriding the work i did on the lower significant digits okay so how long does this take this also only takes order n plus u because i'm instantiating this thing of size u and then how big are these data structures well maybe i'm storing one a constant amount for each index so that's a u overhead and then i'm paying one for every item i'm storing right these things are only the lengths the sum total of their lengths is n right because i'm only storing n things in there so the total amount of space the total amount of work i have to do is order i need to be able to append in constant time and i need to be able to cycle through these things iterate over them in linear time but if i have that i get n plus u yeah ah so your uh your colleague is saying how do i ensure that the things in these lists that there are they collide how do you ensure that they're sorted i don't i just ensure that they came in in the order that they came right but as long as i sorted the lower order digits correctly in the previous things then i'm assuming that their order as they come in will be sorted if they collide that's the assumption that's the reason why i'm doing these building up from the least significant to the most significant it's so that i know that when they collide the underlying stuff there is sorted already in the input does that make sense great yeah so um so this one is still i'm using a direct access array on the keys though this is n this is n because i chose uh so counting sword is general for any u i just happen to pick u being n in this case when i broke this thing up into n squared but this general concept is it uh it doesn't matter what i choose for you does that make sense okay but we will use that right now to sort larger ranges of numbers okay so the idea here this was exactly the idea we're going to combine tuple sort use counting sort as its auxiliary sorting stab a stable sorting algorithm right to do all its work on these digits right and so to sort on n squared size numbers i get linear time which is great right because u is n in this case okay so but can i extend that what if i had n cubed what if i had up to size u equals n cubed or less than n cubed how many digits would i have there how many size and digits would i need to represent a number of size n cubed any ideas what did we do here we divided off an n we took it and stored it we're left with something of size n right if i had a number of size n cubed i could divide off an n i'm left with something of n squared i don't know how to deal with something of n squared actually i do i can split it up into two size and numbers right so if i had numbers bound upper bounded by a cubic right and cubed i could split it up into three digits three is still constant right and so i could split it up into three digits tuples sort them in their increasing priority and sort those again i'm doing linear work per digit i have a constant number of digits so i get a linear time algorithm yeah yeah so it's always going to be big o of n plus u but because i'm bounding my digit size to be n u is n there and so i'm getting linear time does that make sense yeah so the idea here this is what we call radix sort radix sort break up integers uh max size u into a uh a base n tuple right so basically each one of my digits can range from zero to n right how many digits do i have if i have how many base n digits do i have if i have a number of size u yeah log n of u number of digits is log n of u log base n of u right so how long does ray and then tuple sort on digits using counting sort from least to most significant right that's the algorithm how long does that take how long does it take to sort on a digit that spans the key 0 to n linear time right order n time how many times do i have to do this tuple sort the number of digits times right so the running time of this algorithm first i have to you know i have to do this stuff break up each of the integers that takes n time right n times the number of digits i had to create each one of these uh tuples right so n plus n times the number of digits right log log base n of u right so here i had to loop through all the things and then here for each thing i broke it up into log base and view digits and that's how long the first thing took and then how long did it take me to tuple sort end time per digit so i also get this factor does that make sense so how long did how long is that is that good is that bad for what values of u is this linear time if u is less than n to the c for some constancy then this c comes out of the logarithm log n of n is one and we get a linear time algorithm does that make sense okay so that's how we can sort in linear time if our things are only polynomially large right so in counting sort we get n plus u in radix sort we get also a stable sorting algorithm where the running time is n plus n times log base n of u does that make sense and then in the situations where uh there's a typo there and counting sort that should be when u is order n counting sort runs in linear time and it's linear time also in the case of rating sort if our things are bounded by a polynomial in n right by n to the c for some constant c does that make sense all right so that's how to sort in linear time with the caveat that your numbers aren't too big okay see you next week