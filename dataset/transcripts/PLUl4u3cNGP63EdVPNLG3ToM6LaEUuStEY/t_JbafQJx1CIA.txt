today we're going to in one lecture cover an entire field which is computational complexity um it's sort of uh it meets algorithms in an interesting way which is algorithms is mostly about showing how to solve problems well and showing that you can solve a problem well and computational complexity is more about the lower bound side proving that you can't prove you can't solve a problem very well you can't find a good algorithm to solve it we've seen a little bit about lower bounds several lectures ago proving search and sorting lower bounds in the in bounded branching decision tree model but these are much stronger notions of badness this is not about n versus n log n or constant versus log n this is about polynomial versus exponential which has been the sort of bread and butter model of in this class polynomial is a good running time and we're always striving for that exponential is usually pretty trivial to get and so we're going to talk about some different they're called complexity classes that talk about this issue and different ways to prove hardness this is a pretty high level lecture so you're not going to be expected to be able to prove hardness but you'll get a flavor of what it's like and this will segue nicely into other follow-on classes which is we're at pretty much the end of 006 so natural to talk about what other things you might study one result we'll prove today is that most problems are actually have no algorithm which is kind of shocking and lots of other fun things so let's get started with the notion of p this is a set of all problems solvable in polynomial time we talked about what polynomial time means a bunch last lecture so just recall that polynomial time means polynomial in the problem size which i'll denote as end here the number of words in your input okay so these are the problems that are efficiently solvable p is set of all of them and for contrast x is the set of all problems solvable in exponential time so problems solvable in exponential time exponential here means something like 2 to the n to the constant this is one reasonable definition of exponential so just the exponentiation of this of polynomial so as you might expect most problem every problem that we've talked about in this class so far can be solved in exponential time rather easily and algorithms in some sense is about distinguishing these two which problems are in p versus are in say x minus p so to formalize this a little bit i'm going to draw a picture which is a bit of a simplification of reality but for the purposes of this class will suffice and i think is a really helpful way to think about things which is to have a big axis for a single axis for how hard is your problem what is the difficulty of solving your problem and i want to be sure to leave so the easiest problems are over here and each problem is a dot on this axis hardest problems are way down the line and i want to make sure to leave enough space for all the things i care about so p i'm just going to call this segment up front and then i'm going to have a bigger thing for exponential time so this is just to say that p is nested inside x every problem that can be solved in polynomial time can also be solved in exponential time because polynomial is less than or equal to exponential these are just upper bounds x being an x means you're somewhere from this line to the left being in p means you're somewhere from this line to the left in terms of difficulty but formally we would write p is contained in x as sets in fact they're also known to be different from each other they're problems that can be solved in exponential time that cannot be solved in polynomial time for example put that here sure for example n by n chess is in exponential time but not polynomial time so what is the n by n chess problem this is i give you an end by end chess board and i describe to you uh a position here's where all the white pieces are here's where all the black pieces are you can have an arbitrary number of queens and bishops and pawns of each color of course up to n squared of them they don't overlap each other and i want to know uh does white win from this position let's say it's white to move can white win and that problem can be solved in exponential time by exploring the entire tree of all possible games but it cannot you can prove that it cannot be solved in polynomial time so that's a nice example a more positive example so to speak is negative weight cycle detection it's literally negative but it's morally positive negative weight cycle detection is the following problem i give you a graph a directed graph with weights and i want to know does it have a negative weight cycle yes or no and this problem is in p because we saw a polynomial time algorithm for this you run bellman ford on an augmented graph so this is an example of a problem we know how to solve this whole class is full of examples that are that we know how to solve in polynomial time but this is a nice non-trivial and succinct one to phrase it's also an example of a decision problem a lot of basically all the problems i'll talk about today are decision problems like we talked about last class meaning the answer is just yes or no can white win from this position yes or no is there a negative white cycle yes or no tetris we can also formulate as a problem this is a version of tetris that we might call perfect information perfect information tetris suppose i give you a tetris board it has you know some garbage left over from your past playing or maybe it started that way and i give you the sequence of end pieces that are going to come and i want to know can i survive this sequence of end pieces can you place each of these pieces as they fall such that you never overflow the top of the board on an n by n board this problem can be solved in exponential time but we don't know whether it can be solved in polynomial time uh we will talk about that more in a moment it's a problem that very likely is not in p but we can't actually prove it yet all right uh so there's one other class i want to define at this point and we'll get to a fourth one also but r is the class of all problems that can be solved in finite time r stands for finite r stands for recursive actually this is a notion by church way back in the foundations of computing as we know we need we write recursive algorithms to solve problems in the beginning that was the only way to do it now we have other ways with loops but they're all effectively recursion in the end so r is all the problems that can be solved in finite time on any computer uh so very general this should include include everything we care about right and it's bigger than x it includes problems that take doubly exponential time or whatever uh so i will draw a region for r so everything includes p it includes x and so we also have containment but not equal r there's of course many classes in between you could talk about problems that take double a exponential time and that would have a thing in between here or there's also between p and x there's a lot of different things we will talk about one of them but before we get to the finer side of things let me talk in particular about r so we have a nice example we being computational uh complexity theory or i guess it's usually just called theoretical computer science has a problem and if you're interested in this you can take one i think no that doesn't sound right that's probability it'll come to me we have an explicit problem that is not in r so this class has been all about problems that are in p do you have the number 604 604 5. thank you so close to this this class or it's so close to 6046 which is this natural successor to this class so 6045 would talk about this so this class is all about problems that are in p which is very easy but in fact there are problems way out here beyond r and here is one such problem which we won't prove here today it takes a whole lecture to prove this given a computer program does it ever halt does it ever terminate this would be a great thing if we knew how to solve it's basically an infinite loop detector if your problem doesn't halt then it has an infinite loop of some sort and you'd like to tell your user hey you have a bug in your program so this is one part of bug detection and it's impossible there is no algorithm that always saw that solves all inputs to this problem maybe given one program let's say has zero lines of code it could solve that it says yeah that one terminates and maybe you can detect simple kinds of infinite loops so there's some inputs some computer programs that you could detect but there's no one algorithm that solves all inputs so this is kind of sad news we call such problems uncomputable this is just another word for being not in r okay and next thing i'd like to do is prove to you that most decision problems are uncomputable or sketcher proof so remember decision problems are problems where the answer is just yes or no this is a very special kind of problem and even those almost all of them cannot be solved so halting is an example of a problem we want uh we can't solve this whole class 006 is about problems we can solve but today i'm going to show you that actually those are in the minority most problems cannot be computed this is very strange and also a little depressing so we'll talk more about that in a moment first let me argue why this is the case so we i'm going to be a little informal about what is what exactly is a computer program and what exactly is a decision problem but roughly all i need to do the only level of precision i need is just to count how many are there what is a computer program well it's usually a file well it's a file it's like a string of characters what's a character it's a string of bits so a program is just in the end a string of bits finite string of bits we all understand that whatever language you define in the end your every program is just a string of bits and a string of bits we can translate into a number so we can convert between strings of bits and numbers when i say number i mean what's usually called a natural number or a non-negative integer um this is usually represented by uh bold board bold board bold blackboard bold ant capital n so this is just you know zero one two and so on okay now what about decision problems decision problem is a specification of what we want to solve so we can think of it as saying for every input is the answer yes or no that's literally what a decision problem is the only question is what is an input and we've talked about inputs and the size of inputs and and there's lots of different ways to measure them but in the end we can think of an input as a string of bits also it's just a file so a decision problem is a function from inputs to yes or no and inputs we're going to say well that's uh you know string of bits which we can associate with a number in n so here we can start to tie things together so in other words a program is a finite string of bits and a problem is in some sense an infinite string of bits because there are infinitely many possible inputs and for each of them we specify yes or no so this is basically an infinite string of bits so we can imagine you know zero one one zero one zero zero zero one one one zero infinitely um just some for every string of bits we can say okay if your input is the number zero here's the answer no if your input is uh the number one then the answer is yes if your input is the number two your answer is yes and so on down this line every infinite string of bits corresponds to exactly one decision problem which specifies for every possible input integer which corresponds to a string of bits what is the answer yes or no so this may seem subtle or it may seem like not a big deal this is a finite string of bits this is an infinite string of bits but mathematics has well studied this problem and infinite strings of bits there are very many of them uh infinitely many it's not surprising they're also infinitely many integers so that's maybe doesn't seem that deep but there's a difference in infinitude programs and integers are countably infinite and infinite strings of bits are what's called uncountable i think the most intuitive way to see this is an infinite string of bits if i put a a decimal or a binary point in front this encodes a real number between 0 and 1. so this is roughly a real number in 0 1 and when i'm writing approximately equal here this really goes in both directions right given the decision problem i can define a string of bits of course giving me the answer for all inputs and i can convert that into a real number between zero and one but also the other direction if i take any real number that is a corresponding decision problem these are one to one bijection between them and the bad news is real numbers are uncountable and natural numbers are countable which means there's a lot more of these than there are these so one may way you might phrase this is informally is the number of natural numbers is way smaller than the number of real numbers and so from that we derive that most problems are unsolvable because every program solves exactly one decision problem we can also run a program conceptually on all possible inputs and we will figure out what function it's solving and if we don't allow random numbers in our program which i'm not here then every program solves exactly one decision problem possibly it's even worse for us because multiple programs probably solve the same decision problem they're just they add irrelevant lines of code or they don't do anything different or you know you run bellman ford versus running bellman ford five times you'll get the same result and that's actually the bad direction for us we'd like to know whether there is a program that solves every decision problem and because there are only this many programs and this many decision problems it just there aren't enough to go around so most what's the phrasing not nearly enough programs for all problems and so there's no assignment of programs problems because there's just too many problems more money more problems i guess um so when i first saw this result i was shocked and dismayed that why are we even doing computer science if most problems can't be solved luckily it seems like most of the problems we care about can be solved that's what this class is all about and in fact even the problems that seem really really hard for us to solve like n by n chess where we can prove it takes exponential time there is an algorithm to solve chess it's just really slow this is a statement about most problems can't even be solved in finite time no matter how much time you give them so it's not all bad sort of luckily most most problems we care about are in our i don't know why this is sort of a mystery of life but it's good news or it's why we keep persevering trying to solve problems with algorithms the statement tends to be small well i mean this so the question was well maybe it's just because the short statement problems are easy but this is a pretty short statement and it's hard uh i think i don't have a great reason why i wish i understood uh is there's a general result that if you have any question about a program itself then there's no algorithm to solve it basically any non-trivial question about programs is heart uh it's not in our and i guess if you took i mean if you imagine taking a random statement of a problem then maybe this will be in the middle of it with some probability uh maybe that's why most but this is a very strong notion of most there are so many more real numbers than natural numbers that i don't know all right i want to add one more class to this picture which is np it nestles in between p and x so we know that p is contained in or equal to np and np is contained in or equal to x we don't know whether there's a quality here or here probably not but we can't prove it but what is this class a couple of different ways to define it you might find one way or the other more intuitive they are equivalent so as long as you understand at least one of them it's good np is just a class of decision problems so i define p and x and are arbitrary they could be problems with any kind of output but np only makes sense for decision problems and it's going to look almost like the definition of p problem solvable in polynomial time we've just restricted to decision problems but we're going to allow a strange kind of computer or algorithm which i like to call a lucky algorithm and this is going to relate to the notion of guessing that we talked about for the last four lectures in dynamic programming with dynamic programming we said oh there are all these different choices i could make what's the right choice i don't know so i'd like to make a guess and what that meant in terms of a real algorithm is we tried all the possibilities and then took the max or the or or whatever over all those possibilities and so we were but what we were simulating is something that i call a lucky algorithm which can make guesses and always makes the right guess this is a computer that is impossible to buy it'd be great if you could buy a computer that's lucky but we don't know how to build such a computer so what does this mean so informally it means your algorithm can make lucky guesses and it always makes the right guess and whereas in dp we had to try all the options and spend time for all of them the lucky algorithm only has to spend time on the lucky guess on the correct guess more formally what this is is called a non-deterministic model of computation and this n is the the n in non-determinism is the n for np so this is non-deterministic polynomial time uh so algorithm can make guesses and then in the end it should output yes or no so like say if you're exploring a maze this algorithm could say uh should i go left or go right i'm going to guess whether to go left or go right and let's say it guesses left and so then it just goes left and then it reaches another junction and says should i go left or right and i'll say i'll guess and let's say i guess right this time and in the end if i get to some dead end maybe and i say no or if i get to the destination i'm trying to get to i say yes so that's a non-deterministic algorithm and what happened what does it mean to run that algorithm what does it mean for the guesses to be lucky here's what it means these guesses are guaranteed which way you end up going is guaranteed to lead you to a yes if there is one if possible so in my maze analogy if it is if my destination is reachable from my source then i'm guaranteed whenever i guess left or right uh i will choose a path that leads me to my destination whereas if the destination is in some disconnected part of the maze and i can't get there then i don't know what the guesses do it doesn't really matter because no matter what i do i'll end up in a dead end and say no okay that's the that's the model as long as you have an algorithm that always outputs yes or no uh in polynomial time because we're only talking about polynomial time lucky algorithms uh if there's any way to get to a yes then your machine will magically find it without having to spend any time to make these decisions so it's pretty magical computer and it's not a computer that exists in real life but it's a computer that's great to program on it's very powerful you could solve lots of things with it yeah if you have this magical computer you can guess whether it's yes or no why doesn't it just answer the question right so what if we so a nice check is does this make all problems trivial all decision problems maybe i should say well i don't know whether the answer to the problem is yes or no so i'll just guess yes or no this is problematic because so i might say it will guess a or b and if i choose the a option i will output yes and if i choose the b option i'll output no in this model that algorithm will always output yes because what it's saying is if there's any way to get to a yes answer i will do that way and so such an algorithm that tries to cheat and just guess the whole answer of the problem will actually end up always saying yes which means it doesn't solve a very interesting problem it only solves the the problem which is represented by the bib vector 1 1 1 1 1 1 1. where all answers are yes but good good check yeah does there have to be a bound on the number of things it has to choose between yes uh exponential number of choices is okay um i i you i usually like to think of it as you can only guess one bit at a time um but that but we're allowed polynomial time so if you're actually allowed to guess polynomial number of bits at that point you can guess over an exponential size space but not more than exponential cool so it's it's yeah polynomial time let's say in the one bit guessing model did i say makes guesses let's let's add binary here otherwise we get some other class which i don't want okay let's let's do an example of a real example of such an algorithm that's useful which is tetris so i claim tetris is in np because there is a lucky algorithm an undeterministic polynomial time algorithm that can solve the tetris game so again you're given a board you're given some sequence of pieces and you want to know whether you there's some way to place the pieces that lets you survive and so what i'm going to do is for each piece i'm going to guess how to place it so for the first piece i'm going to guess you know how how far left or right do i move it then i let it fall one step maybe i rotate it i choose a sequence of moves among left right down rotate right rotate left and all along the way i make sure i check is that move valid if the move is invalid at any point i just say return no and then if the piece gets nestled into a good spot i continue to the next piece i do the same thing guess all the possible things i could do to that again i only need to guess sort of one bit at a time and i'll only need to do a polynomial number of guesses like a linear number of guesses for each piece about where it falls in so maybe a quadratic number of guesses overall and then at the end if i survived oh i also have to check if a line clears then i clear the line and if in the end i survive i return yes so this is a non-deterministic algorithm so i would say check the rules of the game and if we survive return yes and if at any point we violate the rules for example we go off the top of the board we return no so this is an algorithm that sometimes returns known sometimes return yes depending on what choices you make and this model guarantees if there's any way to get to a yes it will find it if i swapped these answers if i returned yes when i violated the rules and returned no if i survived this would be an uninteresting algorithm because it's very easy to lose in tetris the hard part is to survive if i say is there any way to play the game in such a way that i violate the rules then of course the answer is yes you can just stack pieces and go off the top there's an asymmetry in this definition of yes versus no right it always finds yes answers if possible it doesn't always find no answers if possible so it's very important the the way that i wrote these questions it's important that i define tetris as the problem of can i survive the problem of can i not survive is it impossible to survive that's a different question that problem is not an np probably okay so slight subtlety there yes versus no let me give you the other definition of np so if this one's confusing which although i prefer this definition most people do not so this is confusing let's do the other definition so another definition is that np is a set of decision problems ah that can be checked in polynomial time this actually came up in the last lecture where we talked about subset sum i said here's a bunch of integers here's a target integer and i can prove to you that this integer can be represented as a sum of numbers from my subset of numbers from my set because here they are i gave you this plus this plus this equals a target sum and so that is a solution in some sense that can be checked for a yes example if i can represent my number as a subset sum of a given set it's easy for me to prove that to you and you can check it just by adding up the numbers and checking that each number was in the set whereas no instances we had an example of a target sum that could not be reached and the only reason i knew that is because i had brute force the thing and there's no succinct way to prove to you that that number can't be represented a similar thing with tetris what i would say is so this is version one version two for tetris is that a certificate for a yes input of tetris is a sequence of moves for the pieces okay if it's possible to survive in tetris i can prove it to you i can just play the game and show you that i survived no answers i don't know it's hard to prove to you that i can't survive a given sequence of pieces but yes answers are easy i just show you here's here's the sequence of button presses i'll do for this piece then for this piece then for this piece notice it's exactly the same thing that i guessed in the beginning of this algorithm and then i did some other work to implement the rules and similarly if i gave you a certificate which is the things that i wanted to guess of how to play the game i can check this certificate by just implementing the rules of tetris and seeing whether i survived and if you violate the rules at any point you say no and if you survive you return yes that's what's called a verification algorithm so let me formalize this notion given a problem input plus a certificate like that one over there there is a polynomial time so this isn't yet another definition this is what i mean by this definition of np a verification algorithm that satisfies two properties one is for every yes input so every input where the answer is yes to the problem there exists a certificate such that the verifier says yes so this is saying it's possible to prove to me that an answer is yes because if there's if you ever have an input that the answer happens to be yes you can prove it to me by giving me a certificate there's always some certificate that proves the answer is yes because the verifier which runs in regular polynomial time this is a regular old-fashioned down-to-earth verification algorithm polynomial time in our usual sense it will say yes and furthermore the yes answers from the verifier are actually meaningful because if i ever give it a no input it always says no no matter what certificate i give it so this should really formalize what all this means is equivalent to the previous definition this is saying that proofs exist for yes instances and this is saying that proofs don't exist for no instances meaning there are no false proofs so if the verifier ever outputs yes you know that the answer to your problem is yes but if it outputs no you're not sure maybe you got the certificate wrong because we only know there's some certificate where the verifier will say yes or maybe it was a no input and then it didn't matter what certificate you used but it's nice because it says on say tetris if i give you the sequence of pieces it's very easy to write down a verifier which just implements the rules of tetris and so then you can at least check whether a solution is valid in the yes case in the no case we don't have anything useful so np is a structure some additional structure about the yes inputs in your problem and a lot of decision problems are in nnp a lot of the problems that we care about can be phrased as an np problem as long as it's a decision problem usually answering yes or no is provable like subset sum like tetris these are all problems where if the answer is yes i can give you a convincing proof why and it turns out a lot so a lot of problems fall into this np setting and so we have some tools for talking about problems being hard with respect to np let me first talk a little bit about p does not equal np uh question mark um a lot of people conjecture that p does not equal np it's sort of a standard conjecture in theoretical computer science but we don't know how to prove whether p equals np or or does not equal np and so in this picture i've drawn the hypothesis which is that np is a strictly bigger region than p is but we don't actually know whether there are problems in this region we don't know whether there are problems in this region between np and x we conjecture there are problems here and there are problems here there's definitely problems here or problems here but we don't know which one because we know p does not equal x but we don't know whether p equals np and we don't know whether np equals x if you could prove that p does not equal mp or disprove it you would win a million dollars which not that much money these days but you would be famous to for the rest of time if you could ever prove this every year there's usually a crackpot proof that doesn't work out some of them go to me please don't send them and anyway the it's it's a very hard problem it is sort of the core problem with theoretical computer science how to prove peter's nautical mp but for the most part we just assume it uh now what does this conjecture mean it essentially means the way i like to say it is you cannot engineer luck because np problems are problems you can solve by lucky algorithms p are problems you can solve by regular old algorithms and so if p equal to np it means luck doesn't buy you anything which seems weird like if i can magically make these super powerful guesses uh then i can solve the problem that that's np that seems super powerful way more powerful than regular algorithms where we have to actually brute force and try all the choices um and so it seems seems pretty solid that p d is not equal to p that's my my of course we don't know how to prove it another phrasing is that it's harder to come up with proofs than it is to check them from a mathematical perspective this is equivalent to p does not equal np so that's why you should believe it now let's go over here the next notion is np hardness so in particular i want to claim this is a theorem that exists in the literature that if p does not equal np then tetris is not in p so i said right here tetris is in x but we don't know whether it's in p but in fact we conjecture is not in p because we conjecture that p does not equal p if you could prove this conjecture and there's a lot of theorems that are conditioned assuming p does not equal np then we get some nice results like tetris cannot be solved in polynomial time i cannot figure out whether to win whether i can win a tetris game in polynomial time in the input size why this is a consequence of another theorem which is that tetris is np hard i'm going to define mp hard informally first and then i'll define it slightly more formally in a second but this means roughly that tetris is as hard as all problems in np so let me draw this in the picture so np hard is this part oh did i leave myself enough room maybe not well we'll squeeze it in there's another region here for x-part so your problem being an np was a positive result it says you're no more difficult than this line you're either at this position or to the left being in p is also a positive statement says you're here or to the left being in p is better than being in np because this is a subset of that np hard is a lower bound it says you are at this point this level of difficulty or to the right and so it goes from here off to infinity in difficulty and x part says you're at least as hard as the right extent of the x uh set uh or you're harder than that in a sense that we'll formalize in a moment and this place right here as you might imagine is kind of interesting it's exactly where np meets np hard this thing is called np-complete you probably have heard about mp completeness the famous notion and this is what it means it is the problems that are in np so they have a lucky algorithm that solves them they can be verified their certificates they can be verified and they are np hard so they're in np and they are the hardest among problems in np now they're not the hardest problem they're actually many problems right here at this single level of difficulty called mp complete among them is tetris there are many others which i will list in a moment so that is mp completeness so because these problems are the hardest problems in np if there's any problems here in between in np minus p then these must be among them and so if you assume that p is not equal np as most people do then you know that all problems at this rightmost extreme of np the hardest of the problems in np they must not be in p and that's why i can say if p does not equal np tetris is not in p and also any mp complete problem is not np okay what does as hard as mean this is our good friend reductions we talked about reductions a lot in this class reductions are the easy way to use algorithms you just take your problem and we reduce it to a problem you already know how to solve you take the input to some problem that you want to solve and you convert it into an input to some other problem like single source shortest paths or something like that that you already have an algorithm for solving so if you have an algorithm that solves problem b you can convert that into a solution for b and a reduction should also tell me how to given a solution to b how to convert it back into a solution for a and when i say solution here i actually mean certificate from over there uh so how like so if i um yeah okay so if i have so reduction consists of these two pieces how to convert an input at a to an input for b given a solution to b how to convert it to a solution to a let me give you some examples of reductions you've already seen you've seen a lot of them if i have unweighted shortest paths on the left unweighted [Music] single source shortest paths i can reduce that to weighted shortest paths how set all the weights to one so here i'm given a graph without weights if i set all the weights to one that turns it into an input for weighted string of source source pads so if you didn't know how to solve this you could solve it by converting it if you've already written say a dijkstra algorithm you could apply it to solve unweighted single source shortest paths now we know a faster way to solve this but you know it's only a log factor faster and here we're talking about polynomial versus exponential okay so this is a valid reduction it's not the most interesting one from an algorithmic standpoint but it is an algorithm another one we have uh we've seen is if you have integer weights on the left you can convert that to unweighted on the right by positive integer weights by subdividing each edge of weight w into w edges of no weight so that that's maybe a little bit less efficient it depends how what the sum of the weights are another version that we've seen is longest path in a graph we can weighted path uh we can reduce to shortest path in a graph weighted by negating all the weights we did this in some of the dynamic programming things like oh longest path in a dag we can convert that into shortest path and tag just by negating all the weights so these are all examples of converting one problem to another usually you convert from for algorithms you convert from a problem you want to solve into a problem that you already know how to solve but it turns out the same tool of reductions can be used to prove negative results too and in this case we're going to reduce from a problem that we think cannot be solved and reduce it to the problem that we're interested in solving okay so let me write more precisely what this means if you can find a reduction like this it means that solving a is at least as easy as solving b right because i could solve a in particular by converting it into b solving b and then converting it back to the solution to a so in other words if i can solve b i can solve a which is i can phrase informally as a is at least as easy as b and now using uh grammar or contrapositive whatever this is the same thing as saying that b is at least as hard as a and this is what i mean by at least as hard as so this is my definition of at least as hard in this notion of np hardness okay so what np hard means is that i'm at least as hard as all problems in np and so what that means is every problem in np can be reduced to tetris which is kind of funny but in particular that means that if there's an algorithm for tetris there's an algorithm for all problems in np and so that's actually the contrapositive of this statement so saying if there's a polynomial if i take the contrapositive this this is saying if there's a polynomial time algorithm for tetris then p equals np there's a polynomial time algorithm for every problem in np and the way we prove that is by reductions we take an arbitrary problem in np and we reduce it to tetris luckily that's not as hard as it sounds because it's already been done once there is already a reduction from np to from all problems in np to singular problems out there the mp complete problems there was some first mp complete problem which i guess is turing machine non-determinant it's basically simulating lucky algorithm so it's kind of a not very interesting problem but from that problem if you can reduce it to any other problem you know that problem is np-hard as well and so briefly i want to show you some examples of that here so i want to start out with a problem that i'm just going to assume is mp complete and it's called three partition um it's one way to phrase it is i give you a bunch of integers i think i have it written down over here also the board i give you n integers and i'd like to divide them up into n over three groups of size three such that each group of size three has the same sum uh as it's written up there on the board uh so you can also think of this as the following problem i give you a bunch of rectangles that are a side length or a bunch of sticks let's say of varying lengths and i want to group them up like on the right diagram so that in groups of three such that the total length of each group is exactly the same okay this is just a problem and just believe for now that is mp complete i won't prove that but i'd like to do what i'd like to show you is a reduction from this problem to another problem solving jigsaw puzzles uh so you might think jigsaw puzzles are really easy and especially easy if i lose the projector but in fact if you have a jigsaw puzzle where some of the matches are ambiguous if there's multiple pieces that could fit against a given tab or pocket then i claim i can represent this three partition problem by building little sticks like here so if i want to represent a stick of length a i i'm just going to build and ai i didn't mention they're all integers and they're polynomial sized integers i'm going to represent that by about by ai different pieces here and the red tabs and pockets are designed to be unique global to the puzzle like a regular jigsaw puzzle given this piece on the left and this tab on the right there's a unique pocket there's a piece with a unique pocket that fits perfectly into that piece so this this joining is forced and also this joining is forced but the blue tabs and pockets are different they're all the same they're all identical and so if i build this frame using the you know red unique assignments and i build these rectangles if i want to pack these rectangles into this rectangle that's exactly the three partition problem with some details that i didn't fill in but it turns out you'd be forced to group these into groups of size three something like this varying lengths but okay so that's an example of reduction if you believe the three partition is np hard this proves to you that jigsaw puzzles are np hard something you may not have none every time you solve a jigsaw puzzle you can feel good about yourself now especially if it has ambiguous mates next is tetris so here is a reduction from the same three partition problem which is one of my favorite problems to tetris it starts out with this strange board it has a bunch of columns here where i could put pieces so i'm not allowed to put pieces in these dark regions they all have height t t is the target sum that we want all of the numbers to all the triples of numbers to add up to and there's n over three of these uh slots where i can try to put pieces and it's because of this thing over on the right there's no way to clear lines in this game and now to represent a single number ai i'm going to give you this sequence of pieces which starts with an l piece and then it has a i repetitions of this pattern and then it ends with these two pieces and so what ends up happening is that this is in the intended solution you first place an l at the bottom of one of these buckets and then you repeat this pattern in this nice way and it fills up the ai roughly height of this bucket and then at the end you have to put the eye here and what this guarantee what this ends up guaranteeing is that all of these pieces go into a single bucket it's um you can check it's tedious but uh if you tried to put some of these pieces in one bucket and other pieces in a different bucket you would lose some space and then you would die so if you want to survive you have to put all these pieces into one bucket and so again we're just stacking rectangles we're putting a whole bunch of rectangles in one pocket and then a bunch of rectangles in another pocket we can switch back and forth however we want but the only way to win it turns out is if you get all of those rectangles to add up to exactly the right height then you get a picture like this if you don't get a picture like this you can prove you end up dying then i'll give you a bunch of l's then i'll finally give you this t which clears some lines and then i'll give you it's the most satisfying tetris game ever i'll give you a ton of eyes and you get tetris tetris tetris and you clear the entire board and so if you can solve the three partition problem you can clear the board and win the game and be the best tetris player ever and if there is no solution to three partition you're guaranteed to lose um and so this proves tetris is np hard um cool so what else do i want to say briefly i think that's the main main idea so another example so this spot is called x completeness and this includes problems such as end by end chess so we know that uh chess requires exponential time because in fact it's among the hardest problems in exponential time but most common are the somehow because of the two-player nature of the game most common are mp complete problems and we have a bunch of example mp complete problems i'll just briefly mention here so we saw the subset sum problem which we had a polynomial time algorithm for sorry a pseudo-polynomial time algorithm for last class in fact has no polynomial time algorithm assuming p equals np so pseudopoly is the best you can hope for for subset sum there's a related notion called weekly np hardness which i won't get into here three partition is one we saw we saw some reductions to other problems so these are all mp complete longest common subsequence is another dynamic programming problem we saw with two sequences i mentioned you could solve it for three or four or any constant number but if i give you n sequences each of length n that problem is np hard np complete longest simple path in a graph we know how to solve longest path you just solve shortest path and negative weights but longest simple path where you don't repeat vertices that's np-complete relatedly one of the most famous np-complete problems is traveling salesman problem the short finding the shortest path that visits all vertices uh in a given graph so instead of just going from a to b i want to visit all the vertices in the graph a lot of these problems i'm phrasing as mac as optimization problems but when i say mp complete i actually mean a decision version of the problem for example with this one the decision question is is the shortest path that visits all vertices in a graph less than or equal to a given value x if you can solve this then by binary search you can solve the overall weight three coloring a graph is hard even though two coloring or graph is polynomial three coloring is np-complete assigning three colors to the vertices so that no adjacent vertices have the same color finding the largest clique in a given graph which would be useful for analyzing social networks whatever this is a fun one for me as a geometer if you're in a three-dimensional world which i am and i want to find the shortest path from here to there that doesn't collide with any obstacles like this desk and all the chairs and so on in 3d this problem if you can fly so if you're a drone flying among all these obstacles and you want to find the shortest path from a to b uh this is mp complete quite surprising in two dimensions it's polynomial you can reduce it to graph shortest paths but in 3d it's np hard this is a formula problem that comes up a lot given a boolean formula and or not can you ever make it true if it has some variables that are not assigned and some more fun examples are minesweeper or sudoku basically any paper and pencil puzzle you've ever played there's probably a paper out there proving that it's empty complete and on the video game side uh super mario brothers is np hard legend of zelda's mp hard pokemon is np hard these problems are actually all pro a little bit harder than np in a different class called pspace which i won't go into but if you're interested in this stuff there is a whole class devoted to it which has online video lectures so you can watch them whenever you want called 6892 that gives a bunch of especially fun examples of np hardness and other types of hardness proofs from a sort of algorithm's perspective for lots of games and puzzles you you might care about and that's it you