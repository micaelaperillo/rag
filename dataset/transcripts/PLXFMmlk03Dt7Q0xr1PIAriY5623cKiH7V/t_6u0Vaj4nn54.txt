sometime when you were a kid maybe say third grade or so you learned an algorithm from multiplying two numbers maybe your third grade teacher didn't call it that maybe that's not how you thought about it but you learned a well-defined set of rules for transforming an input namely two numbers into an output namely their product so that is an algorithm for solving a computational problem let's pause and be precise about it many of the Le in this course will follow a pattern we'll Define a computational problem we'll say what the input is and then we'll say what the desired output is then we will proceed to giving a solution to giving an algorithm that transforms the input into the output when the integer multiplication problem the input is just two n digigit numbers so the length n of the two input integers X and Y could be anything but for motivation you might want to think of n as large in the thousands or even more perhaps we're implementing some kind of cryptographic application which has to manipulate very large numbers we also need to explain what is the desired output in this simple problem it's simply the product x * y so a quick digression so back in third grade around the same time I was learning this integer multiplication algorithm I got a C in penmanship and I don't think my handwriting has improved much since many people tell me you know by the end of the course they think of it fondly as a sort of acquired taste but if you're feeling impatient please note there are typed versions of these slides which I encourage you to use as you go through the lectures if you don't want to take the time deciphering the handwriting returning to the integer multiplication problem having now specify the problem precisely the input the desired output we'll move on to discussing an algorithm that solves it namely the same algorithm you learned in third grade the way we will assess the performance of this algorithm is through the number of basic operations that it performs and for the moment let's think of a basic operation as simply adding two single-digit numbers together or multiplying two singled digigit numbers we're going to then move on to counting the number of these basic operations performed by the third grade algorithm as a fun function of the number n of digits in the input here is the integer multiplication algorithm that you learned back in third grade Illustrated on a concrete example let's take say the numbers 1 2 3 4 and 5678 as we go through this algorithm quickly let me remind you that our focus should be on the number of basic operations this algorithm performs as a function of the length of the input numbers which in this particular example is four digits long so as you'll recall we just compute one partial product for each digit of the second number so we start by just multiplying four times the upper number 5 6 78 so you know 4 * 8 is 32 2 carry the three 4 * 7 is 28 with the three that's 31 write down the one carry the three and so on when we do the next partial product we do a shift effectively we add a zero at the end and then we just do exactly the same thing and so on for the final two partial products and finally we just add everything up what you probably realized back in third grade is that this algorithm is what we would call correct that is no matter what integers X and Y you start with if you carry out this procedure this algorithm and all of your intermediate computations are done properly then the algorithm will eventually terminate with the product X X Y of the two input numbers you're never going to get a wrong answer you're always going to get the actual product what you probably didn't think about was the amount of time needed to carry this algorithm out to its conclusion termination that is the number of basic operations additions or multiplications of single-digit numbers needed before finishing so let's Now quickly give an informal analysis of the number of operations required as a function of the input length n let's begin with the first partial product the top row how did we compute this number 22712 well we multiplied four times each of the numbers five six 7 and8 so that was four basic operations one for each digit of the top number plus we had to do these carries so those were some extra additions but in any case this is at most twice times the number of digits in the first number at most 2 N basic operations to form this first partial product and if you think about it there's nothing special about the first partial product the same argument says that we need at most two n operations to form each of the partial products of which there are again n one for each digit of the second number well if we need at most 2 N operations to compute each partial product and we have n partial products that's a total of at most two N squared operations to form all of these blue numbers all of the partial products now we're not done at that point we still have to add all of those up to get the final answer in this case 7, 6,652 and that final addition requires a comparable number of operations roughly another say 2 n^ s at most operations so the upshot the high level point that I want you to focus on is that as we think about the input numbers getting bigger and bigger that is as a function of n the number of digits in the input numbers the number of operations that the grade school multiplication algorithm performs grows like some constant roughly for say time n^ 2 that is it's quadratic in the input length n for example if you double the size of the input if you double the number of digits in each of the two integers that you're given then the number of operations you will have to perform using this algorithm has to go up by a factor of four similarly if you quadruple the input length the number of operations is going to go up by a factor of 16 and so on now depending on what type of third grader you were you might well have accepted this procedure as the unique or at least the optimal way of multiplying two numbers together to form their product now if you want to be a serious algorithm designer that kind of obedient timidity is a quality you're going to have to grow out of an early and extremely important textbook on the design and Analysis of algorithm was by AO hprof and Omen it's about 40 years old now and there's the following quote which I absolutely adore so after iterating through a number of the algorithm design paradigms covered in the textbook they say the following perhaps the most important principle of all for the good algorithm designer is to refuse to be content and I think this is a spoton comment I might summarize it a little a little bit more succinctly as as an algorithm designer you should adopt as your Mantra the question can we do better this question is particularly opopo when you're faced with a naive or straightforward solution to a computational problem like for example the third grade algorithm for integer multiplication a question you perhaps did not ask yourself in third grade was can we do better than the straightforward multiplication algorithm and now is the time for an answer