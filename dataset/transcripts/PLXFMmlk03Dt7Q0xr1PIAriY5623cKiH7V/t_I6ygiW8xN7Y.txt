so far we've developed a divide and conquer approach to counting the number of inversions of an array so we're going to split the array in two parts recursively count inversions on the left on the right we've identified the key challenge as counting the number of split inversions quickly where a split inversion means that the earlier index is on the left half of the array the second index is on the right half of the array these are precisely inversions that are going to be missed by both of our recursive calls and the Crux of the problem is that there might be as many as quadratic split inversions get somehow to get the runtime we want we need to do it in linear time so here's the really nice idea which is going to let us do that the idea is to piggyback on merge sword by which I mean we're actually going to demand a bit more of our recursive calls to make the job of counting the number of split recursions easier this is analogous to when you're doing a proof by induction sometimes making the inductive hypothesis stronger that's what lets you push through the inductive proof so we're going to ask our recursive calls to not only count inversions in the array that they're passed but also along Ong the way to sort the array and hey why not we know sorting is fast merge sort will do it in N log end time which is the runtime we're shooting for so why not just throw that in maybe it'll help us in the combin step and as we'll see it will so what is this bias why should we demand more of our recursive calls well as we'll see in a couple slides the merge sub routine almost seems designed just to count the number of split inversions as we'll see as you merge two sorted subarrays you will naturally uncover all of the split inversions so let me just be a little bit more clear about how our previous highlevel algorithm uh is going to now be souped up so that the recursive calls sort as well so here's the high of algorthm we proposed before where we just recursively count inversions on the left side on the right side and then we have some currently unimplemented subroutine count split in which is responsible for counting the number of split inversions so we're just going to augment this as follows so instead of being called count now we're going to call it sort and count that's going to be the name of our algorithm the recursive calls again just invoke sort and count and so now we know uh each of those will not only count the number of inversions in the subarray but also return it return a sorted version so out from the first one we're going to get uh array B back which is the sorted version of the array that we passed it and we'll get a sorted array C back from the second recursive call the sorted version of the array that we passed it and uh now the count split inversions now in addition to Counting split inversions it's responsible for merging the two sorted subarrays B and C C so counts spit if will be responsible for outputting an array D which is a sorted version of the original uh input array a and so I should also rename our unimplemented sub routine to reflect its now more ambitious agenda so we'll call this merge and count split in now we shouldn't be intimidated by asking our combining sub routine to merge the two sorted subray B and C because we've already seen we know how to do that in linear time so the question is just piggybacking on that work can we also count the number of split inversions in an additional linear time we'll see that we can although that's certainly not obvious so you should again at this point have the question why on Earth are we doing this why are we just making ourselves do more work and again the hope is that the payoff is somehow counting split inversions becomes easier by asking our recursive calls to do this additional work of sorting so to develop some intuition for why that's true why uh merging naturally uncovers the number of splits inversions let's recall with the definition of just the original merge sub routine for merge sort was so here's the same pseudo code we went through several videos ago I have renamed the letters of the arrays to be consistent with the current notation so we're given two sorted subarrays these come back from a cursive calls I'm calling them B and C they both have length n/ two and we're responsible for producing the sorted combination of B and C so that's an output array D of length n and again the idea is simple you just take the two sorted subarrays B and C and then you take the output array D which you're responsible for populating and using a index K you're going to Traverse the output array D from left to right that's what this outer for Loop here does and you're going to maintain pointers I and J to the sorted subarrays B and C respectively and the only observation is that whatever the minimum element that you haven't copied over to D yet is it's got to be either the leftmost element of B that you haven't seen yet or the leftmost element of C that you haven't seen yet B and C by virtue of being sorted the minimum L and remaining has to be uh the next one available to either B or C so you just proceed in the obvious way you compare the two candidates for the next one to copy over you look at B of I you look at C of J whichever one is smaller you copy over so the first part of the if statement is for when B contains the smaller one the second part of the the L statement is for when C contains the smaller one okay so that's how merge works you go down B and C and parallel populating D in sorted order from left to right now to get some Feel For What Earth any of this has to do with the split inversions of an array I want you to think about an input array a that has the following property that has the property that there are no split inversions whatsoever so every inversion in this in this input array a is going to be either a left inversion so both indices are a most n /2 or a right inversion so both indices are strictly greater than n /2 now the question is given such an array a what once you're merging at this step what do the sorted subarrays B and C look like for an input array a that has no split inversions the correct answer is the second one that if you have an array with no split inversions then everything in the first half is less than everything in the second half why well consider the Contra positive suppose you had even one element in the first half which was bigger than any element in the second half that pair of elements alone would constitute a split inversion okay so if you have no split inversions then everything on the left is smaller than everything on the in the right half of the array now more to the point think about the execution of the merge sub routine on an array with this property on an input array a where everything in the left half is less than everything in the right half what is merge going to do right so remember it's always looking for whichever is smaller the first element of remaining in b or the first element remaining in C and that's what it copies over well if everything in B is less than everything in C everything in B is going to get copied over into the output array D before c ever gets touched okay so merge has an unusually trivial execution on input arrays with no split inversions with zero split inversions first it just goes through b and copies it over then it just concatenates C okay there's no interleaving between the two so no split inversions means nothing get copied from C until it's absolutely has to until B is exhausted so this suggests that perhaps copying elements over from the second subarray C has something to do with the number of split inversions in the original array and that is in fact the case so we're going to see a general pattern about copies from the second element C second array C into the output array exposing split inversions in the original input array a so let's look at a more detailed example uh to see what that pattern is so let's return to the example in the previous video which is an array with six elements ordered 135 246 so we do our recursive call and in fact the left half of the array is sorted and the right half of the array is already sorted so no sorting work is going to be done and they're actually going to get zero inversions for both our recursive calls remember in this example it turns out all of the inversions are split inversions so now let's Trace through the merge sub routine invoked on these two sorted subarrays and try to spot a connection with a number of split inversions in the original six element array so we initialize indices I and J to point to the first element of each of these subarrays so this left one is B and this right one is C and the output is d now the first thing we do is we copy the one over from B into the output array so one goes there and we advance this index over to the three and here nothing really interesting happened uh there's no reason to count any split inversions and indeed the number one is not involved in any split inversions because one is smaller than all of the other elements and it's also in the first index things are much more interesting when we copy over the element two from the second array C and notice at this point we have diverged the trivial execution that we would see with an array with no split inversions now we're copying something over from C before we've exhausted copying B so we're hoping this will expose some split inversions so we copy over the two and we advance the second pointer J into C and the thing to notice is this exposes two split inversions the two split inversions that involve the element two and those inversions are 3 comma 2 and 5 comma 2 so why did this happen well the reason we copied two over is because it's smaller than all the elements we haven't yet looked at in both B and C so in particular two is smaller than the remaining elements in B the three and the five but also because B is the left array the indices of the three and five have to be less than the index of this two so these are inversions two is further to the right in the original input array and yet it's smaller than these remaining elements in B so there are two elements remaining in B and those are the two split inversions that involve the elements to so now let's go back to the emerging sub rutine so what happens next well next we make a copy from the first array and we sort of realized that nothing really interesting happens when we copy from the first array at least with respect to split inversions then we copy the four over and yet again we discover a split inversion the remaining one which is 5 comma 4 again the reason is given that four was copied over before uh what's left in B it's got to be smaller than it but by virtue of being in the rightmost array it's also got to have a bigger index so it's got to be a split inversion and now the rest of the merge sub routine executes without any real incident the five gets copied over and we know copies from the left array are boring and then we copy the six over and copies from the right array are generally interesting but not if the left array is empty that doesn't involve any split inversions and you will recall uh from the earlier video that these were the inversions in the original array 32 52 and 54 we discovered them all on an automated method uh by just keeping an eye out when we copy from the right array C so this is indeed a general principle so let me State the general claim so the claim is not just in this specific example in the specific execution but no matter what the input array is no matter how many split inversions there might be the split inversions that involve an element of the second half of the array are precisely those elements remaining in the first array when that element gets copied over to the output array so this is exactly the pattern that we saw in the example what were so on the right array C we had the elements two for and six remember every split inversion has to by definition involve one element from the first half and one element from the second half so to count the split inversions we can just group them according to which element of the second array they're uh that they involve so out of the two four and six the two is involved in the split inversions 32 and 52 the three and the five were exactly the elements remaining in B when we copied over two the split inversions involving four is exactly the uh inversion 54 and five is exactly the element that was remaining in b when we copied over the four there's no split inversions involving six and indeed the element B was empty when we copied the six over into the output array D so what's the general argument well it's quite simple let's just zoom in and and fixate on a particular element X that belongs to that first half of the array that's amongst the first half of the elements and let's just examine which y's so which elements of the second array the second half of the original input array are involved in split inversions with X so there are two cases depending on whether X is copied over into the output array D before or after y now if x is copied to the output before y well then since the output's in sorted order it means X has got to be less than y so there's not going to be any split inversion on the other hand if Y is copied to the output D before X then again because we populate D left to right in sorted order that's got to mean that Y is less than x now X is still hanging out in the left array so it has a less index than y y comes from the right array so this is indeed split inversion so putting these two together it says that the elements X of the array B that form split inversions with Y are precisely those that are going to get copied to the output array after y so those are exactly the number of elements remaining in B when y gets copied over so that proves the general claim so this slide was really the key Insight now that we understand exactly why counting split inversions is easy as we're merging together two sorted subarrays it's a simple matter to just trans this into code and get a linear time implementation of a sub routine that both merges and counts the number of split inversions which then in the overall recursive algorithm will have n log and running time just as a merge sort so let's just spend a quick minute filling in those details so I'm not going to write out the pseudo code I'm just going to write out what you need to augment the merge pseudo code discussed a few slides Ago by in order to count split inversions as you're doing the merging and this will follow immediately from the previous claim which indicated how split inversion relate to uh the number of elements remaining in the left array as you're doing the merge so the idea is the natural one as you're doing the merging according to the previous pseudo code of the two sorted subarrays you just keep a running total of the number of split inversions that you've encountered right so you've got your sorted subarray B you've got your sorted subarray C you're merging these into an output array D and as you Traverse through D and K goes from 1 to n you just start the count at zero and you increment it by something each time you do a copy over from either b or c so what's the increment well what did we just see we saw the copies uh involving b don't count we're not going to look at split inversions when we copy over for B only when we look at them from C right every split inversion involves exactly one element from each of B and C so we may as well count them uh via the elements in C and how many split inversions are involved with a given element of C well it's exactly how many elements of B remain when it gets copied over so that tells us how to increment this running count and it follows immediately from the claim on the previous slide that this uh implementation of this running total counts precisely the number of split inversions that uh the original input array a possesses and recall that the left inversions are counted by the first recursive call the right inversions are counted by the second recursive call every inversion is either left or right or split it's exactly one of those three types so with our three different subroutines the two recursive ones and this one here we successfully count up all of the inversions of the original input array so that's the correctness of the algorithm what's the running time we'll recall in merge short we began by just analing izing the running time of merge and then we discuss the running time of the entire merge sort algorithm let's do the same thing here briefly so what's the running time of this subroutine for this merging and simultaneously counting the number of split inversions well there's the work that we do in the merging and we already know that that's linear and then the only additional work here is incrementing this running count and that's constant time for each element of d right each time we do a copy over we do sum a single addition to our running count so constant time per element of D or linear time overall so I'm being a little sloppy here it's sloppy in a very conventional way but it is a little sloppy by writing o of n plus o of Nal o of n be careful when you make statements like that right so if you added o of n to itself n times it would not be o of n but if you add o of n to itself a constant number of times it is still o of n so you might as an exercise want to write out a formal version of what this means basically there's some constant C1 so that the merge step takes at most c1n steps there's a constant C2 so that the rest of the work is almost C2 * n steps so when we add them we get it is most quantity C1 + C2 * n steps which is still Big O of n because C1 plus C2 is a constant okay so linear work for merge linear work for the running count so that's linear work in the sub routine overall and now by exactly the same argument we used in merge sort because we have two recursive calls on half the size and we do linear work outside of the recursive calls the overall running time is O of n log n so we've really just piggybacked on merge short uh up to the constant factor a little bit to do the counting along the way but they're running time remains big go of and log in