in this next series of videos we'll get some more practice applying the divide and conquer algorithm design Paradigm to various problems this will also give us a glimpse of the kinds of application domains to which it's been successfully applied we're going to start by extending the merge sort algorithm to solve a problem involving counting the number of inversions of an array before we tackle the specific problem of counting the number of inversions in an array let me say a few words about the divide and conquer Paradigm in general so again you've already seen the totally canonical example of divine and Conquer namely merge sword so the following three conceptual steps will be familiar to you the first step no prizes for guessing uh is you divide the problem into smaller sub problems sometimes this division happens only in your mind it's really more of a conceptual step than part of your code sometimes you really do copy over parts of the input into uh say new arrays to pass on to your recursive calls the Second Step again no prizes here is you conquer the sub problems just using recursion so for example in merge short you conceptually divide the array into two different pieces and then you recursively conquer or sort the first half of the array and you you do the same thing with the second half of the array now of course it's not quite as easy as just doing these two steps dividing the problem and then solving the sub problems recursively usually you have some extra cleanup work after the recursive calls end to stitch together the solutions to the sub problems into one for the big problem the problem that you actually care about recall for example in merge sort after our recursive cause the left half of the array was sorted the right half of the array was sorted but we we still had to stitch those together uh and merge into a sorted version of the entire array so the third step is to combine the solutions to the sub problems into one of the original problem generally the largest amount of Ingenuity happens in the third step how do you actually quickly combine solutions to sub problems into one to the original problem sometimes you also get some cleverness in the first step with division sometimes it's as simple as just spitting an array in two but there are cases where the division step also has some Ingenuity now let's move on to the specific problem of counting inversions and see how to apply this divide and conquer Paradigm so let me Begin by defining the problem formally we're given as input an array a of length n and you can Define the problem so that the array a contains any old distinct numbers but let's just keep things simple and assume that it contains the numbers one through n the integers in that range in some order that captures the essence of the problem and the goal is to compute the number of inversions of this array so what's an inversion you may ask well inversion is just a pair of array indices I and J with I smaller than J so that the earlier array entry the I entry is bigger than the later one than the jth one so one thing that should be evident is that if the array contains these numbers in sorted order if the array is simply 1 2 3 4 all the way up to n then the number of inversions is zero the converse you might also want to think through if the array has any other ordering of the numbers between one and N other than the sorted one then it's going to have a nonzero number of inversions let's look at another example so suppose we have an array of six entries so the numbers 1 through six in the following order 135 followed by 2 46 so how many inversions does this array have so again what we need to look for are pairs of array entries so that the earlier or left entry is bigger than the later or right entry so one example which we see right here would be five and two those are right next to each other and out of order the earlier entry is bigger than the other one but there others there's three and two for example those are out of order and uh five and four are also out of order and I'll leave it to you to check that those are the only three pairs that are out of order so summarizing the inversions in this array of length six are 32 52 and 54 corresponding to the array entries uh 2 4 34 and 35 pictorially we can think of it thusly we can first write down the numbers in order one up to six and then we can write down the numbers again but ordered in the way that they're given in the input array so 1 3 5 2 4 6 and then we can connect the dots meaning we connect one to one we connect 2 to two and so on it turns out and I'll leave it for you to to think this through that the number of Crossing pairs of line segments precisely correspond to the number of inversions so we see that there are 1 2 three Crossing line segments and these are exactly in correspondence with the three inversions uh we found earlier 5 and two 3 and 2 and five and four now why might you want to solve this problem you might ask well there's a few reasons it comes up but one would be to have a numerical similarity measure that quantifies how close two different ranked lists are to each other so for example suppose I took you and a friend and I took identified 10 movies that both of you had seen and I asked each of you to order to rank these movies from your most favorite to your least favorite now I can form an array and compute inversions and it quantifies in some sense how dissimilar your two rankings are to each other so in more detail in the first entry of this array I would put down the ranking that your friend gave to your favorite movie so if you had your favorite movie star wars or whatever and your friend only thought it was the fifth best out of the 10 then I would write down a five in the first entry of this array similarly I would take your second favorite movie I would at how your friend ranked that I would put that in the second entry of the array and so on all the way up to the 10th entry of the array where I would put your friend's ranking of your least favorite movie now if you have exactly identical preferences if you rank them exactly the same way the number of inversions of this array would be zero and in general the more inversions this array has it quantifies that your lists look more and more different from each other now why might you want to do this why might you want to know whether two different people ranked things in a similar way had similar preferences well one reason would be in what's called collaborative filtering so probably many of you have had the experience of going to a website and if you've made a few purchases from this website it starts recommending further purchases for you so one way to solve that problem under the hood is to look at your purchases look at what you seem to like find other people who have similar preferences or similar history look at things that they've bought that you haven't and then recommend uh new products to you based on what similar customers seem to have bought so this problem captures some of the essence of identifying which customers or which people are similar Based on data about what they prefer so just to make sure we're all on the same page let me pause for a brief quiz we've already noticed that a given array will have zero inversions if and only if it's in sorted order if it only contains the numbers 1 through n in order so on the other side what is the largest number of inversions an array could possibly have let's say just for an array of size six like the one in this example here so the answer to this question is the first one 15 or in general in an n element array the largest number of inversions is n choose 2 also known as n * n -1 / 2 which again in the case of a six element array is going to evaluate to 15 the reason is the worst Cas is when the array is in backwards order reverse sorted order and then every single pair of array indices is inverted and so the number of indices i j with I less than J is precisely and choose to let's now turn our attention to the problem of computing the number of inversions of an array as quickly as possible so one option which is certainly available to us is the Brute Force algorithm and by Brute Force I just mean we could set up a double for Loop one which goes through I one which goes through J bigger than I and we just check each pair i j individually with I less than J whether that particular pair of array entes Ai and AJ is inverted and if it is then we add it to a running count and then we return the final count at the end of the double four Loop that's certainly correct the only problem is as we just observed there's n choose two or a quadratic number of potential inversions so this algorithm is always going to run in time quadratic in the array length now remember the Mantra of any good algorithm designer can we do better and the answer is yes and the method will be using divide and conquer the way in which we divide will be motivated directly by merge sort where we recurse separately on the left and the right halves of the array we're going to do the same thing here to understand how much progress we can make purely using recursion let's classify the inversions of array into one of three types so suppose we have an inversion of an array I comma J and remember in an inversion you always have I less than J we're going to call it a left inversion if both of the array indices are at most n /2 where n is the array length we're going to call it a right inversion if they're both strictly greater than n /2 and we're going to call it a split inversion if the smaller index is the most n /2 and the larger index is bigger than n over two we can discuss the progress made by recursion in these terms when we recurse on the left half of an array if we Implement our algorithm correctly will successfully be able to count all of the inversions located purely in that first half those are precisely the left inversions similarly a second recursive call on just the right half of an array the second half of an an array will successfully count all of the right inversions there Remains the question of how to count the split inversions but we shouldn't be surprised there's some residual work left over even after the recursive calls do their job that of course was the case in merge sort recursion magically took care of sorting the left half of the array sorting the right half of the array but there was still after their return the matter of merging those two sorted lists into one and here again after the recursion there's going to be the matter of cleaning up and Counting the number of split inversions so for example if you go back to the six element array we worked through before 135 246 you'll notice that there in fact all of the inversions are split so the recursive calls will both come back counting zero inversions and all of the work for that example will be done by the count split inversions sub routine so let's summarize where things stand and give an underspecified highle description of the algorithm as we envision it there is a base case I'll go ahead and write it down for completeness which is if we're given a one element array then there's certainly no inversion so we can immediately return the answer zero for any bigger array we're going to divide and conquer so we'll count the left inversions with a recursive call the right inversions with a recursive call and then we'll have some currently unimplemented subroutine that counts the split inversions since every inversion is either left or right or split and can't be any more than one of those three then we having done these three things we can simply return their sum so that's our high level attack on how we're going to count up the number of inversions and of course we need to specify how we're going to count the number of split inversions and moreover we like that sub routine to run quickly an analogy to merge sort where outside the recursive calls we did merely linear work out uh in the merge sub routine here we'd like to do only linear work in counting up the number of split inversions if we succeed in this goal if we produce a correct and linear time implementation to count up the number of split inversions then this entire recursive algorithm will run in bigo of n log n time the reason the overall algorithm will run in o of nlog n time is exactly the same reason that merge sort ran in nlog N time there's two recursive calls each on a problem of half the size and outside of the recursive calls we would be doing linear work so you could copy down exactly the same recursion Tre argument we used for merge sort it would apply equally well here alternatively very soon we will cover the master method and as one very special case it will prove that uh this algorithm if we can implement it thusly will run in O of n log n time now one thing to realize is this is a fairly ambitious goal to count up the number of split inversions in linear time it's not that there can't be too many split inversions there can actually be a lot of them if you have an array where the first half of the array contains the numbers n /2 + 1 up to n whereas the second part of the array contains the numbers one up to n /2 that has a quadratic number of inversions all of which are split so what we're attempting to do here is count up a quadratic number of things using only linear time can it really be done yes it can as we'll see you in the next video