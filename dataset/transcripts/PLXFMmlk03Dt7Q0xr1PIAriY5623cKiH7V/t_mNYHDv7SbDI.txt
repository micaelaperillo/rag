so in this video we'll start talking about the heap data structure so in this video I want to be very clear on what are the operations supported by a heap what running time guarantees you can expect from canonical implementations and I want you to get a feel for what kinds of problems they are useful for in a separate video we'll take a peek under the hood and talk a little bit about how heaps actually get implemented but for now let's just focus on how to use them as a client so the number one thing you should remember about a given data structure is what operations it supports and what is the running time you can expect from those operations so basically a heap supports two operations there's some bells and whistles you can throw on but the two things you got to know is insertion and extract-min alright so the first thing I have to say about a heap is that it's a container for a bunch of objects and each of these objects should have a key like a number so that for any given object so you can compare their keys and say one key is bigger than the other key so for example maybe the objects are employee records and the key is social security numbers maybe the objects are the edges of a network and the keys are something like the length of the weight of an edge maybe each object indicates an event and the key is the time at which that event is meant to occur now the number one thing you should remember about a given data structure is first of all what are the operations that it supports and second of all what is the running time you can expect from those operations for a heap essentially there's two basic operations insert and extract the objects that has the minimum key value so in our discussion of heaps we're going to allow ties they're pretty much equally easy with it without ties so when you extract min from a heap demand duplicate key values then there's no specification about which one you get you just get one of the objects that has a tied for the minimum key value now of course there's no special reason that I chose to extract the minimum rather than the maximum either you can have a second notion of a heap which is a max heap which always returns the object to the maximum key value or if all you have at your disposal is one of these extract min type heaps you can just negate the sign of all of the key values before you insert them and then extract-min will actually extract the max key value so just to be clear I'm not proposing here a data structure that supports simultaneously an extract min operation and an extract max operation if you want to go through those operations to be data structures that would give it to you probably a binary search tree is the first thing you want to consider so I'm just saying you can have a heap of one of two flavors either the heap supports extract min and not extract max or the equal of support extract max and not extract min so I mentioned that you should remember not just the supported operations of a data structure but what is the running time of those operations now for the heap the way it's canonically implemented the running time you should expect is logarithmic in the number of items in the heap and it's log base 2 with quite good constants so when you think about heaps you should absolutely remember these two operations optionally there's a couple other things about heaps that are might be worth remembering some additional operations that they can support so the first is an operation called heapify like a lot of the other stuff about heaps it has a few of the names as well but I'm going to call it P / v one standard name and the point a heapify is to initialize a heap in linear time now if you have n things and you want to put them all on the heap obviously you could just invoke inserts once for each object if you have n objects it seems like that would take n times log n time login for each of the n inserts but there's a slick way to do them in a batch which takes only in linear time so that's the heapify operation and another operation which can be implemented although there are some subtleties as you can delete not just the minimum but you can delete an arbitrary element from the middle of a heap again in logarithmic time I mentioned this here primarily because we're going to use this operation when we use heaps to speed up Dijkstra's algorithm so that's the gist of a heap you maintain objects that have keys you could insert in logarithmic time and you can find the one with the minimum key in logarithmic time so let's turn to applications I'll give you several but before I dive in any what happened let me just say what's the general principle what should trigger you to think that maybe you want to use a heap data structure in some task so the most common reason to use a heap is if you notice that your program is doing repeated minimum computations especially via exhaustive search and most of the applications that we go through will have this flavor it'll be they'll be a naive program which does a bunch of repeated minimums using just brute-force search and we'll see that a very simple application of a heap will allow us to speed it up tremendously so let's start by returning to the mother of all computational problems sorting and unsorted array now a sorting algorithm which is sort of so obvious and suboptimal that I didn't even really bother to talk about it and any other point in the course is selection sort what are you in selection sort you do is scan through the unsorted array you find the minimum element you put that in the first position you scan through the other n minus 1 elements you find the minimum among them you put that in the second position you scan through the remaining n minus 2 and sorted elements you find the minimum you put it in the third position and so on so evidently this set sorting algorithm does a linear number of linear scans through this array so this is definitely a quadratic time algorithm that's why I didn't bother to tell you about it earlier so this certainly fits the bill as being a bunch of repeated minimum computations or for each computation we're doing exhaustive search so this we should just a light bulb should go off and say ah-ha can we do better using a heap data structure and we can and the sorting algorithm that we get is called heap sort and given a heap data structure the sorting algorithm is totally trivial we just insert all of the elements from the array into the heap then we extract the minimum one by one from the first extraction we get the minimum of all n elements the second extraction gives us the minimum of the remaining n minus 1 elements and so on so when we extract min one by one we can just populate a sorted array from left to right boom we're done what is the running time of heap sort well we insert each element once and we extract each element once so that's to n heap operations and what I promised you is that you can count on heaps being implemented so that every operation takes logarithmic time so we have a linear number of logarithmic time operations for a running time of n log n so let's take a step back and appreciate what just happened we took the least imaginative sorting algorithm possible selection sort which is evidently quadratic time we recognize the pattern of repeated minimum computations we swapped in the heap data structure and boom we get an N log n sorting algorithm which is just too trivial lines and remember n log n is a pretty good running time for a sorting algorithm this is exactly the running time we had from merge sort this was exactly the average running time we got from randomized quicksort moreover he sort is a comparison based sorting algorithm we don't use any data about the key elements we just used it as a totally ordered set and as some of you may have seen in an optional video there does not exist a comparison based sorting algorithm with running time better than n log n so for the question can we do better the answer is no if we use a comparison based sorting algorithm like heap sort so that's pretty amazing all we do is swap in a heap but the running time drops from the really quite unsatisfactory quadratic to the optimal n log n moreover it heaps too it's a pretty practical sorting algorithm you run this it's going to go really fast is it as good as quicksort hmm maybe not quite but it's close it's getting into the same ballpark so let's set up another application which which frankly in some sense is almost trivial but this is also a canonical way in which heaps are used and in this application it will be natural to call a heap by a synonymous name a priority queue so what I want you to think about for this example is that you've been tasked with writing software that performs a simulation of the physical world so you might pretend for example that you're helping write a video game which is for basketball now why would a heap come up in a simulation context well the objects in this application are going to be events records so an event might be for example that the ball will reach the hoop at a particular time and that would be because a player shot at a couple seconds ago when if for example the ball hits the rim that could or another event to be scheduled for the near future which is that a couple players are going to vie for the rebound that event in turn could trigger the scheduling of another event which is one of these players commits it over the back foul on the other one and knocks them to the ground that in turn to trigger another end which is the player that I've knocked on the ground gets up and argues the alcohol and so on so when you have event records like this there's a very natural key which is just the timestamp the time at which this event in the future is scheduled to occur now clearly a problem which has to get solved over and over and over again in this kind of simulation is you have to figure out what's the next event that's going to occur you have to know what other events to schedule you have to know how to update the screen and so on so that's a minimum computation so a very silly thing you could do is just maintain an unordered list of all of the events that have ever been scheduled and do a linear pass through them and compute the minimum but you're going to be computing minimums over and over and over again so again that light bulb should go on and you could say ah maybe a heap is just what I need for this problem and indeed it is so if you're storing these event records in a heap with the key being the time stamps then when you extract min the heap hands for you on a silver platter using only logarithmic time exactly which event is going to occur next so let's move on to a less obvious application of heaps which is a problem I'm going to call median maintenance the ways that this is gonna work as you and I are gonna play a little game so on my side what I'm going to do is I'm going to pass you index cards one at a time when there's a number written on each index card your responsibility is to tell me at each time step the median of the numbers that I passed used so far so after I've given you the first eleven numbers you should tell me as quickly as possible the six smallest after I've given you thirteen numbers you should tell me the seven smallest and so on moreover we know how to compute the median in linear time but the last thing I want is for you to be doing a linear time computation every single time step right I'll I give you one new number do you really have to do linear time just to recompute the median if I just gave you one new number so to make sure that you don't run a linear time selection algorithm ever to give you one new number I'm gonna put a budget on the amount of time that you can use at each time step to tell me the median and it's gonna be logarithmic in the number of numbers that passed you so far so I encourage you to pause the video at this point and spend some time thinking about how you would solve this problem all right so hopefully you've thought about this problem a little bit so let me give you a hint what if you use two heaps you see a good way to solve this problem then all right so let me show you a solution to this problem that makes use of two heaps so the first tip we'll call H low the sequel supports extract max remember we discussed that a heap you can pick whether it supports extract min or extract max you don't get both but you can get either one it doesn't matter and then we'll have another heap h-hi which supports extract min and the key idea is to maintain the invariant that the smallest half of the numbers that you've seen so far are all in the low heat and the largest half of the numbers that you've seen so far are all in the high heat so for example after you've seen the first ten elements the smallest five of them should reside in H Lo and the biggest five of them should reside in H hi after you've seen 20 elements then the bottom ten the smallest tension should reside in H Lo and the largest ten should reside in H hi if you've seen an odd number either one can be bigger it doesn't matter so if you have 21 you have the smallest ten in the one in the biggest 11 and the other or vice versa it's not not important now given this key idea of splitting the elements in half according to the two heaps you need two realizations which I'll leave for you to check so first of all you have to prove eventually maintain this invariant with only o of log I work and step I second of all you have to realize this invariant allows you to solve the desired problem so let me just quickly talk through both of these points and then you can think about it in more detail on your own time so let's start with the first one how can we maintain this invariant using only log I work at time step I this is a little tricky so let's suppose we've already processed the first 20 numbers and the smallest ten of them we've all worked hard to put only in H Lo and the biggest ten of them we've worked hard to put only in h-hi now here's your preliminary observation what's true so what do we know about the maximum element in H low well these are the tenth smallest overall and the maximum then is the biggest of the temps modest so that would be the tenth order statistic so the temps most overall now what about in the high heat what is its minimum value where those are the biggest ten values so the minimum of the ten biggest values would be the 11th order statistic okay so the maximum of H low is the tenth order statistic the minimum of H high is the 11th or a statistic they're right next to each other these are the fact the two medians right now so when this new element comes in the 21st element comes in we need to know which heap to insert it into and well it just if it's smaller than the tenth order statistic then it's still going to be in the bottom then it's in the bottom half of the elements it needs to go in the low heat if it's bigger than the eleventh or statistic if it's bigger than the minimum value of the high heat then that's where it belongs in the high heat if it's wedged in between the tenth and eleventh order statistics it doesn't matter we can put it in neither one this is the new median anyways now we're not done yet with this first point because there's a problem with potential imbalance so imagine that the 21st element comes up and it's less than the maximum of the low heap so we stick it in the low heap and now that has a population of 11 and now imagine the 22nd number comes up and that again is less than the maximum element in the low heap so again we have to insert it in the low heap now we have 12 elements in the low key but we only have 10 in the right heap so we don't have a 50/50 split of the numbers but we can easily rebalance we just extract the max from the low key and we insert it into the high heap and boom now they both have 11 and the low heap has the smallest 11 and the high heat has the biggest 11 so that's how you maintain the invariant that you have this 50/50 split in terms of the small and the high and between the two heaps you check where it lies with respect to the max of the low heap and the men in the of the high heap you put in the appropriate place and whenever you need to do some rebalancing you do something and this uses only a constant number of heap operations when a new number shows up so that's log I work so now given this discussion it's easy to see the second point given that this invariant is true at each time step how do we compute the median well it's going to be either the maximum of the low heat and or the minimum of the high heat depending on whether I is even or odd if it's even both of those are medians if I is odd and then it's just whichever heat has one more element than the other one so the final application we'll talk about in detail in a different video of video concerned with the running time of Dijkstra's shortest path algorithm but I do want to mention it here as well just to reiterate the point of how careful use of data structures can speed up algorithms especially when you're doing things like minimum computations in an inner loop so that's your shortest path algorithm hopefully many of you have watched that video at this point but basically what it does is it has a central while loop and so it operates once per vertex of the graph and at least naively it seems like what each iteration of the while loop does is an exhaustive search through the edges of the graph computing a minimum so if we think about the work performed in this naive implementation it's exactly in the wheelhouse of a heap right so what we do in each of these loop iterations is do an exhaustive search computing a minimum you see repeated repeated minimum computations the light bulb should go off and you should think ah maybe a heat can help and heat can help in Dijkstra's algorithm the details are a bit subtle and they're discussed in the separate video but the upshot is we get a tremendous improvement in the running time so recalling that M denotes the number of edges and n denotes the number of vertices of a graph with the careful deployment of heaps in Dijkstra's algorithm the runtime drops from this really a rather large polynomial the product of the number of vertices in the number of edges down to something which is almost linear time namely oh of M log n where m is the number of edges and n is the number of vertices so the linear time here would be a levan many of the number of edges were picking up an extra log factor but still this is basically as good as sorting so this is a fantastically fast shortest path algorithm certainly way way better than what you get if you don't use heaps and just to repeated exhaustive searches for the minimum so that wraps up our discussion of what I think you really want to know about heaps namely what are the key operations that it supports was the running time you can expect from those operations what are the types of problems that the data structure will yield speed ups for and a suite of applications for those of you that want to take it to the next level and see a little bit about the guts of the implementation there is a separate optional video that talks a bit about that