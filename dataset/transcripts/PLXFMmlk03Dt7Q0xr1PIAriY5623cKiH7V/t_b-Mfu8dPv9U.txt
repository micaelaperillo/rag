okay so this video is not about any particular graph problem not about any particular graph algorithm just sort of the preliminaries we need to discuss algorithms on graphs how do we measure their size how do we represent them and so on remember what a graph is it really has two ingredients first of all there's the set of objects we're talking about those might be called vertices synonymously we might call them nodes we represent pairwise relationships using edges these can be either undirected in which case they're ordered pairs or an edge can be directed from one to another in that case they're ordered pairs and we have a directed graph now when we talk about say the size of a graph or the running time of an algorithm that operates on a graph we need to think about what we mean by input size in particular for a graph there's really two different parameters that control how big it is unlike an array for arrays we just had a single number the length for graphs we have the number of vertices and we have the number of edges usually we'll use the notation n for the number of vertices M for the number of edges so the next Quiz asks you to think about how the number of edges m can depend on the number of vertices n so in particular I want you to think for this quiz about an undirected graph it has n vertices there's no parallel edges okay so for a given pair of vertices there's either zero or one Edge between them moreover let's assume that the graph is unconnected okay so I don't want you to think about graphs that have zero edges now I haven't defined what a graph is what it means for a graph to be connected formally yet but I hope you get the idea means it's in one piece you can't break it into two parts uh that that have no edges Crossing between them so for such a graph no parallel edges in one piece and vertices think about what is the minimum number of edges it could possibly have and what is the maximum number of edges as a function of n that it could possibly have all right so the correct option is the first one the fewest number of edges that a connected undirected graph can have is n minus one and the maximum number of edges that an underc graph with no parallel edges can have is n * N - 1/2 better known as n shoose two so why does it need at least n minus one edges if it's going to be in one piece well think about adding the edges one at a time okay each of the edges of the graph now initially you just have a graph with zero edges the graph has n different pieces n isolated vertices and there's no edges at all now each time you add one Edge what you do is you take two of the existing pieces at Best and fuse them into one so the maximum decrease you can have in the number of different pieces of a graph is it can decrease by one each time you add an edge so from a starting point of n different pieces you got to get down to one piece so that requires the addition of n minus one edges you can also convince yourself of this by by drawing a few pictures and noticing that trees achieve this bound exactly so for example here is a four vertex tree that has three edges so this is a case where m is indeed n minus one now for the upper bound why can't you have more than n shoes too well it's clear that the largest number of edges you can have is for the complete graph or every single pair of edges has one between them again there's no parallel arcs and edges are unordered so there's at most and choose two possibilities of where to put an edge so again if n equals 4 here would be an example with a maximum possible number six edges so now that I've got you thinking about how the number of edges can vary with the number of vertices let me talk about uh the distinction between sparse and dense graphs it's important to distinguish between these two concepts because some data structures and algorithms are better suited for sparse graphs other data structures and algorithms are better suited for dense graphs so to make this precise let me just uh put down this very common notation n is the number of vertices of the graph under discussion m is the number of edges this is quite standard notation please get used to it and use it yourself if you reverse these you will confuse a lot of people uh who have familiarity with graph algorithms and data structures now one thing we learned from the previous quiz is the following so in most applications not all applications but most applications m is at least linear in N remember in the quiz we saw is at least n minus one if you wanted the graph to be connected and it's also Big O of n^2 this is under the assumption that there's no parallel arcs now there are cases where we want to allow parallel arcs in fact we'll do that in the contraction algorithm for the Min cut problem there are cases where we want to allow the number of edges to drop so low that the graph breaks into multiple pieces for example when we talk about connected components but more often than not we're thinking about a connected graph with no parallel edges and then we can pin down the number of edges M to be somewhere between linear and the number of nodes linear and n and quadratic and in now I'm not going to give you a super formal definition of what a sparse or a dense graph is and people are a little loose with this this terminology uh in practice but basically sparse means you're closer to the lower bound closer to linear dense means you're closer to the upper bound closer to quadratic now I know this leaves ambiguity when the number of edges is something you know like n the three halfes uh usually in that case you'd think of it as a dense graph so usually anything which is more than n times some logarithmic terms you'd think about as a dense graph but again people are a little bit sloppy with this uh when they talk about graphs next I want to discuss two representations of graphs and we're mostly going to be using the second one in this course but this first one the adjacency Matrix I do want to mention just briefly just on this slide this is a supernatural idea where you represent the edges in a graph using a matrix let me describe it first for undirected graphs so the Matrix is going to be denoted by capital A and it's a square n byn Matrix where n is the number of vertices of the graph and the semantics are the J entry of the Matrix is one if and only if there's an edge between the vertices I and J in the graph I'm assuming here that the vertices are named 1 2 3 4 Etc all the way up to n it's easy to add bells and whistles to The adjacency Matrix to accommodate parallel edges to accommodate Edge weights or to accommodate directed arcs directed edges if you wanted to have parallel arcs you can just have ai J denote the number of arcs that uh are between I and J if edges have different weights you can just have AIG be the weights of the I Edge and for the directed graph you can use plus ones and minus ones so if the arc is directed from I to J you'd set I AI J to be plus one if the arc is directed from J to I you'd set AI J to minus one there are many metrics by which you can evaluate a data structure or a representation uh two important ones I want to discuss here are first of all the number of resources it requires and in this context that's the amount of space that the data structure needs the second thing is what are the operations that the data structure supports so let's just begin with the space requirements what are they for the adjacency Matrix all right so the answer at least with the sort of straightforward way of storing a matrix is N squared and this is independent of the number of edges so you could try to beat this down for sparse graphs using sparse Matrix tricks but for the basic idea of just actually representing an N byn Matrix you got N squared entries you got to store one bit in each whether the edge is there or not so that's going to give you n s space the constants are of course very small because you're just storing one bit per entry but nonetheless this is quadratic in the number of vertices now that's going to be fine if you have a dense graph if the number of edges is as high as N squared then you're not really wasting anything in this representation but in a sparse graph if m is much closer to linear then this is a super wasteful representation let's talk about the adjacency list representation this is the dominant one we'll be using in this class this has several ingredients so first you keep track of both the vertices and the edges as independent entities so you're going to have an array or a list of each and then we want these two arrays to cross reference each other in the obvious way so given a Vertex you want to know which edges it's involved in given an edge you want to know what its end points are so let's say first most simply each Edge is going to have two pointers one for each of the two end points in a directed graph of course it would keep track of which one is the head and which one is the tail now each vertex is going to point to all of the edges of which it's a member now in an directed graph it's clear what I mean by that and a directed graph you can do it in a couple ways generally you'd have a Vertex keep track of all of the edges for which it is the tail that is all of the edges which you can follow one hop out from the edge if you wanted to you can also have a second array at a more expensive storage where the vertex also keeps track of the edges pointing to it the edges for which it's the head so let me ask you the same question I did with an adjacency Matrix what is the space required of an adjacency list as a function of the number of edges M and the number of vertices n of the graph so the correct answer to this question is the third option Theta of m + n which we're going to think of as linear space in the size of the graph so this quiz is is a little tricky so to explain the answer let me return to the slide with the ingredients of chency lists and let's compute the space for each of these four ingredients separately most of them are straightforward for example consider the first ingredient this is just an array or a list of the N vertices and we just need constant space per vertex to keep track of its existence so this is going to be Theta of n linear in the number of vertices similarly for the M edges we just need linear space in the number of edges to remember their existence so that's going to be Theta of M now each Edge has to keep track of both of its end points so that's two pointers but two is a constant for each of the M edges we have a constant space to keep track of end points so that's going to give us another Theta of M constant per Edge now this fourth case you might be feeling kind of nervous because a vertex in principle uh could have edges involving all n minus one of their vertices so the number of pointers at a single vertex could be Theta of n also you could have you know you do have n vertices that could be Theta of n^2 and certainly in something like a complete graph you really would have that much but the point is in sparse graphs n n s is way Overkill to the space needed by this four set of pointers actually if you think about it for each pointer in the fourth category a Vertex pointing to a given Edge there is a pointer in the third category pointing in the opposite direction from that edge back to that vertex so there's actually a onetoone correspondence between pointers in the third category and pointers in the fourth category since the third category has space Theta of M so does all of the pointers in the fourth category so adding up over the four ingredients we have 1 Theta of N and three Theta of M's so that's going to give us overall a Theta of m + n if you prefer another way you could think about this would be Theta of the max of m&n these are the same up to a constant Factor now as we discussed in a previous slide often m is going to be bigger than n but I wanted to do a generic analysis here which applies even if the graph is not connected if even if it is in multiple pieces so the space of the adjacency list is within a constant Factor the same as the number of ingredients in the graph the number of vertices plus the number of edges so in that sense that's exactly what you want now being confronted with these two graph representations that I've shown you I'm sure you're asking well which one should you remember which one should you use and the answer as it so often is is it depends it depends on two things it depends on the density of your graph it depends on how M compares to uh n and it also depends on what kind of operations that you support want to support now given what we're covering in this class and also the motivating applications I have in mind uh I can give you basically a clean answer to this question for the purposes of these five weeks which is we're going to be focusing on adjacency lists the reason we're going to focus on adjacency lists in this class is both is for both of these reasons both because of the operations we want and both because of the graph density and motivating applications so first first of all most of the graph Primitives not all but most will be dealing with Graph Search and adjacency lists are perfect for doing Graph Search you get to a node you follow an outgoing Arc you go to another node you follow an outgoing Arc and so on and so adjacency lists are the perfect thing to do Graph Search adjacency matrices are definitely good for certain kinds of graph operations but they're not things we're really going to be covering in this class so that's reason one reason two is a lot of the motivations for graph Primitives these days comes from massive massive Network works I mentioned earlier how the web can be fruitfully thought of as a directed graph where the vertices are individual web pages and directed arcs correspond to hyperlinks going from the page with the hyperlink pointing to the one that the hyperlink goes to now it's hard to get an exact measurement of the web graph but a conservative lower bound on the number of vertices is something like 10 billion so that's 10 the 10 now that's pushing the limits of what computers can do but it's within the limits so if you you work hard you can actually operate on graphs with 10 to the 10 nodes now suppose we use an adjacency Matrix representation so if n is 10 10 then n SAR is going to be like 10 20 and now we're getting close to the estimated number of atoms in the known universe so that is clearly not feasible now and it's not going to be feasible ever so the adjacency Matrix representation is totally out for uh huge sparse graphs like the web graph adjacency lists well the degree on average in the web is thought to be something like 10 so the number of edges is only going to be something like 10 the 11 and then the adjacent SE this representation will be proportional to that and again that's really pushing what we can do with current technology but it is within the limits so using that representation we can uh do non-trivial computations on graphs even at the scale of the web graph