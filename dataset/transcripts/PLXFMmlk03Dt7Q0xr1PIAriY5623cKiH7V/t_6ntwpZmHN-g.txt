now let's turn to the analysis of the deterministic selection algorithm that we discussed in the last Slide by Blum Floyd Pratt revest and tarent in particular let's prove that it runs in linear time on every possible input Let's uh remind you what the algorithm is so the idea is we just take the r select algorithm but instead of choosing a pivot at random we do quite a bit more work to choose what we hope is going to be a guaranteed pretty good pivot so again lines 1 through three are the new choose pivot sub routine and it's essentially implementing a two- round knockout tournament so first we do the first round matches so what does that mean that means we take a we think of it as comprising these groups of five elements so the first five elements 1 through five then the elements 6 through 10 The Elements 11 through 15 in the array and so on we sort each of those five using let's say merge sort although it doesn't matter much uh then the winner of each of these n over five first round matches is the median of those five that is the third highest element third largest element out of the five so we take those n over five first round win the middle element of each of the five and the sorted to groups we copy those over into a new array Capital C of length n over five and then we run the second round of our tournament at which we elect the median of these n over five first round winners as our final pivot as our final winner so we do that by recursively calling deselect on C it has link n over five we're looking for the median so that's the N over 10th order statistic in that array so we call the pivot p and then we just proceed exactly like we did in the randomized case that is we partition a around the pivot we get get a first part a second part and we recurs on the left side or the right side as appropriate depending on whether the pivot uh is less than or bigger than the element that we're looking for so the claim is Believe It or Not that this algorithm runs in linear time now you'd be right to be a little skeptical of that claim certainly you should be demanding from me some kind of mathematical argument about this linear time claim it's not at all clear that that's true one reason for skepticism is that this is an unusually extravagant an algorithm in two senses for something that's going to run in linear time first is first is its extravagant use of recursion there are two different recursive calls as discussed in the previous video we have not yet seen any algorithm that makes two recursive calls and runs in linear time the best case scenario was always in log in time for our two recursive call algorithms like merge sort or quick sort the second reason is that outside of the recursive calls it seems like it does kind of a lot of work as well so to drill down on that point point and get a better understanding for how much work this algorithm is doing the next Quiz asks you to focus just on line one so when we sort groups of five in the input array how long does that take so the correct answer to this quiz is the third answer maybe you would have guessed that given that I'm claiming that the whole algorithm takes linear time you could have guessed that this sub routine wouldn't be worse than linear time but you should also be wondering you know isn't sorting always n log in so aren't we doing sorting here why isn't the N log in thing kicking in the reason is we're doing something much much more modest than sorting the length n input array all we're sorting are these puny little subarrays that have only five elements and that's just not that hard that can be done in constant time so let me be a little more precise about it the claim is that sorting an element with an array with five elements takes only some constant number of operations let's say 120 where did this number 120 come from well you know for example suppose we use merge s if you go back to those very early lectures we actually counted up the number of operations that merge sorts needs to sort an array of length M for some generic M here m is five so we can just plug five into our previous formula that we computed for merge s right if we plug M = 5 into this formula what do we get we get 6 * 5 * log base 2 of 5 + 1 who knows what log base 2 of five is that's some weird number but it's going to be a most three right so if that's a most 3 3 + 1 is 4 multiply that by five then again time six and boom you get your 120 so it's constant time to sort just one of these groups of five now of course we have to do a bunch of groups of five but there's only a linear number of groups constant per each so that's going to be linear time overall so to be really pedantic we do 120 operations at most per group there's n over five different groups we multiply those we get 24 n operations to do all the sorting and that's obviously a big O event so linear time for step one so having warmed up with step one let's look now at the whole seven line algorithm and see what's going on now I hope you haven't forgotten the Paradigm that we discussed for analyzing the running time of deterministic divide and conquer algorithms like this one so name we're going to develop a recurrence and remember a recurrence expresses the running time the number of operations performed in two parts first of all there's the work done by the recursive calls on smaller sub problems and secondly there's the work done locally not in the recursive calls so let's just go through these lines one at a time and just do a running tally of how much work is done by this algorithm both locally and by the recursive calls so the quiz was about uh step number one we just argued that since it's constant time to sort each group and there's a linear number of groups we're going to do linear work Theta of n uh for step one so copying these first round winners over into their special array C is obviously linear time now when we get to the third line we have a recursive call but it's a quite easy recursive call to understand it's just uh recursing on a array that has size 20% as large as the one we started with on N over five elements so this remember the notation we use for recurrences uh generally we denote by capital T the running time of an algorithm on arrays of given length so this is going to be the running time that our algorithm uh has in the worst case on inputs of length n/5 because n over 5 is the length of the array that we're passing to this recursive call good step four partition well we had videos about how to implement partition and why it's a linear time we knew that all the way back in quick sort so that's definitely Theta of n step five is constant time I'm not going to worry about it and finally we get to line six and seven so most one of these will execute so in either case there's one recursive call so that's fine we know in recurrences when there's a recursive call we just write capital T of whatever the input length is so we just have to figure out what the input length here is it was n over5 in step in line three so just have to figure out what it is in line six or 7 oh yeah now we're remembering why we didn't use recurrences when we discussed randomized quicksort and uh the randomized selection algorithm it's because we don't actually know how big the recursive call is how big the input passed to this recursive call in line six or seven is line three no problem it's guaranteed to be 20% of the input array because that's how we Define it but for line six or seven the size of the input array that gets passed to the to the recursive call it depends on how good the pivot is it depends on the splitting of the array a into the two parts which depends on the choice of the pivot P so at the moment all we can write is T of question mark we don't know we don't know how much work gets done in that recursion because we don't know what the input size is let me summarize the results of this discussion so I'm going to write down a recurrence for the D select algorithm so let T of n denote the maximum number of operations the D select ever requires to terminate on an array input of length n this just the usual definition of t of n we use in recurrences what we established in our tally on the last slide is that deselect does linear stuff outside the recursive calls it does the Sorting of groups of five it does the copying and it does the partitioning each of those is linear so all of them together is also linear and then it does two recursive calls one whose size we understand one whose size we don't understand so for once I'm not going to be sloppy and I'm going to write out an explicit constant about the work done outside the recursive calls I'm not going to write Big O of n I'm going to actually write C * n for some constant C so of course no one ever cares about base cases but for completeness let me write it down anyways uh when D select gets an input of only one element it returns it let's call that one operation for Simplicity and then in the general case and this is was interesting uh when you're not in the base case when you have to recurse what happens well you do linear work outside of the recursive calls so that's C * n for some constant c c is just the linear the the expressed constant and all our big thetas on the the previous slide plus the recursive call in line three and we know that happens on an array of size n over5 as usual I'm not going to worry about rounding up or rounding down it doesn't matter plus our mystery recursive call on an array of unknown size so that's where we stand and we seem stuck because of this pesky question mark so let's prove a Lemma which is going to replace this question mark with something we can reason with with an actual number that we can then analyze so the upshot of this key Lemma is that all of our hard work in our choose pivot sub routine in lines 1 through three bears fruit in the sense we're guaranteed to have a pretty good pivot may not be the median it may not give us a 50/50 split then we could replace the question mark with uh 1/2 time n but it's going to let us replace the question mark by a 7/10 * n now I don't want to live you I'm going to be honest it's it's not quite 710 n it's more like 710 nus 5 there's a little bit of additive error so taking care of the additive error adds nothing to your conceptual understanding of this algorithm or why it works uh but for those of you who want a truly rigorous proof uh there are some posted lecture notes which go through all the Gory details but in lecture I'm just going to tell you what's sort of morally true and ignore the fact that we're going to be off by you know three here and four there and it will be clear when I show you the proof of this Lemma where I'm being a little bit sloppy and why it really shouldn't matter and it doesn't so to explain why this key Lemma is true why we get a 3070 split or better guaranteed let me set up a little notation I'm getting sick of writing n over5 over and over again so let's just give that a synonym let's say k so this is the number of different sort of first round matches that we have the number of groups I also want some notation to talk about the first round winners that is the medians of these groups of five the K first round winners so we're going to call XI the E smallest of those who win their first round match who make it to the second round so just to make sure the notation is clear we can express the pivot element in terms of these X's remember the pivot is the final winner it wins not only its first round tournament but also the second round tournament it's not only the middle element of the first group of five it's actually the median of the N over5 Middle elements it's the median of the medians that is of the K middle elements it's uh the K Over tooth order statistic K Over tooth smallest I'm saying this assuming that K is even if K was odd it would be some slightly different formula as you know so let's remember what we're trying to prove we're trying to prove that for our proposed pivot which is exactly this element X subk over2 it's exactly the winner of this two- round knockout tournament we're trying to argue that for this post pivot we definitely get a 3070 split or better so what that means is there better be at least 30% of the elements that are bigger than the pivot that way if we recurse on the left side in the first part we don't have to deal with more than 70% of the original elements similarly there better be at least 30% of the elements that are smaller than the pivot that way if we recurse on the right hand side we know we don't have to deal with more than 70% of the original input elements so if we achieve this goal we prove that there's at least 30 % on each side of x k over2 then we're done that proves the key Lemma that we get a 3070 split or better so I'm going to show you why this goal is true I'm going to introduce a thought experiment and I'm going to lay out it abstractly then we'll sort of do an example to make it more clear and then we'll go back to the general discussion and finish the proof so what we're going to do is a thought experiment for the purposes of counting how many elements of the input array are bigger than our pivot choice and how many are smaller so in our minds we're going to imagine that we take the N elements in a and we arrange them in a 2d grid so here are the semantics of this grid each column will have exactly five elements and it will corespond to one of the groups of five so we'll have n over five columns corresponding to our n over five groups in our first round of our tournament if n is not a multiple of five then one of these groups has size between 1 and four but I'm just not going to worry about it that's some of the uh additive loss which I'm ignoring moreover we're going to arrange each column in a certain way so that going from bottom to top the entries of that group go from smallest to largest so this means that in this grid we have five rows and the middle row the third row corresponds exactly to the middle elements to the winners of the first round matches so because these middle elements these first round winners are treated specially I'm going to denote them with big squares the other four elements of the group two of which are smaller two of which are bigger are just going to be little circles furthermore in this thought experiment in our mind we're going to arrange the columns from left to right in order of increasing value of the middle element now remember I introduced this notation xub I is the I smallest amongst the middle elements so a different way of what I'm trying to say is that the leftmost column is the group group that has X1 as its middle element so among the N over5 Middle elements one of the groups has the smallest middle element we put that all the way on the left so this is going to be X1 in the First Column the smallest of the first round winners X2 is the second smallest of the first round winners X3 is the third smallest and so on at some point we get to the median of the first round winners x k over2 and then way at the right is the large largest of the first round winners and I'm sure that you remember that the median of medians which is XK over 2 is exactly our pivot so this is our lucky winner I know this is a lot to absorb so let me go ahead and go through an example if what I've said so far makes perfect sense you should feel free to skip the following example but if you're still some details you're wondering about I'm hoping this example will make everything crystal clear so let's suppose we have an input array I need a a slightly big one to make the grid make sense so let's say there's an input array of 20 elements so there's going to be the input array which is in a totally arbitrary order is going to be the version of the array after we sort each group of five and then I'm going to show you the grid so here's the input array we're going to use let's now go ahead and delineate the various groups of five so after sorting each group we get the following from each group there's a single winner namely the middle element so that would be the 12 and the six and the 9 and the 14 those are the four survivors from the first round of the tournament and the median of these four elements which at the end of the day is going to be our pivot is the second smallest of the four that's how we Define the median for an even number of elements so that's going to be the nine so this first transformation from the input array to this vaguely mini sorted version of this input array with the groups of five sorted this we actually do in the code this happens in the algorithm now this grid we're just doing in our minds okay we're just in the middle of proving why the algorithm is fast why the pivot is guaranteed to give us close to a 3070 split or better so let me show you an example of this Grid in our mind what it looks like for this particular input so the grid always has five rows the columns always have five elements because the columns correspond to the groups here because n equal 20 n over 5 is four so there's going to be four columns and five rows and moreover we arrange the columns from left to right so that these middle elements go from smallest to largest so our middle elements are 6 9 12 and 14 and we're going to draw the columns in that order from left to right so first we'll write down the middle elements the middle row from decreasing to increasing 6 99 12 14 again the median of these is our pivot which is the nine and then each column is just the other four elements uh that goes along with this middle element uh from decreasing to increasing as we go from bottom to top so this is the grid that we're been talking about on the other slide in this particular example so I hope that makes what we're talking about clear what these x's mean and what order we have amongst the rows amongst the columns and so on so so let's go back to the general argument here is the key Point here is why we're doing this entire thought experiment it's going to let us prove our key limma that we get a 3070 splitter better 30% of the stuff at least is less than the pivot 30% of the stuff at least is bigger than the pivot so why is there at least 30% of the stuff below the pivot why is the pivot bigger than at least 30% well it's bigger than everything to the left and everything below the stuff to the left that is we know that x k over2 is bigger than the K over2 minus one elements that are to the left of it those other middle elements that it's bigger than that's because it's the median of the medians so if we just go straight west from the pivot we only see stuff which is less furthermore these columns are arranged from decreasing to increasing order as we go from south to North from bottom to top so if he travels south from any of these smaller exis we only see stuff which is still smaller so all we're using here is transitivity of the less than relation you go straight west you see stuff which is only smaller from any of those points if you go Southward you'll see stuff which is even smaller than that so this entire yellow region everything Southwest of the pivot elements is smaller than it and that's a good chunk of the grid right so for all of these columns it's basically three out of the five or 60% of them are smaller than the pivot and half of the columns essentially are in this part of the grid so if the pivot is bigger than 60% of the stuff in 50% of the groups that means it's bigger than 30% of the elements overall and if we reason in an exactly symmetric way we find that the pivot is also smaller than at least 30% of the array so to find things bigger than the pivot what do we do first we travel Eastward that gives us middle elements that are only bigger than it and then we stop wherever we want on our Eastward journey and we head north and we're going to see stuff which is still bigger so this entire Northeastern corner is bigger than the pivot element and again that's 50% that's at 60% of roughly 50% of the groups returning to our example the southwest region of the nine is this stuff 1 3 4 5 six certainly all of that is smaller than the nine you'll notice there's other things smaller than the nine as well there's the eight there's the two there's the seven which we're not counting but it depends on the exact array whether or not in those positions you're going to have stuff smaller than the pivot or not so it's this yellow region we guaranteed to be smaller than the pivot similarly everything Northeast of the pivot is bigger than it those are all double- digit numbers and our pivot is nine again there's some other stuff and other regions bigger than the pivot the 20 the 10 the 11 but again those are positions where we can't be guaranteed that it will be bigger than the pivot so it's the yellow regions which are guaranteed to be bigger and smaller than the pivot and that gives us the guaranteed 3070 split okay so that proof was hard work showing that this deterministic choose to attine guarantees a 3070 splitter better and you probably feel a little exhausted like we deserve a QED at this point but we haven't earned it we have not at all proved that this deterministic selection algorithm runs in linear time why doesn't a guarant 3070 split guarantee us linear time automatically well we had to work pretty hard to figure out this element guaranteeing this 3070 split in particular we had to invoke another recursive call so maybe this was a pic Victory maybe we had to work so hard to compute the pivot that it outweighs the benefit we get from this guaranteed 3070 split so we still have to prove that's not the case even in conjunction doing both of these things we still have our linear time bound we'll finish the analysis in the next video