in this video in the next we're going to take it to the next level and peer under the hood into implementations of balanced binary search trees now frankly the nitty-gritty details of all balanced binary search Tre implementations get pretty complicated and if you really want to understand them at A fine grain level there is no substitute for uh reading an advanced algorithms textbook that includes coverage of the topic and or studying open source implementations of these data structures I don't see the point of regurgitating all of those details for you here what I do see the point in doing is giving you the gist of some of the key ideas in these implementations in this first video I want to focus on a key primitive that of rotations which is common to all balance binary search tree implementations whether it's red black trees AVL trees bb+ trees whatever all of them use rotations in the next video we'll talk a little bit more about the details of red black trees in particular so what is the point Behind These magical rotation operations well the goal is to do just constant work just rewire a few pointers and yet locally rebalance a search tree without violating the search tree property so there are two flavors of rotations left rotations and right rotations in either case when you invoke a rotation it's on a parent child pair in a search tree if it's a right child of the parent then you use a left rotation we'll discuss that on this slide and a right rotation is in some sense an inverse operation which you use when you have a left child of the parent so what's the generic picture look like when you have a node X in a search tree and it has some right child y well X in general might have some parent X might also have some left sub tree let's call that left sub tree of x capital a it could of course be empty and then y has its two sub trees let's call the left sub tree of y b and the right sub tree C it's going to be very important that rotations preserve the search tree property so to see why that's true let's just be clear on exactly which elements are bigger than of which other elements in this picture so first of all y being a right child of X Y is going to be bigger than x now all of the keys which lie in the subtree a because they're to the left of X these keys are going to be even smaller than x by the same token anything in the sub tree Capital C that's to the right of Y so all that stuff is going to be even bigger than y what about subtree capital B what about the nodes in there well on the one hand all of these are in X's right subtree right to get to any node in B you go through X and then you follow the right child to Y so that means everything is B is bigger than x yet at the same time time it's all in the left sub tree of Y so these are all things smaller than y summarizing all of the nodes in B have keys strictly in between X and Y so now that we're clear on how all of the search keys in the different parts of this picture relate to each other I can describe the point of a left rotation fundamentally the goal is to invert the relationship between the nodes X and Y currently X is the parent and Y is the child we want to rewire a few pointers so that Y is now the parent and X is the child now what's cool is given that that is our goal there's pretty much a unique way to put all of these pieces back together to accomplish it so let's just follow our nose so remember the goal y should be the parent and X should be the child well X is less than y and there's nothing we can do about that so if x is going to be a child of Y it's got to be the left child so your first question might be well what happened to X's parent so X used to have some parent let's call it P and now X's new parent is y similarly y used to have a parent X and there's a question what should y's new parent be well Y is just going to inherit X's old parent P so this change has no bearing for the search tree property either this collection of nodes was P's left sub Tree in that case case all of these nodes were less than P or this sub tree was P's right sub Tree in which case all of these are bigger than P but P could really care less which of X or Y is its direct descendant now let's move on to thinking about how what we should do with the subt trees a b and c so we have three sub trees we need to reassemble into this picture and fortunately we have three slots available X has both of its child pointers available and Y Has Its Right child available so what can we put where well a is the sub tree of stuff which is less than both X and Y so that should sensibly be X's left child that's exactly as it was before by the same token Capital C Is The Stuff bigger than both X and Y so that should be y the bigger nodes child right child just as before and what's more interesting is what happens to subtree capital B so B Used to Be y's left child but that can't happen any any more cuz now X is y's left child so the only hope is to slot capital B into the only space we have for it X's right child fortunately for us this actually works slotting B into the only open space we have for it X is Right child does indeed preserve the switch tree property recall we notice that every key in capital B is strictly between X and Y therefore it better be an X's right subtree and it better be in y's left subtree but it is that's exactly where we put it so that's a left rotation but if you understand a left rotation then you understand a right rotation as well because a right rotation is just the inverse operation so that's when you take a parent child pair where the child is the left child of the parent and now you again want to invert their relationship you want to make the old child the new parent and the old parent the new child and once again given this goal there's really a unique way to reassemble the components of this picture so that the goal is accomplished so that Y is now the parent of X so what are the laudable properties of rotations well first of all I hope it's clear that they can be implemented in constant time all you were doing are rewiring a constant number of pointers furthermore as we've discussed they preserve the search tree property so these nice properties are what make rotations the ubiquitous primitive common to all balanced search implementations so this of course is not the whole story in a complete specification of a balanced sech Tre implementation you have to say exactly when and how you deploy these rotations you'll get a small taste of that in the next video but if you really want to understand it in more depth I again encourage you to check out either a comprehensive data structures textbook check out a number of balance search tree uh demonstrations which are readily available on the web or have a Peak at an open source implementation of one of these data structures