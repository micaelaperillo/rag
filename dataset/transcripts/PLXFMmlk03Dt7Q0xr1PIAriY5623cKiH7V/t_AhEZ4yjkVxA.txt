and let's begin with the idea of shortest paths so again I give you the movie graph I give you Kevin Bacon as a starting point what's the fewest number of hops the fewest number of edges on a path that leads to say John Ham so some notation I'm going to use D of V to denote the shortest path distance so with respect to a starting node s the fewest number of hops or the fewest number of edges on a path that starts at s and goes to V and again you can Define this in the same way for unded graphs or direct graphs in a directed graph you always want to Traverse arcs in the forward Direction in the correct direction and to do this we just have to add a very small amount of extra code to the BFS code that I showed you earlier it's just going to be a very small constant overhead and basically it just keeps track of what layer each node belongs to and the layers are exactly tracking shortest path distances away from the starting point s so what's the extra code well first in the initialization step you set your preliminary estimate of the distance the number the shortest path distance from s to a Vertex v as well if V equals s you know you can get from s to S on a path of length zero the empty path and if it's any other vertex all bets are off you have no idea if there's a path to V at all so let's just initially put plus infinity for all vertices other than the starting point this is something we will of course revise once we actually discover a path to a Vertex V and the only other extra code you have to add is when you're considering so when you take a uh vertex off of the front of the Q and then you iterate through its edges and you're considering one of those edges VW so here V would be the vertex that you just removed from the front of the queue and as usual if the other end of the edge W has already been dealt with then you know you just throw it out that would be redundant work to look at it again but if this is the first time you're seeing the vertex W then in addition to what we did previously in addition to marking it as explored and putting it the que at the back we also compute its distance and it's distance is just going to be one more than the distance of the vertex V responsible for W's addition to the Q responsible for first discovering this vertex W so returning to our running example of breath first search let's see what happens so again remember the way this worked is we start out with uh from the vertex s and we set the distance you know in our initialization equal to zero we don't know what the distance is of anything else so then how did breath of search work so we in the initial step we put s in the Q we go to the main while loop and then the Q is not empty we extract s from the Q we look at its neighbors those neighbors are A and B we handle them in some order let's again think of that we first handle the edge between s and a so then what do we do we say we haven't seen a yet so we Mark a as explored we put a in the Q at the front and now we have this extra step it's the first time we're seeing a so we want to compute its distance and we compute its distance as one more than the vertex responsible for discovering a and so in this case s was the vertex whose exploration unveiled the existence of the vertex a to us s's distance is zero so we set A's distance to one okay and that's tantum out to being a member of the E layer so what happens in the next iteration of the Y Loop so now the Q contains uh sorry the next iteration of the for Loop excuse me so after we've handled the edge s comma a we're still dealing with s's edges now we handle the edge s comma B we put this is the first time we've seen B we put B at the end of the Q we mark it as explored and then we also execute this new step we set B's distance to one more than the vertex responsible for discovering it that would again be the vertex s s led to B's Discovery and so we said B's distance to be one more than s's distance also known as one and that corresponds to being the other node in layer one now having handled all of s's adjacent arcs we go back to the while loop we ask if the Q is empty certainly not it contains two vertices first a then B we extract the first vertex because it's fifo that would be the vertex a now we look at A's incident edges there's s comma a which we ignore there's a comma C this is the first time we've seen C so as before we mark C as explored we add C to the end of the Q and now again we have this additional line we set C's distance to be one more than the vertex responsible for its Discovery in this case it's a that first discovered C so we're going to C's distance to be one more than A's distance also known as two so then having handled a we move on to the next vertex in the Q which in this case is B again we can forget about the edge between S and B we've already seen s we can forget about the edge between B and C we've already seen C but D is now discovered for the first time via B it gets marked as explored it goes to the end of the Q and its distance is set equal to one more than B's distance which is two so then we deal with C again it has four arcs four edges three of them are irrelevant the one to e is not irrelevant because this is the first time we've seen e so E's distance is computed as one more than C because C was the one who first found e and so e gets a distance of three and then the rest of the algorithm proceeds as before and you will notice that the labelings the shortest path labels are exactly the layers as promised I hope you find it very easy to believe at this point that claim is true in general that the distance computed by breath first search for an arbitrary vertex V that's reachable from s uh is that's going to be equal to I if and only if V is in the I layer as we've been defining it previously and what does it really mean to be in the I layer it means that the shortest path distance between V and S has I hops I edges so I don't want to spend time giving a super rigorous proof of this claim but let me just sort of give you you know the gist the basic idea and I encourage you to to produce a formal proof at home if that's something that interests you so one way to do it is you can do it by induction on the layer I and so what you want to prove is that all of the nodes that belong to a given layer I do indeed be for search does indeed compute uh the distance of I for them so what does it mean to be a node in layer I well first of all you can't have been seen in either any of the previous layers you weren't a member of layers 0 through IUS one and furthermore you're a neighbor of some somebody who's in layer IUS one right you're seen for the first time once all of the layer ius1 nodes are processed so the inductive hypothesis tells you that distances were correctly computed for everybody from the lower from the lower layers so in particular whoever this node V was from layer IUS one who is responsible for discovering you in layer I it has a distance computed as IUS one yours is assigned to be one more than its namely I so that pushes through the inductive step everything in layer I indeed gets the correct label uh of as short as F distance of I away from s so before we wrap up with this application I do want to emphasize it is only breath first search that gives us this guarantee of shortest paths so we had a wide family of graph search strategies all of which find everything findable breath first search is one of those but this is a special additional property that breath first search has you get shortest path distances from it so in particular depth first search does not in general compute shortest path distances this is really a special property of breath first search by contrast in this next application which is going to be Computing the connected components of an undirected graph this is not really fundamental to breath first search for example you could use depth first search in here instead and that would work just as well