having completed our first analysis of an algorithm namely an upper bound on the running time of the merge short algorithm what I want to do next is take a step back and be explicit about three assumptions three biases that we made when we did this analysis of merge short and interpreted the results these three assumptions we will adopt as guiding principles for how to reason about algorithms and how to define a so-called fast algorithm for the rest of the course so the first guiding principle is that we used what's often called worst case analysis by worst case analysis I simply mean that our upper bound of 6n log n + 6n applies to the number of lines I've executed for every single input array of length n we made absolutely no assumptions about the input where it comes from what it looks like beyond what the input length n was put differently if hypothetically we had some adversary whose sole purpose in life was to concoct some malevolent input designed to make our algorithm run as slow as possible the worst this adversary could do uh is upper bound Ed by this same number 6 n log n plus 6n now this so sort of worst case guarantee popped out so naturally from our analysis of merge sort you might well be wondering what else could you do well two other methods of analysis which do have their place although we won't really discussed them in this course are quote unquote average case analysis and also the use of a set of pre-specified benchmarks by average case analysis I mean you analyze the average running time of an algorithm under some assumption about the relative frequencies of different inputs so for example in the Sorting problem one thing you could do although it's not what we did here you could assume that every possible input array is equally likely and then analyze the average running time of an algorithm by benchmarks I just mean that one agrees up front about some set say 10 or 20 uh Benchmark inputs which are thought to represent practical or typical inputs for the algorithm now both average case analysis and benchmarks are useful in certain settings but for them to make sense you really have to have domain knowledge about your problem you need to have some understanding of what inputs are more common than others what inputs better represent typical inputs than others by contrast in Works case analysis by definition you're making absolutely no assumptions about where the input comes from so as a result worst case analysis is particularly appropriate for general purpose sub routines sub routines that you design uh without having any knowledge of how they will be used or what kind of inputs they will be used on and happily another bonus of doing worst case analysis as we will in this course it's usually mathematically much more tractable than trying to analyze the average performance of an algorithm under some distribution over inputs or to understand the detailed behavior of an algorithm on a particular set of Benchmark inputs this mathematical tractability was reflected in our merge sort analysis where we had no op priori goal of analyzing the worst case per se but it's naturally what popped out of our reasoning about the algorithms running time The second and third gutting principles are closely related the second one is that in this course when we analyze algorithms we won't worry unduly about small constant factors or lower order terms we saw this philosophy at work very early on in our analysis of merge short when we discussed the number of lines of code that the merge sub rutine requires we first upper bounded it by 4 m + 2 for an array of length M and then we said ah let's just think about it as 6m instead let's have a simpler sloppy upper bound and work with that so that was our already an example of not worrying about small changes in the constant factors now the question you should be wondering about is why do we do this and can we really get away with it so let me tell you about the justifications for this guiding principle so the first motivation is clear and we used it already in our merge sord analysis which is it's simply way easier mathematically if we don't have to precisely pin down what the leading constant factors and lower order terms are the second justification is a little less obvious but is extremely important so I claim that given the level at which we're describing and analyzing algorithms in this course it would be totally inappropriate to obsess unduly about exactly what the constant factors are recall our discussion of the merge sub rutine so we wrote that sub rutine down in pseudo code and we gave an analysis of 4M plus 2 on the number of lines of code executed given an input of length M we also noted that it was somewhat ambiguous exactly how many lines of code we should count it as depending on how you count Loop increments and so on so even there small constant factors could creep in given the under specification of the pseudo code depending on how that pseudo code gets translated into an actual programming language like C or Java you'll see the number of lines of code deviate even further not by a lot but again by small constant factors when such a program is then compiled down into machine code you'll see even greater variance depending on the exact processor the compiler the compiler optimizations the programming implementation and so on so to summarize because we're going to describe algorithms at a level that transcends any particular programming language it would be inappropriate to specify precise constants the precise constants will ultimately determined by more uh machine dependent aspects like who the programmer is what the compiler is what the processor is and so on and now the third justification is frankly we're just going to be able to get away with it that is one might be concerned that ignoring things like small constant factors leads us astray that we wind up deriving results would suggest that an algorithm is fast when it's really slow in practice or vice versa but for the problems that we discussed in this course we'll get extremely accurate predictive power even though we won't be keeping track of low order terms and constant factors when the mathematical analysis we do suggests that an algorithm is fast indeed it will be when it suggests that it's not fast indeed that will be the case so we lose a little bit of granularity of information but we don't lose in what we really care about which is accurate guidance about what algorithms are going to be fast faster than others so the first two justifications I think are pretty self-evident this third justification is more of an assertion but it's one will be backing up over and over again as we proceed through this course now don't get me wrong I'm not saying constant factors aren't important in practice obviously for crucial programs the constant factors are hugely important if you're running the sort of crucial Loop for you know that your startup survival depends on by all means optimize the constant like crazy the point is just that understanding tiny constant factors in the analysis is an inappropriate level of granularity for the kind of algorithm analysis we're going to be doing in this course okay let's move on to the third and final guiding principle so the third principle is that we're going to use what's called asmic analysis by which I mean we will focus on the case of large input sizes the performance of an algorithm as the size n of the input grows large that is tends to Infinity now this focus on large input sizes was already evident when we interpreted our bound on merge sord so how did we describe the ban on merge short we said oh well it needs a number of operations proportional a constant Factor times n log n and we very cavalierly declared that this was better than any algorithm which has quadratic dependence of its running time on the number of operations so for example we argued that merge sort is a better a faster algorithm than something like insertion sort without actually discussing the constant factors at all so mathematically we were saying the running time of merge sort which we know which we can represent as the function 6 n log base 2 of n + 6n is better than any function which has a quadratic dependence on N even one with a small constant like let's say 12 n^2 which might be roughly the running time of insertion sort and this is a mathematical statement that is true if and only if n is sufficiently large once n grows large it's certainly true that the expression on the left is smaller than the expression on the right but for small n the expression on the right is actually going to be smaller because of the smaller leading term so in saying that merge sword is superior to insertion sort the bias is that we're focusing on problems with large n so the question you should have is is that reasonable is that a Justified assumption to focus on large input sizes and the answer is certainly yes so the reason we focus on large input sizes is because frankly those are the only problems which are even which are at all interesting if all you need to do is 100 numbers use whatever method you want and it's going to happen instantaneously on Modern computers you don't need to know say the divide and conquer Paradigm if all you need to do is sort 100 numbers so one thing you might be wondering is if with computers getting faster all the time according to Moore's Law if really it doesn't even matter to think about algorithmic analysis If eventually all problem sizes will just be trivially solvable on super fast computers but in fact the opposite is true Mo's law with computers getting faster actually says that our computation Ambitions will naturally grow we naturally focus on ever larger problem sizes and the gulf between an N squ algorithm and an N logn algorithm will become ever wider a different way to think about it is in terms of how much bigger a problem size you can solve as computers get faster if you're using an algorithm with a running time which is proportional to the input size then if computers get faster by a factor of four then you can solve problems which were a factor of four larger whereas if you're using an algorithm whose running time is proportional to the square of the size then if computers get faster by a factor of four you can only solve double the problem size and we'll see even Starker examples of this gulf between different algorithmic approaches as time goes on so to drive this point home let me show you a couple of graphs so what we're looking at here is we're looking at a graph of two functions so the solid function is the upper bound that we proved on merge short so this is going to be 6n log base 2 of n + 6n and the dotted line is a estimate a rather generous estimate about the running time of insertion sort namely 12 * n^2 and we see here in the graph exactly the behavior we discussed earlier which is that for small n down here in fact because 1 12 n^ SAR has a smaller leading constant it's actually a smaller function and this is true up to this crossing point of maybe 90 or so but then beyond n equal 90 the quadratic growth in the n^ S term overwhelms the fact that it had a smaller constant and it starts being bigger than this other function 6n log n + 6n so in the regime below 90 it's predicting that insertion sort will be better and in the regime above 90 it's predicting that merge sort uh will be faster now here's what's interesting let's scale the x-axis let's look well beyond this crossing point of 90 let's just increase it in order of magnitude up to rays of of size 1500 and I want to emphasize these are still very small problem sizes if all you need to do is sort of raise of size 1500 you really don't need to know divide and conquer or anything else I'll talk about that's a pretty trivial problem on Modern computers so what we're seeing is that even for very modest problem sizes here array of of size say 1500 uh the quadratic dependence in the insertion sort bound is more than dwarfing the fact uh that it had a lower constant Factor so in this large regime the gulf between the two algorithms is growing and of course if I increase to another 10x or 100x or 1,000x to get to genuinely interesting problem sizes the gap between these two algorithms would be even bigger it would be huge that said I'm not saying you should be completely ignorant of constant factors when you implement algorithms it's still good to have a general sense of what these constant factors are so for example in highly tuned versions of merge sort which you'll find in many programming Lang libraries in fact because of the difference in constant factors the algorithm will actually switch from merge sort over to insertion sort once the problem size drops below some particular threshold say seven elements or something like that so for small problem sizes you use the algorithm with smaller constant factors and the insertion sort for larger problem sizes you use the algorithm with better rate of growth namely merge sort so to review our first gunning principle is that we're going to pursue worst case analysis we're going to look to bounds on the performance on the running time of an algorithm which make no domain assumptions which make no assumptions about uh which input of a given length the algorithm is provided the second guiding principle is we're not going to focus on constant factors or lower order terms that would be inappropriate given the level of granularity at which we're describing algorithms and third is we're going to focus on the rate of growth of algorithms for large problem sizes putting these three principles together we get a mathematical definition of a fast algorithm namely we're going to pursue algorithms whose worst case running time grows slowly as a function of the input size so let me tell you how you should interpret what I just wrote down in this box so on the left hand side is clearly what we want okay we want algorithms which run quickly if we Implement them and on the right hand side is a proposed mathematical surrogate of a fast algorithm right the left hand side is not a mathematical definition the right hand side is as we'll become clear in the next set of lectures so we're identifying fast algorithms which those that have good ASM totic runtime running time which grows slowly with the input size now what would we want from a mathematical definition we'd want a sweet spot okay on the one hand we want something we can actually reason about this is why we zoom out and squint and ignore things like uh constant factors and lower order terms we can't keep track of everything otherwise we'd never be able to analyze stuff on the other hand we don't want to throw out the baby with the bath water we want to retain predictive power and this turns out this definition turns out for the problems we're going to talk about in this course to be the sweet spot for reasoning about algorithms okay worst case analysis using the asmic running time we'll be able to prove a lot lots of theorems we be to establish a lot of performance guarantees for fundamental algorithms but at the same time we'll have good predictive power what the theory Advocates will in fact be algorithms that are well known to be fast in practice so the final explanation I owe you is what do I mean by the running time grows slowly with respect to the input size well the answer depends a little bit on the context but for almost all of the problems we're going to discuss the Holy Grail will be to have what's called a linear time algorithm an algorithm whose number of instruction grows proportional to the input size so we won't always be able to achieve linear time but that's in some sense the best case scenario notice linear time is even better than what we achieved with our merge short algorithm for sorting merge short runs a little bit super linear it's n Times log n where n is the input size if possible we'd love to be linear time it's not always going to be possible but that is what we will Aspire toward for most of the problems we'll discuss in this course looking ahead the next series of videos is going to have two goals first of all on the analysis side I'll describe formally what I mean by ASM totic running time I'll introduce bigo notation and its variance explain its mathematical definitions and give a number of examples on the design side we'll get more experience applying the divide and conquer Paradigm to further problems see you then