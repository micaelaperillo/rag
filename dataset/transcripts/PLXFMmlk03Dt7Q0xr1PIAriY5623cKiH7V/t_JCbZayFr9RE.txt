if you want to multiply two integers is there a better method than the one we learned back in third grade to give you the final answer to this question you'll have to wait until I provide you with a toolbox for analyzing divide and conquer algorithms a few lectures hence what I want to do in this lecture is convince you that the algorithm design space is surprisingly Rich there are certainly other interesting methods of multiplying two integers Beyond what we learned in third grade and the highlight of this lecture will be something called carrot subba multiplication let me introduce you to katuba multiplication through a concrete example I'm going to take the same pair of integers we studied last lecture 1 2 3 4 5 6 7 8 I'm going to execute a sequence of steps resulting in their product but that sequence of steps is going to look very different than the one we undertook during the grade school algorithm yet will arrive at exactly the same answer the sequence of steps will strike you as very mysterious it'll seem like I'm pulling a rabbit out of a hat in the rest of this video we'll develop more systematically what exactly this carrot subba multiplication method is and why it works but what I want you to appreciate already on this slide is that the algorithm design space is far richer than you might expect there's a dazzling array of options for how to actually solve solve problems like integer multiplication let me Begin by introducing some notation for the first and second halfs of the input numbers X and Y so the first half of X that is 56 we're going to regard as a number in its own right called a similarly B will be 78 c will be 12 and D will be 34 I'm going to do a sequence of operations involving only these double digit numbers a b c and d and then after a few such operations I will collect all of the terms together in a magical way resulting in the product of X and Y first let me compute the product of a * C and also the product of B * D I'm going to skip the elementary calculations and just tell you the answer so you can verify that a * C is 672 whereas B * D is 2652 next I'm going to do something even still more inscrutable I'm going to take the sum of A and B I'm going to take the sum of c and d and then I'm going to compute the product of those two sums that boils down to Computing the product of 134 and 46 namely 6164 now I'm going to subtract our first two products from the results of this computation that is I'm going to take 6164 subtract 2652 and subtract 672 you should check that if you subtract the results of the first two steps from the result of the third step you get 2840 now I claim that I can take the results of steps one two and four and combine them in a super simple way to produce the product of X and Y here's how I do it I start with the first product AC and I Pat it with four zeros I take the result of the second step and I don't pat it with any zeros at all and I take the result of the fourth step and I Pat it with two zeros if we add up these three quantities from right to left we get 25 6 6 0 07 if you go back to the previous lecture you'll note that this is exactly the same output as the grade school algorithm that is this is in fact the product of 1 2 3 4 and 5678 so let me reiterate that you should not have any intuition for the computations I just did you should not understand what just went down on this slide rather I hope you feel some mixture of bafflement and Intrigue but more to the point I hope you appreciate that the third grade algorithm is not the only game in town There's fundamentally different algorithms for multiplying integers than what you learned as a kid once you realize that once you realize how rich the space of algorithms is you have to wonder can we do better than that third grade algorithm in fact does this algorithm already do better than the third grade algorithm before I explain full-blown carratu multiplication let me Begin by explaining a simpler more straightforward recursive approach to integer multiplication now I am assuming you have a bit of programming background in particular that you know what recursive algorithms are that is algorithms which invoke them elves as a sub routine with a smaller input so how might you approach the integer multiplication problem recursively well the input are two digits each two numbers each has n digits so to call the algorithm recursively we need to form inputs that have smaller size less digits well we already were doing that in the computations on the previous slide for example the number 5678 we treated the first half of the digits 56 as a number in its own right and similar L 78 in general given a number x with n digits it can be expressed decomposed uh in terms of two and over two digigit numbers namely as a the first half of the digits shifted appropriately that is multiplied by 10 raed to the^ n /2 plus the second half of the digits B in our example we had a equal to 56 78 was b n was 4 so 10 the N /2 was 100 and then C and D were 12 and 34 what I want to do next is illuminate the relevant recursive calls to do that let's look at the product x * y express it in terms of these smaller numbers a b c and d and do an elementary computation multiplying the expanded versions of X and Y we get an expression with three terms one shifted by n 10 raised to the power n and the coefficient there is a * C we have a term that's shifted by 10 the n /2 and that has a coefficient of a d and also plus BC and bringing up the rear we have the term B * D we're going to be referring to this expression a number of times so let me both Circle it and just give it a short hand we're going to call this expression star one detail I'm glossing over for Simplicity is that I've assumed that n is an even integer now if n is an odd integer you can apply this exact same recursive approach to integer multiplication in the straightforward way so if n was nine then you would decompose one of these input numbers into say the first five digits and the latter four digits and you would proceed in exactly the same way now the point of expression star is if we look at it despite being the product of just Elementary algebra it suggests a recursive approach to multiplying two numbers if we care about the product of X and why why not instead compute this expression star which involves only the products of smaller numbers a b c and d you'll notice staring at the expression star there are four relevant products each involving a pair of these smaller numbers namely AC a d BC and BD so why not compute each of those four products recursively after all the inputs will be smaller and then once our four recursive calls come back to us with the answer we can formulate the rest of expression star in the obvious way we just pad a * C with n zeros at the end we add up a d and BC using the grade school algorithm and Pad the result with n over two zeros and then we just sum up these three terms again using the grade school addition algorithm so the one detail missing that I've glossed over required to turn this idea into a Bonafide recursive algorithm would be to specify a base case as I hope you all know recursive algorithms need a base case if the input is sufficiently small then you just immediately compute the answer rather than recursing further of course recursive algorithms need a base case so they don't keep calling themselves till the rest of time so for integer multiplication what's the base case well if you're given two numbers that have just one digit each then you just multiply them in one basic operation and return the result so what I hope is clear at the moment is that there is indeed a recursive approach to solving the integer multiplication algorithm resulting in an algorithm which looks quite different than the one you learned in third grade but which nevertheless you could code up quite easily in your favorite programming language now what you shouldn't have any intuition about is whether or not this is a good idea or a completely crackpot idea is this algorithm faster or slower than the grade school algorithm you'll just have to wait to find out the answer to that question let's now refine this recursive algorithm resulting in the full-blown katuba multiplication algorithm to explain the optimization behind carrot sub multiplication let's recall the expression we were calling star on the previous slide so this just expressed the product of X and Y in terms of the smaller numbers a b c and d in the straightforward recursive algorithm we made four recursive calls to compute the four products which seemed necessary to Value to compute the expression star but if you think about it there's really only three quantities in star that we care about the three relevant coefficients we care about the numbers a and BC not per se but only in as much as we care about their sum a plus BC so this motivates the question if there's only three quantities that we care about can we get away with only three rather than four recursive calls it turns out that we can and here's how we do it the first coefficient AC and the third coefficient BD we compute exactly as before recursively next rather than recursively Computing a d or BC we're going to recursively compute the product of a plus b and c plus d if we expand this out this is the same thing as Computing AC plus a d plus BC plus BD now here is the key observation in Carro subba multiplication and it's really a trick that goes back to the early 19th century mathematician gaus let's look at the quantity we computed in step three and subtract from it the two quantities that we already computed in steps one and two subtracting out the result of Step One cancels the AC term subtracting out the result of step two cancels out the BD term leaving us with exactly what we wanted all along the middle coefficient a d plus BC and now in the same way that on the previous slide we had a straightforward recursive algorithm making four recursive calls and then combining them in the obvious way here we have a straightforward recursive algorithm that makes only three recursive calls and on top of the recursive calls does just grade school addition and subtraction so you do this particular difference between the three recursive recursively computed products and then you do the shifts the ping by zeros and the final sum as before so that's pretty cool and this kind of showcases the Ingenuity which bears fruit even in the simplest imaginable computational problems now you should still be asking the question you know is this crazy algorithm is it really faster than the grade school algorithm that we learned in third grade totally not obvious we will answer that question a few lectures hence and we'll answer it as a special case of an entire toolbox I'll provide you with to analyze the running time of so-called divide and conquer algorithms like katuba multiplication so stay tuned