let's explore our second strategy for Graph Search namely depth first search and uh again like with breath first search I'll open by just reminding you what depth for search is good for and uh we'll Trace through it in a particular example and then we'll tell you what the actual code is so if bre first search is the cautious and tentative exploration strategy then depth first search or DFS for short is its more aggressive cousin So the plan is to explore aggressively and only backtrack when necessary and this is very much the strategy one often uses when trying to solve a maze to explain what I mean let me show you how this would work in uh the same running example we used when we discussed breath first search so here if we invoke depth first search from the node number s here's what's going to happen so obviously we start at s and obviously there's two places where we can go next we can go to a or to B and uh depth for search is underdetermined like breath first search we can pick either one so like with the breath first search example let's go to a first so it will be the second one that we explore but now unlike breath first search where we automatically went to node B next since that was the other layer one node here the Only Rule is that we have to go next to one of A's immediate neighbors so we might go to B but we're not going to B because it's one of the neighbors of s we go because it's one of the neighbors of a and actually to make sure the difference is clear let's assume that we aggressively pursue deeper and we go from a to c and now the depth for search strategy is again just TOs pursue deeper so you go to one of C's immediate neighbors so maybe we go to E next so e is going to be the fourth one visited now from E there's only one neighbor not counting the one that we came in on so from E we go to D and D is the fifth one we see now from D we have a choice we could either go to b or we could go to C so let's suppose we go to C from D well then we get to a node number three where we've been before okay and as usual we're going to keep track of where we've already been so at this point we have to backtrack from C back to D we Retreat to D now there's still another outgoing Edge from D to explore namely the one to B and so what happens is we actually wind up wrapping all the way around this outer cycle and we hit B6 and now of course anywhere we try to explore we see somewhere we've already been so from B we try to go to S but we've been there so we Retreat to B we try we can try to go to a but we've been there so we Retreat to B now we've explored all of the options out of B so we have to retreat from B we have to go back to D now from D we've explored both B and C so we have to retreat back to e e we've explored the only outgoing Arc D so we have to retreat to C C we Retreat to a from a we actually haven't yet looked along this Arc but that just sends us to B where we've been before so then we Retreat back to a finally we Retreat back to S and S even at s there's still an extra Edge to explore at s we say oh we haven't tried this SB Edge yet but of course when we look across we get to B where we've been before and then we backtrack to S then we've looked at every Edge once and so we stop so that's how depth first search works you just pursue your path you go to an immediate neighbor as long as you can until you hit somewhere you've been before and then you Retreat so you might be wondering you know why bother with another Graph Search strategy after all we have breath first search which seem pretty awesome right it runs in linear time it's guaranteed to find everything you might want to find it uh computes shortest paths it computes connected components if you Ed it in a for Loop kind of seems like what else would you want well it turns out depth first search is going to have its own impressive catalog of applications which you can't necessarily replicate with breath first search and I'm going to focus on applications in directed graphs so there's going to be a simple one that we discussed in this video and then there's going to be a more complicated one that has a separate video devoted to it so in this video we're going to be discussing Computing topological orderings of directed ayylic graphs that is directed graphs that have no directed cycle the more complicated application is Computing strongly connected components in directed graphs the runtime will be essentially the same as it was for breath for search and the best we could hope for which is linear time and again we're not assuming that the that there's necessarily that many edges there may be much fewer edges than vertices so linear time in these connectivity applications means o of m+n so let's now talk about the actual code of depth first search there's a couple ways to do it one way to do it is to just make some minor modifications to the code for breath first search the primary difference being instead of using a Q and its first first in first out Behavior you swap in a stack with its last in first out Behavior again if you don't know what a stack is you should read about that in the programming textbook or or on the web it's something that supports constant time insertions to the front and constant time deletions uh from the front unlike a q which is meant to support constant time deletions to the back okay so stack it operates just like those cafeteria trays that you know where you put in a tray and the last one that got pushed in when you take the first one out that's the last one that got put in so these are called push and pop in a stack context both are constant time so if you swap out the queue you swap in the stack make a couple other minor modifications breath first search turns into depth first search for the sake of both variety and elegance I'm instead going to show you a recursive version so depth first search is very naturally phrased as a recursive algorithm and that's what we'll discuss here so depth for search of course takes as input a graph G and again it could be undirected or directed it doesn't matter just with a directed graph be sure that you only follow arcs in the appropriate Direction which should be automatically handled in the adjacency lists of your graph data structure anyways so as always we keep a Boolean local to each vertex of the graph remembering whether we've start we've been there before or not and of course as soon as we start exploring from s we better make a note that now we have been there we better plant a flag as it were and remember depth first search is an aggressive search so we immediately try to recursively search from any of s's neighbors that we haven't already been to and if we find such a Vertex if we find find uh somewhere we've never been we recursively call depth first search uh from that node the basic guarantees of depth first search are exactly the same as they were for breath first search we find everything we could possibly hope to find and we do it in linear time and once again the reason is this is simply a special case of the generic search procedure that we started this sequence of videos about so it just corresponds to a particular way of choosing amongst multiple Crossing edges between the region of explored nodes and the region of unexplored nodes essentially always being biased toward the most recently discovered explored nodes and just like breath first search the running time is going to be proportional to the size of the component that you're discovering and the basic reason is that each node is looked at only once right this uh Boolean make sure that we don't ever explore a node more than once and then for each Edge we look at it at most twice once from each each end point and given that these exact same two claims hold for depth first search as for breath first search that means if we wanted to compute connected components in an undirected graph we could equally well use an outer for loop with depth first search as our Workhorse in the Inner Loop it wouldn't matter either of those for undirected graphs depth first search bread for search is going to find all the connectic components in O of M plus n time in linear time so instead I want to focus on an application particular to depth first search and this is about finding a topological ordering of a directed a cyclic graph