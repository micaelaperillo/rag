so the time has arrived for us to finish the proof of the fact that this deterministic selection algorithm based on the median of medians ideas does indeed run in linear time we've done really all of the conceptual difficult work we discussed the algorithmic ingenuity required to choose a pivot deterministically that's guaranteed to be pretty good so remember the idea was you take the input array you logically break it into groups of five you sort each group that's like the first round of two round knockout tournament the winners of the first round are the middle elements of each group of fives that's the initial set of medians and then the second round we take a median of these n over five first round winners and that's what we return as the pivot and we prove this key lemma which is the 3070 lemma which says that if you choose the pivot by this two round knockout tournament you're guaranteed to get a 30/70 split or better so your recursive call in line six or seven and deselect is guaranteed to be on an array that has at most 70% of the elements that you started with in other words you're guaranteed to prune at least 30% of the array before you recurse again but what remains to understand is whether or not we've done a sensible trade-off have we kept the work required to compute this 3070 split small enough that we get the desired linear running time or have we is the cost of finding a pretty good pivot outweighing the benefit of having guaranteed good splits that's what we got to prove that's the next subject here's the story so far you'll recall that as usual we defined T of n to be the worst-case running time of an algorithm in this case deselect on inputs of array length on input arrays of length n and we discussed okay does the base case as usual but in the general case we discussed how outside of the two recursive calls the deselect algorithm does a linear number of operations what does it have to do it has to do the sorting but each sorting is on a group of size constant of size five so it takes constant time per group there's a linear number of groups so step one takes linear time the copying takes a linear time and the partitioning takes linear time so there's some constant C which is going to be bigger than one but it's going to be constant so that outside the recursive calls deselect all those dozen most C times n operations now what's up with the recursive calls well remember there's two of them first there's one on line three less is responsible for helping choose the pivot this one we understand it's always on 20 the input Iranian Lee the first round winners so we can very safely write T of n over five for the work done in the worst case by that first recursive call well we didn't understand until he proved the key lemma was what's up with the second recursive call which happens on either line six or line seven the size of the input array on which we recurse depends on the quality of the pivot and it was only one who proves the key lemma that we had a guarantee on the quality of our pivot 3070 split are better what does that mean that means the largest sub array we could possibly recurse on has seven tenths and elements so what remains is to find the solution for this recurrence and hopefully prove that it is indeed Big O of n so let me go ahead and rewrite the recurrence at the top of the slide we're not really gonna worry about the base case T of 1 equals 1 but we're sitting is the fact that the running time on an input of length n is at most C times n we're again C is some constant which is going to have to be at least 1 given all the work that we do outside of the recursive calls plus the recursive call on line 3 on an array of size n over 5 plus the second recursive call which is on some array that has size in the worst case 7/10 and so that's cool this is exactly how we handle the other deterministic divide and conquer algorithms that we studied in earlier videos we just wrote down a recurrence and then we saw the recurrence but now here's the trick and all of the other occurrences that came up for example merge sort strassens matrix multiplication algorithm carat super multiplication you name it we just plug the parameters into the master method and because of the power of the master method boom I'll popped up an answer it just told us what the recurrence evaluated to now the master method as powerful as it is it did have an assumption you might recall the assumption was that every sub problem solved had the same size and that assumption is violated by this linear time selection algorithm there are two recursive calls one of them is on 20% of the original array the other one is probably on much more than percent of the original rate could be as much as 70 percent of the original array so because we have two recursive calls and subproblems of different size well this does not fit into the situations that the master method covers it's a very rare algorithm in that regard now there are more general versions of the master method of the master theorem which can accommodate a wider class of recurrences including this one here alternatively we could push the recursion tree proof so that we could get a solution for this recurrence some of you might want to try that at home but I want to highlight a different way you can solve recurrences just for variety just to give you yet another tool now the good news of the about this approach that I'm going to show you is that it's very flexible it can be used to solve sort of arbitrarily crazy recurrences it certainly going to be powerful enough to evaluate this one the bad news is that it's very out of hock it's not very necessarily very easy to use it's kind of a dark arc figuring out how to apply it so it's often just guessing checked is what it's called you guess what the answer to a recurrence is and then you verify it by induction here because we have such a specific target in mind the whole point of this exercise is to prove a linear time bound I'm gonna call it just hope and check so we're gonna hope that it's linear time and then we're gonna try to produce a proof of that just to verifies the linear time bound using induction specifically what are we hoping for we're crossing our fingers that there's a constant I'm gonna call it a it could be big but it's got to be constant again remember constant means it does not depend on n in any way such that our recurrence at the top of this slide T of n is bounded above by a times n for all n at least one why is this what we're hoping well suppose this were true by definition T of n is an upper bound on the running time of our algorithm so if it's bounded above by a times n then it's obviously whole event it's obviously a linear time algorithm where a is the constant that gets suppressed in the Big O notation so that's the hope now let's check it and again check means just verify by induction on n so the precise claim that I'm going to prove is the following I'm going to go ahead and choose the constant a remember all we need is some constant a no matter how big as long as it's independent again that'll give us the Big O of n time so I'm just going to tell you what a I'm gonna use for convenience I'm gonna choose a to be ten see now what a CC is just the constant that we inherit from the recurrence that were given now remember what this recurrence means this is what the running time is of the deselect algorithm and the C times n represents the work that outside of the recursive calls so this is just the constant multiple on the amount of linear work the deselect does for sorting the groups for doing the partitioning and ever doing the copying guess there's going to be some small constant reasonable constant and for the proof I'm just going to multiply that by ten and use that as my a and the claim is if I define a in that way then indeed it is true that for all in at least one T of n is bounded above by a times n now I realized I just I pulled this constant a out of nowhere right why 10 times C well if you recall our discussion when we proved that things were Big O of something else there again there was some constant so it formally prove that something is Big O of something else you have to say with the constant is and and the proof you always wonder how do you know what constant to use so in practice when you're actually if you I have to do one of these proofs yourself you reverse engineer what kind of constant would work so you just go through the argument with a generic constant then you like oh well if I set the constant to be this I can complete the proof so we'll see that's exactly what's going to happen the proof of this claim it'll be obvious the very last line you'll see why it shows a equal ten C so I just reverse engineer for what I needed for the proof but to keep the proof easy to follow a line by line I decided to just full disclosure tell you the constant right at the beginning now no prizes for guessing that the way this proof proceeds is by induction on in induction is the obvious thing to use we're trying to prove an assertion for every single positive number N and moreover were given this recurrence which relates solutions of smaller subproblems to that a bigger problem so that sets things up for use of the inductive hypothesis if you want a longer review of what proofs by induction are I suggest that you go back and re-watch the optional video where we prove the correctness of quicksort there there's a fairly formal discussion of what the template is like for a proof by induction and that's the one we're going to apply here so there's two ingredients standing proof by induction is a usually trivial one in the form of the base case that's also going to be trivial here so in the base case you just directly establish the assertion when N equals 1 so we're trying to prove that T of n is at most 8 times n for every n when N equals 1 if we just substitute then what we're trying to prove is that T of 1 is at most 8 times 1 also known as a and we're given that T of 1 is 1 right that's the base case of the recurrence that we're given so that's what we're using here what we want to be true is that this is almost 8 times 1 but it is so the constant C we're assuming is at least 1 so certainly if you multiply C times 10 to get a it's definitely at least 1 so the right-hand side here is unquestionably bigger than the left-hand side a in fact is even bigger than 10 let alone bigger than 1 so the interesting ingredient is generally inductive step so remember what you do here is you assume you've already proven the assertion that in this case the T of n is at most a n for all smaller integers and now you just merely have to prove it again for the current integer so we're now understood in the case where n is bigger than 1 and the assumption that we've already proven to proven it for everything smaller is called the inductive hypothesis so what does it mean that we already proved it for all smaller numbers it means we can use in the proof of our inductive step the fact that T of K is in most pay times K for all K strictly less than n all we got to do is enlarge the range of ends to which this holds to one more to the current value N and all we have to do is follow our nose so pretty much we have to start on the left hand side with T of n we have to wind up on the right hand side with a times N and pretty much at every step of the proof there's just going to be one conceivable thing we could do so we just follow our nose we start with what we want to upper bound T of n well what do we got going for us the only thing we can do at this point is invoke the recurrence that we were given up here so we have an upper bound on T of N in terms of the T value of smaller integers so we are given the T of n is at most C times n plus T of n over 5 plus T of 7/10 n I'm of course ignoring fractions you would round up or round down if you wanted to be precise and the auxilary lecture notes are more precise if you want to see what the gory details look like it's really just exactly the same argument one just has to be a little bit more anal about it so now that we've invoked the recurrence what can we possibly do we can't really do any direct manipulation and it is three terms but fortunately we have this inductive hypothesis that applies to any value any integer which is less than n so we have here n over five that's really less than n we have 70% of n that's really less than n so you can fly' think that divided by this is twice we already know that these T values are bounded above by eight times their arguments so T of n over five is in most a times n over five T of seven times n is at most eight times seven tenths n now we can group terms together now we're comparing apples to apples so we have n times quantity C plus a over five plus seven tens a let me just go ahead and group the two eight terms together and that's going to be nine-tenths a now don't forget where we're going what the end goal is we want to upper bound even by a n so we want to write that this is bounded above by eight times N and now you see exactly how i reverse-engineered our choice of a as a function of the given constant C since a is ten times as big as C if I take 90% of a and at C I just get a back so by our choice of a this equals a am and that pretty much wraps things up so don't forget what all this stuff stands for so what are we just prove what do we just prove by induction we prove T of n is the most a constant times n for every n that is T of n is Big O of n what was T of n that was the running time of our algorithm that's what we cared about so because T of n is Big O of n indeed deselects runs in time