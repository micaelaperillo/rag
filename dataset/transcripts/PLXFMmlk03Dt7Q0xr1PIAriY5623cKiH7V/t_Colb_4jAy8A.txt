we've discussed a number of divide and conquer algorithms and so far I've been giving short shrift to proofs of correctness this has been a conscious decision on my part uh coming up with the right divide and conquer algorithm for a problem can definitely be difficult but once you have that Eureka moment and you figure out the right algorithm you tend to also have a good understanding of why it's correct why it actually solves the problem and every possible input similarly when I present to you a Divine and Conquer algorithm like say merge sort or a quick sort I expect that many of you have a good and accurate intuition about why the algorithm is correct in contrast the running time of these divide and conquer algorithms is often highly non-obvious so correctness proofs for divide and conquer algorithms tend to Simply formalize uh the intuition that you have via a proof by induction that's why I haven't been spending much time on them but nevertheless I do feel like I owe you at least one rigorous correctness proof for a divide and conquer algorithm and we may as well do it for quick sort so in this optional video we'll briefly review proofs by induction and then we'll show how such a proof can be used to rigorously establish the uh correctness of quick sort the correctness proofs for most of the other divide and conquer algorithms that we discuss can be formalized in a similar way so let's begin by reviewing the format for proofs by induction so the canonical type of proof by induction and the kind that we'll be using here uh is when you want to establish an assertion for all of the positive integers in so now some assertion which is parameterized by n where N is a positive integer I know this is a little abstract so let me just be concrete about the assertion we actually care about for quick swort so for us the assertion P of n is the statement that quick swort is always correct on inputs of length n arrays that have n elements so an induction proof has two parts the first part is a base case and the second part is an inductive step for the base case you have to get started so you show that at the very least your assertion is true when n equals 1 this is often a trivial matter and that'll be the case when we establish the correctness uh of quick sort just on arrays with only one element so the non-trivial part of a proof by induction is usually the inductive step and in the inductive step you look at a value of n not covered by the base case so a value of n bigger than one and you show that if the assertion holds for all smaller values small integers then it also holds for the integer n that is you show that for every positive integer n that's two or greater you assume that P of K holds for all K strictly less than n and under that assumption which is called the inductive hypothesis under the assumption that P of K holds for all K strictly less than n you then establish that P of n holds as well so if you manage to complete both of these steps if you prove both the base case that uh P of one holds you argue that directly and then also you argue that assuming the inductive hypothesis that the assertion holds for all smaller integers it also holds for an arbitrary integer n then you're done then in fact you have proven that the assertion P of n holds for every single positive integer n right so for any given n that you care about the way you can derive that from one and two is you just start from the base case P of one holds then you apply the inductive Step n minus one times and boom you've got it so you know that P holds for the integer n that you care about as well and that's true for arbitrarily large values of n so those are proofs by induction in general now let's instantiate this uh proof format this type of proof for establishing the correctness of quick sort so let me write again what is the assertion we care about our definition of p of n is going to be the quick sword is always correct on arrays of length n and of course what we want to prove is that quick sort is correct no matter what size array that you give it that is we want to prove that P of n holds for every single n at least one so this is right in the Wheelhouse of proofs by induction okay so that's how we're going to establish it now depending on the order in which you're watching the videos you may or may not have seen our discussion about how you actually choose the pivot recall that the first thing quick sort does is choose a pivot then it partitions the array around a pivot so we're going to establish the correctness of quicksort no matter how the choose pivot sub routine gets implemented okay so no matter how you choose pivots you'll always have correctness as we as we'll see in a different video the choice of pivots definitely has an influence on the running time of quicksort but the correctness of quicksort is no matter how you choose the pivot so let's proceed by approv by induction so for the base case when n equals 1 this is a fairly trivial statement right so then we're just talking about inputs that have only one element every such array is already sorted quick sort in the B when n equals one just Returns the input array it doesn't do anything and that is indeed a sorted array that it returns so by this rather trivial argument we had directly proven that P of one holds we've proven the rather unimpressive statement that quick sort always correctly sorts one element arrays okay no big deal so let's move on to the inductive step so in the inductive step we have to fix an arbitrary value of n that's at least two a value of n not covered by the base case so let's fix some value of n at least two now what are we trying to prove we're trying to prove that quick sort always correctly sorts every input array of length n so we also have to fix an arbitrary such input so let's make sure we're all clear on what it is we need to show what are you showing an inductive step assuming that P of K holds for all smaller values all smaller integers then P of n holds as well and remember this is the inductive hypothesis so in the context of quick sort we're assuming that quick sort uh never makes a mistake on any input array that has length strictly smaller than n and now I just have to show it never makes a mistake on array input arrays that have size exactly n so this is the point in the proof where we actually delve into how quick sort is implemented to argue correctness so recall what the first step of Quicks swort is it picks some pivot arbitrarily we don't know how we don't care how and then it partitions the array around this pivot element [Applause] P now as we argued in the video where we discussed the partition sub routine at the conclusion of that sub routine the array has been rearranged into the following format the pivot is wherever it is everything to the left of the pivot is less than the pivot and everything bigger than the pivot is greater than the pivot right this is where how things stand at the conclusion of the partitioning sub routine so let's call this stuff less than the pivot the first part of the partitioned array and the stuff bigger than the pivot the second part of the partitioned array and recall our observation from the overview video that the pivot winds up in its correct position right where would the pivot be where is any element supposed to be in the final sorted array well it's supposed to be to the right of everything less than it and to the left of everything bigger than it and that's exactly where uh this partitioning subroutine deposits the pivot element p so now to imply the inductive hypothesis which you recall is a hypothesis about how quick sort operates on smaller subarrays let's call the length of the first part and the second part of the partitioned array K1 and K2 respectively now crucially both K1 and K2 are strictly less than n both of these two parts have length strictly less than that of the given an input array a that's because the pivot in particular is excluded from both of those two parts so they can have at most n minus one elements that means we can plot the inductive hypothesis which says that the quick sword never makes a mistake on an array that has size strictly less than n that implies that are two recursive calls to quick sort the one to the first part and the one to the second part don't make mistakes they're guaranteed to sort those subarrays correctly by the inductive hypothesis and to be very precise what we're using to argue that the recursive calls are correct are P of K1 and P of K2 where p is the assertion that quick sort isolve is correct on arrays of length uh K1 and K2 and we know that both of these statements are true because K1 and K2 are less are both less than n and because of the inductive hypothesis so what's the upshot the upshot is quick sorts going to be correct right so the first recursive call puts all of the elements that are less than the pivot in the correct relative order next comes the pivot which is bigger than all of that stuff in the first part and less than all the stuff in the second part and then the second recursive call correctly orders uh all of the elements in the second part so with those three things pasted together we have a sorted version uh of the input array and since this array was an arbitrary one of length n that establishes the assertion P of N and since n was arbitrary that establishes the inductive step and completes the proof of corre correctness of quick sort for an arbitrary method of choosing the pivot element