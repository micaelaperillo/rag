so let's talk about the absolutely fundamental problem of searching a graph and the very related problem of finding paths through graphs so why would one be interested in searching a graph for figuring out if there's a path from point A to point B well there's many many reasons I'm gonna give you a highly non exhaustive list on this slide so let me begin with a very sort of obvious and literal example which is if you have a physical network then often you want to make sure that the network is fully connected in the sense that you can get from any starting points to any other points so for example think back to the phone network it would have been a disaster if callers from California could only reach callers in Nevada but not their family members in Utah so obviously a minimal condition for functionality of something like a phone network is that you can get from any one place to any other place similarly for road networks within a given country and so on it can also be fun to think about other non physical networks and ask if they're connected so one network that's fun to play around with is the movie network so this is the graph where the nodes correspond to actors and actresses and you have an edge between two nodes if they played a role in a common movie this is going to be an undirected graph or the edges correspond to not necessarily co-starring but both the actors appearing at least at some point in the same movie so versions of this movie Network you should be able to find publicly available on the web and there's lots of fun questions you can ask about the movie Network like for example what's the minimum number of hops where a hop here again is a movie that two people both play a role in the minimum number of hops or edges you can get from one actor to another actor so perhaps the most famous statistic that's been thought about with the movie network is the bacon number so this refers to the fairly ubiquitous actor Kevin Bacon and the question the bacon number of an actor is defined as the minimum number of hops you need in this movie graph to get to Kevin Bacon so for example you could ask about Jon Hamm also known as Don Draper from Mad Men and you could ask how many edges do you need on a path through the movie graph to get to Kevin Bacon and it turns out that the answer is 1 excuse me 2 you need one intermediate point namely Colin Firth and that's became that's because Colin Firth and Kevin Bacon both starred in the Atom Egoyan movie where the truth lies and Jon Hamm and Colin Firth were both in the movie a single man so that would give Jon Hamm a bacon number of two so these are the kind of questions you can ask about connectivity not just in physical networks like telephone and telecommunication networks but also logical networks about pairwise relationships between objects more generally so the bacon number is fundamentally not just about any pass but actually shortest paths the minimum number of edges you need to traverse to get from one actor to Kevin Bacon and shortest paths or also have a very practical use that you might use yourself in driving directions so when you use a website or a phone app and you ask for the best way to get from where you are now to say some restaurant where you're going to have dinner obviously you're trying to find some kind of path through a network through a graph and indeed often you want the the shortest path perhaps in mileage or perhaps an anticipated travel time now I realize that when you're thinking about paths and graphs it's natural to focus on sort of a very literal paths and quite literal physical networks things like routes through a road network or pass through the internet and so on well you should really think more abstractly as a path as just a sequence of decisions taking you from some initial state to some final state and it's this abstract mentality which is what makes graph search sort of so ubiquitous and feels like artificial intelligence where you want to formulate a plan of how to get from an initial state to some goal state so to give a simple recreational example you can imagine just trying to understand how to compute automatically a way to fill in a Sudoku puzzle so that you get to so that you solve the puzzle correctly so you might ask you know what is the graph that we're talking about when we want to solve a Sudoku puzzle well this is going to be a directed graph or here the nodes correspond to partially completed puzzles so for example at one node of this extremely large graph perhaps for ye d1 cells are filled in with some kind of number and now again remember a path is supposed to correspond to a sequence of decisions so what are the actions that you take in solving Sudoku well you fill in a number into a square so an edge which here is going to be directed is going to move you from one partially completed puzzle to another where one previously empty square gets filled in with one number and of course then the path that you're interested in computing or what you're searching for when you search this graph you begin with the initial States of the Sudoku puzzle and you want to reach some goal state where the pseudo composable is completely filled in without any violations of the rules of Sudoku and of course it's easy to imagine millions of other situations where you want to formulate some kind of plan like this like for example if you have a robotic hand and you just want to graph some object you need to think about exactly how to approach the object with this robotic hand so that you can grab it without for example first knocking it over and you can think of millions of other examples another thing which turns out to be closely related to graph search as we'll see and has many applications in its own right is that of computing connectivity information about graphs so in particular the connected components so this is especially for undirected graphs corresponds to the pieces of a graph we'll talk about these topics in their own right I'll give you applications for them later so for undirected graphs I'll briefly mention an easy clustering heuristic you can derive out of computing connected components for directed graphs where the very definition of computing components is a bit more subtle I'll show you applications to understanding the structure of the web so these are a few of the reasons why it's important for you to understand how to efficiently search graphs it's a fundamental and widely applicable graph primitive and I'm happy to report that in this section of the course pretty much anything any questions we want to answer about graph search computing connecting components and so on there's going to be really fast algorithms to do it so this will be a part of the course where there's lots of what I call for free primitives processing steps subroutines you can run without even thinking about it all of these algorithms we're going to discuss in the next several lectures are run in linear time and they're going to have quite reasonable constants so they're really barely slower then reading the input so if you have a graph and you're trying to reason about it you're trying to make sense about it you should in some sense feel free to apply any of these subroutines we're going to discuss to try and glean some more information about what they look like how you might use the network data there's a lot of different approaches to systematically searching a graph so there's many methods in this class we're going to focus on two very important ones namely breadth-first search and depth-first search but all of the graph search methods share some things in common so on this slide let me just tell you the high order bits of really any graph search algorithm so graph search subroutines generally are passed as input a starting vertex from which the search originates so that's often called a source vertex and your goal then is to find everything findable from this search vertex and obviously you're not going to find anything that you can't find it's not final what do I mean by findable I mean there's a path from the starting point to this other node so for any of the nodes to which you can get along a path from the starting point you should discover it so for example if you're given an undirected graph that has three different pieces like this one I'm drawing on the right and perhaps S is this left most node here then the findable vertices starting from s ie the ones to which you can reach from a path test is clearly precisely these four vertices so you would want graph search to automatically discover and efficiently discover these four vertices if you started at s you can also think about a directed version of the exact same graph where I'm going to direct the vertices like so so now the definition of the findable nodes is a little bit different we're only expecting to follow arcs forward along the forward direction so we should only expect at best to find all of the nodes that you can reach by following a succession of forward arcs that is any any node that there's a path to from s so in this case these three nodes would be the ones we'd be hoping to find this blue node to the rights we would no longer expect to find because the only way to get there from s is by going backward along ours and that's not what we're going to be thinking about and our graph searches so we want to find everything findable ie that we can get to along paths and but we want to do it efficiently and efficiently means we don't explore anything twice right so the graph has m arcs M edges and and nodes are n vertices and really we want to just look at either each piece of the graph only once or a small constant number of time so we're looking for running time which is linear in the size of the graph that is Big O of M plus n now when we were talking about representing graphs I said that in many applications it's natural to focus on connected graphs in which case M is going to dominate n you're gonna have at least as many edges as nose essentially but connectivity is the classic case where you might have the number of edges being much smaller than the number of nodes there might be many pieces and the whole point of what you're trying to do is discover them so for this sequence of lectures where we talk about graph search and connectivity we will usually write M plus n we'll think that either one could be bigger or smaller than the other so let me now give you a generic approach to graph search so it's gonna be able underspecified there'll be many different ways to instantiate it two particular instantiation will give us breadth-first search and depth-first search but here's just a general systematic method for finding everything findable without exploring anything more than once so motivated by the second goal the fact that we don't want to explore anything twice with each node with each vertex we're going to remember whether or not we've explored it before so we just need one boolean per node and we'll initialize it by having everything unexplored except s our starting point will have it start off as explored and it's useful to think of the nodes thus far as being in some sense territory conquered by the algorithm and then there's going to be a frontier in between the conquer two on conquer territory and the goal of the generic algorithm is at each step we supplement the conquered territory by one that new node assuming that there is one adjacent to the territory we've already conquered so for example in this top example with the undirected network initially the only thing we've explored is the starting point s so that's sort of our home base that's all that we have conquered so far and then in our main while loop which we iterate as many times as we can until we don't have any edges meeting the following criterion we look for an edge with one endpoint that we've already explored one endpoints inside the conquered territory and then the other endpoint outside so this is how we can in one hop supplement the number of nodes we've seen by one new if we can't find such an edge then this is where the search stops if we can find such an edge well then we suck V into the conquer territory we think of it being explored and we return to the main while loop so for example in this example on the writes we start with the only explored node being s now there's actually two edges that cross the frontier in the sense one of the endpoints is explored namely one of the endpoints as s and the other one is some other vertex right there's this there's these two vert two edges to the left - or two C's adjacent to s so in this algorithm we pick either one it's underspecified which one we pick but maybe we pick the top one and so then all of a sudden this second top vertex is now also explored so the conquer territory is the union of them and so now we have a new frontier so now again we have two edges that cross from the explored nodes the unexplored nodes these are the edges that are in some sense going from Northwest to Southeast again we pick one of them it's not clear how the algorithm doesn't tell us we just pick any of them so maybe for example we pick this rightmost edge crossing the frontier now the rightmost edge of these runners vertex of these four is explored so our conquered territory is the top three vertices and now again we have two edges crossing the frontier the two edges that are incident to the bottom node we think one of them not clear which one maybe this one and now the bottom node is also explored and now there are no edges crossing the frontier so there are no edges who on the one hand have one endpoint being explored and either end the point being unexplored so these will be the four vertices as one would hope that the search will explore started from s well generally the claim is that this generic graph search algorithm does what we wanted it finds everything findable from the starting point and moreover it doesn't explore anything twice I think it's fairly clear that it doesn't explore anything twice right as soon as you look at a node for the first time you suck it into the conquered territory it never to look at it again similarly as soon as you look at an edge you suck them in but when we support breadth and depth first search will be more precise about the running time and exactly what I mean by you don't explore something twice so at this level of generality I just want to focus on the first point that anyway you instantiate the search algorithm it's going to find everything findable so what do I really need the formal claim is that at the termination of this algorithm the nose that we've marked explored are precisely the ones that can be reached via a path from s that's the sense in which the algorithm explores everything that could potentially be findable from the starting point that's one thing I want to mention is that this claim and the proof I'm going to give of it it holds whether or not G is an undirected graph or a directed graph in fact almost all of the things that are gonna say about graph search in particular about breadth-first search and depth-first search worked in essentially the same way either an undirected graphs or directed graphs the obvious difference being in an undirected graph you can traverse an edge in either direction and a directed graph we're only supposed to traverse it in the forward direction from the tail to the head the one big difference between undirected and directed graphs is when we do connectivity computations and I'll remind you when we get to that point which one they're talking about ok but for the most part when we just talk about basic graph search it works essentially the same way whether it's undirected or directed so keep that in mind all right so why is this true why are the nodes that get explored precisely the nodes for which there's a path to them from s well one direction is easy which is you can't find anything which is not findable that is if you wind up exploring a node the only reason that can happen is because you traversed a sequence of edges that got you there and that sequence of edges obviously defines a path from s to V if you really want to be pedantic about the forward direction that explored nodes have to have paths from s then you can just do an easy induction and I'll leave this for you to check if you want in the privacy of your own home so the important direction of this claim is really the opposite why is it that no matter how we instantiate this generic graph search procedure it's impossible for us to miss anything that's the crucial point we don't miss anything that we could in principle find via a path but we're going to proceed by a contradiction so what does that mean we're going to assume that the statement that we want to prove is true is not true which means that it's possible that G has a path from s to V and yet somehow our algorithm misses it doesn't as explores right that's the thing we're really hoping doesn't happen so let's suppose it has happened in the driver contradiction so suppose G does have a path from s to some vertex B called the path P I'm going to draw the picture for an undirected graph but the situation would be same in the in the directed case so there's a bunch of hops there's a bunch of edges and then eventually this path ends at V now the bad situation the situation from which we wanted to have a contradiction is that V is unexplored at the end of this algorithm so let's take stock of what we know s for sure is explored right we initialize the search procedure so that s is marked as explored V by hypothesis and this proof by contradiction is unexplored so s is explored V is unexplored so now imagine we just in our heads as a thought experiment we traverse this path P we started asked to me know as explored we go to the next vertex that may or may not have been explored we're not sure we go to the third vertex again who knows might be explored might be unexplored and so on but by the time we get to V we know it's unexplored so we started s it's been explored we get to V it's been unexplored so at some point there's some hop along this path P from which we move from an explored vertex to an unexplored vertex there has to be a switch at some point because the end of the day at the end of the path were at an unexplored node so consider the first edge and there must be one that we switched from being an explored node to being at an unexplored node so I'm gonna call the endpoints of this purported edge u and W where u is the explored one in W is a young explored one now for all we know you could be exactly the same as s that's Apollo the possibility or front we know W could be the same as V that's also a possibility and the picture I'll draw as if this as UX was somewhere in the middle of this path but again it may be a wonder yes that's totally fine but now in this case there's something I need you to explain to me how is it possible that on the one hand our algorithm terminated and on the other hand the is this edge u comma X where u has been explored and X has not been explored that my friends is impossible our generic search algorithm does not give up it does not terminate unless there are no edges where the one endpoint is explored in the other endpoint is unexplored as long as there's such an edge it has going to suck in that unexplored vertex into the conquer territory it's going to keep going so the upshot is there's no way that our algorithm terminated with this picture with there being an edge u Xu explored X unexplored so that's the contradiction this contradicts the fact that our algorithm terminated with the unexplored so that is a general approach to graph search so that I hope gives you the flavor of how this is going to work but now there's two particular instantiation of this generic method that are really important and have their own suite of applications so we're going to focus on breadth-first search and depth-first search we'll cover them in detail in the next couple of videos I want to give you the highlights to conclude this video now let me just make sure it's clear where the ambiguity in our generic method is why we can have different instantiations of it that potentially have different properties in different applications the question is a given iteration of this while loop what do you got you got your notice that you already explored so that includes S Plus probably some other stuff and then you've got your nodes that are unexplored and then you have your crossing edges right to there edges with one point in each sock and for an undirected graph there's no orientation to worry about these crossing edges just have one endpoint in the explored side one endpoint in the unexplored side in the directed case you focus on edges or the tail of the edges in the explored side and the head of the edges in the unexplored side so they go from the explored side to the unexplored side and the question is in general an iteration of this while loop there's going to be many such crossing edges there are many different unexplored nodes we could go to next and different strategies for picking the unexplored node to explore next leads us to different graph search algorithms with different properties so the first specific search strategy we're going to study is breadth-first search colloquially known as BFS so let me tell you sort of the high-level idea in applications of breadth-first search so the goal is going to be to explore the nodes in what I call layers so the starting point s will be in its own layer layer zero the neighbors of s will constitute layer 1 and then layer 2 will be the nodes that are neighbors of layer 1 but that are not already in that layer 0 or layer 1 and so on so layer I plus 1 is the stuff next to layer I that you haven't already seen yet you can think of this as a fairly cautious and tentative exploration of the graph and it's going to turn out that there's a close correspondence between these layers and shortest path distances so if you want to know the minimum number of hops or the minimum number of her edges you need in a path to get from point A to point B in a graph the way we wanted to know the fewest number of edges in the movie graph necessary to connect to jon hamm to Kevin Bacon that corresponds directly to these layers so if a node is in layer I then you need is to get from s to I in the graph once we discuss breadth-first search we'll also discuss how to compute the kinetic components or the different pieces of an undirected graph turns out this isn't that special the breadth-first search you can use any number of graph search strategies to compute connected components in undirected graphs but i'll show you how to do it using a simple loop 2 version of breadth-first search and we'll be able to do this stuff in the linear time that we want the very ambitious goal of getting a linear time to get the linear time implementation you do want to use the right data structure but it's a super simple data structure something probably you've seen in the past namely a queue so something that's first-in first-out so the second search strategy that's super important to know is depth-first search also known as DFS to its friends depth-first search has a rather different field in breadth-first search it's much more aggressive search where you immediately try and plunge as deeply as you can it's very much in the spirit of how you might explore a maze where you go as deeply as you can only backtracking when absolutely necessary depth-first search will also have its own set of applications it's not for example very useful for computing shortest path information but especially in directed graphs it's going to do some remarkable things for us so in a directed acyclic graph so wrecked a graph with no directed cycles and will give us what's called the topological ordering so it'll sequence the nodes in a linear ordering from the first to the last so that all of the arcs of the directed graph go forward so this is useful for example if you have a number of tasks that have to get completed with certain precedence constraints like for example you have to take all of the classes and your undergraduate major there are certain prerequisites a topological ordering will give you a way in which to do it respecting all of the prerequisites and finally we're for undirected graphs it doesn't really matter whether you use BFS or DFS to keep you connected components and directed graphs or even defining connected components is a little tricky it turns out depth-first search is exactly what you want that's what you're going to get a linear time implementation for computing the right notion of connected components in the directed graph case time wise both of these are superb strategies for exploring a graph they're both linear time and very good constants so depth-first search again we're going to get order o of M + end time and the graph with M edges and n vertices you do want to use a different data structure reflecting the different search strategy so here because you're exploring aggressively as soon as you get to endowed you immediately start exploring its neighbors you want to last in first out data structure also known as a stack depth-first search also admits a very elegant recursive formulation and in that formulation you don't even need to maintain a stack data structure explicitly the stack is implicitly taken care of in the recursion so that concludes this overview of graph search both what it is what our goals are what kind of applications they have and two of the most common strategies the next couple videos are going to explore these search strategies as well as a couple of these applications in greater depth