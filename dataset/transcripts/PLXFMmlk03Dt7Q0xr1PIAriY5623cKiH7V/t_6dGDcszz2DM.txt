in this series of videos will study the master method which is a general mathematical tool for analyzing the running time of divide and conquer algorithms we'll begin in this video motivating the method then we'll give its formal description that'll be followed by a video working through six examples finally we will conclude with three videos that discuss a proof of the master method with a particular emphasis on the conceptual interpretation of the master methods three cases so let me say at the outset that this lecture is a little bit more mathematical than the previous two but it's really not just math for math sake will be rewarded for our work with this powerful tool the master method which has a lot of predictive power it'll give us good advice about which divide and conquer algorithms are likely to run quickly and which ones are likely to run less quickly indeed it's sort of a general truism that novel algorithmic ideas often require mathematical analysis to properly evaluate this lecture will be one example of that truism as a motivating example consider the computational problem of multiplying two and digit numbers recall from our first set of lectures that we all learned the iterative grade-school multiplication algorithm and that that requires a number of basic operations additions and multiplications between single digits which grows quadratically with a number of digits and on the other hand we also discussed an interesting recursive approach using the divide and conquer paradigm so recall divide and conquer necessitates identifying smaller subproblems so for integer multiplication we need to identify smaller numbers that we want to multiply so we proceeded in the obvious way breaking each of the two numbers into its left half of the digits and its right half of the digits for convenience I'm assuming that the number of digits n is even but it really doesn't matter having decomposed x and y in this way we can now expand the product and see what we get so let's put a box around this expression and call it star so we began with the sort of obvious recursive algorithm where we just evaluate the expression star in the straightforward way that is star contains four products involving n over two digit numbers AC ad BC and BD so we make four recursive calls to compute them and then we complete the evaluation in the natural way namely we append zeros as necessary and add up these three terms to the final result the way we reason about the running time of recursive algorithms like this one is using what's called a recurrence so to introduce a recurrence let me first make some notation T of n this is going to be the quantity that we really care about the quantity that we want to upper bound namely this will be the worst case number of operations that this recursive algorithm requires to multiply to end digit numbers this is exactly what we want to upper bound a recurrence then is simply a way to express T of n in terms of T of smaller numbers that is the running time of an algorithm in terms of the work done by its recursive calls so every recurrence has two ingredients first of all it has a base case describing the running time when there's no further recursion and in this integer multiplication algorithm like in most divide and conquer algorithms the base case is easy once you get down to a small input in this case to one digit numbers then the running time is just constant all you do is multiply the two digits and return the result so I'm going to express that by just declaring the T of one the time you tell to why one digit numbers is bounded above by a constant I'm not going to bother to specify what this constant is you can think of it as one or two if you like it's not going to matter for what's to follow the second ingredient in a recurrence is the important one and it's what happens in the general case when you're not in the base case and you make recursive calls and all you do is write down the running time in terms of two pieces first of all the work done by the recursive calls and second of all the work that's done right here now work done outside of the recursive calls so on the left-hand side of this general case we just write T of N and then we want an upper bound on T of n in terms of the work done by recursive calls and the work done outside of recursive calls and I hope it's self-evident what the recurrence should be in this recursive algorithm Vantage of multiplication as we discussed there is exactly four recursive calls and each is invoked on a pair of n over two digit numbers so that gives us four times the time needed to multiply n over two digit numbers so what do we do outside of the recursive call well we've had the results of the recursive calls with a bunch of zeros and we add them up and I'll leave it to you to verify that grade-school addition in fact runs in time linear in the number of digits so putting it all together the amount of work we do outside of the recursive calls is linear that is its Big O of n let's move on to the second more clever recursive algorithm for integer multiplication which dates back to gaps Gauss's insight was to realize that in the expression star that we're trying to evaluate there's really only three fundamental quantities that we care about the coefficients for each of the three terms in the expression so this leads us to hope that perhaps we can compute these three quantities using only three recursive calls rather than four and indeed we can so what we do is we recursively compute a times C like before and B times D like before but then we compute the product of a plus B with C plus D and the very cute fact is if we number these three products 1 2 & 3 that's the final quantity that we care about the coefficient of the 10 to the N over 2 term namely ad plus BC is nothing more than the third product minus each of the first two so that's the new algorithm what's the new recurrence the base case obviously is exactly the same as before so the question then is how does the general case change and I'll let you answer this in the following quiz so the correct response for this quiz is the second one namely the only thing that changes with respect to the first recurrence is that the number of recursive calls drops from 4 down to 3 a couple of quick comments so first of all I'm being a little bit sloppy when I say there's three recursive calls each on digits each on numbers would n over two digits when you take the sums a plus B and C plus D those might well have interpret two plus 1 digits amongst friends let's ignore that let's just call it n over 2 digits needs to the recursive calls as usual the extra plus 1 is not going to matter in the final analysis secondly I'm ignoring exactly what the constant factor is in the linear work done outside of the recursive calls indeed it's a little bit bigger in Gauss's algorithm than a new the naive algorithm with four recursive calls but it's only by a constant factor and that's going to be suppressed in the Big O notation so let's look at this recurrence and compare it to two other recurrences one bigger one smaller so first of all as we noted it differs from the previous recurrence of the naive recursive algorithm and having one fewer recursive call so we have no idea what the running time is either of these two recursive algorithms but we should be confident that this one certainly can only be better that's for sure another point of contrast is merge sort so think about what the recurrence would look like for the merge sort algorithm it would be almost identical to this one except instead of a three we'd have a two right merge short makes two recursive calls each on an array of half the size and outside of the recursive calls it does linear work namely for the merge subroutine we know the running time of merge sort it's n log n so this algorithm Gauss's algorithm is going to be worse but we don't know by how much so well we have a couple clues about what the running time of this algorithm might be more or less than honestly we have no idea what the running time of Gauss's recursive algorithm for integer multiplication really is it is not obvious we currently have no intuition for it we don't know what the solution to this recurrence is but it will be one super special case of the general master method which we'll tackle next