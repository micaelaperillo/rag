so let's just see how it works on the same example we traced through earlier so we start out just by initializing uh things in the obvious way so the shortest path distance from s to itself we say is zero and the shortest path from s to itself is just the empty path and initially our X is going to be just the source vertex itself so now we enter the main while loop and so remember in the while loop we say well let's scan all of the edges whose tail is in the vertices we've already looked at whose tail is in X and whose head is outside of X now in this first generation there are two such edges there's the edge s comma V and the edge s comma W so how do we know which of these two to choose well we evaluate Dyer's greedy Criterion and so remember what that is Dyer's greedy score for a given Edge VW that's crossing the frontier is just the previously computed shortest path distance for the tailor of the arc plus the length of the arc itself so at this point SV has a greedy score of 0 + 1 which is one and the arc S comma W has a greedy score of 0 + 4 which is four so obviously SV is going to be the shorter of those two so we use the edge SV this is playing the role of V Star W star on the previous slide and the algorithm then suggests that we should add V to our set X so we suck in v and our new X consists of s and V and it also tells us how to compute the shortest path distance and the shortest path from s to V namely in the a array we just write down what was the greedy the Dyer's greedy score for this particular Edge and that was 0 + 1 or one it also tells us how to compute the shortest path for V namely we just inherit the shortest path to the tail of the arc which in this case is the empty path from s to itself and then we tack on the end we append The Arc we use us to get here the arc S ofv so now we go to the next iteration of the while loop so with our new set capital x consisting of s and V and now again we want to look at all edges which are crossing the frontier edges that have tail uh in X and head outside X and now we see there's three such Crossing edges there's s comma W there's V comma W and there's V comma T all of those have the tail and x and the head outside of X so we need to compute Dyer's greedy score for each of those three and then pick the minimum so let's go from bottom to top so first of all we can look at the arc S comma v s comma W excuse me and the greedy score here is the shortest path distance for the tail so that's zero plus the length of the Ark which is four so here we get a four in this iteration then if we do this crossbar Edge this VW Edge the dyer greedy score is the a value or the shortest path distance value of the tail and we computed that last iteration the a of V value is one we add to that the length of the arc which in this case is two so this Edge three this Edge V comma W has a score of three finally there's the arc V comma T and here we're going to add one which is the shortest path distance of the tail of the Ark plus the edge length which is six so that has the worst score so since the edge V comma W has the smallest score that's the one that guides how we supplement X and how we can compute the shortest path distances and the shortest path for the newly acquired vertex W so the changes are first of all we enlarge X so X is now everything but T and then how do we compute things for w well the shortest path so the our entry in the a array is just going to be dy's greedy score in the previous iteration so that was 1 + 2 so that's going to be equal to three and then what is the shortest path how do we fill up the array B well we inher it the shortest path to the tail of the Ark which in this case is the arc S comma V and then we appin The Arc that we used uh to choose this new vertex W so that's the arc VW so the New Path is just the SV W path so that's what we compute as the shortest path from s to W in this graph so now we proceed to the final iteration of dous algorithm we know what vertex we're going to bring into X it's going to be the vertex T that's the only one left but we still have to compute by which Edge we discover T and bring it into the set X so we have to compute the greedy score for each of the two Crossing arcs V comma T and W comma T and in this final iteration the score for the arc VT is unchanged so this is still going to be the a value of its tail one plus the length of the arc six so the score here is still seven and now for the first time W comma T is a Crossing edge of the frontier and when we compute it score it's the a value of its tail W which is three plus the length of this Arc which is three so we get a greedy score of six so by DX's greedy Criterion we pick the edge WT instead of the edge VT and of course that doesn't matter who gets brought into X but it does matter how we compute the A and B values for T so in the final iteration we compute a t to be the DI or greedy score of the edge that we picked which is the edge WT and the score was six so we comp the shortest path distance from s to T to be6 and then what is the path itself well we inherit the shortest path to the tail of the arc that we used to discover T so that's the shortest path to W which we previously computed as being the path through V and then we append The Edge we use to discover T so we pend The Edge WT so the shortest path from s to T we're going to compute as the zigzag path s goes to V goes to T sorry goes to W goes to to T and then now uh indeed X is all of the vertices we've computed it for everything this is our final output the contents of the especially the a array is the final output shortest path distances from s to all of the four possible destinations and if you go back and compare this to the example you went through to the quiz you will see at least on this example indeed Dyer's algorithm corrects the shortest path distances now I've said it before I'm going to say it again someone shows you their algorithm works just on some example especially a prettyy simple for note example you should not jump to the conclusion that this algorithm always works sometimes algorithms work fine on small examples but break down once you go to more interesting complicated examples so I definitely owe you a proof that Dyer's algorithm works not only in this network but in any network and actually it doesn't work in any network it's only going to work in any network with non- Negative Edge lengths so to help you appreciate that let's conclude this video with a non-example showing what goes wrong in Dyer's algorithm when you have networks with Negative Edge lengths so before I actually give you a a real non-example let me just answer a preliminary question which you might have and this would be a very good question if it's something that's occurred to you the question would be well you know why is it why are these Negative Edge LS such a big deal why can't we just reduce shortest path computation with Negative Edge links to the problem of computing shortest paths with non- Negative Edge links right so why don't we just sort of clear things out we just add a big number to all the edges that makes them all non- negative and now we just run dier algorithm and we're good to go so this is exactly the sort of question you should be looking to ask if as a computer scientist as a serious programmer when confronted with a problem you always want to look for ways to reduce it to simpler problems that you already know how to solve and this is a very natural idea of how to reduce a seemingly harder shorter path problem to one we already know how to solve using dyous algorithm the only problem is uh it doesn't quite work why doesn't it work well if you let's say you have a graph and the most Negative Edge is is minus 10 so all the edge links are minus 10 and above so then what you'd want to do is add 10 to every single edge in the network and that ensures that all the EDG links are non- negative run Dyer's algorithm get your shortest path the issue is that different paths between a common origin and destination have differing numbers of edges so some might have five edges some might have two edges now if you add 10 to every single edge in the graph you're going to change path lengths by different amounts if a path has five edges it's going to go up by 50 when you add 10 to every Edge if a path has only two edges it's only going to go up by 20 when you add 10 to every Edge so as soon as you start changing the path Links of different paths by different amounts you might actually screw up which path is the shortest the path which is shortest under the new Edge lengths need not be the one which is shortest under the old Edge lengths so that's why this reduction doesn't work to be concrete let's look at this very simple three vertex graph with vertices SV and T and Edge lengths as shown 1 - 5 and - 2 now what I hope is clear is that in this graph the shortest path the one with the minimum length is the two hop path SVT that has length Min -4 the direct St Arc has length min-2 which is bigger than Min -4 so the upper path is the shortest path now suppose we tried to massage this by adding a constant to every Edge so that all edges all Edge lengths were non- negative we'd have to add five to every Edge because that's the biggest negative number the VT Edge so that would give us new Edge lengths of six and 0 and three and now the problem is we've changed which path is the shortest one we added 10 to the top path and only five to the bottom path and as a result they've reversed so now the bottom path St is actually the shorter one so if you run Dyer on this graph it's going to come back with the path St even though that's not in fact the shortest path in the original Network the one that we actually care about okay so that's why you can't just now L reduce shortest paths with Negative Edge lengths to shortest paths with non- Negative Edge lengths moreover on this very same super simple three node graph you know we can try run running DIY for shortest path algorithm it's perfectly well defined it'll produce some output but it's actually going to be wrong it is not going to compute shortest path distances uh correctly in this graph so let me show you why well so of course the initialization will work as it always does so it's going to start by saying the shortest path distance uh from s to itself is zero via the path and then what's it going to do next it's going to say okay well we need to enlarge the set capital x by one vertex and there are two Crossing edges is the XV Edge and the St Edge and uh what's it going to do it's going to use the Dy greedy score so the score of this upper Edge is going to be one and the score of this bottom Edge is going to be min-2 CU remember you take the previously computed shortest path value of the tail that's zero in both cases and then you add the edge length so the edge lengths are 1 and-2 so the scores are 1 and - two which of these is smaller well evidently the St Arc has the smaller score minus two so what is D Isa going to do it's going to say yes let's go for this Edge St let's bring T into the set capital x t is now part of the conquered territory and of course as soon as you bring a node into the set X into the conquered territory you have to commit or Dyer's algorithm chooses to commit to its shortest path distance and its shortest path what is the definition of its shortest path distance as computed by dyra well it's just its greedy score so it's going to assign the vertex T the shortest path distance of minus 2 and the path is going to be just the ark St but notice that this is in fact wrong the shortest path distance from s to T is not minus 2 in this graph there is another path namely the one that goes through V that has length minus 4 less than minus two so dter computes incorrect shortest path distances on this trivial three node graph so to summarize The Story So Far We've described Dexter's algorithm I've showed you that it works in a very simple example that doesn't have Negative Edge lengths and I've showed you that it doesn't work in an even simpler example that does have Negative Edge lengths so I've both given you some plausibility that it might work generally at least for non- Negative Edge links but I've also tried to sew some seeds of doubt that it's not at all clear at this point if duct algorithm is always correct or not even if you have non- Negative Edge lengths and certainly if it is always correct there better be a a foolproof argument for why you should be demanding an explanation of a claim that Dyers is correct in any kind of generality that's the subject of the next video