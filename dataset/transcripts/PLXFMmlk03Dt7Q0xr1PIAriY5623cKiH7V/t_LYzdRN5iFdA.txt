the goal of this video is to provide more details about the implementation the quicksort algorithm and in particular here we're going to drill down on the key partition subroutine so let me remind you what the job of the partition subroutine is in the context of sorting an array so recall the key idea in quicksort is to partition the input array around the pivot element so this has two steps first you somehow choose a pivot element and in this video we're not going to worry about how you choose the pivot element for concreteness you might just want to think about you keep the first you pick the first element of the array to serve as your pivot so in this example array the first element happens to be 3 so we could choose 3 is the pivot element now there's a key rearrangement step so you rearrange the array so that it has the following property any any entries that are to the left of the pivot element should be less than the pivot element or is any entries which are to the right of the pivot element should be greater than the pivot element so for example in this version of the second version of the array we see to the left of the 3 is the 2 and the 1 there in reverse order but that's ok both the 2 in the 1 to the left of the 3 and they're both less than 3 and the 5 elements to the right of 3 are they're jumbled up but they're all bigger than the pivot element so this is a legitimate rearrangement that satisfies the partitioning and property and again recall this definitely makes partial progress toward having a sorted array the pivot element winds up in its rightful position is winds up where it's supposed to be in the final sorted array to the right of everything less than it to the left of everything bigger than it moreover we've correctly bucketed the other n minus 1 elements to the left or to the right of the pivot according to where they should wind up in the final sorted array so that's the job that the partitioning subroutine is responsible for now what's cool is we'll be able to implement to this partition subroutine in linear time even better we'll be able to implement it so that all it does really is swaps in the array that is it works in place it needs no additional essentially constant additional memory to rearrange the array according to those properties and then as we saw in the high-level description the quicksort algorithm what partitioning does is it enables a divide and conquer approach it reduces the problem size after you've partitioned an array around the pivot all you got to do is we curse on the left side we curse on the right side and your done so what I owe you is this implementation how do we actually satisfy the partitioning property stuff to the left of the pivot smaller than that stuff to the right of the pivots bigger than it in linear time and in place well first let's observe that if we didn't care about the in-place requirement if we were happy to just allocate a second array and copy stuff over it would actually be pretty easy to implement a partitioning subroutine in the linear time that is using oh of an extra memory it's easy to partition around the pivot element in oh of n time and as usual you know probably I should be more precise and write theta of n in these two cases that would be the more accurate stronger statement but I'm going to be sloppy I'm going just going to write the weaker but still correct statement using Big O okay so Big O of n time using linear extra memory so how would you do this well let me just sort of illustrate by example I think you'll get the idea so let's go back to our running example of an input array well if we're allowed to use linear extra space we can just pre allocate another array of length N and then we can just do a single scan through the input array bucketing elements according to whether they're bigger than or less than the pivot and so for example we can fill in the additional array both from the left and the right using elements that are less than or bigger than the pivot respectively so for example we start with the 8 we know that the 8 is bigger than the pivot so we put that at the end of the output array then we get to the to the two's less than the pivot so that should go on the left-hand side of the output array we get to the 5 it should go on the right-hand side and the 1 should go on the left-hand side and so on when we complete our scan through the input array there'll be one hole left and that's exactly where the pivot belongs to the right of everything less than it to the left of everything bigger than it so it's really interesting then is to have an implementation of partition which is not merely linear time but also uses essentially no additional space that doesn't resort to this cop out of that pre allocating an extra array of length n so let's turn to how that works first starting at a high level then filling in the details so I'm going to describe the partitioning subroutine only for the case where the pivot is in fact the first element but really this is without loss of generality if instead you want to use some pivot from the middle of the array you can just have a pre-processing step that swaps the first element of the array with the given pivot and then run the subroutine that I'm about to describe okay so with constant time pre-processing the case of a general pivot reduces to the case of where the pivot is the first element so here's the high-level idea and it's very cool the idea is we're going to be able to get away with just a single linear scan of the input array so in any given moment in this scan which is just going to be a symbol for loop will be keeping track of both the part of the array we've looked at so far and the part that we haven't looked at so far so there's maybe two groups what we've seen what we haven't seen then within the group we've seen we're going to have that be split further according to the elements that are less than the pivot and those that are bigger than the pivot so we're going to leave the pivot element just hanging out in the first element of the array until the very end of the algorithm when we correct its position with a swap and at any given snapshot of this algorithm we will have some stuff that we've already looked at and some stuff that we haven't yet looked at in our linear scan of course we have no idea what's up with the elements that we haven't looked at yet who knows what what they are and whether they're bigger or less than the pivot but we're going to implement the algorithm so among the stuff that we've already seen it will be partitioned in the sense that all elements less than the pivot come first all elements bigger than the pivot come last and as usual we don't care about the relative order amongst elements less than the pivot or amongst elements bigger than the pivot so summarizing we do a single scan through the input array and the trick will be to maintain the following invariants throughout the linear scan but basically everything we've looked at in the input array is partitioned everything less than the pivot comes before everything bigger than the pivot and we want to maintain that invariant doing only constant work and no additional storage with each step of our key for each step of our linear scan so here's what I'm going to do next I'm going to go through an example and execute to the partition subroutine on a concrete array the same input array we've been using as an example thus far now maybe it seems weird to give an example before I've actually given you the algorithm before I given you the code but doing it this way I think you'll see the gist of what's going on in the example and then when I present the code it'll be very clear what's going on whereas if I presented the code first it might seem a little opaque when I first show you the algorithm so let's start with an example throughout the example we want to keep in mind the high-level picture that we discussed in the previous slide the goal is that at any time in the partition subroutine we've got the pivot hanging out in the first entry then we've got stuff that we haven't looked at so of course who knows the who knows whether those elements are bigger than or less than the pivot and then for the stuff we've looked at so far everything less than the pivot comes before everything bigger than the pivot this is the picture we want to retain as we go through the linear scan as this high-level picture would suggest there's two boundaries that were going to need to keep track of throughout the algorithm we're going to need to keep track of the boundary between what we've looked at so far and what we haven't looked at yet so that's going to be we're use the index J to keep track of that boundary and then we also need a second boundary for amongst the stuff that we've seen where is the split between those less than the pivot and those bigger than the pivot so that's going to be I so let's use our running example array so stuff is pretty simple when we're starting out we haven't looked at anything so all of this stuff is unpartitioned and I and J both point to the boundary between the pivot and all the stuff that we haven't seen yet now to get our running time which is linear we want to make sure that at each step we advance J we look at one new element that way in a linear number of steps we'll have looked at everything and hopefully we'll be done and we'll have a partition too right so in the next step we're going to advance J so the region of the array which is which we haven't looked at which is unpartitioned is one smaller than before we've now looked at the eight the first element after the pivot now the eight itself is indeed a partitioned array everything less than the pivot comes before everything after the pivot turns out there's nothing less than the pivot so vacuously this is indeed partitioned so J recall to delineate the boundary between what we looked at and what we haven't looked at idle any eights the amongst the stuff we've looked at where is the boundary between what's bigger than and was less than the pivot so the aid is bigger than the pivot so I should be right here okay because we want I to be just to the left of all the stuff bigger than the pivot now what's going to have it in the next iteration this is where things get interesting suppose we advance j-1 further now the part of the array that we've seen is an 8 followed by a 2 now an 8 and a 2 is not a partitioned sub array remember what it means to be a practitioner baray all the stuff left is it less than the pivot all the stuff less than 3 should come before everything bigger than 3 so a 2 obviously fails that property 2 is less than the pivot when it comes after the 8 which is bigger than the pivot so to correct this we're going to need to do a swap we're going to swap the 2 and the 8 that gives us the following version of the original array so now the stuff that we have not yet looked at is one smaller than before we've advanced J so all this stuff is unpartitioned who knows what's going on with that stuff jay is one further entry to the right than it was before and at least after we've done this swap we do indeed have a partitioned array so post swap the two and the eight are in the partition now remember I delineate the boundary between amongst what we've seen so far the stuff less than the pivot less than three in this case and that bigger than three so I is going to be wedged in between the 2 and the 8 in the next iteration our life is pretty easy so in this case in advancing J we uncover an element which is bigger than the pivot so this is what happened in the first iteration we uncovered the 8 it's different than what happened in the last iteration when we uncovered the 2 and so this case this third iteration is going to be more similar to the first iteration than the second iteration in particular we won't need a swap we won't need to advance I we just advance J and we're done so let's see why that's true so we've advanced J we've done one more iteration so now the stuff that we haven't seen yet is only the last 4 elements so who knows what's up with the stuff we haven't seen yet but if you look at these stuff we have seen the two the eighth and e5 this is in fact partitioned right all the numbers that are bigger than three succeed come after all the numbers bigger than smaller than three so the J the boundary between what we've seen in what we have in is between the 5 and the 1 and the I the boundary between the stuff less than the pivot and bigger than the pivot is between the 2 and the 8 just like it was before adding a 5 to the end didn't change anything so let's wrap up this example on the next slide so first let's just remember where we left off on the previous slide so I'm just going to redraw that same step after three iterations of the algorithm and now notice in the next iteration we're going to again have to make some modifications to the array if we want to preserve our invariant the reason is that when we advance J when we scan this one now again we're scanning in a new element which is less than the pivot and what that means is that the partitioned region or the region that we've looked at so far will not be partitioned will have two eight five one remember we need everything less than three to be to precede everything bigger than three and this one at the end is not going to cut it so we're going to have to make a swap now what are we going to swap we're going to swap the one and the eat so why do we swap the one in the eight well clearly we have to swap the one with something and what makes sense what makes sense is the left-most array entry which is currently bigger than the pivot and that's exactly the eat that's the first leftmost entry bigger than three so if we swap the one with it then the one will become the rightmost entry smaller than three so after the swap we're going to have the following array the stuff we haven't seen is the for the seven and the six so the J will be between the eight and the four the stuff we have seen is the two one five and eight and notice that this is indeed partitioned all the elements which are less than three the two and the one precede all of the entries which are bigger than three the 5 and the 8 I remember is supposed to split be the boundary between those less than three and those bigger than three so that's going to lie between the 1 and the 5 that is one further to the right than it was in the previous iteration okay so the because the rest of the unseen elements the four the 7 and the six are all bigger than the pivot the last three iterations are easy no further swaps are necessary no increments to I are necessary J is just going to get incremented until we fall off the array and then fast forwarding the partition subroutine or this main linear scan will terminate with the following situation so at this point all of the elements have been seen all the elements are partitioned J and effect has fallen off the end of the array and I the boundary between those less than and bigger than the pivot still lies between the 1 and the 5 now we're not quite done because the pivot element 3 is not in the correct place remember what we're aiming for is an array where everything less than the pivot is to the left of it and everything bigger than the pivot is to the right but right now the pivot still is hanging out in the first element so we just have to swap that into the correct place where is the correct place well it's going to be the rightmost element which is smaller than the pivot so in this case the 1 so the subroutine will terminate with the following array 1 2 3 5 8 4 7 6 and indeed as desired everything to the less left of the pivot is less than the pivot and everything to the right of the pivot is bigger than the pivot the 1 & 2 happened to be in sorted order but that was just sort of an accident and the 4 5 6 & 7 & 8 you'll notice are jumbled up they're not in sorted order so hopefully from this example you have a gist of how the partition subroutine is going to work in general but just to make sure the details are clear let me now describe it's the pseudocode for the partition subroutine so the way I'm going to denote it is there's going to be an input array a but rather than being told some explicit link what's going to be passed to the subroutine are two array indices the leftmost index which delineates this part of the sub array you're supposed to work on and the rightmost index the reason I'm writing it this way is because partition is going to be called recursively from within a quicksort algorithm so at any point in quicksort we're going to be recursing on some subset contiguous subset of the original input array L&R meant to denote what the left boundary in the right boundary of that sub array are so let's not lose sight of the high-level picture of the invariant that the algorithm is meant to maintain so as we discussed we're assuming the pivot element is the first element although that's really without loss of generality and in a given time there's going to be stuff we haven't seen yet who knows what's up with that and amongst the stuff we've seen that we're going to maintain the invariant that all the stuff less than the pivot comes before all the stuff bigger than the pivot and J and I denote the boundaries between the seen and the unseen and between the small elements and the large elements respectively so back to the pseudocode we initialize the pivot to be the first entry in the array and again remember L denotes the leftmost index that were responsible for looking at the initial value of I should be just to the right of the pivot so that's going to be L plus 1 that's also the initial value of J which we'll assign in the main for loop so this for lib with J taking on all values from L +1 to the rightmost index r denotes the linear scan through the input array and what we saw in the example is that there were two cases depending on for the newly seen element whether it's bigger than the pivot or less than the pivot the easy case is when it's bigger than the pivot then we essentially don't have to do anything remember we didn't do any swaps we didn't change I the boundary didn't change it was when that the new element was less than the pivot that we had to do some work so we're going to check that is the newly seen element AJ less than P and if it's not we actually don't have to do anything let me just put us a comment if the new element is bigger than the pivot we do nothing of course at the end of the four loop the value of J will get incremented so that's the only thing that changes from iteration iteration when we're sucking up new elements that happen to be bigger than P so what do we do in the example when we suck up a new element less than P well we have to do two things so in the event that the newly seen elements is less than P I'll circle that here in pink we need to do a rearrangement so we again have a partitioned sub array amongst those elements we've seen so far and the best way to do that is to swap this new elements with the leftmost element that's bigger than the pivot and because we have an index I which is keeping track of the boundary between the elements less than the pivot bigger than the pivot we can immediately access the leftmost element bigger than the pivot that's just the I Thor a index of the that's just the I entry in the array now I am doing something a little sneaky here I should be honest about which is there is the case where you haven't yet seen any elements bigger than the pivot and then you don't actually have a leftmost element bigger than the pivot to swap with turns out this code still works I'll let you verify that but it does do some redundant swaps really you don't need to do any swaps until you first see some elements bigger than the pivot and then see some elements less than the pivot so you can imagine a different implementation of this where you actually keep track of whether or not that's happened to avoid the redundant swaps I'm just going to give you the the simple pseudocode and again for intuition you want to think about the case just like in the picture here in blue where we've already seen some elements that are bigger than the pivot and the next newly seen element is less than the pivot that's really sort of the key case here now the other thing we have to do after one of these swaps is now the boundary between where the pivot elements start where the array elements less than the pivot and those bigger than the pivot has moved it's moved one to the right so we have to increment I so that's the main linear scan once this concludes J will have fallen off the end of the array and everything that we've seen the final elements except for the pivot will be arranged so that those less than P or first those bigger than P will be last the final thing we have to do is just swap the pivot in to its rightful position and recall for that we just swap it with the rightmost element less than so that is it that is the partition subroutine there's a number of variants of partition this is certainly not the unique implementation if you look on the web or if you look in certain text books you'll find some other implementations as well discussion of the various merits but I hope this gives you I mean this is a canonical implementation I hope it gives you a clearer picture of how you rearrange the array using in-place swaps to get the desired property that all this stuff before the pivot comes first all the stuff after the pivot comes last let me just add a few details about why this pseudocode I just gave you does indeed have the properties required the running time is o of n really theta of n but again I'll be sloppy and write Big O of N where n is the number of array elements that we have to look at so n is R minus L plus 1 which is the length of the sub array that this partition subroutine is invoked upon and why is this true well if you just go inspect the pseudo code you can just count it up naively in and you'll find that this is true we just do a linear scan through the array and all we do is basically a comparison and possibly a swap and an increment for each array that we array entry that we see also if you inspect the code it is evident that it works in place we do not allocate some second copy of an array to populate like we did in the naive partitioning subroutine all we do is repeated swaps correctness of the subroutine follows by induction so in particular the best way to argue it is via invariants so I'll state the invariant here but mostly leave it for you to check that indeed every iteration of the for loop maintains this invariant so first of all all of these stuff to the rights of the pivot element to the right of the leftmost entry and up to the index I is indeed less than the pivot element as suggested by the picture and also suggested by the picture everything beginning with the i-10 tree leading just up before the j-10 tree is bigger than the pivot and I'll leave it as a good exercise for you to check that this holds by induction the invariant holds initially when both I and J are equal to L plus one because both of these sets are vacuous okay so there are no such elements so they're trivially satisfied these properties and then every time we advance J well in one case it's very easy where the new element is bigger than the pivot it's clear that if the invariant held before it also holds it at the next iteration and then if you think about it carefully this swap in this increment of I that we do in the case where the new element is less than the pivot after the swap once the for loop completes again if this invariant was true at the beginning of it it's also true at the end so what good is that well if by this claim at the conclusion of the linear scan at which point jade has fallen off the end of the array the array must look like this at the end of the for loop the question mark part of the array has vanished so everything other than the pivot has been organized so that all of the stuff less than the pivot comes before everything after the pivot and that means once you do the final swap once you swap the pivot element from its first from the leftmost entry with the rightmost entry less than the pivot you're done okay you've got the desired property that everything to the left of the pivot is less than at everything to the right of the pivot is bigger than it so now that given a pivot element we understand how to very quickly rearrange the array so that it's partitioned around that pivot element let's move on to understanding how that pivot element should be chosen and how given suitable choices of that pivot element we can implement the quicksort algorithm to run very quickly in particular on average in n log n time