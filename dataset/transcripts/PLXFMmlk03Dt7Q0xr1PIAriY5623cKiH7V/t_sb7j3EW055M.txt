in this video I'll prove to you that Dijkstra's algorithm does indeed computes correct shortest paths in any directed graph or all edge links are non-negative let me remind you about what is Dijkstra's algorithm it's very much in the spirit of our graph search primitives in particular breadth-first search so there's going to be a subset X of vertices which are the ones that have been processed so far initially X contains only the source vertex of course the distance from the source vertex to itself is 0 and the shortest path from s to itself is the empty path so then we'll have a main while loop there's going to be n minus 1 iterations and each iteration will bring one vertex which is not currently an X into capital X an invariant that we're going to maintain is that all the vertices in X we will have computed estimates of the shortest path distance from s to that vertex and also we'll have computed the shortest path itself from s to that vertex remember our standing assumptions stated in the previous video we're always going to assume there's at least one path from the source vertex s to every other destination V our job is just to compute the shortest one and also we have to assume that the edge lengths are non-negative as we've seen otherwise dutchess algorithm might fail now the key idea inductors algorithm is a very careful choice of which vertex to bling from outside of X into capital X so what we do is we scan the edges crossing the frontier meaning given the current edges vertices that we've already processed we look at all of the edges whose tail has been processed and whose head has not been processed so the tail is in capital X the head is outside of X that is they cross the cut from left to right in the diagrams that we usually draw now there may be many such edges how do we decide amongst them well we compute the Dijkstra greedy score for each the Dijkstra greedy score is defined as the shortest path distance we computed for the tail and that's been previously computed because the tails and capital X and then we add to that the length contributed by this edge itself by the edge of VW which is crossing the cut from left to right so amongst all edges crossing the cut from left to right we compute all those greedy Dijkstra greedy score x' we pick the sum of the edge with a smallest greedy score calling that edge just V Star W star for the purposes of notation W star is the one that gets added to X so it's the head of the arc or the smallest greedy score and then we compute the shortest path distance of that new vertex W star to be the shortest path distance to V star plus the length contributed by this edge V Star W star and then what is the shortest path that's just the shortest path previously computed to V Star Plus this extra edge of V Star W star tacked on to the end is the formal statement we're going to prove for this video we're not going to worry at all about running time that'll be the discussion of the next video we'll discuss both the running time of the basic algorithm and a super-fast implementation that uses the heap data structure for now we're going to just focus on correctness so the claim is that for every directed graph not just the four node five work example we studied as long as there's no negative edge links Dijkstra's algorithm works perfectly it can be to all of the correct shortest path distances so just to remind you about the notation what does it mean to correct all shortest path distances correctly it means that what the algorithm actually computes which is a of V is exactly the correct shortest path distance which we were denoting by capital L of V in the previous video so both the algorithm and the perfect correctness were established by SK dice curve this is back in the late 1950s so Dijkstra was a Dutch computer scientist and certainly you know one of the forefathers of the field as a really as a science as an intellectual discipline he was awarded the ACM Turing award so that is the Nobel Prize in computer science effectively I believe it was 1972 and it worked for a long time in the Netherlands but then also spent a lot of his later career at UT Austin so the way this proof is going to go is going to be by induction and basically what we're going to do is we're going to say every iteration when we have to commit to shortest a shortest path distance to some new vertex we do it correctly and so then the form of the induction will be well given that we made all of our previous decisions correctly we computed all our earlier shortest paths in the correct way that remains true for the current iteration so formally it's induction on the number of iterations of Dijkstra's algorithm and as is more often than not the case of by induction the base case is completely trivial so that just says before we start the while loop what do we do will we commit to the shortest path distance from s to itself we set it to zero we said the shortest path to be the empty path that is of course true of course even here we're using the fact that there are no edges with negative edge lengths that makes it obvious that sort of having a non empty path can't get you negative edge lengths better than zero so the first shortest path computation we do from s to s is trivially correct the hard part of course is the inductive step just define all of the future decisions done by the algorithm and of course mindful of that example that non example we had at the end of the previous video in the proof by induction we'd better make use of the hypothesis that every Edge has non-negative lengths okay otherwise the theorem would be false so we'd better somewhere in the proof use the fact that edges cannot be negative so let's move on to the inductive step remembering the inductive step the first thing to do is state the inductive hypothesis you're assuming you haven't made any mistakes up to this point let's be a little bit more formal about that so that is everything we computed in the past okay what did we compute in the past well for each vertex which is in our set capital X for each vertex that we've already processed we want to claim that our computed shortest path distance matches up exactly with the true correct shortest path distance so in our running notation for every already processed vertex so for all vertices V in our set capital X what we computed as our estimate of the shortest path distance for V is in fact the real shortest path distance and also the computed shortest path is in fact a true shortest path from s to V so again remember this is a proof by induction we are assuming this is true and we're going to certainly make use of this assumption when we establish the correctness of the new iteration the current iteration so what happens in an iteration well we pick an edge which we've been calling V Star W star and we add the head of this edge W star to the set X so let's get our bearings and remember what Dijkstra's algorithm computes as the shortest path in shortest path distance for this new vertex W star so by the definition of the algorithm we assign as a shortest path the purported shortest path from s to W star the previously computed purportedly shortest path from s to V Star and then we tack on the ends the direct arc V Star W star so pictorially we already had some path that started at s and ended up at V star and then we tack on the end this arc going to W star and one hop and this whole shebang is what we're going to assign as be a W star so let's use the inductive hypothesis inventive hypothesis says that all previous iterations are correct so that is any shortest path we computed in previous iteration is in fact a bonafide shortest path from the source s to that vertex now V star remember is in X so that was previously computed so by the inductive hypothesis this path be V star from s to V Star is in fact a true shortest path from s to V star in the graph so therefore it has length L of E star remember L of e star is just by definition the true shortest path distance in the graph from s to V Star and now given that the path that we've exhibited from s to W star is just the same one as that we inherited the V Star Plus this extra edge attacked on it's pretty obvious what the length of the left-hand side is so it has lengths just the length of the old path which we just argued is the shortest path distance from s to V star plus the length of this arc that we tacked on so that's going to be L of V Star W star so by the definition of the algorithm what we compute for W star is just the Dijkstra greedy score which is just the computed shortest path distance to the tale V Star Plus the length of the direct edge by the inductive hypothesis we've correctly computed all previous shortest path distances V Star is something we computed in the past by the inductive hypothesis it's correct so this is equal to L of e star by the inductive hypothesis alright so don't worry if you're feeling a little lost at this point we've actually really done no content in this proof yet we haven't done the interesting part of the argument all we've been doing is setting up our dominoes getting them ready to be knocked down so what have we done in the current iteration well first of all our estimate of the shortest path distance from the source to W star to the new vertex that we're including in the set capital X is the true shortest path distance to V Star Plus the length of the edge from V Star W star that's the first thing secondly the path that we have in the B array is a bona fide path from s to W star with exactly this distance and the point is now it's clear what has to be proven for us to complete the inductive step and therefore the proof of correctness of Dijkstra's algorithm so what do we need to prove we need to prove that this isn't just any old path that we've exhibited from s to this vertex W star but it's the shortest path of them all but differently we need to show that every other s W star path in this graph has length at least this circled value so let's proceed let's show that no matter how you get from the source vertex s to this destination W star the total length of the path that you travel is going to be at least this circle value at least L of V star plus L of V Star W star now on the one hand we don't have a lot going for us because this path P could be almost anything it could be a crazy-looking path so how do we argue that it has to be long well here's the one thing we've got going for us for any path P that starts an S and goes to W star any such path must cross the frontier remember it starts on the left side of the frontier it starts at the source vertex which is initially and forever in the set capital X and remember that we only choose edges that cross the frontier whose head is outside of X and W star is exactly the head of the edge we chose in this iteration so this is not an X so any path that starts in X and goes outside of X at some crosses from one to the other so let's think about the graph and it's two pieces that to the left of the front earring that to the right the stuff is already processed in the stuff list which has not yet been processed s of course is on the left hand side and at the beginning of this iteration of the while loop w star was on the right hand side any path no matter how wacky has to at some point cross this frontier maybe it does it a bunch of times who knows but it's got to do at once let's focus on the first time that it crosses the frontier and let's say that it crosses the frontier with the vertex Y going to the vertex Z that is any path P has the form where there's an initial prefix where all the vertices are an X and then there's some first point at which it crosses the frontier and goes to a vertex which is not an X we're calling the first such vertex outside of X Z and then it can skip back and forth who knows but certainly it ends up in this vertex W star which is not an X so we're going to make use of just this minimal information about an arbitrary path P and yet this will give us enough of a foothold to lower bound its length and that this lower bound will be strong enough we can conclude that our path that we computed is the best smaller than any possible competitor hole so let's just summarize where we left on the previous slide we established that every directed path from s to W star P no matter what it is has to have a prescribed form we're in ambles for a while inside X and then the portal through which it escapes X for the first time we're calling Y and then the first vertex it sees outside of X is Z and there has to be one and then it perhaps ambles further and eventually reaches W star it could well be that Z and W star are exactly the same that's totally fine for this argument so here's one of our competitors this path P we have to show is at least as long as our path so we need a lower bound on the length of this arbitrary path from to W star so let's get that lower bound by arguing about each piece separately and then invoking Dijkstra's greedy criterion so remember we said we better use the hypothesis that edge links are non-negative otherwise we're toast otherwise we know the algorithm is not correct so here's where we use it this final part of the path from Z to W star if it's non-empty then it's got to have non-negative length right every edge as part of the sub path has non-negative edge lengths so the total length of this part of the path is non-negative so why does Z by construction is a direct arc remember this is the first arc that path P uses to go from X to get outside of X okay so it's how it escapes the conquer territory X and this just has some length L of Y Z so that leaves the first part of this path the prefix of the path that lies entirely in capital X so how do we get a lower bound on the length of this path well let's begin with something trivial this is some path from s to Y so certainly it's at least as long as a shortest path from s to Y and now we're going to use the inductive hypothesis again so this vertex Y this is something we treated in a previous iteration right this belongs to the set capital X we've already processed it we've already computed or estimate of its shortest path length and the inductive hypothesis assures us that we did it correctly so whatever value we have hanging out in our array capital A that is indeed the length of a true shortest path so the length of a shortest sy path is L of Y by definition and it's a y by the inductive hypothesis and now we're in business all right so what does this mean we can say about the total length of this arbitrary path P well we've broken it into three pieces and we have a lower bound on the length for each of the three pieces our lower bounds are our computed shortest path distance to Y the length of the direct edge from Y to Z and 0 so adding those up we get that the length of path P is at least our computed shortest path distance to Y plus the length of the arc from Y to Z so why is this useful well we've got one remaining trick up our sleeve there's a hypothesis which is presumably very important which they have not yet invoked and that is the choice of Dijkstra's greedy criterion at no point in the proof yet have we used the facts that we select which vertex to add next according to Dijkstra's greedy score so that is going to be the final nail in the coffin that's what's going to complete the proof how do we do that well we've taken an arbitrary path P we've lower bounded its length in terms of the computed shortest path distance up to the last vertex of this prefix y plus the arc length to get from X to outside of x cyz so remember this means y is on the left part of the frontier and Z is not and therefore in this iteration the edge Y Z was totally a candidate for us to use to enlarge our frontier remember we looked at all of the edges crossing from left to right y z is one such edge and amongst all of them we chose the one with the smallest Dijkstra greedy score that was the Dijkstra greedy criterion so what have we shown we've shown that the length of our path is no more than what's a lower bound on the length of this arbitrary other path P so this completes the proof so let me just remind you of all of the ingredients in case you got lost along the way so what we started out with is we realized our algorithm or Dijkstra's algorithm it does compute some path from s to W star right it just takes the path that computed previously to V Star and it just depends this final hop at the end so that gives us some path from s to W star moreover it was easy to figure out exactly what the length of that path is and the length of the path that came up with is exactly this circled quantity at the bottom of the slot it's the shortest path distance from s to V star plus the length of the direct arc from V Star W star so that was how well we did but we had to ask the question is it possible to do better right we're trying to argue that our algorithm does the best possible that no competing path could possibly be shorter than ours so how did we do that well we considered an arbitrary compact competing path P the only thing we know about it is that it starts at s and it ends up at W star and we observe that any path can be decomposed into three pieces a prefix a direct edge and a suffix then we give a lower bound on this path P thread the direct edge you know the length is just whatever it is the suffix we just use the trivial lower bound that's at least zero and that's where we use the hypothesis that every Edge has non-negative edge lengths and for the prefix because that's all in the stuff we already computed we can invoke the inductive hypothesis and say well whatever this path is it goes from s to some vertex and why it's at least the shortest path distance from s to Y which is something we computed in a previous iteration we've lower bounded the length of any other path in terms of the Dijkstra greedy score for that path since we choose the path with the best greedy score that's why we end up we wind up with the shortest path of them all from s to W star this of course is embedded in an outer proof by induction on the number of iterations but this is the inductive step which justifies a single iteration since we can justify every iteration given correctness of the previous ones that means by induction all of them are correct so all of the shortest paths are correct and that is why Dijkstra's algorithm correctly computes shortest paths and any directed graph with non-negative edge lengths