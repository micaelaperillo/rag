So what's the problem? Well, so I did say most of the stuff about graph search, it really doesn't matter undirected or directed. It's pretty much co cosmetic changes. But the big exception is when you're computing connectivity, when you're computing the pieces of a graph. So right now I'm only going to talk about undirected graphs. The directed case, we can again get a very efficient algorithms for it, but it's quite a bit harder work. So that's going to be covered in detail in a separate video. So for now, focus just on an undirected graph G. And we're certainly not going to assume that G is connected. Indeed, part of the point here is to figure out whether or not it's connected, i.e. in one piece. So maybe the graph looks like this. So for example, maybe the graph has 10 vertices and looks like this on the right. And intuitively, especially given that I've drawn it in such a clean way, it's clear that this graph has three pieces. And those are the things that we want to call the connected components. But we do want a somewhat more formal definition. Something which is actually you know in math that we could say is true or false about a given graph. And roughly we define the connected components of an undirected graph as the maximal regions that are connected in the sense you can get from any vertex in the region from any other vertex in the region using a path. So maximal connected regions in that sense. Now the slick way to do this is using an equivalence relation. And I'm going to do this here in part because it's really the right way to think about the directed graph case which we'll talk about in some detail later. So for under edged graphs, so this isn't super important, but let me go ahead and state the the formal definition just for completeness about what is a connected component. What do I mean by a maximal uh region that's that's uh mutually connected? So a good formal definition is as the equivalence classes of the relation on vertices where which we define by U being related to V if and only if there's a path between U and V in the graph G. So I'll leave it for you to do the simple check that this squiggle is indeed an equivalence relation. Let me remind you what equivalence relations are. This is something you generally learn in your first class on proofs or your first class in discrete math. Uh so it's just something which may or may not be true about pairs of objects and to be an equivalence relation you have to satisfy three properties. So first you have to be reflexive meaning everything has to be related to itself and indeed in a graph there is a path from any node to itself namely the empty path. So also equivalence relations have to be symmetric meaning if u and v are related then v and u are related. Because this is an undirected graph it's clear that this is symmetric. If there's a path from u to v in the graph there's also a path from v to u. So no problem there. Finally, equivalence classes got to be transitive. So that means if U and V are related and so are V and W, then so are U and W. That is if U and V have a path, V and W have a path, then so does U and W. And you can prove transitivity just by pasting the two paths together. And so the upshot is when you want to say something like the maximal subset of something where everything is the same, the right way to make that mathematical is using equivalence relations. So over in this blue graph, we want to say 1, three, five, seven, and nine are sort of all the same in the sense that they're mutually connected. And so that's exactly what this relation is making precise. All five of those nodes are related to each other. Two and four are related to each other. 6, 8, and 10, all pairs of them are related to each other. So the equivalence, so equivalence relations always have equivalence classes. The maximal mutually related stuff. And in this graph context, that's exactly these connected components. It's exactly what you want. So what I want to show you is that you can use a breath first search wrapped in an outer for loop over all of the vertices to compute to identify all of the kinetic components of a graph in time linear in the graph and over n plus m time. Now you might be wondering you know why do you want to do that? Well there's a lot of reasons. So an obvious one which is relevant for physical networks is to check if a network has uh broken into two pieces. So certainly if you're an internet service provider you want to make sure that uh from any point in your network you can reach any other point in the network and that boils down to just understanding whether the graph that represents your network is a connected graph that is if it's in one piece or if it's not in one piece. So obviously you can ask this same question about recreational examples. So, if you return to the movie graph, maybe you're wondering, can you get from every single actor in the IMDb database to Kevin Bacon? Or are there actors for which you cannot reach Kevin Bacon via a sequence of edges, a sequence of movies, uh, in which two actors have both played a role. So, that's something that boils down to a connectivity computation. If you have network data and you want to display it, you want to visualize it and show it to a group of people so that they can interpret it. Obviously, one thing you want to do is you want to know if there's multiple pieces and then you want to display the different pieces separately. So, let me mention one probably a little less obvious application of undirected connectivity which is it gives a nice quick and dirty uh heristic for doing clustering if you have pair wise information about objects. So, let me let me be a little more concrete. Suppose you have a set of objects that you really care about. So, this could be a set of documents maybe web pages that you've crawled something like that. It could be a set of images either your own or drawn from some database. Or it could be for example a set of genomes. Suppose further that you have a pair-wise function, okay, which for each pair of objects tells you whether they're very much like each other or very much different. And so let's suppose that if two objects are very similar to each other, like they're two web pages that are almost the same or they're two genomes where you can get from one to the other with a small number of mutations, then they have a low score. Okay? So low numbers close to zero indicate that the objects are very similar to each other. High numbers, let's say, you know, they could go up to even a thousand or something, indicate that they're very different objects. Two web pages that have nothing to do with each other, two genomes for totally unrelated parts or two images that seem to be of, you know, completely different people or even completely different objects. Now here's a graph you can construct using these objects and this similarity data that you have about them. So you can have a graph where the nodes are the objects. Okay? So for each pix for each image, for each document, whatever you have a single node and then for a given pair of nodes, you put in an edge if and only if the two objects are very similar. So for example, you could put in an edge between two objects if and only if the score is at most 10. So remember the more similar two objects are the closer their scores to zero. So you're going to get an edge between very similar documents, very similar genomes, very similar images. Now in this graph you've constructed you can find the connected components. So each of these connected components will be a group of objects which more or less are all very similar to each other. So this will be a cluster of closely related objects in your database. And you can imagine a a lot of reasons why given a large set of unstructured data, just a bunch of pictures, a bunch of documents or whatever, you might want to find clusters of highly related uh objects. So we'll probably see more sophisticated heristics for clustering in some SQL course, but already undirected connectivity gives you a super fast linear time uh quick and dirty heristic for identifying clusters of similar objects given pair-wise data about similarity. So that's some reasons you might want to do it. Now let's uh actually talk about how to compute the connected components in linear time using just a simple for loop and breath per search as its uh inner workhorse. So here's the code to compute all the connected components of an undirected graph. So first we initialize all nodes as being unexplored. I'm also going to assume that the nodes have names. Let's say their names are from one to n. So these names could just be the position in the node array that these nodes occupy. So there's going to be an outer for loop which walks through the nodes in an arbitrary order. Let's say from 1 to n. This outer for loop is to ensure that every single node of the graph will be inspected for sure at some point in the algorithm. Now again one of our maxims is we should never do redundant work. So before we start exploring from some node, we check if we've already been there. And if we haven't seen I before then we invoke the breath first search sub routine we were talking about previously in the lecture in the graph G starting from the node I. So to make sure this is clear let's just run this algorithm on this blue graph to the right. So we start in the outer for loop and we set i equal to one and we say have we explored node number one yet? And of course not we haven't explored anything yet. So the first thing we're going to do is we're going to we're going to invoke BFS on node number one here. So now we start running the usual breath first search sub routine starting from this node one. And so we explore you know layer one here is going to be nodes three and five. So we explore them in some order. For example, maybe node number three is what we explore second. Then node number five is what we explore third. And then the second layer in this component is going to be the nodes seven and nine. So we'll explore them in some order as well. Let's say seven first followed by 9. So after this BFS initiated from node number one completes, of course it will have found everything that it could possibly find, namely the five nodes in the same connected component as node number one. And of course all of five of these nodes will be marked as explored. So now we return once that exits we return to the outer for loop. We increment I we go to I equal 2 and we say oh have we already explored node number two? No we have not. And so now we invoke BFS again from node number two. So that'll be the sixth node we explore. There's not much to do from two. All we can do is go to node number four. So that's the seventh node we explore. That BFS terminates uh finding the nodes in this connected component. Then we go back to the outer for loop. We increment I to three. We say, "Oh, have we already seen node number three?" Yes, we have. We saw that in the first breath first search. So we certainly don't bother to BFS from node three. Then we increment I to four. Have we seen four? Yes, we have in the second call to BFS. Have we seen node five? Yes, we have. In the first call to BFS, have we seen node six? No, we have not. So, the final imation of breath first search begins from node number six. That's going to be the eighth node overall that we see. And then we're going to see the nodes 8 and 10 in some order. So, for example, maybe we first explore node number eight. That's a that's one of the first layer in this component. And then node number 10 is the other node of the first layer in this component. So, in general, what's going on? Well, what we know about what we know what will happen when we invoke breath first search from a given node I, we're going to discover exactly the nodes in I's connected component, right? Anything uh where there's a path from I to that node will find it. That's the BFS guarantee. That's also the definition of a connected component. All the other nodes which have a path uh to to I. Another thing that I hope was clear from the example but you know just to just to reiterate it is every bet birth for search call when you explore a node you remember that through the entire for loop right so when we invoke breath for search from node number one we explore nodes 1 3 5 7 and 9 and we keep those marked as explored for the rest of this for the rest of this algorithm right so and that's so that we don't do redundant work when we get to later stages of the for loop so as far as what does this algorithm accomplish well it certainly finds every connected compon component, right? There is absolutely no way it can miss a node because this for loop literally walks through the nodes, all of them, one at a time. Okay? So, you're not going to miss a node. Moreover, we know that, you know, as soon as you hit a connected component for the first time, uh, and you do breath first search from that node, you're going to find the whole thing. That's the breath first search guarantee. As far as what's the running time, well, it's going to be exactly what we want. It's going to be linear time which again means proportional to the number of edges plus the number of vertices. And again depending on the graph one of these might be bigger than the other. So why is it O of M plus N? Well as far as the nodes we have to do this initialization there where we mark them all as unexplored. So that takes constant time per node. Uh we have just the basic overhead of a for loop. So that's constant time uh per node. And then we have this check constant time per node. So that's O of N. And then recall we proved that within breath first search you do a amount of work proportional you do constant time for each node in that connected component. Now each of the nodes of the graph is in exactly one of the connected components. So you'll do constant time for each node in the BFS in which you discover that node. So that's again O of N over all of the connected components. And as far as the edges note we don't even bother to look at edges until we're inside one of these breath first search calls. They play no role in the outer for loop or in the pre-processing. And remember what we proved about an invocation of breath first search the running time you only do constant amount of work per edge in the connected component that you're exploring. In the worst case you look at an edge once from either endpoint and each of that triggers a constant amount of work. So when you discover a given connected component the edge work is proportional to the number of edges in that connected component. Each edge of the graph is only is in exactly one of the connected components. So over this entire for loop over all of these BFS calls for each edge of the graph you'll only be responsible for a constant amount of work of the algorithm. So summarizing because breath first search from a given starting node does works in time proportional to the size of that component. Piggybacking on that sub routine and looping over all of the nodes of the graph, we find all of the connected components in time proportional to the number of edges and nodes in the entire graph.