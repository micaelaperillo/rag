in this sequence of videos we'll discuss our last but not least data structure namely the balanced binary search tree like our discussion of other data structures we'll begin with the what that is we'll take the client's perspective and we'll ask what operations are exported by this data structure what can you actually use it for then we'll move on to the how and the why we'll peer under the hood of the data structure and look at how it's actually implemented and in understanding the imple implementation we'll understand why the operations have the running times that they do so what is a balanced binary search tree good for well I recommend thinking about it as a dynamic version of a sorted array that is if you have data stored in a balanced binary search tree you can do pretty much anything on the data that you could if it was just a static sorted array but in addition the data structure can accommodate insertions and deletions you can accommodate a dynamic set of data that you're storing over time so to motivate the operations that a balanced binary search Tre supports let's just start with a sorted array and look at some of the things you can easily do with data that happens to be stored in such a way so let's think about an array that has numerical data although generally as we've said in data structures there's usually associated other data that's what you actually care about and the numbers are just some unique identifier for each of the records so these might be an employee ID number Social Security numbers uh packet ID numbers in a network context uh Etc so what are some things that are easy to do given that your data is stored as a sorted array well there's a bunch of things first of all you can search and recall that searching in assorted array is generally done using binary search so this is how we used to look up phone numbers when we had physical phone books you'd start at the middle of the phone book if the name you were looking for was less than the midpoint you'd recurse on the left-and side otherwise you'd recurse on the right hand side as we discussed back in the master method lectures long ago this is going to run in logarithmic time roughly speaking every time you recurse you've thrown out half of the array so you're guaranteed to terminate within a logarithmic number of iterations so binary search gives us logarithmic search time something else we discussed in previous lectures is the selection problem so previously we discussed this in the much harder context of unsorted arrays remember in the selection problem in addition to an array you're given an order statistic so if your order statistic that your target is 17 that means you're looking for the 17th smallest number that's stored in the array so in previous lectures we worked very hard to give a linear time algorithm for this problem in unsorted arrays now in a sorted array if you want to know the 17th smallest element in the array pretty easy problem just return whatever element happens to be in the 17th position of the array since the array sorted that's where it is so no problem if it's already sorted constant time you can solve the selection problem of course two special cases of the selection problem are finding the minimum element of the array that's just uh the order statistic problem with I equal 1 and the maximum element that's just when I equals n so this just corresponds to returning the element that's in the first position in the last position of the array respectively well let's do some more brainstorming what other operations could we Implement on a sorted array well here's a couple more so there are operations called the predecessor and successor operations and so the way these work is you start with one element so say you start with a pointer to the 23 and you want to know where in this array is the next smallest element that's the predecessor query and the successor operation Returns the next largest element in the array so the predecessor of the 23 is the 17 the successor of the 23 would be the 30 and again in assorted array these are trivial right you just know the predecessor is just one position back in the array the successor is one position forward so given a pointer to the 23 you can return the 17 or the 30 in constant time what else well how about the rank operation so we haven't discussed this operation in the past so what rank is this asks for how many keys stored in the data structure are less than or equal to a given key so for example the rank of 23 would be equal to six because six of the eight elements in the array are less than or equal to 23 and if you think about it implementing the rank operation is really no harder than implementing search all you do is search for the given key and wherever the search terminates in the array you just look at the position of the array and and boom that's the rank of that element so for example if you do a binary search for 23 and then when it terminates you discover it is there in position number six then you know the rank is six if you do an unsuccessful search say you search for 21 well then you get stuck in between the 17 and the 23 and at that point you can conclude that the rank of 21 in this array is five let me just wrap up the list with a final operation which is Trivial to implement in ass sorted array namely you can output or print say the stored keys in sorted order let's say from smallest to largest and naturally all you do here is a single scan from left to right through the array outputting whatever element you see next the time required is constant per element or linear overall so that's a quite impressive list of supported operations could we really be so greedy as to want still more from our data structure well yeah certainly we definitely want more than just what we have on this Slide the reason being these are operations that operate on a static data set which is not changing over time but the world in general is dynamic for example if you're running a company and keeping track of the employees sometimes you get new employees sometimes employees leave that is we want a data structure that not only supports these kinds of operations but also insertions and deletions now of course it's not that it's impossible to implement insort or delete in a sorted array it's just that they're going to run way way too slow in general you have to copy over a linear amount of stuff on an insertion or deletion if you want to maintain the sorted array property so this linear Time Performance for insertion and deletion is unacceptable unless you barely ever do those operations so the raison Detra of a balanced binary search tree is to implement this exact same set of operations just as rich as that supported by ass sorted array but in addition insertions and deletions now a few of these operations won't be quite as fast we're going to have to give up a little bit instead of constant time they running logarithmic time but we'll still get logarithmic time for all of these operations linear time for outputting the elements in sorted order plus we'll be able to insert and delete in logarithmic time so let me just spell that out in a little more detail so a balanced binary search tree will act like a sorted array plus it will have fast meaning logarithmic time in inserts and deletes so let's go ahead and spell out all of those operations so search is going to run in log in time just like before select runs in constant time in a sorted array and here it's going to take logarithmic so we'll give up a little bit on the selection problem but we'll still be able to do it quite quickly even on the special cases of finding the minimum or finding the maximum uh in our in our data structure we're going to need logarithmic time in general same thing for finding predecessors and successors there not they're no longer constant time they go up to logarithmic rank took us logarithmic time in the even in the sorted array version and that will remain logarithmic here as we'll see we lose essentially nothing over the sorted array if we want to Output the key values in sorted order say from smallest to largest and crucially we have two more fast operations compared to the sorted array data structure we can insert stuff so if you hire a new employee you insert them into your data structure if an employee decides to leave you can remove them from the data structure you do not have to spend linear time like you do for sorted array you only have to spend logarithmic time where as always n is the number of keys being stored in the data structure so the key takeaway here is that if you have data and it has keys which come from a totally ordered set like say numeric Keys then a balanced binary search tree supports a very rich collection of operations so if you anticipate doing a lot of different processing using the ordering information of all of these Keys then you really might want to consider a balanced binary search tree to maintain them one thing to keep in mind though is we have seen a couple other data structures which don't do quite as much as balance binary search trees but what they do they do better we already we just discussed in the last Slide the sorted array so if you have a static data set you don't need inserts and deletes well then by all means don't bother with balanced binary search trees just use a sorted array because it'll do everything super fast but we also saw two Dynamic data structures which don't do as much but do it but what they do they do very well so we saw a heap so what a heap is good for is it's just as dynamic as a search tree it allows insertions and deletions both in logarithmic time and in addition it keeps track of the minimum element or the maximum element remember in a heap you can choose whether you want to keep track of the minimum or keep track of the maximum but unlike in a search tree a heap does not simultaneously keep track of the minimum and the maximum so if you just need those three operations insertions deletions and remembering the smallest and this would be the case for example in a priority cue or a scheduling application as discussed in the Heap videos then a binary search tree is overkill you might want to consider a heap instead in fact the benefits of a heap don't show up in the bigo notation here both have logarithmic operation time but the constant factors both in space and time are going to be faster with a heap than with a balanced binary search tree the other Dynamic data structure that we discussed is a hash table and what hash tables are really really good at is handling insertions and searches that is lookups some sometimes depending on the implementation they'll also handle deletions really well also so if you don't actually need to remember things like Minima Maxima or remember ordering information on the keys you just have to remember what's there and what's not then the data structure of choice is definitely the hash table not the the balanced binary search tree again a balanced binary search tree would do fine it would give you logarithmic lookup time but it's kind of overkill for the problem if all you need are fast lookups a hashtable recall will give you constant time lookups so that'll be a noticeable win over the balanced binary search tree but if you want a very rich set of operations for processing your data then the balanced binary search tree could be the optimal data structure for your needs