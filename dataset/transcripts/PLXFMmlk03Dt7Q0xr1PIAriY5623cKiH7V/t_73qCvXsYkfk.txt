so in this lecture we're going to drill down into our first specific search strategy for graphs and also explore some applications namely breath first search so let me remind you the intuition and applications of breath first search the plan is to systematically explore the nodes of this graph beginning with the given starting vertex in layers so let's think about the following example graph where s is the starting point for our breath first search so the star vertex s will constitute uh the first layer so we'll call that l0 and then the neighbors of s are going to be the first layer and so those are the vertices that we explore uh just after s so those are L1 now the second layer is going to be the vertices that are neighboring vertices of L1 but are not themselves in L1 or for that matter l0 so that's going to be C and D that's going to be the second layer now you'll notice for example s is itself a neighbor of these nodes in layer one but we've already counted that in the previous layer so we don't count s toward L2 and then finally the neighbors of L2 which are not already put in some uh layer is e so that'll be layer three again notice C and D are neighbors of each other but they've already been classified in Layer Two so that's where they belong not in layer three so that's the highle picture breath first search you should have we'll talk about how to actually precisely implement it on the next slide again just a couple of the things that uh you can do with breath first search which we'll explore in this video is uh Computing shortest paths so it turns out shortest path distances correspond precisely to these layers so for example if you had as s you had that as the Kevin Bacon node in the movie graph then John Ham would pop up in the second layer uh from the breath for search from Kevin Bacon I'm also going to show you how to compute the connectic components of an under the graph that is compute its pieces we'll do that in linear time and for this entire sequence of videos on graph Primitives we will be satisfied with nothing less than the Holy Grail of linear time and again remember in a graph you have two different size parameters the number of edges M and the number of noes n for these videos I'm not going to assume any relationship between M and N either one could be bigger so linear time is going to mean o of M plus n so let's talk about how you'd actually Implement breath first search in linear time so the sub routine is given as input both a graph G I'm going to explain this as if it's undirected but this entire procedure will work in exactly the same way for a directed graph again obviously in an undirected graph you can Traverse an edge in either direction for a directed graph you have to be careful only to Traverse arcs in the intended direction from the tail to the head that is Traverse them forward so as we discussed when we talked about just generic strategies for Graph Search we don't want to explore anything twice that would certainly be inefficient so we're going to keep a Boolean at each node marking whether we've already explored it or not and by default I'm just we're just going to assume that nodes are unexplored they're only explored if we explicitly mark them as such so we're going to initialize the search with the starting vertex s so we Mark S as explored and then we're going to put that in what I was previously calling conquered territory the nodes we've already started to explore so to get linear time we're going to have to manage those in a you know slightly non-naive but but pretty straightforward way namely via a q which is a first in first out data structure that I assume you've seen if you've never seen a q before please look it up in a programming textbook or on the web but basically a q is just something where you can add stuff uh to the back in constant time and you can take stuff from the front in constant time you can Implement these for example using a dou link list now recall that in the general systematic approach to Graph Search the trick was to in each iteration of some while loop to add one new vertex to the conquered territory to identify one unexplored node that is now going to be explored so that while loop is going to translate into one in which we just check if the Q is non empty so we're assuming that the Q data structure supports that query in constant time which is easy to implement and if the Q is not empty we remove a node from it and because it's a q the removing nodes from the front is what you can do in constant time so call the node that you get out of the Q V so now we're going to look at V's neighbors vertices with which a chair edges and we're going to see if any of them have not already been explored so if W is something we haven't seen before if it's unexplored that means it's in the unconquered territory which is great so we have a new victim uh we can Mark W as explored we can put in our queue and we've Advanced the frontier and now we have one more explored node than we did previously and again a que by construction it supports adding constant time additions at the end of the Q so that's where we put W so let's see how this code actually executes in the same graph that we were looking at uh in the previous slide and what I'm going to do is I'm going to number the nodes in the order in which they are explored so obviously the first node to get explored is s that's where the Q starts so now when we follow the code what happens well in the first iteration of the while loop we ask is the Q empty no it's not because s is in it so we remove in this case the only node of Q It's s and then we iterate over the edges incident to S now there are two of them there's the edge between s and a and there's the edge between S and B and again this is still a little underspecified in the sense that the algorithm doesn't tell us which of those two edges we should look at turns out it doesn't matter either of those is a valid execution of breath first search but for concreteness let's suppose that of the two possib edges we look at the edge s comma a so then we ask has a already been explored no it hasn't this is the first time we've seen it so we say oh goody this is sort of a new Gris for the mill so we can add a to the to the Q at the end end and we Mark W as sorry Mark a as explored so a is going to be the second vertex that we Mark so after marking a is explored and adding it to the Q so now we go back to the for Loop and so now we move on to the second Edge incident to S that's the edge between S and B so we ask have we already explored B nope this is the first time we've seen it so now we do the same thing with B so b gets marked as explored it gets added to the Q at the end so the Q at this juncture has first a record for a cuz that was the first one we put in it after we took s out and then B follows a in the Q and again depending on the execution this could go either way but for concreteness I've done it so that a got added before B so at this point this is what the Q looks like so now we go back up to the while loop we say is the Q empty certainly not it actually has two elements now we remove the first node from Q in this case that's the node a that was the one we put in before the node B and so now we say well let's look at all of the edges incident a and in this case a has two incident edges it has one that it shares with s and it has one that it shares with c and so if we look at the edge between A and S then we'd be asking in the if statement has s already been explored yes it has that's where we started so there's no reason to do anything with s that's already been taken out of the Q so in this for Loop for a there's two iterations one involves the edge with s and that one we completely ignore but then there's the other Edge that a shares with C and C we haven't seen yet so at that part of the the for Loop we say aha C is a new thing new node we can Mark as explored and put in the CU so that's going to be our number four and so now how is the Q changed well we got rid of a and so now B is in the front and we added C at the end and so now the same thing happens we go back to the while loop the Q is not empty we take off the first vertex in this case that's going to be B B has three incident edges it has one incident to S but that's irrelevant we've already seen s it has one incident to C that's also irrelevant that's also irrelevant because we've already seen C true we just just saw it very recently but we've already seen it but the edge between B and D is new and so that means we can take the note D mark it as explored and add it to the Q so D is going to be the fifth one that we see and now the Q has the element C followed by D so now we go back to the while loop and we take C off of the Q it again has four now edges the one with a is a irrelevant we've already seen a the one with B is irrelevant we've already seen b the one with d is irrelevant we've already seen D but we haven't seen e yet so when we get to the part of the for Loop of the edge between c and e we say aha e is new so e will be the sixth and final vertex to be marked as explored and that will get added at the end of the Q so then in the final two iterations of the Y Loop the D is going to be removed we'll iterate through its three edges none of those will be relevant because we've seen all of the other three end points and then we'll go back to the while loop and we'll get rid of e e's IR relevant cuz it has two edges we've already seen the other end points and now we go back to the wild Loop the Q is empty and we stop and that is breath first search and to see how this simulates the notion of the layers that we were discussing in the previous slide notice that the nodes are numbered according to the layer that they're in so s was layer zero and then the two nodes that s caused to get added to the Q the A and the B are numbered two and three and the edges of layer three are precisely the ones sorry the edges of layer two are precisely the ones that got added to the Q while we were processing the nodes from layer one that is C and D are precisely the nodes that got added to the Q while we were processing A and B so this is level zero level one and level two e is the only node that got added to the Q while we were processing level Layer Two the vertices C and D so e will be the third layer so in that sense by using a first in first. data structure this Q uh we do wind up processing the nodes according to the layers that we discussed earlier so the claim is that breath first search is a good way to explore a graph in the sense that it meets the two high level goals that we delineated in the previous video uh first of all it finds everything findable and obviously nothing else and second all it does it without redundancy it does it without exploring anything twice which is the key to its linear time implementation so a little bit more formally claim number one at the end of the algorithm the vertices that we've explored are precisely the ones such that there is a path from s to that vertex again this claim is equally valid whether you're running BFS in an undirected graph or directed graph of course in an undirected graph we mean an undirected path from s Tov whereas in a directed graph we mean a directed path from SV that means a path where every Arc in the path gets traversed in the forward Direction so why is this true well this is true we basically prove this more generally for any Graph Search strategy of a certain form of which breath first search is one if it's hard for you to see the right way to interpret breath first search as a special case of our generic search algorithm you can also just look at our proof for the generic search algorithm and copy it down for breath first search so it's clear that you're only going to again the forward direction of this claim is clear if you actually find something if something's marked as explored it's only because you found a sequence of edges that led you there so the only way you mark something that is explored is if there's a path from s Tov conversely to prove that anything with an S Tov with a path from V will be found you can proceed by contradiction you can look at the part of the path from s Tov that that BFS does successfully explore and then you could ask Why didn't it go one more hop it never would have terminated before reaching all the way to V so you can also just copy that same proof uh that we had for the generic search strategy in the previous video okay so again the upshot breath first search it finds everything you'd want to find okay so it only traverses paths so you're not going to find anything where there isn't a path to it but it never misses out okay anything where there's a path BFS guaranteed to find it no problem claim number two is that the running time is exactly what we want and I'm going to State it in a form that will be useful later when we talk about connected components so the running time of the main while loop ignoring any kind of uh pre-processing or initialization is proportional to what I'm going to call NS and Ms which is the number of nodes that can be reached from s and the number of edges that can be reached from s and the reason for this claim this just becomes clear if you inspect the code which we'll do in a second so let's return to the code and just tally up all the work that gets done so I'm going to ignore this initialization I'm just going to focus on the main while loop so we can summarize the total work done in this while loop as follows first we just think about the vertices so in this search we're only going to deal ever deal with the vertices that are findable from s so that's NS and what do we do for with a given node well we insert it into the Q and we delete it from the Q right so we're never going to deal with a single node more than once so that's constant time overhead per vertex that we ever see so that's the proportional to the NS part now a given Edge we might look at it twice so for an edge VW we might consider it once when we first look at the vertex V and we might might consider it again when we look at the vertex W each time we look at an edge we do constant work so that means we're only to do constant work uh per Edge okay so we look at each vertex at most once we look at each Edge findable from s at most twice we do constant time constant work when we look at something so the overall running time is going to be proportional to the number of vertices findable from S Plus the number of edges findable from s so that's really cool we have a linear time implementation of a really nice Graph Search strategy moreover we just need very basic data structures a q to make it run fast with small constants but it gets even better we can use breath first search as a Workhorse for some interesting applications so that's what we'll talk about in the rest of this video