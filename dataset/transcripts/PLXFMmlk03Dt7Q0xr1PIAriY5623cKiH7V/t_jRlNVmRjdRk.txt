we've arrived at another one of computer science's Greatest Hits namely Dyer's shortest path algorithm so let me tell you about the problem it's a problem called single Source shortest paths basically what we want to do is compute something like driving directions so we're given as input a graph in this lecture I'm going to work with directed graphs although the same algorithm would work for undirected graphs with cosmetic changes as usual we'll use M to denote the number of edges and N to denote the number of vertices the input also includes two extra ingredients first of all for each Edge e were given as input a non- negative length which I'll denote by elsabe in the context of a driving directions application LCB could denote the the mileage how long uh this particular road is or it could also denote the expected travel time along the edge the second ingredient is a vertex from which we are looking for paths this is exactly the same as we had in breath first search and depth first search we have an originating vertex which we'll call here the Source our responsibility then is to given this input compute for every other vertex V in this network the length of a shortest path from The Source vertex s to that destination vertex V and so just to be clear what is the length of a path that has say three edges in it well it's just the sum of the length of the first Edge in the path plus the length of the second Edge in the path plus the length of the third Edge in the path so if you had a path like this with three edges and lengths 1 2 and three then the length of the path would just be six and then we Define the shortest SV path in the natural way so amongst all of the paths directed from s Tov each one has its own respective path length and then the minimum overall SV paths is the shortest path distance uh in the graph G so I'm going to make two assumptions for these lectures uh one is really just for convenience uh the other is really important the other assumption without which DX's algorithm is not correct as we'll C so for convenience we'll assume that there is a directed path from s to every other vertex V in the graph otherwise the shortest path distance is something we Define to be plus infinity and the reason this is not a big assumption is if you think about it you could detect which vertices are not reachable from s just in a pre-processing step using say breath first or depth first search and then you could delete the irrelevant part of the graph and run D's algorithm as will describe it on what remains alternatively DX's algorithm will quite naturally figure out which vertices there are paths to from s and which ones there are not so this won't really come up so to keep it simple just think about we have an input graph where you can get from s Tov for every different vertex V and the challenge then is amongst all the ways to get from s Tov what is the shortest way to do it so the second assumption already appears in the problem statement but I want to reiterate it just so it's really clear when we analyze dux's algorithm we always focus on graphs where every length is non- negative ative no Negative Edge lengths are allowed and we'll see why a little bit later in the in the video now in the context of a driving directions application it's natural to ask the question why would you ever care about Negative Edge links until we invent a time machine it doesn't seem like Negative Edge links are going to be relevant when you're Computing literal paths through literal networks but again remember that paths can be thought of as more abstractly as a just sequence of decisions and some of the most powerful applications of shortest paths are coming up with optimal we such sequences so for example maybe you're engaging in financial transactions and you have the option of both buying and selling assets at different times if you sell then you get some kind of profit and that would correspond to a negative EDG length so there are quite interesting applications in which Negative Edge links are relevant if you are dealing with such an application Dyer's algorithm is not the algorithm to use there's a different shortest path algorithm a couple other ones but the most well-known one is called Bellman Ford that's something based on Dynamic program which we may well cover in a SQL course okay so for Dyer's algorithm we always focus on graphs that have only non- Negative Edge lengths so with the next Quiz I just want to make sure that you understand the single Source shortest path problem here let me draw for you here a simple Ford node Network and ask you for what are the four shortest path lengths so from The Source vertex s to each of the four vertices in the network all right so the answer to this quiz is the final option 0136 uh to see why that's true well uh all of the options had zero as the shortest path distance from s to itself so that just uh seemed kind of obvious so the empty path will get you from s to itself uh and have zero length now suppose you wanted to get from s to V well there's actually only one way to do that you have to go along this one hot path so the only path has length one so the shortest path distance from s to V is 1 now now W is more interesting there's a direct one hop path s w that has length four but that is not the shortest path from s to W in fact the two hop path that goes through v as an intermediary has total path length three Which is less than the length of the direct Arc from s to W so therefore the shortest path distance from s to W is going to be three and finally for the vertex T there's three different paths going from s to T there's the t two hop path goes through V there's the two hop path which goes through W both of those have path length seven and then there's the three hop path which goes through both V and W and that actually has a path length of 1 plus 2 plus 3 equal to 6 so despite having the largest number of edges the zigzag path is in fact the shortest path from s to T and it has length six all right so before I tell you how D's algorithm works I feel like I should justify the existence of this video a little bit right because this is not the first time we've seen shortest paths you might be thinking rightfully so we already know how to compute shortest pass that was one of the applications of breath first search so the answer to this question is both yes and no breath first search does indeed compute shortest paths we had an entire video about that but it works only in the special case where the length of every edge of the graph is one at the moment we're trying to solve a more General problem we're trying to solve shortest paths when edges can have arbitrary non- Negative Edge length so for example in the graph that we explored in the previous quiz if we ran breath first search starting from the vertex s it would say that the shortest path distance from s to T is two and that's because there's a path with two hops going from s to T put differently T is in the second layer emanating from s but as we saw in the quiz there is not in fact a shortest to hot path from s to T if you care about the edge lengths rather the the minimum length path is shortest path with respect to the edge weights is this three hop path which has a total length of six so breath first search is not going to give us what we want when the edge lengths are not all the same and if you think about an application like driving directions then needless to say it's not the case that every Edge in the network is the same some roads are much longer than others some roads will have much larger travel times than others so we really do need to solve this more General shortest path problem similarly if you're thinking more abstractly about a sequence of decisions like Financial transactions uh in general different transactions will have different values so you really want to solve General shortest paths you're not in the special case that breath first search solves now if you're feeling particularly sharp today you might have the following objection to what I just said you might say h big deal General Edge weights unit Edge weights it's basically the same say you have an edge that has link three how is that fundamentally different than having a path with three edges Each of which has length one so why not just replace all the edges with a path of edges of the appropriate length now we have a network in which every Edge has unit length and now it can just run breath first search so put succinctly isn't it the case that Computing shortest paths with General Edge weights reduces to Computing shortest paths with unit Edge weights well the first comment I want to make is I think this would be an excellent objection to raise and indeed as programmers as computer scientists this is the way you should be thinking if you see a problem that seems superficially harder than another one you always want to ask well maybe just with a with a clever trick I can reduce it to a problem I already know how to solve that's a great attitude in general for problem solving and indeed you know if all of the edge lengths were just small numbers like 1 2 and three and so on this trick would work fine the issue is when you have a network where the different edges can have very different lengths and that's certainly the case in many applications uh definitely Road networks would be one where you have both sort of long highways and you have have neighborhood streets and potentially in financial transaction based networks you would also have a wide variance between the value of different transactions and the problem then is some of these Edge links might be really big they might be a 100 they might be a thousand it's very hard to put AR prior bounds on how large these Edge weights could be so if you start wanly replacing single edges with these really long Paths of like the Thousand you've blown up the size of your graph way too much so you do have a faithful representation of your old network but it's too wasteful so even though breath for search runs in linear time it's now on this much larger graph and we much prefer something which is linear time or almost linear time that works directly on the original graph and that is exactly what dyra shortest path algorithm is going to accomplish let's now move on to the pseudo code for dyra shortest path algorithm so this is another one of those algorithms where no matter how many times I explain it it's always just uh super fun to teach and the main reason is because it exposes the beauty that pops up uh in good algorithm doign design so the pseudo code AS you'll see in a second is itself very elegant we're just going to have one Loop and in each iteration of the loop we will compute the shortest path distance to one additional vertex and by the end of the loop we'll have computed shortest path distances to everybody the proof of correctness which we'll do in the next video uh is a little bit subtle but also quite natural quite pretty and then finally Dyer's algorithm will give us our first opportunity to see the inner playay between good algorithm design and good data structure design so with a suitable application of the keep data structure will be able to implement Dyer's algorithm so it runs blazingly fast almost linear time namely M * login but I'm getting a little ahead of myself let me actually show you this pseudo code at a high level you really should think of dxer algorithm is being a close cousin of breath for search and indeed if all of the edge lengths are equal to one dex's algorithm becomes breath for search so this is sort of the Slick generalization of breath first search when edges can have different lengths so like our generic search procedures we're going to start at the source vertex s and in each iteration we're going to conquer one new vertex and we'll do that once each iteration after n minus1 iterations will be done and in each iteration will correctly compute the shortest path distance to one new possible destination vertex V so let me just start by initializing some notation so capital x is going to denote the vertices that we've dealt with so far and by dealt with I mean we've correctly computed shortest path distance from The Source vertex to every vertex in X we're going to augment X by one new vertex in each iteration of the main Loop remember that we're responsible for outputting n numbers one for each vertex we're not just Computing one thing we're Computing the shortest path distance from The Source vertex s to every other vertex so I'm going to frame the output in terms of this array capital A so for each vertex we're going to have an entry in the array a and the goal is at the end of the algorithm a will be populated with the correct shortest path distances now to help you understand Dyer's algorithm I'm going to do some additional bookkeeping which you would not do in a real implementation of Dyer's algorithm specifically in addition to this array capital A in which we compute shortest path distances from The Source vertex to every other destination there's going to be an array capital B and which will keep track of the actual shortest path itself from The Source vertex s to each destination V so the arrays A and B will be indexed in the same way there'll be one entry for each possible destination vertex V cap a will store just a number for each destination shortest path distance the array B in each position will store an actual path the path the shortest path from s Tov but again you would not include this in an actual implementation I just find in my experience it's easier for students to understand this algorithm if we think of the paths being carried along as well so now that I've told you the semantics of these two arrays I hope it's no surprise how we initialize them for the source vertex itself s right the shortest path distance from s to itself is zero the empty path gets you from s to S with length zero there's no negative edges by assumption so there's no way you can get from s back to S uh with non-positive length so this is definitely the shortest path distance for S by the same reasoning the shortest path from s to S is just the empty path the path with no edges in it so now let's proceed to the main while loop So the plan is we want to grow this set capital x like a mold until it covers the entire graph so in each iteration it's going to grow and cover up one new vertex and that vertex will then be processed and at the time of processing we're responsible for computing the shortest path distance from s to this vertex and also figuring out what the actual shortest path from s to this vertex is so in each iteration we need to grow X by one node to ensure that we make progress so the obvious question is which node should we pick which one do we add to X next so there's going to be two ideas here the first one we've already seen in terms of all of these generic Graph Search procedures which is we're going to look at the edges and the vertices which are on the front here so we're going to look at the vertices that are just one hop away from vertices we've already put into X so that motivates at a given iteration of the while loop to look at the stuff we've already processed that's X and the stuff we haven't already processed that's V minus x s of course starts in X and we never take anything out of X so s is still there you know in some generic iteration of the while loop we might have some other vertices that are in X and in a generic iteration of this Loop there might be multiple vertices which are not in X and now as we've seen in our Graph Search procedures there are General our edges Crossing this cut so there are edges which have one end point in each side one end point in X and one end point outside of X this is a directed graph so they can cross in two directions they can cross from left to right or they can cross from right to left so you might have some edges internal to X those are things we don't care about at this point you might have edges which are internal to V minus X we also don't care care about those at least not quite yet and then you have edges which can cross from X to v- X as well as edges that can cross in the reverse direction from vus X back to X and the ones we're going to be interested in just like when we did Graph Search and directed graphs are the edges Crossing from left to right the edges whose tail is amongst vertices we've already seen and whose head is some not yet explored vertex so the first idea is that at each iteration of the while loop we scan or we examine all of the edges with tail and x and head outside of x one of those is going to lead us to the vertex that we pick next so that's the first idea but now we need a second idea because this is again quite underdetermined there could be multiple such vertices which meet this Criterion so for example in the cartoon in the bottom left part of this slide you'll notice that there's one vertex here which is the head of an arc that crosses from left to right and there's yet another vertex down here in vus X which again is the head of an arc which crosses from left to right so there are two options of which of those two to suck into our set X and we might want some guidance about which one to pick next so the key idea in dyra is to give each vertex a score corresponding to how close that vertex seems to the source vertex s and then to pick among all candidate vertices the one that has the minimum score let me be more precise so among all Crossing edges with tail on the left side and head on the right side we pick the edge that minimizes the following Criterion the shortest path distance that we previously computed from s to the vertex V plus the length of the edge that connects V to W so this is quite an important expression so I will call this Dyer's greedy Criterion this is a very good idea to use this method to choose which vertex to add to the set X as we'll see I need to give a name to this Edge which minimizes this quantity over all Crossing edges so let's call it v w star so for example in the cartoon in the bottom left maybe of the two edges Crossing from left to right maybe the top one is the one that has a smaller value of D's greedy Criterion so in that case this would be the vertex V and the other end of the edge would be the vertex W star so this Edge varar W star is going to do wonders for us it will both guide us to the vertex that we should add to X next that's going to be W star it's going to tell us how we should compute the shortest path distance to W Star as well as what the actual shortest path from s to W star is so specifically in this iteration of the while loop after we've chosen this Edge V Star W star we add W star to X Remember by definition W star was previously not in capital x so we're making progress by adding it to X that's one more vertex in X now X is supposed to represent all of the nodes that we've already processed so an invariant of this algorithm is that we've computed shortest path distances for everybody in X as well as the actual shortest paths so now that we're putting W star in X we're responsible for all of this information shortest path information so what we're going to do is we're going to set the r estimate of w Stars shortest path distance from s to be equal to the value of this Dy greedy Criterion for this Edge that is whatever our previously computed shortest path distance from s to V Star was plus the length of the direct Edge from V Star to W star now a key point is to realize that this code does make sense by which I mean if you think about this quantity AV this has been previously computed and that's because an invariant of this algorithm is we've always computed shortest path distances to everything that's in capital x and of course the same thing holds when we need to assign W star shortest path distance because V Star was a member of capital x we had already computed its shortest path distance so we can just look up uh the V Star entry position in the array a so over in our picture in our left we would just say well what did we compute the shortest path distance to V Star previously maybe it's something like 17 and then we'd say you know what is the length of this direct Edge from V Star to W star maybe that's six then we would just add 17 and 6 and we would put 23 as our estimate of the shortest path distance from s to W star so we do something analogous with the shortest paths itself and the array B that is again we're responsible since we just added W star to capital x we're responsible for suggesting a path from s to W star in the B array so what we're going to do is we're just going to inherit the previously computed path to V and we're just going to tack on that end one extra hop namely the direct Edge from varar to W star that'll give us a path from s all the way to W star via V Star as an intermediate pit stop and that is the entirety of Dyer's algorithm I've explained all of the ingredients about how it works at a conceptual level so the two things I owe you is you know why is it correct why does it actually compute shortest paths correctly to all of the different vertices and then secondly how fast can we implement it so the next two videos are going to answer both of those questions but before we do that let's go through an example to get a better feel for how this algorithm actually works and I also want to go through a non-example so that you can appreciate how it breaks down when there are negative edges and that'll make it clear why we do need a proof of correctness because it's not correct without any assumptions about the edge lengths