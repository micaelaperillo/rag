for this final video on binary search trees I want to talk a little bit about implementation implementation details for the red black tree data structure in particular the insertion operation as I've said in the past it really doesn't make sense for me to spell out all of the gory details about how this is implemented if you want to understand them in full detail you should check out various demonstrations are readily available on the web or a comprehensive textbook or an open-source implementation red-black trees you'll recall satisfied for invariance and the final two invariants in particular ensure that the red black tree always has logarithmic height and therefore all of the supported operations run in logarithmic time the problem is we've got to pay the piper whenever we have an operation that modifies the data structure it potentially destroys one or more of the invariants and we have to then restore that invariance without doing too much work now amongst all of the supported operations there are only two that modify the data structure insertion and deletion so from 30,000 feet the approach to implementing insert and delete is to just implement them as if it's a normal binary search trees if we didn't have to worry about these invariants and then if that invariant is broken we try to fix it with minimal work and the two tools that we have at our disposal to trying to restore it in variant are first of all recoloring flipping the color of nodes from red to black and second of all left and right rotations as covered in the previous video my plan is to discuss the insertion operation not in full detail but I'll tell you about all of the key ideas now deletion you got to remember that even in a regular binary search tree deletion is not that trivial and in a red black tree it's downright painful so that I'm not going to discuss I'll defer you to textbooks or online resources to learn more about deletion so here's how insert is going to work so suppose we have some new node with the key X and we're inserting it into a red-black tree so we first just forget about the invariance and we insert it as usual and remember that's easy all we do is follow left and right child pointers until we fall off the end of the tree until we get to a null pointer and we install this new node with key X where we fell off the tree that makes X a leaf in this binary search tree let's let Y denote X's parent after it gets inserted now in a red black tree every node has a color it's either red or black so we have a decision to make we just added this new node with key X and we got to make it either red or black and we're sort of between a rock and a hard place whichever color we make it we have the potential of destroying one of the invariance specifically suppose we color it red well remember what the third invariant says it says you cannot have two Reds in a row so if Y X's new parent is already red then when we color X red we have two Reds in a row and we've broken invariant number three on the other hand if we color this new node X black we've introduced a new black node to certain root null paths in this tree and remember the fourth invariant insists that all of the root null paths have exactly the same number of black nodes so by adding a black node to some but not all of the paths were in general going to destroy that invariant if we color X black so what we're going to do is we're going to choose the lesser of two evils and in this context the lesser of two evils is to color X red again we might destroy the third invariant we'll just deal with the consequences later so why you ask is coloring X red and destroying the third invariant the lesser of two evils well intuitively it's because this invariant violation is local the flaw and are not quite red black tree is small and manageable it's just a single double red and we know exactly where it is it's x and y so there's sort of more hope in squashing it with minimal work by contrast to be colored X black then we've violated this much more global type of property involving all of the route tunnel paths and that's a much more intimidating violation to try to fix than just this local one of having a double read between X and its parent indeed some of the time we'll just get lucky and it will just so happen that X's parent why is colored black and then we're golden this new node X that's colored red it doesn't create a double red there's no other violations of the other invariance and so boom we've got a new red black tree and we can stop so the tricky case then is when X's parent Y is also red in this case we do not have a red black tree we have a double red and we have to do some more work to restore the third invariant so suppose why is red what do we then know well remember before we inserted X we had a red black tree all four of the invariants were satisfied so therefore why by virtue of being red it could not have been the root it has to have a parent let's call that parent W moreover by the third invariant there was no double red in this tree before he inserted X so by virtue of Y being red its parent W must have been black so now the insertion operation branches into two different cases and it depends on the color on the status of w's other child so in the first case we're going to assume that w's other child that is not Y but the other child of W exists and is colored red and the second case we're going to treat when W either doesn't have a second child Y is its only child or when its other child is colored black so let's recap where things stand so we just inserted this new node and it has the key X and our algorithm colored this node red so X is definitely red now if its parent Y was black we already halted so we've already dealt with that case so now we're assuming that Y X's parent is also red that's what's interesting now by virtue of Y being red we know that y's parent that is x's grandparent w has to be colored black and for case two of insertion we are assuming that w has a second child call it Z and that Z is colored red so how are we going to quash this double red problem we again we have two tools at our disposal one is to recolor nodes the second is to do rotations so for case one we're only going to actually have to do recolor and we're not even going to have to bust out our rotations in particular what we're going to do is we're going to recolor Z&Y black and we're going to recolor w red so in some sense we take the Reds that are at Z&Y and we consolidate them at W the important property of this recoloring is that it does not break the fourth invariant remember the fourth invariant says that no matter which path you take from the root to a null pointer you see exactly the same number of black nodes so why is invariants still true after this recoloring well for any path from a root to a null pointer which doesn't go through the vertex W it's irrelevant none of these nodes are on that path so the number of black nodes is exactly the same so think about a path which does go through W well if it goes through W to get to a null pointer have to go through exactly one of Z or Y so before we did the recoloring this path picked up a black node via W and it did not pick up a black node via Z or Y both of those were red now any such path does not pick up a black node at W that's now red but it does pick up exactly one black node either Z or Y so for every single path in the tree the number of black nodes it contains is exactly the same before or after this for coloring therefore since the fourth invariant held previously it also holds after this recolor eight the other great thing is that it seems like we've made progress on restoring the 13 beer at the property that we don't want any double ribs at all in the entire tree remember before we did this recoloring we only had a single double read it involved X&Y we just recolored why from red to black so certainly we no longer have a double read involving X and y and that was the only one in the tree so are we done do we now have a bonafide red black tree well the answer depends and it depends on the color of w's parent so remember W just got recolored from black to red so there's now a possibility that W being this new red node participates in some new double red violation now double use children Z and Y are black so those certainly can't be double Reds but W also has some parent and if double use parent is red then we get a double red involving W and its parent of course if double use parent was black then we're good to go we don't get a double red by recoloring double W red so we have no double Reds in the tree and we can just stop summarizing this recoloring preserves the fourth invariant and either it restores the third invariant or if it fails to restore the third invariant at least it propagates the double red violation upward into the tree closer to the root we're perfectly happy with the progress represented by propagating the double red upward why well before we inserted this new object X we had a red black tree and we know red black trees have logarithmic height so the number of times that you can propagate this double red upward is bounded above by the height of the tree which is only logarithmic so we can only visit case one a logarithmic number of times before this double root is propagated all the way to the top of the tree all the way to the root so we're not quite done the one final detail is what happens when this recoloring procedure actually recolors the root so you could for example look at this green picture on the right of this slide and asked well what if w is actually the root of this red black tree and we just recolored it red now notice in that situation where the we're dealing with the root of the tree we're not going to have a double red problem so in variant 3 is indeed restored when we get to the top of the tree but we have a violation of invariant number 2 which states that the root must always be black well if we find ourselves in this situation there's actually a super simple fix which is this red root we just recolor it black now clearly that's not going to introduce any new double Reds the worry is that instead it breaks in variant 4 but the special property of the root vertex is that it lies exactly once on every root no path so if we flip the color of the root from red to black it increases the number of black nodes on every single root and all paths by exactly 1 so if they all had the same number of black nodes before they all have the same number of black nodes now after the recoloring that completes case 1 of how insertion works let's move on to case two so case two gets triggered when we have a double read and the deeper node of this double read pay or call it X it's uncle that is if it has grandparent W parent Y and double use other child other than Y either doesn't exist or if it exists it's labeled it's colored black that is case two I want to emphasize you might find yourself in case two right away when you insert this new object X it might be that immediately it has some uncle which is colored X or it might be that you've already visited case one a bunch of times propagating this double red up the tree and now at some point the deeper red node X has a black uncle either way as soon as that happens you trigger case two well it turns out case q is great in the sense that with merely constant work you can restore invariant number three you can get rid of the double read without breaking any of the other invariance you do have to put to use both of the tools we have available in general bo3 colorings and rotations left and right rotations as we discussed in the previous video but if you do just a constant number of each recoloring z' and rotations you can get all four of the invariance simultaneously there are unfortunately a couple of sub cases depending on exactly the relationships between X Y Z and W for that reason I'm not going to spell out all the details here check out a textbook if you're interested or even better work it out for yourself now that I've told you that two to three rotations plus summary colorings is always sufficient in case two to restore all of the invariance follow your nose and figure out how it can be done so let's summarize everything that we've said about how insertion works in a red-black tree so you have your new node with key X you insert it as usual so you make it a leaf you tentatively color it red if its parent is black you're done you have a red black tree and you can stop in general the interesting case is this new node X's parent is red that gives you a double red a violation of invariant 3 now what happens is you visit this case one propagating this double red upward in the tree this upward propagation process can terminate in one of three ways first of all you might get lucky and at some point the double red doesn't propagate you do the recoloring in case one and it just so happens you don't get a new double red at that point you have a red black tree and you can stop the second thing that can happen is the double red propagation can make it all the way to the root of the tree then you can just recolor the root black and you can stop with all of the invariants satisfied alternatively at some point when you're doing this upward propagation you might find yourself in case two as discussed on this slide where the lower red node in your double red pair X has a black or non-existent uncle Z in that case with constant time you can restore all of the four invariants so the work done overall is dominated by the number of double red propagations you might have to do that's bounded by the height of this tree and that's bounded by a Big O of log n so in all of the cases you restore all four invariants you do only a logger and the amount of work so that gives you a logarithmic insertion operation for red black trees as promised