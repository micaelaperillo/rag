so in this video we'll graduate beyond the domain of just vanilla binary search trees like we've been talking about before and we'll start talking about balanced binary search trees these are the search trees you really want to use when you want to have real-time guarantees on your operation time because they're search trees which are guaranteed to stay balanced which means the height is guaranteed to stay logarithmic which means all of the operations search trees support that we know and love will also be logarithmic in the number of keys that they're storing so let's just quickly recap what is the basic search tree property it should be the case that at every single note of your search tree if you go to the left you only see keys that are smaller than where you started and if you go to the right you only see keys that are bigger than where you started and a really important observation which is that given a set of keys there going to be lots and lots of different legitimate valid binary search trees with those keys so we've been having these running examples with the keys 1 2 3 4 5 on the one hand you can have a nice and balanced uh search tree that has height only two with the keys 1 through five on the other hand you can also have these crazy chains basically devolve to link lists where the height for n elements could be as high as n minus one so in general you could have an exponential difference in the height it could be as small in the best case as logarithmic as big in the worst case as linear so this obviously motivates search trees that have the additional property that you never have to worry about their height you know they're going to be well balanced you know they're going to have height logarithmic you're never worried about them having this really lousy linear height remember why it's so important to have a small height it's because the running time of all of the operations of search trees depends on the height you want to do search you want to do insertion you want to find predecessors whatever the height is going to be what governs the running time of all of those properties so the high level idea behind balance search trees is is really exactly what you'd think which is that you know because the height can't be any better than logarithmic in the number of things you're storing that's because the trees are binary so the number of nodes can only double each level so you need a logarithmic number of levels to accommodate everything that you're storing but it's got to be logarithmic let's make sure it stays logarithmic all the time even as we do insertions and deletions if we can do that then we get a very rich collection of supported operations all running in logarithmic time as usual n denotes the number of keys being stored in the tree there are many many many different balance search trees uh they're not super most of them are not super different from each other I'm going to talk about one of the more popular ones which are called red black trees so these were invented back in the 70s these were not the first balanced binary search tree data structure that honor belongs to AVL trees which again are not very different from red black trees though the invariants are slightly different another thing you might want to look up uh and read about there a very cool data structure called spat trees due to Slater in Tarin uh these unlike red black trees and AVL trees which only are modified on insertions and deletions which if you think about it is sort of what you'd expect spay trees modify themselves even when you're doing lookups even when you're doing searches so they're sometimes called self-adjusting trees for that reason and they're super simple but they still have kind of amazing guarantees and then finally going beyond the just the binary tree Paradigm uh many of you might want to look up examples of B trees or also B+ trees these are very relevant for implementing databases here what the idea is in a given node you're going to have not just one key but many keys and from a node you have multiple branches that you can take depending on where you're searching for Falls with respect to the multiple keys that are at that node the motivation in a database context uh for going beyond the binary Paradigm is to have a better matchup with the memory hierarchy so that's also very important although a little bit outside of the scope here that said uh what we discuss about red black trees much of the in tuition will translate to all of these other balance tree data structures if you ever find yourself in a position where you need to learn more about them so red black trees are just the same as binary search trees except they also always maintain a number of additional invariants and so what I'm going to focus on in this video is first of all what the invariants are and then how the invariants guarantee that the height will be logarithmic time permitting at some point there'll be optional videos more about the guts more about the implementations of red black trees namely how do you maintain these invariant under insertions and deletions that's quite a bit more complicated so that's appropriate for for optional material but understanding what the invariants are and what role they play in controlling the height is very accessible and it's something I think uh every programmer should know so there I'm going to write down four invariants and really the bite comes from the second two okay from the third and the fourth invariants the first two invariants uh you know are just really cosmetic so the first one uh we're going to store one bit of information additionally at each node Beyond just the key uh and we're going to call this bit as indicating whether it's a red or a black node you might be wondering you know why red black well I asked my colleague Leo gias about that a few years ago and he told me that when he and Professor Sedwick were writing up this article uh the journals were just had access to a certain kind of new printing technology that allowed very limited color uh in the printed copies of the journals and so they were eager to use it and so they named their data structure red black so they could have these nice red and black pictures in the journal article unfortunately there was then some snafu and at the end of the day that technology wasn't actually available so it wasn't actually printed the way they were envisioning it but the name has stuck so that's the rather idiosyncratic reason why these data structures got the name uh that they did red black trees so secondly we're going to maintain the invariant that the root of the search tree is always black can never be red okay so with the superficial pair of invariants out of the way let's go to the two main ones so first of all we're never going to allow Two Reds in a row by which I mean if you have a red node in the search tree then its children must be black if you think about it for a second you realize this also implies that if a node is red and it has a parent then that parent has to be a black node so in that sense there are no true red nodes in a row anywhere in the tree and the final invariant which is also rather severe is that every path you might take from root to a null pointer passes through exactly the same number of black nodes so to be clear on what I mean by a root null path what you should think about is an unsuccessful search right so what happens in an unsuccessful search you start at the root depending on whether you need to get smaller or bigger you go left or right respectively you keep going left right as appropriate until eventually you hit a null pointer so I want you to think about that process by which you start at the root and then eventually fall off the end of the tree in doing so you Traverse some number of nodes some of those nodes will be black some of those nodes will be red and I want you to keep track of the number of black nodes and the constraints that a red black tree by definition must satisfy is that no matter what path you take through the tree starting from the root terminating in a null pointer the number of black nodes traversed has to be exactly the same cannot depend on the path has to be be exactly the same on every single rout M path let's move on to some examples so here's a claim and this is meant to kind of wets your appetite for the idea that red black trees must be pretty balanced they have to have height basically logarithmic so remember what's the most unbalanced search tree well that's These Chains so the claim is even a chain with three nodes cannot be a red black tree so what's the proof well consider such a search tree right so maybe with the key values 1 2 and three so the question that we're asking is is there a way to color the no these three nodes red and black so that all four of the invariants are satisfied so we need to color each red or black remember in variant two says the root the one has to be black so we have four possibilities for how to color two and three but really because of the third invariant we only have three possibilities we can't color two and three both red cuz need to have two Reds in a row so we can either make two red three black two black three red or both two and three black and all of the cases are the same uh just to give one example suppose that we color the node two red and one and three are black the claim is inv variant four is then broken and inv variant four is going to be broken no matter how we try and color two and three uh red and black what is inv variant four says it says really on any unsuccessful search you pass through the same number of black nodes and so one unsuccessful search would be you search for zero and if you search for zero you go to the root you immediately go left and hit a null pointer so you see exactly one black node namely one on the other hand suppose you searched for four then you'd start at the root you'd go right you go to two you go right you go to three you go right again and only then would you hit a null pointer and on that unsuccessful search you'd encounter two black nodes both the one and the three so that's a violation of the fourth invariant therefore this would not be a red black tree I'll leave it for you to check that no matter how you try to color two and three uh red or black you're going to break one of the invariants if they're both red you break the third invariant if at most one is red you break the fourth invariant so that's a non-example of a red black tree so let's look at an example of a red black tree one a search tree where you actually can color the notes red or black so that all four invariants are maintained so one search tree which is very easy to make red black is a perfectly balanced one so for example let's consider this three node search tree has the keys 3 five and 7 and let's suppose the five is the root so it has one child on each side three and the seven so can this be made a r red black tree so remember what that question really means it's asking can we color these three nodes some combination of red and black so that all four of the invariant are satisfied if you think about it a little bit you realize yeah you can definitely color these nodes red or black to make and satisfy all four in the inv variance in particular suppose we color all three of the nodes black we've been satisfied in variant number one we've colored all the nodes we've satisfied in variant number two in particular the root is black we've satisfied in variant number three there's no Reds at all so there's certainly no Two Reds in a row and if you think about it we satisfy in variant four because this tree is perfectly balanced no matter what you unsuccessfully search for you're going to encounter two black nodes if you search for say one you're going to encounter three and five if you search for say six you're going to encounter five and seven so all root null paths have exactly two black nodes and variant number four is also satisfied so that's great but of course the whole point of having a binary search tree data structure is you want to be dynamic you want to accommodate insertions and deletions every time you have an insertion or deletion into a red black tree you get a new node let's say an insertion you get a new node you have to color it something and now all of a sudden you got to worry about breaking one of these foreign variants so let me just show you some easy cases where you can accommodate insertions with too much work time permitting will include some optional videos with the notion of rotations which do more fundamental restructuring of search trees so that they can maintain the foreign variance and stay uh nearly perfectly balanced so if we have this red black tree where everything's black and we insert say six that's going to get inserted down here now if we try to color it black it's no longer going to be a red black tree and that's because if we do an unsuccessful search now for say 5.5 we're going to encounter three black nodes where if we do an unsuccessful search for one we only encounter two black nodes so that's not going to work but the way we can fix it is instead of coloring the six black we color it red and now this six is basically invisible to invariant number four it doesn't show up in any root andol paths so because you had two black nodes on all root andol paths before before the six was there that's still true now that you have this red six so all foreign variants are satisfied once you insert the six and color it red if we then insert say an eight we can pull exactly the same trick we can color the eight red again it doesn't participate in invariant four at all so we haven't broken it moreover we still don't have two Reds in a row so we haven't broken in variant number three either so this is yet another red black tree in fact this is not the unique way to color the nodes of this search tree so that it satisfies all four of the invariants if we instead recolor 6 and8 black but at the same time recolor the not seven red were also golden clearly the first three inv variants are all satisfied but also when pushing the red upward consolidating the red at 6 and 8 and putting it at seven instead we haven't changed the number of black nodes on any given path any black any path that previously went through six went through seven anything that went through eight went through seven so there's exactly the same number of red and black nodes on each such path as there was before so all paths still have equal number of black nodes and invariant for remains satisfied as I said I've shown you here only very simple examples where you don't have to do much work on an insertion to retain the red black properties in general if you keep inserting more and more stuff and certainly if you do deletions you have to work much harder to maintain those four invariants time permitting we'll cover just a taste of it in some optional videos so what's the point of these seemingly arbitrary for invariance of a red black tree well the whole point is is that if you satisfy these four invariants in your search tree then your height is going to be small and because your Height's going to be small all your operations are going to be fast so let me give you a proof that if a search tree satisfies the foreign variance then it has super small height in fact no more than double the absolute minimum it could conceivably have at most Two Times log based 2 of n so the formal claim is that every red black tree with n nodes has height o of log N More precisely at most 2 * log base 2 of n + 1 so here's the proof and what's cool about this proof is it's very obvious the role played by these invariance three and four essentially what the invariant guarantee is that a red black tree has to look like a perfectly balanced tree with at most a sort of factor 2 inflation so let's see exactly what I mean so let's begin with an observation and this this has nothing to do with red black trees forget about the colors for a moment and just think about the structure of binary trees and let's suppose we have a lower bound on how long root null paths are in a tree so for some parameter K and go ahead and think of K as like 10 if you want suppose we have a tree where if you start from the root and no matter how it is you navigate left and right child pointers until you terminate at a null pointer no matter how you do it you have no choice but to see at least K nodes along the way if that hypothesis is satisfied then if you think about it the top of this tree has to be totally filled in so the top of this tree has to include a perfectly balanced search tree binary tree of depth K minus one so let me draw a picture here of the case of k equal 3 so if no matter how you go from the root to a null pointer you have to see at least three nodes along the way then it means the top three levels of this tree have to be full so you have to have the root it has to have both of it children and has to have all four of its grandchildren the proof of this observation is by contradiction if in fact you were missing some nodes in any of these top K levels well that would give you a way of hitting a null pointer seeing less than K nodes so what's the point is the point is this gives us a lower bound on the population of a search tree as a function of the length of its root null paths so the size n of the tree must include at least the number of nodes in a perfectly balanced tree of depth K minus1 which is 2 raed to the K minus1 so for example 1 K = 3 it's 2 raed to 3 2 cubed - 1 or 7 so that's just a basic fact about trees nothing about red black trees so let's now combine that with the red black tree in variance to see why red black trees have to have small height so again to recap where we got to on the previous Slide the size n the number of nodes in a tree is at least 2 the K minus 1 where K is the fewest number of nodes you will ever see on a root null path so let's rewrite this a little bit and let's actually say let's instead of having a lower bound on n in terms of K let's have an upper bound on K in terms of n so the length of every root null path the minimum length of every root null path is bounded above by log base 2 of quantity n + 1 this is just adding one to both sides and taking the logarithm base 2 so what what does this buyas well now let's start thinking about red black trees so in a red black tree with n nodes what does this say this says that the number of nodes forget about red or black just the number of nodes on some root n path has to be at most log base 2 of n + 1 in the best case all of those are black maybe some of them are red but in the in the maximum case all of them are black so we can write in a red black tree with n nodes there is a root null path with at most log base 2 of n + 1 black nodes this is an even weaker statement than what we just proved we proved that some path must have at most log base 2 of n plus1 total nodes so certainly that path has the most log based two of n plus1 black nodes now let's now let's apply the two knockout punches of our two invariants all right so fundamentally what is the fourth invariant telling us it's telling us that if we look at a path our red black tree we go from the root we think about say an unsuccessful search we go down to a null pointer it says if we think of the red nodes as invisible if we don't count them in our tally then we're only going to see log basically a logarithmic number of nodes but when we care about the height of the red black tree of course we care about all of the nodes the red nodes and the black nodes so so far we know if we only count black nodes then we're good we only have log base 2 of n+1 nodes that we need to count so here's where the third invariant comes in it says well actually black nodes are a majority of the nodes in the tree in a strong sense there are no Two Reds in a row on any path so if we know the number of black nodes is small then because you can't have two Reds in a row the number of total nodes on the path is at most twice as large in the worst case you have a black root then red then black then red then black then red then black Etc in the worst case the number of red nodes is equal to the number of black nodes which double uh the length of a path once you start counting the red nodes as well and this is exactly what it means for a tree to have logarithmic depth so this in fact proves the claim if a search tree satisfies the invariance 1 through four in particular if there's no Two Reds in a row and all route and all paths have an equal number of black nodes then knowing nothing else about the search tree it's got to be almost balanced it's perfectly balanced up to a factor of two and again the point then is that operations in a search tree and the search trees are going to run in logarithmic time because the height is what governs the running time of those operations now in some sense I've only told you the easy part which is if it just so happens that your search tree satisfies these foreign variants then you're good the height is guaranteed to be small so the operations are guaranteed to be fast clearly that's exactly what you want from this data structure but for the poor soul who has to actually implement this data structure the hard work is maintaining these invariants even as the data structure changes remember the point here is to be dynamic to accommodate insertions and deletions insertions and deletions can disrupt these foreign variants and then one has to actually change the code to make sure they're satisfied again so that the tree stays balanced has L low height even under arbitrary sequences of insertions and deletions so we're not going to cover that in this video it can be done without significantly slowing down any of the operations it's pretty tricky take some nice ideas there's a couple well-known algorithms textbooks that cover those details or if you look at open source and implementations of balance search trees you can look at code that uh does that implementations but because it can be done in a practical way and because red black tree support such a rich array of operations that's why you will find them used in a number of practical applications that's why balance search trees should be part of your programmer toolbox