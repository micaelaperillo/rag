so in this video in the next we're going to study a very cool divide and conquer algorithm for the closest pair problem uh this is a problem where you're given end points in the plane and you want to figure out which pair of points are closest to each other so this will be the first taste we get of an application in computational Geometry which is the part of algorithms which studies how to reason and manipulate geometric objects so those algorithms are important in among other areas uh robotics computer vision uh and computer Graphics so this is relatively Advanced material it's a bit more difficult than the other applications of divide and conquer that we've seen the algorithm is a little bit tricky and it has a quite non-trivial proof of correctness so just be ready for that and also be warned that because it's more advanced I'm going to talk about the material at a slightly uh faster Pace than I do in most of the other videos so let's begin Now by defining the problem formally so we're given as input end points in the plane so each one just defined by its x coordinate and its y-coordinate and when we talk about the distance between two points in this problem we're going to focus onityan distance so let me remind you what that is briefly but we'll introduce some simple notation for that which we'll use for the rest of the lecture so we're just going to note the ukian distance between two points pi and PJ by D of P PJ so in terms of the X and Y coordinates of these two points we just look at the square differences in each coordinate sewn them up and take the square root and now as the name of the problem would suggest the goal is to identify among all pairs of points that pair which has the smallest distance between them next let's start getting a feel for the problem by making some preliminary observations first I want to make an assumption purely for convenience that there's no time T so that is I'm going to assume all end points have distinct x coordinates and also all end points have distinct y-coordinates it's not difficult to extend the algorithm to accommodate ties I'll leave it to you to think about how to do that so next let's draw some parallels with the problem of counting inversions which was an earlier application of divide and conquer that we saw the first parallel I want to point out is that if we're comfortable with a quadratic time algorithm then this is not a hard problem we can simply solve this by Brute Force search and again by Brute Force search I just mean we set up a double for Loop which iterates over all distinct pairs of points we compute the distance for each such pair and we remember the smallest that's clearly a correct algorithm it has to iterate over a quadratic number of pairs so it's running time is going to be uh Theta of n^2 and as always the question is can we apply some algorithmic Ingenuity to do better can we have a better algorithm than this naive one which iterates over all pairs of points you might have an initial Instinct that because the problem asks about a quadratic number of different objects perhaps we fundamentally need to do quadratic work but again recall back in counting inversions using divide and conquer we were able to get an nlog N algorithm despite the fact that there might be as many as a quadratic number of inversions in an array so the question is can we do something similar here for the closest pair problem now one of the keys to getting an nlog end time algorithm for counting inversions was to leverage a sorting sub routine recall that we piggybacked on merge sort to count the number of inversions in end longed time so the question is here with the closest pair problem perhaps sorting again can be useful in some way to beat the quadratic barrier so to develop some evidence that sorting will indeed help us uh compute the closest pair of points in better than quadratic time let's look at a special case of the problem really an easier version of the problem which is when the points are just in one dimension so on the line rather than in two dimensions in the plane so in the 1D version all of the points just lie on a line like this one and we're given the points in some arbitrary order not necessarily in sorted order so a way to solve the closest pair problem in one dimension is to Simply sort the points and then of course the closest pair better be adjacent in this ordering so you just iterate through the N minus one consecutive Pairs and see which one is closest to each other so more formally here's how you solve the one-dimensional version of the problem you sort the points according to their only coordinate because again remember this is one dimension so as we've seen using merge sort we can sort the points in Ed long end time and then we just do a scan through the points so this takes linear time and for each consecutive pair we comp their distance and we remember the smallest of those consecutive Pairs and we return that that's got to be the closest pair so in this picture on the right I'm just going to circle here and green uh the closest pair of points so this is something we discover by sorting and then doing a linear scan now needless to say this isn't directly useful this is not the problem I started out with we wanted to find the closest pair among points in the plane not points in the line but I want to point out that this even in the line there are a quadratic number of different pairs so Brute Force search is still a quadratic time algorithm even in the 1D case so at least with one dimension we can use sorting piggyback on it to beat the naive Brute Force search bound and solve the problem in end log end time so our goal for this lecture is going to be to devise an equally good algorithm for the two-dimensional case we want to solve closest pair of points in the plane again in N log n time so we will succeed in this goal I'm going to show you an N log end time algorithm for 2D closest pair it's going to take us a couple steps so let me begin with the high level approach all right so the first idea to try is just to copy what worked for us in the onedimensional case so in the onedimensional case we first sorted the points uh by their coordinate and that was really useful now in the 2D case points have two coordinates x coordinates and Y coordinates so there's two ways to sort them so let's just sort them both ways that is the first step of our algorithm which is we really think of as a pre-processing step we're going to take the input points we evoke merge sort once to sort them according to x coordinate that's one copy of the points and then we make a second copy of the points uh where they're sorted by a y-coordinate so we're going to call those copies of points PX that's an array of the points sorted by x coordinate and py for the sorted by y-coordinate now we know merge short takes n log n time so this pre-processing step only takes o of n log n time and again given that we're shooting for an algorithm with running time Big O of n log n why not sort the points we don't even know how we're going to use this fact right now but it's sort of harmless it's not going to affect our goal of getting a big of O of n log n time algorithm and indeed this illustrates a broader point which is one of the themes of this course so recall I hope one of the things you take away from this course is a sense for what are the for free Primitives what are manipulations or operations you can do on data uh which basically are Costless meaning that if your data set fits in the main memory of your computer you can basically invoke the Primitive and it's just going to run blazingly fast and you can just do it even if you don't know why and again sorting is the canonical for free primitive although we'll see some more later in the course and so here we're using exactly that principle so we don't even understand why yet we might want the points to be sorted it just seems like it's probably going to be useful motivated by the 1D case so let's go ahead and make sorted copies of the points by X and y-coordinates up front so reasoning by analogy with the 1D case suggests that sorting the points might be useful but we can't carry this analogy too far so in particular we're not going to be able to get away with just a simple linear scan through these arrays to identify the closest pair of points so to see that consider the following example so we're going to look at a point set which has six points there's going to be two points which I'll put in blue which are very close in x-coordinate but very far away in y-coordinate and then there's going to be another pair of points points which I'll do in green which are very close in y-coordinate but very far away in x coordinate and then there's going to be a red pair of points which are not too far away in either the x coordinate or the y-coordinate so in this set of six points the closest pair is the pair of red points they're not even going to show up consecutively in either of the two arrays right so in the array that's sorted by x coordinate this blue point here is going to be wedged in between the two red points they won't be consecutive and similarly in the in py just sort of by y-coordinate this green point is going to be wedged between the two red points so you won't even notice these red points if you just do a linear scan through PX and P or py and look at the consecutive pairs of points so following our pre-processing step where we just in invoke merge sword twice we're going to do a quite non-trivial divide and conquer algorithm to compute the closest pair so really in this algorithm we're applying the divide and conquer algorithm Twice first internal to the Sorting sub routine assuming that we use the merge sort algorithm to sort Divine and Conquer is being used there to get an nlog and time uh in this pre-processing step and then we're going to use it again on the sorted arrays in a new way and that's what I'm going to tell you about next so let's just briefly review the divide and conquer algorithm design Paradigm before we apply to the closest pair problem so as usual the first step is to figure out a way to divide your problem into smaller sub problems sometimes this has a reasonable amount of Ingenuity but it's not going to here in the closest pair problem we're going to proceed exactly as we did in the merge sort and Counting inversions problems where we took the array and broke it into its left and right half so here we're going to take the input Point set and again just recurse on the left half of the points and recurse on the right half of the points we're here by left and right I mean with respect to the points x coordinates there's pretty much never any Ingenuity in the conquer step that just means you take the sub problems you identified in the first step and you solve them recursively that's what we'll do here we'll recursively compute the closest pair in the left half of the points and the closest pair in the right half of the points so where all the creativity in divide and conquer algorithms lie is in the combined step given solutions to your sub problems how do you somehow recover a Sol solution to the original problem the one that you actually care about so for closest pair the question is going to be given that you've computed the closest pair on the left half of the points the closest pair on the right half of the points how do you then quickly recover the closest pair from the whole point set that's a tricky problem that's what we're going to spend most of our time on so let's make this divide and conquer approach for closest pair a little bit more precise so let's now actually start spelling out our closest pair algorithm the input we're given it's this follows the pre-processing step so recall that we invoke merge sword twice we get our two sorted copies of the points set PX sorted by x coordinate and py sorted by y coordinate so the first step then is the division step so given that we have a copy of the points PX sorted by x coordinate it's easy to identify the leftmost half of the points those would the those n /2 uh smallest x coordinates and then the right half those with the n/ two largest x coordinates we're going to call those q and R respectively one thing I'm skipping over is the base case I'm not going to bother writing that down so base case omitted but it's what you would think it would be so basically once you have a small number of points say two points or three points then you can just solve the problem in constant Time by Brute Force search you just look at all the pairs and you return the closest pair so think of there being at least four points in the input now in order to recurse to call close pair again on the left and right halves we need sorted versions of Q andr both by x coordinate and by y-coordinate so we're just going to form those uh by doing suitable linear scans through PX and py and so one thing I encourage you to think through carefully or maybe even code up uh after the video is how would you uh form QX X qy RX and r y given that you already have PX and py and if you think about it because PX and py are already sorted just producing these sorted sublists takes linear time it's in some sense the opposite of the merge sub routine we used in merge sort here we're sort of splitting rather than merging but again this can be done in linear time that's something you should think through carefully later so that's the division step now we just conquer meaning we recursively call closest pair on each of the two sub problems so when we invoke closest pair on the left half of the points on Q uh we're going to get back what are indeed the closest pair of points amongst those in Q so we're going to call those P1 and PQ so among all pairs of points that both line in Q P1 and q1 minimize the distance between them similarly we're going to call P2 Q2 the results of the second recursive call that is P2 and Q2 are amongst all pairs of points that both lie in R the pair that has the minimum ukian distance now consider actually there's two cases there's a lucky case and there's an unlucky case in the original Point set P if we're lucky the closest pair of points in all of P actually both of them lie in Q or both of them lie in r in this lucky case we'd already be done if the closest pair in the entire Point set they happen to both lie in Q then this first recursive call is going to recover them and we just have them uh in our hands P1 q1 similarly if both of the closest pair of points in all of P lies on the right side in r R then they get handed to us on a silver platter by the second recursive call uh that just operates on R so in the Unlucky case the closest pair of points in P happens to be split that is one of the points lies in the left half in Q and the other point lies in the right half in R notice if the closest pair of points in all of p is split is half in Q and half in R neither recursive call is going to find it okay the pair of points is not passed to either of the two recurs calls so there's no way it's going to be returned to us okay so we have not identified the closest pair after these two recursive calls if the closest pair happens to be split this is exactly analogous to what happened when we were counting inversions the recursive call in the left half of the array counted the left inversions the recursive call on the right half of the array counted the right inversions but we still had to count the split inversions so in this closest pair algorithm we still need a special purpose sub rutine that computes the closest pair for the case in which it is split in which there's one point in Q and one point in R so just like in counting inversions I'm going to write down that sub routine I'm going to leave it unimplemented for now we'll figure out how to implement it quickly uh in the rest of the lecture now if we have a correct implementation of closest split pair so that takes us uh input The Original Point set sort of by x and y coordinate and Returns the smallest pair that's split or one points in Q and one points in R then we're done so then the split then the closest pair has to either be on the left or on the right or it has to be split steps 2 through four compute the closest pair pair in each of those categories so those are the only possible candidates for the closest pair and we just return the best of them so that's an argument for why if we have a correct implementation of the closest split pair sub routine then that implies a correct implementation of closest pair now what about the running time so the running time of the closest pair algorithm is going to be in part determined by the running time of closest split pair so in the next Quiz I want you to think about what kind of run on time we should be shooting for with a closest split pair sub routine so the correct response to this quiz is the second one and uh the reasoning is just by analogy with our previous algorithms for merge sort and for counting inversions so what is all of the work that we would do in this algorithm well we do have this pre-processing step we call merge sord twice we know that's n logn so we're not going to have a running time better than nlogn because we sort at the beginning and then we have a recursive algorithm with the following flavor it makes two recursive calls each recursive call is on a problem of exactly half the size with half the points of the original one and outside of the recursive calls by assumption by in the problem we do a linear amount of work in the Computing the closest split pair so we the exact same recursion tree which proves an nlog nbound for merge short proves an nlog end Bound for how much work we do after the pre-processing step so that gives us an overall running time bound of n log in remember that's what we were shooting for we were working n log in already to solve the one-dimensional version of closest pair and the goal of these lectures is to have an nlog algorithm for the two version so this would be great so in other words the goal should be to have a correct linear time implementation of the closest split pair sub routine if we can do that we're home free we get the desired nlog n algorithm now I'm going to proceed in a little bit to show you how to implement closest split pair but before I do that I want to point out one subtle but key idea which is going to allow us to get this linear time correct implementation so let me just put that on this slide so the key idea is that we don't actually need a full-blown correct implementation of the closest split pair sub routine so I'm not actually going to show you a linear time sub routine that always correctly computes the closest split pair of a point set the reason I'm not going to do that is that's actually a strictly harder problem than what we need to have a correct recursive algorithm we do not actually need a sub rutine that for every Point set always correctly computes the closest split pair of points remember there's a lucky case and there's an unlucky case the lucky case is where the closest pair in the whole point set P happens to lie entirely in the left half of the points Q or in the right half of the points R in that lucky case we one of our recursive calls will identify this closest pair and hand it over to us on a silver platter we could care less about the split pairs in that case we get the right answer without even looking at the split pairs now there's this unlucky case where the split pair happens to be the closest pair of points that is when we need this line your time sub routine and only then only in The Unlucky case where the closest pair of points happens to be split now that's in some sense a fairly trivial observation but there's a lot of Ingenuity here in figuring out how to use that observation the fact that we only need to solve a strictly easier problem and that will enable the linear time implementation that I'm going to show you next so now let's rewrite the high level recursive algorithm slightly to make use of this observation that the closest split pair subroutine only has to operate correctly in the regime of The Unlucky case when in fact the closest split pair is closer than the result of either recursive call so I've erased the previous steps four and five that and but we're going to rewrite them in a second so before we invoke Clos a split pair what we're going to do is we're going to see how well did our recursive calls do that is we're going to define a parameter little Delta which is going to be the closest pair that we found the distance of the closest pair we found by either recursive call so the minimum of the distance between P1 and q1 1 the closest pair that lies entirely on the left and P2 Q2 the closest pair that lies entirely on the right now we're going to pass this Delta information as a parameter into our closest split pair sub routine we're going to have to see why on Earth that would be useful I still owe you that information but for now we're just going to pass Delta as a parameter for use in closest split pair and then as before we just do a comparison between the three candidate closest Pairs and return the best of the of the trio and so just we all clear on on where things stand so what remains is to describe the implementation of closest split pair before I describe it let me just be crystal clear on what it is that we're going to demand of the sub rutine what do we need to have a correct and O of n log n time closest pair algorithm well as you saw in the quiz we want the running time to be o of n always and for correctness what do we need again we don't need it to always compute the closest split pair but we need it to compute the closest split pair in the event that there is a split pair of distance strictly less than Delta strictly better than the outcome of either recursive call so now that we're clear on what we want let's go ahead and go through the pseudo code for this closest split pair sub routine and I'm going to tell you up front it's going to be fairly straightforward to figure out that the sub routine runs in linear time o of n time the correctness requirement of Clos to split pair will be highly non obvious in fact after I show you the pseudo code you're not going to believe me you're going to look at the pseudo code and you're going to be like what are you talking about but in the second video on the closest paare lecture we will in fact show that this is a correct sub routine so how does it work well let's look at a point set so the first thing we're going to do is a filtering step we're going to prune a bunch of the points away and sort of zoom in on a subset of the points and the subset of points we're going to look at is those that lie in a vertical strip which is roughly centered in the middle of the point set so here's what I mean by centered we're going to look at the middle x coordinate so let xar be the biggest X coordinate in the left half so that is in the sorted version of the points by x coordinate we look at the n/ 2th smallest x coordinate so in this example where we have six points all this means is we draw we imagine drawing a line between the third point so that's going to be xar the x coordinate of the third point from the left now since we're passed as input a copy of the point sorted by x coordinate we can figure out what xar is in constant time just by accessing the relevant entry of the array PX now the way we're going to use this parameter Delta that we're passed so remember what Delta is so before we invoke the closest split pair subed in the recursive algorithm we make our two recursive calls we find the closest pair on the left the closest pair on the right and Delta is whatever the smaller of those two distances are so Delta is the parameter that controls whether or not we actually care about the closest split pair or not we care if and only if there is a split pair at distance less than Delta so how do we use Delta well that's going to determine the width of our strip so the strip's going to have width to Delta and it's going to be centered around X and the first thing we're going to do is we're going to ignore forever more points which do not lie in this vertical strip so the rest of the algorithm will operate only on the subset of P the subset of the points that lie in this strip and we're going to keep track of them sorted by y coordinate so the formal way to say that they lie in this strip is that they have x coordinate in the interval with lower end point xar minus Delta and upper end point xar plus Delta now how long does it take to construct this set as s y sorted by y-coordinate well fortunately we've been passed as input a sorted version of the points py so to extract Sy y from py all we need to do is a simple linear scan through py uh checking for each point where its x coordinate is so this can be done in linear time now I haven't yet shown you why it's useful to have the sorted set syy but if you take it on faith that it's useful to have the points in this vertical strip sorted by y-coordinate you now see why it was useful that we did this merge sort all the way at the beginning of the algorithm before we even underwent any recursion remember what is our running time goal for closest split pair we want this to run in linear time that means we cannot sort inside the closest split pair sub routine that would take too long we want this to be linear time fortunately since we sorted once and for all at the beginning of the closest pair algorithm extracting sorted sublists from those sorted lists of points can be done in linear time which is within our goals here now it's the rest of the sub routine where you're never going to believe me that it does anything useful so I claim that essentially with a linear scan through Sy we're going to be able to identify the closest split pair of points in the interesting unlucky case where there is such a split pair uh with distance less than Delta so here's what I mean by that linear scan through sy so as we do the scan we we're going to keep track of the closest pair of points of a particular type that we've seen so far so let me introduce some variables to keep track of the best candidate we've seen so far so there's going to be a v variable best which will initialize to be Delta remember we're uninterested in Split pairs unless they have distance strictly less than Delta and then we're going to keep track of the points themselves so we'll initialize the best pair to be null now here's the linear scan so we go through the points of Sy Y in order of y coordinate okay well not quite all the points of Sy y we stop at the eighth to last point and you'll see Y in a second and then for each position I of the array Sy y we investigate the seven subsequent points of this same array Sy y so for J going from 1 to 7 we look at the E and i+ J entry of Sy y so if s y looks something like this array here at any given point in this double for loop we're generally looking at an index I a point in this in this I entry of the array and then some really quite nearby point in the array i+ J cuz J here is going to be uh at most s Okay so we're constantly looking at pairs in this array but we're not looking at all pairs at all we're only looking at pairs that are very close to each other within seven positions of each other and what do we do for each choice of I and J well we just look at those points we compute the distance we see if it's better than all of the pairs of points of this form that we've looked at in the past and if it is better then we remember it so we just remember the best I.E closest pair of points of this particular type for choices of IJ of this form so in more detail if the distance between the current pair points p and Q is better than the best we've seen so far we reset the best pair of points to be equal to p and Q and we reset the best distance the closest distance seen so far to be the distance between p and Q and that's it then once this double four Loop terminates we just return the best pair so one possible execution of closest split pair is that it never finds a pair of points p and Q with distance less than Delta in that case this is going to return null and then in the outer call in the closest pair obviously you interpret a null pair of points to having infinite distance so if you call closest split pair and it doesn't return any points then the interpretation is that there's no interesting split pair of points and you just return the better of the results of the two recursive calls P1 q1 or P2 Q2 now as far as the running time of this sub routine what happens here well we do constant work just initializing the variables then uh notice that the number of points in Sy y well in the worst case you have all of the points of P so there going to be at most end points and so you do a linear number of iterations in the outer for Loop but here's the key point in the inner for Loop right normally double for Loops give rise to quadratic running time but in this inner for Loop we only look at a constant number of other positions we only look at seven other positions and for each of those seven positions we only do a constant number of work right we just compare a distance and make a couple other comparisons and reset some variables so for each of the linear number of outer iterations we do a constant amount of work so that gives us a running time of O of n for this part of the algorithm so as I promised analyzing the running time of this CL closer split pair sertin was not challenging we just in a straightforward way looked at all the operations and again because in the key linear scan we only do constant work per index the overall running time is Big O of n just as we wanted so this does mean that our overall recursive algorithm will have running time o of n logn what is totally non- obvious and perhaps even unbelievable is that this subroutine satisfies the correctness uh requirements that we wanted remember what we needed we needed that whenever we're in the Unlucky case whenever in fact the closest pair of points in the whole point set is split this sub routine better find it so but it does and that's made precise in the following correctness claim so let me phrase the claim in terms of an arbitrary split pair which has distance less than Delta not necessarily the closest such pair so Suppose there exists a p on the left a point on the left side and a point on the right side so that is a split pair and suppose the distance uh of this pair is less than Q now there may or may not be such a pair of points PQ don't forget what this parameter Delta means what Delta is by definition is the minimum of D of P1 q1 where P1 q1 is the closest pair of points that lie entirely in the left half of the point set q and d of P2 Q2 where similarly P2 Q2 is the closest pair of points that lies entirely on the right inside of R so if there's a split pair with distance less than Delta this is exactly the Unlucky case of the algorithm this is exactly where neither recursive call successfully identifies the closest pair of points instead that closest pair is a split pair on the other hand if we are in the lucky case then there will not be any split pairs with distance less than Delta because the closest pair lies either all on the left or all on the right and it's not split but remember so we're interested in the case where there is a split pair uh that has distance less than Delta where there is a split pair that is the closest pair so the claim has two parts the first part part A says the following it says that if there's a split pair p and Q of this type then p and Q are members of Sy y now let me just sort of redraw the cartoon so remember what Sy Y is Sy Y is that vertical strip and again the way we got that is we drew a line through a median x coordinate and then we fattened it by Delta on either side and then we focused only on points that lie in the vertical strip now notice our counts uh split pair subroutine if it ever returns a pair of points it's going to return a pair of points PQ that belong to Sy first it filters down to Sy y then it does a linear search through Sy y so if we want to believe that our sub rutine identifies best uh split pairs of points then in particular such split pairs of points better show up in Sy they better survive the filtering step so that's precisely what part A of the claim is here's Part B of the claim and this is the more remarkable part of the claim which is that P and Q are almost next to each other in this sorted array syy so they're not necessarily adjacent but they're very close they're within seven positions away from each other so this is really the remarkable part of the algorithm this is really uh what's surprising and what makes the whole algorithm work so just to make sure that we're all clear on everything let's show that if we prove this claim then we're done then we have a correct fast implementation of a closest pair algorithm I certainly owe you the proof of the claim that's what the next video is going to be all about but let's show that if the claim is true then we're home free so if this claim is true then so is the following coraly which I'll call Cory one so cor 1 says if we're in the Unlucky case that we discussed earlier if we're in the case where the closest point and the whole point set P does not lie both on the left does not lie both on the right but rather has one point on the left and one on the right that is it's a split pair then in fact the count split pair subroutine will correctly identify uh the closest split pair and therefore the closest pair overall why is this true well what does counts split pair do okay so it has this double for Loop and it thereby explicitly examines a bunch of pairs of points and it remembers the closest pair of all of the pairs of points that it examines what does this so what are the criteria that are necessary for a count split pair to examine a pair of points well first of all the points p and Q both have to survive the filtering step and make it into the array Sy y right so count split pair only searches over the array s y secondly it only searches over pairs of points that are almost adjacent in s that are only seven positions apart but amongst pairs of points that satisfy those two criteria counts split pair will certainly compute the closest such pair right it just explicitly remembers the best of them now what's the content of the claim with the claim is guaranteeing that every potentially interesting split pair of points namely every split pair of points with distance less than Delta meets both of the criteria which are necessary to be examined by the counts spit pair sub routine so first of all and this is the content of part A if you have an interesting split pair of points with distance less than Delta then they'll both survive the filtering step they'll both make it into the array Sy Y part A says that part B says they're almost adjacent in Sy y so if you have an interesting split pair of points meaning it has distance less than Delta then they will in fact be at most seven positions apart therefore count split pair will examine all such split pairs all split pairs with distance less than Delta and just by construction it compute the closest pair of all of them so again in The Unlucky case where the best pair of points is a split pair then this claim guarantees that the count split pair will compute the closest pair of points therefore having handled correctness we can just combine that with our earlier observations about running time and corollary 2 just says if we can prove the claim then we have everything we wanted we have a correct o of n log n implementation for the closest pair points so with further work and a lot more Ingenuity we've replicated the guarantee that that we got just by sorting for the one-dimensional case now again these corollaries hold only if the claim is in fact true and I've have given you no justification for this claim and indeed even the statement of the claim I think is a little bit shocking so if I were you I would demand an explanation for why this claim is true and that's what I'm going to give you in the next video