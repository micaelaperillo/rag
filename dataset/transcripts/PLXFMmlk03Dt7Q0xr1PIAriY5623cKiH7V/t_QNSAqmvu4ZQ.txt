so in this video we'll go over the basics behind implementing binary search trees we're not going to focus on the balance aspect in this video that'll be discussed in later videos we're going to talk about things which are true for binary search trees in general balanced or otherwise but let's just recall you know why it is are we doing this you know what is the raison Detra of this data structure the balanced version of a binary search tree and basically it's a dynamic version of a sorted array so it does pretty much everything you can do on a sorted array maybe in slightly more more expensive time but still really fast uh but in addition it's Dynamic it accommodates insertions and deletions so remember if you want to keep a sorted array data structure every time you insert every time you delete you probably going to wind up paying a linear factor which is way too expensive in most applications by contrast with a search tree a balanced version you can insert and delete in logarithmic time in the number of keys in the tree and moreover you can do stuff like search in logarithmic time no more expensive than binary search on a sorted array and also you can solve say the selection problem in the special cases the minimum and maximum okay it's not constant time like an assorted array but still logarithmic pretty good and in addition you can print out all of the keys from smallest to largest in linear time constant time per element just like you could with a linear scan through assorted array so that's what they're good for everything a sorted array can do more or less plus insertions and deletions everything in logarithmic time so how are search trees organized and again what I'm going to say in the rest of this video is true both for balanced and unbalanced search trees we're going to worry about the balancing aspect uh in the later videos all right so let me tell you the key ingredients in a binary search tree let me also just draw a simple cartoon example up in the upper right part of the slide so there's a one toone correspondence between nodes of the tree and keys that are being stored and as usual in our data structure discussions uh we're going to act as if the only thing that we care about the only thing that exists at each node is this key when generally there's Associated data that you really care about so each node in the tree will generally contain both a key plus a pointer to some data structure that has more information maybe the key is the employee ID number and then there's a pointer to lots of other information about that employee now in addition to the nodes you have to have links amongst the nodes and there's a lot of different ways to do the exact implementation of the pointers that connect the nodes of a tree together for the video I'm just going to keep it as straightforward as possible and we're just going to assume that at each node there's three pointers one to a left child another one to a right child and then a third pointer which points to the parent now of course some of these pointers can be null and in fact in the five node uh binary search tree I've drawn on the right uh for each of the five nodes at least one of these three pointers is null so for example for the node with key one uh it has a null left child pointer there's no left child Its Right child pointer is going to point to the node with key two its parent pointer is going to point to the node that has key three similarly uh three is going to have a null parent pointer and the root node in this case three is the unique node that has a null parent pointer uh here the node with key value three of course has a left child pointer it points to one it has a right child pointer at points to five now here is the most fundamental property of search trees let's just go ahead and call it the search tree property so the search tree property asserts the following condition at every single of a search tree if the node has some key value then all of the keys stored in the left sub tree should be less than that key and similarly all of the keys stored in the right sub tree should be bigger than that key so if we have some node whose stored key value is X and this is somewhere you know say deep in the middle of the tree so upward we think of as being toward the root and then if we think about all the nodes that are reachable after following the left child pointer from X that's the left sub tree and similarly the right sub tree being everything reachable via the right child pointer from X it should be the case that all keys in the left sub tree are less than x and all keys in the right sub tree are bigger than x and again I want to emphasize this property holds not just at the root but at every single node in the tree I've defined the search tree property assuming that all of the keys are distinct that's why I wrote strictly less than in the left subtree and strictly bigger than in the right subtree but search trees can easily accommodate duplicate Keys as well you just have to have some convention about how you handle ties so for example you could say that everything in the left sub tree is less than or equal to uh the key at that node and then everything in the right sub tree should be strictly bigger than that node that works fine as well so if this is the first time you've ever heard of the search tree property maybe at first blush it seems a little arbitrary it seems like I pulled it out of thin air but actually this you would reverse engineer this property if you sat down and thought about what property would make search really easy in a data structure the point is the search stre property tells you exactly where to look for some given key so looking ahead a little bit stealing my fire from a slide to come suppose you were looking for say a key 23 and you start at the root and the root is 17 the point of the First Street property is you know where 23 has to be if the root is set 17 and you're looking for 23 if it's in the tree no way is it in the left sub tree it's got to be in the right sub tree so you can just follow the right sh pointer and forget about the left sub tree for the rest of the search this is very much in the spirit of binary search where you start in the middle of the array and again you compare what you're looking for to what's in the middle and either way you can recurse on one of the two sides forgetting forever more about the other half of the array and it's exactly the point of the search tree property we're going to search from root on down the search tree property guarantees we have a unique direction to go next and we never have to worry about any of the stuff that we don't see we could also draw a very loose analogy with our discussion of heaps you might recall heaps were also logically we thought of them as a tree even though they're implemented as an array and heaps had some Heap property and if you go back and review the Heap property you'll find that it is not the same thing as the search tree property those are two different properties and that's because they're trying to make different things easy back when we talked about heaps the property was that this was for the extract Min version parents always have to be smaller than their children that's different than the search stre property which says stuff to the left is smaller than you stuff to the right is bigger than you in heaps we had the Heap property so that identifying the minimum value was trivial it was guaranteed to be at the roots heaps are designed so that you can find the minimum easily search trees are are defined so that you can search easily that's why we have this different search tree property if you want to get smaller you go left if you want to get bigger you go right one point that's important to understand early and this will be particularly relevant once we once we try to enforce balancing in our subsequent videos is that for a given set of keys you got to have a lot of different search trees on the previous slide I drew one search tree containing the key values 1 2 3 4 5 let me redraw that exact same search tree here if you stare at this tree a little while you'll agree that in fact at every single node of this of this tree all of the things in the left sub tree are smaller all of the things in the right sub tree are bigger however let me show you another valid binary search tree with this exact same set of keys so in this second search tree the root is five the maximum value and everybody has no right children only the left children are populated and it goes 5 4 3 2 1 in descending order if you check here again it has the property that at every node everything in the left sub tree is smaller everything in the right sub Tree in this case empty is bigger so extrapolating from these two cartoon examples we surmise that for a given set of n Keys search trees that contain these Keys could vary in height anywhere from the best case scenario of a perfectly balanced binary tree which is going to have like logarithmic height to the worst case of one of these link list like chains which is going to be linear in the number of keys in and so just to remind you uh the height of a search tree which is also sometimes called the depth is just the longest number of hops it ever takes to get from a root to a leaf so in the first search tree here the height is two and in the second search tree the height is four if the search tree is perfectly arranged with the number of nodes essentially doubling at every level then the depth is you're going to run out of nodes around the depth of log base 2 of N and in general if you have a chain of n Keys the depth is going to be n minus one but let's just call it n amongst friends so now that we understand the basic structure of binary search trees we can actually talk about how to implement all of the operations that they support So as we go through most of the supported operations one at a time I'm just going to give you a really high level description it should be enough for you to code up your own implementation if you want or as usual if you want more details or actual uh working code you can check on the web or in one of a number of good programming or algorithms textbooks so let's start with really the primary operation which is search searching we've really already discussed how it's done when we discussed the search tree property again the search tree property makes it obvious how to look for something in a search tree pretty much you just follow your nose you have no other choice so you started the rout it's the obvious place to start if you're lucky the root is what you're looking for and then you stop and you return the roote more likely the root is either bigger than or less than the key that you're looking for now if the key is smaller the if the key you're looking for is smaller than the key at the root where are you going to look well the search tree property says if it's in the tree it's got to be in the left sub tree so you follow the left sub child pointer if the key you're looking for is bigger than the key at the root where's it got to be got to be in the right sub tree so you're just going to recurse on the right subtree so in this example if you're searching for say the key 2 obviously you're going to go left from the root if you're searching for the key four obviously you're going to go right from the root so how can the search terminate well can terminate in one of two ways first of all you might find what you're looking for so in this example if you search for four you're going to Traverse a right child pointer then a left child pointer and then boom you're at the four and you return successfully the other way the search can terminate is with a null pointer so in this example suppose you were looking for a node with key 6 what would happen well you start at the root 3 is 2 small so you go to the right you get to five five is still too small because you're looking for six so you try to go right but the right child pointer is no and that means six is not in the tree if it was anywhere in the tree it had to be to the right of the three it had to be to the right of the five but you tried it and you ran out of pointers so the six isn't there and you return correctly with an unsuccessful search next let's discuss the insert operation which really is just a simple piggybacking on the search that we just described so for Simplicity let's first think about the case where there are no duplicate Keys the first thing to do on this insertion is search for the key K now because there are no duplicates this search will not succeed this key K is not yet in the tree so for example in the picture on the right we might think about trying to insert the key six what's going to happen when we search for six we follow a right child pointer we go from 3 to five and then we try to follow another one and we get stuck there's a null pointer going to the right of five then when this unsuccessful search terminates at a null pointer we just rewire that pointer to point to a node with this new key K so if you want to permit duplicates in your data structure you got to tweak the code of insert a little bit but really barely at all you just need some convention for handling the case when you do encounter the key that you're about to insert so for example if the current node has a key equal to the one you're inserting you could have the convention that you always continue on the left subtree and then you continue the search as usual again eventually terminating in a null pointer and you stick the new inserted node uh you rewire the null pointer to point to it one good exercise for you to think through which I'm not going to say more about here is that when you insert a new node you retain the search tree property that is if you start with a search tree you start with a tree where at every node stuff to the left is smaller stuff to the right is bigger you insert something and you follow this procedure you will still have the search tree property after this new node has been inserted that's something for you to think through