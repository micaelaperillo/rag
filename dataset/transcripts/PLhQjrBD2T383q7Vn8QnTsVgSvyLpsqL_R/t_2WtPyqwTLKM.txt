[Music] [Applause] [Music] [Music] [Music] oh all right this is cs50 Harvard University's introduction to the intellectual Enterprises of computer science and the Art of programming my name is David men and actually took this class myself some years ago but I almost didn't it was my first year in college and my roommates and I were living in Matthews hall for those familiar nice Matthews um our claim to fame actually at the time was that our room was literally Matt Damon's just three years prior so uh onward from that but my first year I didn't really have the the nerves to like set foot in this classroom let alone computer science in fact for me computer science and cs50 in particular was very much this class to to beware like I was kind of comfortable with computers but I certainly wasn't among those more comfortable with computers and so I shied away my first year instead I actually took a whole lot of classes in government in fact in high school I was really enjoying history I love this constitutional law class that I took my senior year of high school and so I figured okay if that's what I liked in high school and if that's where my comfort zone was that's probably what I should be doing in college and so I essentially declared as my concentration or major government for the first year year and a half of school but my sophomore year when I was living actually in MA house instead okay no one for ma in MA house instead um it was I I sort of followed some friends I think the first week of class in September of that year to a class called cs50 and honestly like once I stepped foot in that classroom the professor at the time was a famous computer Scientist by the name of Brian kernahan now at Princeton like I was hooked and literally would I go back thereafter on Friday evenings when at the time problem sets were released and like sit down at like 7 800 p.m. on Friday nights and like dive into homework which isn't necessarily something we recommend per se but for me it was like this sign that like wow I've sort of found my calling I found my classmates here on campus and that's not going to be the case for everyone certainly we have no expectations that after taking one computer science class that you will or might want to take others but what's so empowering about computer science and cs50 in particular is it's so applicable to the broader World whether you're in the Arts Humanity social sciences Natural Sciences or Beyond it's just so applicable the concepts and the Practical programming skills with which you will exit a class like this now it's going to be challenging along the way and indeed I put in my time back in the day and even I did find it challenging and here for instance is a photograph of a very famous MIT hack so to speak from down the road whereby it communicates that getting an education from MIT is like trying to drink from a fire hose which is to say there's going to be so much information like so much new stuff that certainly on any given day of the week you're not going to be able to absorb all of it that first time around but at the end of the day it's through that that challenge putting the time in that the returns are therefore just so much higher at the end of the course and indeed will you walk out of the course with a much better understanding not only of computer science and programming But ultimately how to teach yourself new technologies and beyond for the next three plus months will we have teaching fellows teaching assistants course assistance and myself by your side sort of guiding you through the course's material but the goal by terms end is is to take those and leave those training wheels off so that you're well equipped to sort of go teach yourself new and be ideas beyond the class itself take comfort though in knowing that most cs-50 students have never taken a CS course before and indeed as per the syllabus what ultimately matters in this course is not so much where you end up relative to your classmates but where you end up relative to yourself when you began and when you began is thus today and so consider just how comfortable or uncomfortable you are with Computing let alone computer science and programming particularly if you've never explored either in a classroom before and consider the Delta just a few months from now that will really describe how far you have come and that is all that matters not how much the student to the left to the right in front or behind you right now knows um with that said let me add some additional inspiration if I may um here's a photograph of my own very first homework assignment in cs50 from 1996 um and I will draw your attention to the fact that even though this is a so-called hello world program that we'll play with ourselves next week it is pretty much literally the shortest easiest program you can write in a programming language called C I still somehow got minus two on my very first homework assignment which is to say like we're all going to make mistakes along the way but the goal will be to learn and enjoy that process here on out the end of the day too like me you'll exit with your own proudly held hi hook cs50 t-shirt as is our tradition too with that said there's so many other Traditions within cs50 both on campus and off and in particular do we try in cs50 to provide not only the academic support structure that you might want going through the class but also a collective shared Community experience which is to say in just a few days we'll start off the term formally with cs50 puzzle day which is not only an opportunity to get together with friends with pizza and prizes and also logic puzzles of sorts but really to send the message the computer science itself is not about program it's not about C it's not about python it's not about programming languages per se but about problem solving ever more so collaboratively with other smart people by your side in this class or Beyond and indeed are there at toward the end of the semester reinforcements of the Same by way of a little something that we call the cs50 hackathon which will be an opportunity overnight to dive into your own final projects the Capstone of this course there after followed by the cs50 fair which will be a campus-wide exhibition for students faculty and staff across campus of your very own final projects be it your very own web app or mobile app or anything else you decide to create by terms end and indeed the the sort of objective at the end of the day truly with that final project in particular is going to be to create for yourselves for your classmates for attendees something that we didn't even teach you how to do and indeed that will signal ultimately that you're indeed on your way and ready toward that end thought we would give you a sense of cs50's past by way of have this short video if we could dim the lights that paints a picture of all that awaits here and Beyond [Music] a [Music] all right so welcome aboard to cs50 and computer science itself so what is computer science well put simply it's the study of information like how do you represent it and how do you process it but more fundamentally what we'll teach in this class is computational thinking that is to say the application of ideas from computer science to problems of interest to us within the class and problems of interest to you after the class and so at the end of the day what computer science really is is about problem solving Argo that sort of global applicability and by problem solving we mean something quite simple in fact we can distill it as follows with this mental image this is problem solving you've got some problem to solve thus known as the input that you want to solve and the goal of course to problem solving is to actually produce a solution so the output in this model would be the solution the interesting part ultimately it's going to be in how you process that input and turn it into that output airgo solve problems but before we can do that we all kind of have to agree how to represent these inputs and outputs especially if we want to do it in a standardized Global Way using literally computers be them laptops desktops phones or almost any other kind of electronic device nowadays so how can we do that well there's different ways to represent information in the world for instance if I were to take attendance uh old school style maybe in a smaller room I might do one two 3 4 5 6 7 and so forth and just count people on my human hands that's actually known as unary notation otherwise mathematically known as base one because you're using your fingers literally in this model as digits but little quick question how high can you count with one human hand five is incorrect if you use a different base system than one so it's obviously correct if you're just using unary and just counting 1 2 3 4 five but I dare say I can come up with more patterns in my human hand alone that would enable me without a second hand or a couple of feet to count higher than five in fact maybe for those more comfortable how high Could you actually count on a single human hand perhaps so 31 believe it or not is in fact the correct answer but why well here I initially started pretty naively 1 2 3 4 five and I just kind of combined all of my fingers and counted the collective total but what if I'm a little more clever and take into account the pattern of fingers that go up so maybe this is still zero this is one but now maybe we just agree universally that this is two even though it's just my single pointer finger maybe we all just agree that this is three with two fingers up maybe we agree that this is often offensive with just one middle finger up but this would then be four this could then be five this could then be six this could be seven and if I keep permuting my fingers in this way allow me to spoil it this would be in fact 31 but again why but the difference here is that we're no longer using unary or base one as a mathematician would say but rather base two because if we take into account not just the total number of fingers that I'm using but whether each finger is down or up being therefore in two potential States down up a b black white however you want to distinguish those two states of the world you're now operating what's called base 2 and perhaps more familiarly even if you're not a computer person per se this is the so-called binary system and odds are even if you're not a compter computer science person at all you probably generally know the computers only understand or speak what what alphabet so to speak so zero ones and zeros zeros and ones otherwise known as the binary system and in fact there's a term of art here that's worth noting when you're using zeros and ones which of course are a total of two digits you have binary digits so to speak by implying two which means there's two possibilities zero or one if we actually get rid of some of these letters and then join these two phrases here you have a technical term that is a bit a bit is just a binary digit which is to say it's a zero or one and this is in contrast of course with the system you and I know as the decimal system deck implying 10 because in the real world you and I daily use 0 through n which is 10 possibilities computers only use zero and one that is to say two bits to represent information instead so how do we represent this information especially when at the end of the day what we're using are indeed computers and electronic devices well if I want to represent zero I can actually think of this as kind of analogous to the physical world maybe I have a a light bulb that's off or on and controlled by a switch that turns it off or on so you can think of a binary digit that is a zero as really just being a light bulb that is off by contrast if you think of a one in the digital world as of course being the second of two possibilities you can think of that in the human or analog world the physical world as being a light bulb that is on and in fact what's inside of your Mac your PC your Android phone your iPhone are millions of tiny little light switches known as transistors that just can be turned on or off on or off and essentially you can use those transistors to store information because if you want to store a zero you turn one of those switches off if you want to store a one you turn one of those switches on of course that sort of invites the question well how do we count higher than zero or one well we would seem to need to use more than just maybe a single bit a single light bulb so if we wanted to count higher than for instance zero or one why don't we go ahead and maybe do this so just so I have some place to put these let me borrow some of our actual physical light bulbs here from the stage and let me propose that now with three bits on the stage three light switches three transistors whatever metaphor you're most comfortable with this is how a computer would represent a zero because all of them are off so it's off off off but if a computer wanted to count to one we could do naively this we could turn this on and if a computer wanted to turn represent two we could do this and if a computer wanted to represent three we could do this but I'm kind of painting myself into a corner and not using these light bulbs as cleverly as I could because at the moment I've only counted as high as three so if I want to count to four to five to six I'm going to need more and more light bulbs can we be a little more clever well again someone else who's among those more comfortable what's the spoiler here how high using binary zeros and ones could I count with three light bulbs total and back yeah so seven here is the answer and if that too you're sort of wondering how are people figuring out 31 and 7 that's the goal at hand here so let me do this let me turn all of these off again so that my three light bulbs are switches again represent zero and the first one's easy this is how a computer would represent the number one it would be on off off how though is a computer going to represent two well just like my proposed finger example let's do this let's turn this one off and this one on that is how a computer would represent two by saying off on off in other words 0 1 0 would be the way to pronounce it digitally what if I instead want to represent three that's how on my finger I did this with two fingers well I'm going to turn this one on this is three now this will for those as comfortable than be nonobvious this now is how I would represent the number four this is how I would represent five this is how I would represent six and this as per the spoiler is how I would represent seven so perhaps very nonobvious what it was I just did or why I chose those patterns but I dare say if you sort of rewind in your mind's eye or literally later on video you'll find that I actually did show you eight distinct patterns of light bulbs the first one was off off off the last one was on on on and there were another six total in between them well wait why seven well if you start counting at zero and I claim there's eight possibilities you can only count from zero to seven as we will soon see so how are these patterns coming about and what is it that our computers are actually doing well it's actually doing something a little like this quite like in decimal so in the human world you and I are very much in the habit of using base 10 0 through 9 AKA decimal well how do we use it instinctively as humans well what's this number obviously on the screen 123 but why is it 123 like for years you haven't really thought about why this pattern of symbols or digits on the screen 1 2 3 represents mathematically this number that you know obviously as 123 but if you Reign to grade school odds are like me you were taught that the rightmost digit is in the ones column this second digit is in the 10 column this digit is in the hundreds column and so forth so even though none of us have to do this math explicitly what you're instantly doing is 100 * 1 + 10 * 2 + 1 * 3 which gives you 100 + 20 + 3 oh that's why it is 123 because these digits in this order have that significance the digits to the left have more weight so to speak than the digits to the right so what can we take away from this well let's generalize at first as just any three-digit number so number number number the ones column the T column the hundreds column but there's some math going on there and it's not particularly sophisticated those are actually powers of 10 so 10 the 0 10 the 1 10 to the 2 and there's your decimal system because the base in this value is a 10 that's because there's 10 possibilities for each of those placeholders 0 through 9 but in the binary world in the world of computers where all they have are zeros and ones why because all they have physically is transistors tiny tiny tiny light bulbs that can be off or on if you only have two digits to play with the 10 base should of course become a two base and now if we do some math here two to the 0o two to the one and two to the two you get the ones column the two's column The Four's column and if we keep going eight 16 32 64 128 and so forth It's powers of two instead of powers of 10 but this is to say computers represent information in exactly the same way you and I have since childhood but they have fewer digits at their disposal so these columns need to be weighted differently so we can still count from zero all the way up toward Infinity so what does this mean well here we have three bits on the screen 0 0 0 if we were to convert this now mentally or on paper pencil to decimal how do we do it well 4 * 0 + 2 * 0 + 1 * 0 that gives us the mathematical number you and I know know as zero that was three light bulbs off off off well what if we turn on one light bulb all the way on the right what decimal number does this binary number 0 01 represent just one because it's 4 * 0 2 * 0 1 * 1 here's where things got more interesting even if non obvious in light bulb form or even physical hand form 0 one0 in binary is what in decimal two cuz it's 2 * 1 and that's it 0 1 1 in binary is of course now three this is now four this is now five this is now six and seven on on on or one one one is the highest we can count with these three bits all right so how might a computer intuitively count as high as eight what do you need to do presumably you going need to add a bit so you need another light bulb another switch you need more memory so to speak to use nen clature with which you're probably familiar so in fact if we change all of those to zero we give oursel one more bit for a total of four Ah that's got to be the e place cuz it's just another power of two so 1 0 is the decimal number eight you don't say 1,000 in binary you literally say 1 z0 0 but that is the number you and I know as eight and you can keep going up and up and up and how then computers with Excel or any kind of number crunching software count really high and keep track of really big numbers the computer just throws more and more transistors at it more and more bits to count higher and higher and higher than this turns out though one bit three bits even four bits aren't that useful in practice CU like literally you can count as high as uh seven or maybe 15 or 31 so more commonly as as is commonly known is to use a bite of bits instead uh how many bits is in a bite for those familiar so just eight why eight it's just more useful than one or two or three or some other number and as an aside it happens to be a Power of Two which is just useful electronically as well so a bite then is just eight bits and here are those columns I rattled off off the top of my head here is how a computer would represent zero in decimal but using eight binary digits or bits uh little trivia and again this is not what computer science is about but it helps to sort of know sort of the lower bounds and the upper bounds of these kinds of values how high can you count with eight bits or one bite if this is zero yeah so it's actually 255 so if I were to change all of these zeros to ones and then do some quick mental or calculator math 128 plus 64 plus 32 16 8 4 2 and 1 would actually give me 255 total plus zero which gives me 256 total possibilities so this is only to say this is not again the kind of math we'll frequently do but you'll commonly see in the computer world and programming world powers of two numbers like 255 256 why because these are the common units of measures that systems tend to use so let me pause here and see with respect to Binary zeros ones transistors and the like any questions or confusion we can clear up a really good question why are bits just on or off instead of maybe uh sort of 0% 50% 100% by playing with voltages so the voltage inference of yours is actually correct that what computers typically do maybe they use zish volts to represent zero maybe fiveish volts to represent uh uh to represent one it turns out it's just really easy to do Extremes in computers if you start to split that range of voltage levels for those who remember any of their electricity it just gets harder and harder to be exact and if you get things a little too murky you might mistake a zero for a one or a two or a three so it turns out it's just simpler to use the binary system but there do exist computers known as tary computers that actually use three values 0 1 and two which is somewhere of course between binary and decimal but you can do different things it's just simple on and off and case in point I don't want to really be dramatic and turn off my computer but if I pulled out the power plug that could be off literally AKA Zer plug it back in that's a one there's just a cleanliness and simplicity to that other questions or confusion that we can clear up no okay so if if you're in agreement for the moment that okay using just zeros and ones we can represent any number we want from zero on up let me propose that we do more useful things with our computers and our pockets and desktops and Laps like represent letters for the sake of Google docs Microsoft Word or any kind of text uh text that we might want to write so knowing now that computers only contain or only use zeros and ones and therefore only contain Hardware like transistors how could you represent something like a capital letter A in English inside of a computer which of course is not a number anymore like what could we do yeah okay yeah so we could take the alphabet A through Z in English and we could just assign each letter a number and honestly that is not only the correct answer it's really the only answer because at the end of the day if all you have are zeros and ones available to you that is the entirety of the potential solution to this problem so it turns out that yes capital letter A some years ago was decided by a bunch of people in a room shall be represented with this pattern of zeros and ones 0 1 0 0 0000 0 1 and now trained as you are to do a bit of quick binary math what decimal number is used to represent apparently capital A so 65 because it's 64 + 1+ 1 * 1 is 65 what is B turns out it's 66 what is C 67 so they kept things simple there on out might have been nice if a were zero or maybe a were one but nope we're stuck with 65 instead but everything after that is very much predictable and in fact for lowercase letters there's a whole uh other set of numbers uh such as lowercase a happens to be 97 lowercase b happens to be 98 and so forth but again this is sort of like CS trivia but what's important here is that they're indeed contiguous from 65 to 66 to 67 on up that's something we're going to be able to let bage beyond the letter A alone what is this system what is this mapping that you yourself proposed it's asy the American Standard code for information interchange and indeed it was a bunch of Americans years ago who came up with this system unfortunately at the time they only allocated seven and eventually eight bits total for representing letters both uppercase and lowercase numbers on the keyboard as well punctuation symbols as well and so per our conversation a moment ago if the Americans in this room so to speak only used eight bits total how many different characters can we represent with a computer in this story so only 255 technically 256 if we again start counting from zero so that's not nearly enough but it is to represent all human languages but it is enough to represent at least English among some others so here for instance is a chart of the asky mapping and sure enough if we zoom in on like this column here 65 is capital a 6 6 is capital B dot dot dot 72 is H 73 is I and so forth so there is a standardized mapping for at least all of these English letters well suppose you were to receive an email or a text message or like a Google doc containing this pattern of zeros and ones so 0 1 0 0 1 0 0 and so forth and so forth so three bytes worth three sets of eight bits that is to say three bytes Each of which represents a single letter in aski what message have you received well I'll do the math this time so we don't have to suppose what you really received was decimal 72 73 33 what message did you just receive if you recall the previous chart I was in fact correct why because H is 72 I is 73 and wait a minute 33 so here's H here's I 33 if we uh um highlight it instead happens to be an exclamation point so like that is literally what is going on underneath the hood so to speak when you get a text message today that literally says in all caps and an exclamation point hi your phone has received at least three bytes Each of which represents a letter of the alphabet your computer is quickly doing the mental math to figure out exactly what numbers those are and then looking up in the so-called asky chart in its memories uh in some sense what letter should you actually see on the screen there and so if you were to then display that message um you would see it indeed in English as opposed to those numeric equivalents how else might we use this then well here again is that chart and maybe just to vary things maybe take a little pressure off of me here why don't we try spelling something else this time a different three-letter word but maybe eight volunteers could we get a bites worth of volunteers and I can sweeten the deal with some stress balls in exchange you just have to be comfortable coming up on stage and being on the internet so yes one two about 3 4 about five six 7 and how about eight come on up a round of applause for our volunteers yep come on all right so what I'm going to have each of you do is represent a bit in a particular order so if you want to just in any order line yourselves up here facing the audience come on over all right and we will have you repres well we got to see who who ends up where I'll sco this way a little bit this way this way all right so you shall be the one's place and just hold that in front of you two's Place three's uh Four's Place eight Place 32 64 and 128 and just compress yourselves a little bit if you could so each of these folks represents a bit in a particular place and let's say this if you're just standing there sort of uncomfortably without any hand raised we'll assume that you're representing a zero quite simply if your hand goes up though the audience should assume that you're representing a one and therefore what we'll do is spell out a three-letter word and on each round of this you'll either stay stay like this or you'll raise your hand but first let's actually meet some of our volunteers here uh starting with position number one if you'd like to say your name perhaps where you're from and or studying hi my name is Brooke I'm from Indiana and I'm studying biology and computer science nice welcome hi I'm Becca I'm from like Maryland DC area and I'm studying electrical engineering welcome hi I'm Addison I'm from Maryland I'm studing engineering hi I'm Sharon I'm from Ronda and I'm studying CSN math welcome hi I'm Grace I'm from Alabama and I'm studying electrical engineering welcome hi I'm Angelina I'm from Maryland and also I say Matthews nice Matthew nice and I'm studying applied math and econ as well as environmental science and public policy welcome I'm Owen bells and I'm from roal Virginia and I'm studying CS nice welcome and and my name is Max I'm from London I'm am also staying in Matthews and I'm studying computer science and Neuroscience thank welcome aboard as well if you're wondering too why I was wearing these glasses at the start so very common on the internet nowadays is these POV video so it turns out these Ray bands actually record video footage and we have a couple of them and we thought we'd offer them to a couple of volunte if everyone wants to record their point of view for everyone here and Vlad here is going to help make sure they're recording second volunteer yes number two all right so as Vlad gets those set on the backs of your pieces of paper you have instructions for the following three rounds each round represents a letter the audience participation part of this is to actually do the mental math to figure out what number these volunteers are representing so go ahead and execute round one either keeping your hand down or raising it appropriately okay what number are our volunteers here representing 66 because we have a 64 plus a two that then maps to what asky letter B was the first letter okay hands down round two go little harder what's now being represented I'm starting to hear it 79 is in fact correct 79 cuz we have a 64 and an 8 and a four and a two and a one so if it's a 79 we have the asky letter O Okay so we've got b o and then lastly third round go we have 01 01 0111 what number is this 87 which spells the letter W which spells the word not B Take a Bow if you could all right a round of applause for our volunteers here and come on off this way and help yourself to a cs50 stress Spa apprciate it thank you thank you to our volunteers so this is only to say we've now agreed on how we can represent numbers from zero on up we've agreed on how we can represent letters but at least letters using asky and in fact these are more than just decoration in fact there a little bit of uh trivia by lectures end if you want to come up for your very own cs50 stress ball turns out there's 64 light bulbs at the foot of the stage here if you break them down into eight bite or single 8 bit or single bite chunks there's an eight-letter word that happens to be spelled out today using this here asky chart so today's mystery is what exactly is that their word but of course if you have only eight bits you can only represent like 256 characters which sounds like plenty for English and indeed it is 0 through 9 a through b capital and lower uppercase and lowercase as well as punctuation but there's so many other languages in the world that have other characters for instance we have act not just the English alphabet we might see here on a US English keyboard we have accented characters we have uh various Asian languages have even many more glyphs we need more than 256 possible characters and so nowadays computers do not just use seven or even eight bits they might use eight bits for some letters like all of the English letters they might use 16 bits for certain other languages maybe even 24 or 32 bits and fun fact if you have 32 bits and we have more than that on the stage if you've got 32 bits you can actually represent as many as 4 billion possible characters which is quite a bit no pun intended so what else can we represent well the goal of this system not just ASI but something known as Unicode which is a newer standard is to be backwards compatible with ASI so humans left all of those other numbers alone 65 66 67 and so forth but they added to it a super set of representations that maybe are 16 24 or 32 bits the goal being to be able digitally to represent all human languages past present and future and even through uh pictograms things like uh smiley faces and the like even people places things in emotions that transcend human language and in fact odds are within the past few minutes or hours most of you have used one or more of these here Emoji these pictograms which it turn out are just characters on a keyboard you might have to hit a special button to pull up that form of the keyboard but these are just here characters and so these Emoji have exploded in popularity for a number of reasons one of which is my God what are we going to do with four billion possible patterns of zeros and ones we can start to kind of have some fun with it and represent things Beyond English and human languages alone now as an aside um when it comes to Unicode it turns out Unicode years ago standardized this pattern of 32 zeros and ones to represent just one of those Emoji so Emoji tend to use even more bits here um anyone know what decimal number this is this is not a fun mathematical exercise the spoiler is 4 b36 m991 106 is the decimal number that actually represents as of present the most popular Emoji in the world does anyone want to Hazard a guess what emoji this here number represents heart hearts no but it's actually this so-called face with tears of joy so perhaps think about the frequency would you send that one and even though it's obviously a picture on the screen sure it actually is more like a font because underneath the hood it's indeed just a pattern of zeros and ones or a decimal number that the computer is storing but the computer be it Mac OS or Windows or or iOS or Android know to display that pattern as this here picture but the pictures might look different depending on the hardware why because there's companies like Google and Microsoft and meta and others that have their own artists on staff as employees and those artists interpret the descriptions like face with tears of joy differently so those of you with an Android phone actually see face with tears of joy looking a little something like this and if you have telegram for instance installed on your phone it's even more animated than that it's this here Emoji using the same pattern of zeros and on so different artists render these here Emoji in different ways but all they are here are patterns now for all of the other answers save one that was uh shouted out a moment ago this is a sort of um uh Cloud diagram of the most popular Emoji as of a couple of years ago per Unicode whereby the size of the Emoji indicates its relative popularity so heart I did hear over here is indeed one of the most popular ones as well question a really good question why do certain Emoji not show up on one device or another it depends on how recent the software is pretty much every year the humans behind the Unicode Consortium release new Emoji which is to say they decide that this other pattern will represent this new Emoji this other pattern will represent this new emoji and unless you update your phone your laptop your desktop to the very latest software and the manufacturer of that device or software also updates by hiring an artist to draw those pictures in their own font in their own style you're going to see usually just like an empty black square or maybe just like a black and white heart instead of something more colorful really just placeholders because it's as though you don't have the right font installed or really you have an older version of that same font installed but it's become sort of an annual tradition that new and more Emoji are released every year which is among the reasons why uh these updates contain more and more yeah do that is an amazing segue how do you represent color in bites well you use RGB which happens to be by coincidence the next SL so let's again recap we know how to represent letters we know how to represent numbers we can even represent Emoji but those Emoji technically on the screen are of course composed of colors like a whole bunch of yellow for that their smiley face how do computers then using only zeros and ones represent colors well by convention they typically use a system that by an acronym is called RGB red green blue and this is to say that a computer to represent a single dot on the screen maybe this one this one this one will allocate some number of bits or some number of bytes to represent the color of just that their dot otherwise known as a pixel you can actually see pixels on your phone or even on your TV or monitor if you go really close especially if it's an older monitor you can see the tiny little squares each of those has some number of bits telling the device what color to use in particular these devices typically use three numbers in total three bytes so that is to say 24 bits per pixel and they do this if you were to represent a single dot on the screen using these three numbers just by intent here this is 72 73 33 which in the context of a text message an email a Google doc represents of course High textually what if a computer uses that same pattern of zeros and ones that is the same pattern of decimal digits to represent the color on a screen which is gerine if you're opening an image using Photoshop so using a different piece of software that knows about colors and images and not just text well this would imply that you want that dot on the screen to have like a medium amount of red a medium amount of green and a little bit of blue why do I see medium and little well again if each of these numbers is using eight bits or one bite the highest we can count as we discovered was 255 so I'm kind of averaging here so 72 out of 255 feels to me like a medium amount of red 33 feels like relatively little blue but if now the computer combines those wavelengths of light so to speak a medium amount of red medium amount of green a little bit of blue what you get is the color code for a single Dot and does anyone want to guess what color roughly this represents these three bites not white not purple not brown yellow in fact is the answer so it represents in a single Pixel roughly this shade here of yellow which is to say if we look back at any of those Emoji which again are represented by patterns of zeros and ones but you and I as humans perceive them as images on the screen let me actually go ahead and zoom and zoom in further to one such sample emoji and when you zoom in far enough or you put the phone close enough to your face you can actually see all of those little dots known as pixels all of the little squares and given that so many of these pixels are yellow that is to say that that pattern of three bytes 72 73 33 is used to represent this pixel another three identical bytes are used to represent this pixel this one this one and so forth so now if you've taken digital photos on your phone or a camera you're probably generally familiar from the internet and Hardware today that a photograph is what like 1 Megabyte 10 megabytes depending on the resolution of it well megabyte means millions of bytes where are all of these bytes inside of these photographs or these images you're taking or downloading they correspond to every one of the single pixels on the screen there's at least three bytes being used to represent every one of those dots as an aside bit of a white lie because nowadays there's fancy compression software that can use fewer than that many btes but in general that's where all of those btes those millions of btes are coming from so how was that for an answer to how do we represent colors thank you so if we agreed now that there's this way and perhaps others to represent colors well how do we represent not just images but videos well videos you know once a upon a time or movies were called Motion Pictures so Mo pictures with motion why is that well it's analogous to growing up if you ever played with one of these picture books and in fact there's memes nowadays that have made these popular again whereby you have a whole bunch of images on individual sheets of paper and if you flip through them fast enough your human mind and eyes perceive it as actual motion even though you're just seeing image image image image image image but it's so fast it looks like motion that's all a video is on your screen that's all a film is on your TV it is not in fact continuous motion it's maybe 30 frames or images per second maybe 24 frames or images per second which is to say we know how to represent numbers we know how to represent letters we know how to represent colors and thus images now we kind of get videos for free because it's just more of the same use more and more of those patterns why are videos so darn large why are they gigabytes to download billions of bytes because there's so many darn images 30 some odd images per second in those kinds of videos and maybe lastly just to top off our multimedia how could you represent sound maybe musicians in the room how using only zeros and ones could you represent something as serous as music something analog as digital yeah yeah so each number that we store in the computer could correspond to a certain frequency which has a direct relationship to the the sound or the pitch of a note for instance in the world of piano and many other instruments you've got like your a your B your C maybe you have Sharps and flats as well we could just agree like the asky people did years ago to represent the musical note a let's use this pattern musical note a sharp let's use this pattern and so forth but maybe pitch alone or frequency alone is not enough maybe we need that number but maybe a second number for the volume the sort of digital equivalent of how hard are you hitting the key on the piano maybe a third number for how long are you holding the key down so maybe the pitch and the volume and the duration kind of like RGB we could use three bytes to represent every musical note in some piece and if we wanted to keep track of what instrument should be played by the computer to sound that music well maybe that's just a fourth bite or something else as well which is to say at the end of the day all we have are these zeros and ones to throw at the problem so for now that's it for representing information we've got our numbers we've got our letters we've got our IM colors and images our videos and now sound any questions on how computers then are representing as promised those inputs and outputs using just zeros and ones yeah in the middle computer correct so the computer is taking as input at the end of the day zeros and ones and is outputting zeros and ones however as we'll learn in this class by writing software by writing code that understands those zeros and ones we will enjoy not just literally seeing zeros and ones we will see a b c we will see colors we will see uh video we will hear sounds so long as we write the code to interpret those zeros and ones and indeed it's worth noting now that that same pattern I keep using for an example 72 73 33 how does a computer know is that the message high is that the color yellow is it a dot in a video alone just depends on the context simply put if you're opening that pattern of zeros and ones with like Excel or a calculator program odds are the software will interpret those three bytes as numbers of course if though you open that same pattern in a text messaging program Google Docs Microsoft Word they that same pattern will be interpreted as a sequence of letters instead if you open Photoshop that same pattern you'll probably see a single dot that happens to be yellow conversely once you yourself are a programmer or even better programmer you will be able to write in code how you want the computer to treat these patterns of zeros and ones you can essentially tell the computer use this to store a number or a letter or a color or something else that's the power the programmer themselves have at the end of the day other questions on representing things with bits no all right so lastly then in this middle of this black box so to speak is the sort of Secret Sauce that s soles problems that converts those inputs to outputs those problems to Solutions so what is an algorithm it's really just step-by-step instructions for solving some problem and indeed I think back to my own first time in cs50 where we learned the same from Professor Brian kernahan and as luck would have it just had my 25th Reunion where we pulled some video footage from 1996 and so we're actually fortunate to have the very first few minutes of cs50 over 25 years ago when I myself took it but the lessons back then as today are fundamentally the same and what's important indeed is to not only express yourself correctly but precisely as we'll explore today this then is Professor Brian kernahan who years ago very me memorably introduced us and my classmates to algorithms by actually in class shaving his beard if we could dim the lights here for Brian the other thing that we're going to talk about in this class is the notion of an algorithm an algorithm is a very precise description of how to do something and the operative word there is precise okay it has to be very very very very precise and the task that I am going to do is that I'm going to trim my beard which has gotten out of whack and I brought a variety of things which one might use to trim beards with [Applause] so suffice it to say I don't have much of a beard but I do have this here other technology known uh Once Upon a Time as a phone book and these phone books of course have lots of information in them happen to be storing numbers and letters in particular for those unfamiliar uh they are storing humans names from uh A to Z here in English and associated with everyone's name as a number so even if you've never had occasion to physically use this kind of device turns out it's pretty much equivalent to the contacts or the address book app on your iOS phone or your Android phone as well why because if you pull up your contacts of course you see some familiar names here alphabetized by first name or last name and if you click on any of those names you reach the person you're presumably trying to call or text pictured here then is John Harvard's whose number here is +1 949468 2750 which you're welcome to call or text at your leisure but here is John Harvard that's partway through the phone book digitally well it turns out that physically in the phone book we might use an algorithm step-by-step instructions for finding John Harvard in pretty much the same way as iOS Android Mac OS windows or other operating systems themselves use so I could when looking for John Harvard first name starting with j i could start at the beginning of the phone book and start looking Page by Page by Page for John Harvard and if he's there I can call this is an algorithm it's indeed step byep but that was a bug few pages turned but is this algorithm correct step by step assuming I'm paying attention so yes like if John Harvard is in here I will eventually find him once I get to the J section now this is a little tedious it's going to take like a while few dozen few hundred pages so maybe I could do things a little smarter from grade school like 2 4 6 8 10 12 12 14 16 and so forth going twice as fast is that algorithm correct so no but why I could miss him right I could just get unlucky really with 50-50 probability because John Harvard could be sandwiched between two pages now this isn't a complete loss this algorithm maybe what I could do is if I get past the J section to like K I could double back at least one page just to make sure I didn't miss John Harvard so I can still go twice as fast plus like an extra step just to make sure I didn't mess up so the first algorithm might take as many pages as there are in the phone book so if this p phone book has a th000 pages in the worst case if I'm not looking for John Harvard but someone whose name starts with z might take me a thousand pages to actually get there second algorithm twice as fast literally might take me 500 plus one step to get there because I'm going two at a time so long as I indeed fix that bug but what we used to do back in the day and what your phone is doing today albe it digitally is going rough to the middle of the phone book looking down and realizing oh I'm accidentally in the M section so halfway through the phone book but what do I now know about John Harvard is he to the left or to the right so he's obviously to the left because J comes before M so what I can do literally and what your computer does figuratively is tear the problem in half throw half of the problem away leaving us now with the same fundamental problem but it's half as big so I've gone from a th000 Pages suddenly to 500 pages and compare this to the other two 1,000 Pages 999 998 versus 1,000 Pages 998 996 994 that's still slow I went from 1,000 to 500 in just one step of this algorithm what do I do next I go roughly to the middle here oh I went a little too far I'm in the E section now so is John Harvard to the left or right now so he's to the right so I can again tear the problem in half throw the left half away knowing now that John Harvard must alphabetically be in here and I can divide and divide and divide and conquer this problem again and again by using that heris of going left or going right and I dare say if I do this correctly I'll eventually be left with one single page on which John Harvard's number actually is or maybe he's not in the phone book at all so how many steps maximally might that third and final algorithm take it's not a thousand it's not even 500 or 5501 how many times can you divide thousand pages in half again and again and again roughly nine 10 so typically 10 times give or take there's a bit of rounding there because it's not a perfect power of two but roughly 10 times like that is fundamentally better than both of the two algorithms because I go from a th000 pages to 500 to 250 to 125 and so forth literally having the problem again and again so we can actually appreciate and see this even more so graphically and this is among the things we'll do later in the term when we speak to not only writing correct code but is your code welld designed is it better than your previous code is it better than someone else's code is it better than some other product if you have given more thought to the algorithms and the quality thereof you can perhaps minimize the time required to solve problems but no less correctly so if we have a simple XY plot here on the Y AIS or vertical is the amount of time to solve in whatever unit of measure seconds Pages however you want to count on the horizontal or x-axis is the size of the problem measured in for instance numbers of pages so this would mean zero pages in the phone book this would mean a lot of pages in the phone book this would mean no time to solve this would mean a lot of time to solve what's the relationship then among those three algorithms well the first one is essentially a straight line a slope of one and if the phone book has n pages in it we'll describe the slope here as essentially one over one for the algorithm with uh the first algorithm turn Page by Page by page which is to say if we were to add one more page to the phone book next year first algorithm is going to take one more step but the second algorithm is definitely better it's definitely faster but it's still a straight line so it's going to take roughly n/ two steps on average because you only have to go through half of the phone book because you're going two pages at a time instead of the whole phone book in the worst case if someone's name is z to go through every page in total so if we actually compare these let me just draw some dashed lines suppose that you have this many pages in the phone book if you just draw this vertical white line here it's going to take this much time in red using the first algorithm but it's going to literally take half as much time in yellow for the second algorithm because you're literally going two pages at once but the third and final algorithm is a fundamentally different shape it instead looks a little something like this it looks like it's flatter and flatter and flatter it's always increasing it never gets perfectly flat but it grows so much more slowly as a function of phone book size and for those who recall their ALG their logarithms this would be described as log base 2 of N and in fact that's where the math came from log base 2 of 1,000 is roughly 10 in total even if you need a calculator to confirm this much but this shape is fundamentally different why well suppose that Cambridge where we are in Austin the town across the street next year combine their two phone books and they go from a th000 pages each to one phone book with 2,000 Pages the first algorithm is going to literally take twice as many steps or Pages second algorithm is going to take half as many or 50% more because you're going two at a time but the third algorithm is going to barely Miss A Beat why because if this is a th000 Pages here and 2,000 pages is over there just inferring from the shape of the green line it's not going to be much higher on the vertical axis than uh the other two were so more specifically if you have a 2,000 page phone book next year how many more more steps will it take you using that third and final algorithm just one because you'll divide and conquer a 2,000 page phone book into a 1,000 page phone book and then you're back at the original story and that's the sort of power of learning algorithms That's The Power of learning computer science and learning how to program is to be able to navigate Big Data so to speak things the size of Google things the size of artificial intelligence training data sets using better and better more clever algorithms that perform faster and therefore not only make the software more competitive but also make it more usable and more favorable for people like you and me when using that software so when it comes to implementing algorithms as programmers as computer scientists what you're really doing is taking these algorithms which might be expressed in English conceptually as we just did but really just translating them to code be it's C or C++ or python or r or Ruby or any number of other languages that exist in the world but for now let's consider how we might Implement that algorithm using something that's literally still English but pseudo code something that is still correct but precise and finite as per Professor kernan's advice which is to say use your own vernacular of English and just say what you mean but very succinctly there's no one way to write pseudo code it's not some formal language I'm just going to convert the steps I did intuitively to stepbystep instructions as follows step one what I did was pretty much pick up the phone book step two what I did was prettyy much open to middle of phone book for the third algorithm step three look at page step four if person is on page then step five call person if that does not prove to be the case step six else if the person is earlier in the book then open to the middle of the left half of the book and then go back to line three then if the else if the person is later in the book open to the middle of the right half of the book and again go to line three else there's a fourth and final case if the person like John Harvard is not on the page is not earlier is not later what's the fourth scenario we'd best consider he's just not there else we should do something specific like quit now as an aside everyone in this room has probably had one of these stupid technical support issues where your phone or your laptop or your desktop computer just freeze all of a sudden or maybe it spontaneously reboots for no reason odds are that's because not you but some other human made a mistake they probably wrote code working at Microsoft or Apple or Google or somewhere else and they didn't actually anticipate that oh there could be a fourth scenario that could happen in the real world but if there's no code that tells the computer what to do in that fourth and final scenario who knows what the computer is going to do it might by default reboot it might by default freeze that's just a hint of the bugs the mistakes in software to come but even though this is just one way to write this code AKA pseudo code there are some Salient characteristics that we'll use throughout today one there are these verbs these actions and henceforth as aspiring computer scientists or programmers we're going to start to call these by what uh more more technical audience would these are functions a function is an action or a verb it's like a bite-sized task that a computer can do for you those then are functions in this Udo code but there's other types of code in here there are these things here if else if else if else those are example of what we're going to start calling conditionals these are sort of proverbial Forks in the road where maybe you go this way maybe you go this way but you decide which way to go based on a question the questions that you ask are what we'll technically call Boolean Expressions named after mathematician bull a Boolean expression is a question with a yes or no answer a true or false answer a black or white answer a one or zero answer there's two possibilities and there's a hint of the binary underneath a Boolean expression is going to tell you yes or no you should go down that fork in the road notice what's important here is that indentation mattered as a result notice that on line four when I first asked if the person is on page question mark so to speak I should only do line five per its indentation if the answer is yes or true I should only open to the middle of the left half of the book and go back back to line three if person is instead earlier in the book so indentation in pseudo code and in many programming languages has logical significance it tells you whether to do things or not but there's another construct in here go back to go back to which literally makes me go back to line three potentially again and again and again creating some kind of cycle or what we'll typically call a loop instead so even in this relatively simple real world algorithm we have these four fundamental character istics of most computer programs that we will write in this class and you might write Beyond this class that we have some technical jargon now to describe them but what's important to note is that line eight and line 11 even though they're saying go back to line three go back to line three you might think you're running the risk of what we'll call an infinite Loop where you literally get stuck in a loop forever which doesn't sound like a good thing if at some point you want to turn your computer off even though it's still working but these will not induce infinite Loop why what is happening in this particular algorithm every time we go back to line three that guarantees eventually we will stop going back to line three person on page exactly if the person is on the page we will call them or we will quit but more importantly because we keep dividing and conquering the problem in this case having the phone book having the phone book eventually we're going to run out of phone book in which case indeed John Harvard is either on that page or not and we will call or we will quit instead so we'll see in time and in fact allow me to promise odd are at some point you will write code that seems to take control of the computer for you where it's doing something doing something doing something and it literally won't respond to you anymore that's just going to be because of a mistake a so-called bug that you yourself will invariably have uh added to your code accidentally but will show you ways for terminating it or breaking out of those conditions and indeed what we'll do in just a little bit after a break for today's lecture is explore not just these concept but some of the ways you can use them to solve real and very Visual and audio problems but for now let's at least connect it to something that's been all to Germain in recent months the past few years namely artificial intelligence which is a topic we'll come back to at the end of the course too to give you a sense of like what the connection is with what everyone's been talking about in the world of AI and what it is we're going to spend the next few weeks building up to by writing code if you were to try to implement something like a chatbot for instance that just answers questions and has a conversation with you you could do that using pseudo code and as we'll soon see you can use uh C python any number of other languages too that pseudo code might look like this when implementing a chatbot you could tell the chatbot if the student says hello to you then say hello back and the indentation as per earlier implies this is conditional else if the student says goodbye to you say goodbye to the student else if the student asks you how you are say you are well so you can just enumerate question after question after question and just handle all of these conditional possibilities but things kind of escalate quickly especially with the tools of today like chat GPT are we really going to have the wherewithal as programmers to write another conditional like else if the student asks why 111 in binary is seven in decimal like this kind of hints it oh my God there's like an infinite number of things this human could ask the chatbot do we really have to write an infinite number of conditionals like that's just not possible like there's not enough time in the day there's not enough lines of code available we artificial intelligence surely needs to be able to figure some of this out instead and so indeed this is not how you implement AI but rather how you implement an AI like a chatbot is you typically train it based on lots and lots of data you give it lots of inputs lots of inputs training data and let it figure out what it should say in response to certain questions and it boils down to a lot of probability a lot of Statistics Otherwise Known now as large language models which if we really Peak under the hood are actually typically implemented with what are called neural networks inspired by the world of biology whereby we humans have all of these neurons that transmit electrical signals such that my brain tells my hand to move this way this way and this other way and so what computer scientists have been doing over the past many years is implementing in software using literally zeros and ones graphs or networks neural networks that look a little something like this where each of the circles represents a neuron each of the arrows represents a pathway between them and provides as input to these networks huge amounts of data like all of the internet all of Wikipedia all of the books that it might consume as input and then the goal of this neural network as per this single final neuron right here is to produce an answer to a question maybe it's simple like yes no or maybe it's something like the answer to the 111 question or how are you or goodbye or hello or the like and what these neural networks do is use statistics and probability and try to Output the most probabilistically likely answer to this question that's been asked and really just hope that it is correct there's no programmer at open aai or Google or Microsoft that's trying to anticipate every one of these questions we might ask not only in English but in other languages as well so you might be wondering why there's this like 8ot duck on the stage so the Persona that cs50's own AI takes is in fact that of a rubber duck because it turns out in programming circles and this is true long before cs50 it has often been recommended to students and aspiring programmers that you keep like literally a physical rubber duck on your desk the idea being in the absence of a friend family member colleague ta who could answer technical questions for you if you're alone in your room and Ma at night you can sort of talk to the duck maybe door closed and ask the duck your questions or more importantly talk the duck through what confusion you're having and the mere Act of talking through through the problem explaining logically what you're trying to do what you're actually doing and what the error actually is invariably that sort of proverbial light bulb goes off and you realize oh I'm an idiot I hear in my own words where I've gone aai and even though this duck will never say anything back to you that alone rubber duck debugging or rubber ducking tends to be a valuable programming technique believe it or not but thanks to these large language models we have not only physical but virtual Ducks as well and so available to you will be in class not tools like chat GPT and the like which are through policy disallowed it is UN it is not reasonable to use chat GPT and the like but you are allowed and encouraged to use cs50's own AI based tools which resemble those same tools but know something about cs-50 and aspire to behave akin to a good teaching fellow guiding you two solutions as opposed to handing you something outright so this is a tool that will be available literally this URL throughout the course cs50. it will also be embedded in the programming environment you'll soon meet which is called Visual Studio code a cloud-based version thereof the duck will live in that environment as well as well as on stage from time to time which is to say we'll not only talk about but use throughout the course this thing known as AI but this is ultimately code that we're going to start writing next week and unfortunately this code here is written in a language called C this is essentially the program that I lost two points on like some 25 plus years ago and it it does look edly cryptic and that's why today what we'll focus on is not what this code looks like nor the zeros and ones that that code gets converted to so your computer can understand as input what you want it to do we're going to focus on a much more visual incarnation of this but I know thus far this has been a lot so let's go ahead and take a five minute break here and when we come back in five we'll do some actual programming so see you in five all right so it's now time to solve with actual code some actual problems albe it in a fun and visual and audio way but recall that where we left off was this like starting next week you'll be writing code that ultimately looks like this but thankfully you will not be writing zeros and ones and no normal person myself included can understand what all of these zeros and ones are at a glance we could take out some paper pencil and probably figure it out very tediously but this is the exactly the point computers only understand this stuff but what we as programmers will start writing today and Beyond is code at a higher level and indeed this is going to be uh this is going to be frequent within computer science where there's different like levels of abstraction that we operate at and the lowest level the Nitti gritty is like the zeros and ones the computer understand like that's it in this class for zeros and ones hopefully you at least have wrapped your mind around why zeros and ones can be used in triples and in uh as btes to represent higher and higher numbers but let's just now agree that computers can do that let's abstract away from that detail and focus on higher level languages than zeros and ones namely language like this so this is an example of the very first programming language I learned back in the day as per that homework in a language called C it's an older language but it remains one of the most popular languages and omnipresent languages nowadays because it's incredibly fast and it's particularly good at making devices operate quickly for us pedagogically the value of C is not that you're probably in Silicon Valley and other such jobs going to be using C yourself that much but because it's going to provide a conceptual foundation on top of which we introduce other languages like python which is newer and improved so to speak that gives you more and more functionality sort of for free out of the box by abstracting away some of the stuff we'll focus on in the coming days first so at the end of the day you should better understand languages like Python and JavaScript and SQL because of your underlying understanding of a language like C but this is too much for the first day many of you will think that this is too much for the second week but in fact C is really only sort of scary looking because all this darn punctuation in syntax the semicolon the parentheses the double quotes the curly braces and the like and I concur like this is intellectually uninteresting and a lot of the challenges early on when learning programming is you just don't have the muscle memory like that I or some of the teaching fellows might for knowing what symbols should beware but that's going to come with time and practice I guarantee it what we'll do for today though is just throw away all of that unintellectual uh intellectually uninteresting detail and focus really on ideas and some of you might be in your comfort zone here because if back in middle school you were playing with a programming language called scratch you were probably using at the time just to have fun in class or out of class making games animations interactive art what you probably didn't use it for at least in middle school was to consider and explore programming languages themselves but what's wonderful about scratch which is this graphical programming language from down the street at MIT where it was invented some years ago is you can program not by using your keyboard per se but by dragging and dropping puzzle pieces otherwise known as blocks that will snap together if it makes logical sense to do so and what you won't have to deal with is parentheses and double quotes and semicolons and all of that at least until next week but the nice thing about scratch is that after this week and after the called Problem set zero the first assignment in which you'll use scratch you'll have a mental model via which it will be easier to pick up all of the subsequent syntax as well so let's see how we can start programming in Scratch by making the simplest of programs first you can do this at scratch.mit.edu you needn't do this now in the moment problems at zero will walk you through all of these steps but what I've done here is opened up at scratch.mit.edu precisely the default uh web page therein this is after having clicked the create button in scratch which is going to allow me to create my first program but first a tour of the user interface here and what is ultimately available to you well within the scratch environment we'll see a few different regions of the screen one we have this pallet of puzzle pieces at left the blue ones relate to motion the purple ones relate to looks the pink ones relate to sound and so forth so the color of the blocks just roughly categorizes what that Block's purpose in life is we're going to be able to use those puzzle pieces by dragging and dropping them from left to right in the right here in the middle of the screen is where I'm going to write my actual programs this is where I'll drag and drop these puzzle pieces lock them together and actually write my code what am I going to be coding well I'm going to be controlling one or more Sprites much like in the world of games if familiar a Sprite is like a character that you might see on the screen the default character in the world of scratch is in fact a cat that looks like this and if in this case I have just one cat I can then make that cat do things in his own little world at top right by making the cat move up down left right spinning around or doing other things as well but if you want to introduce a dog or a bird or any number of other custom characters you just add more Sprites and they get their own place in that same world as for how to think about movement in this world it's actually pretty familiar even though it gets a little numeric for a moment if scratch at the moment is in the middle of the screen the cat is at 0 comma 0 if you think about XY coordinates or latitude longitude if you move the cat all the way up this would still be xal 0 but it would be y 180 what's the 180 180 pixels vertically or dots on the screen this is - 180 pixels on the screen at the bottom by contrast if you go left and right your x value might change negative - 240 but Y is zero or positive 240 and Y is zero as well but most of the time you won't need to know or care about what the pixel coordinates of the cat are all you're generally going to care about is the Pro most likely is do you want the cat to go relatively up down left or right and let MIT figure out the mathematics of moving this thing around in most cases all right so let's go ahead and introduce the first of these programs by doing something quite simple as we did in C there but a little more simply by writing code as follows I'm going to go back to scratch.mit.edu I've already clicked per before the create button and if I click on the yellow category of blocks here at left and I'll zoom in we'll see a whole bunch of yellow puzzle pieces and probably the most common one you will use to write code in scratch for just this first week is literally when green flag clicked why well if we go back over to the cat's world at top right notice that above the cat's rectangular world there's not only a green flag for starting there's a red stop sign for stopping as well so let's do this let me go ahead and click and drag when green flag clicked anywhere into the middle and let go and now I'm going to go to looks and it looks like there's a whole bunch of purple puzzle pieces here I'm going to choose something simple like say hello drag it and notice if I get just close enough it's going to want to magnetically snap together so I'll just do that and it does its thing the fact that there's this white oval with text means that is an input to this say puzzle piece I can literally then change what the input is if I want to more conventionally say hello comma World which in fact according to lore was the very first program written in C and now nowadays in most every language including in Brian kernan's book so hello world is generally the first program that most any programmer first writes so that's it as programs go let me go ahead and zoom out here let me go over to the right and click the green flag and somewhat excitingly maybe underwhelmingly we've now written a program that quite simply says hello world on the screen now let's make this a little more technical for just a moment what is this here puzzle piece as I keep calling it it's actually a similar in it's an incarnation of one of the ideas from our pseudo code before what did we call those actions and verbs last time in my pseudo code functions that's right so these purple puzzle pieces here are indeed functions and some functions as we can see take inputs like hello comma World After All how does scratch know what to say you have to provide the cat with input which is to say functions can indeed take inputs like this in this case one input but we'll see opportunities for passing in more input as well what the cat is doing though visually on the screen here at top right is what's generally called a side effect sometimes when you call a function it does something visually and in this case you're seeing literally a cartoon speech bubble hello world that is the side effect of this function so if we now want to map this to our world of inputs and outputs and see where this side effect is this is the Paradigm I proposed at the start of class that is computer science in a nutshell and will be the framework we use literally throughout the class no matter how uh no matter how the languages in particular evolve so what's the input to this particular program well this white oval hello world is my input the algorithm step-by-step instructions for solving some problem is implemented in code this language called Scratch by way of this purple puzzle piece and the output of that function given this input is the side effect whereby the cat indeed says hello world visually on the screen in that speech bubble so the same Paradigm with which we began today governs how exactly this cat here works well let's actually go back to this program and make it a little more interesting than that let me go ahead and click the red stop sign and let me actually use a different type of puzzle piece another function that does something a little different first I'm going to get rid of the say block so I'm going to not only pull it away I'm going to drag it over anywhere it left and just let go and it will delete itself automatically or I could right click or control click and from a little menu I could also explicitly say delete and what I'm going to do now is under sensing which is a light blue shade of puzzle piece there's a whole bunch here but I'm going to focus on this one ask something and wait and the default text is what's your name and that's fine but because it's a white oval that input can be manually Changed by me if I wanted to change the question I'm going to drag it over here it's going to magnetically slap uh snap together and I'm okay with that question but what do I want to say with the answer well let's go ahead and do this I could go to looks again I could grab another say block let it snap in and I could say something like uh hello comma David but this is going to be the first of many bugs that I make intentionally or otherwise let me click the green flag scratch is now just like in a web browser prompting me for some input here so let me go ahead and type in my name David enter and voila like it works hello David I'm kind of cheating though right because if I zoom out stop and play again let me type in like ulia's name here enter and it still says hello comma David so that didn't really implement the idea that I wanted all right so how can I fix this well it seems that this time I want more than a side effect I want to use the value that the human types in and for this we need another feature of functions which is that not only can they sometimes have side effects something visually happens some functions can hand you back a value a so-called return value that will allow you to actually reuse whatever the human typed in so a return value is something that gets virtually handed back to you and you can store it in something called a variable like X Y and Z in mathematics and you can generally reuse it one or more times so let me actually draw our attention then to at left not only the blue puzzle piece ask what's your name and weight but notice that there's a special puzzle piece below it this blue oval called answer and that represents what a computer scientist would call a return value so MIT has kind of bundled it together side by side to make clear that one of those pieces relates to the other what it means is that I can do this I can drag this oval and use this oval as the input to the save function now notice it's not the same size but it is the right shape so that's okay scratch will sort of grow or Shrink things to fit properly but this two isn't quite right let me go ahead and do this let me go ahead and stop that click the green flag I'll type in my name again da ID enter and it's just kind of like weird or rude like I wanted a hello at least and it just said David on the screen okay so I can fix that let me stop with the red stop sign let me just separate these temporarily and I can leave it in the middle there but they have no logical connection temporarily let me go back up to looks let me grab a say block a second one and let me go ahead and say just to be grammatical like hello comma space and then I'll reconnect this here so at the moment it looks like what I want I want a hello comma and then the return value printed out based on whatever the human typed in so let me zoom out let me click the green flag again what's your name da DAV ID and watch the cat's side effect enter it's still not greeting me properly there's no hello and if in case it was too fast let's do it again green flag daav ID enter it just it rudely just says my name which is weird what's the bug here though it's a little more subtle why yeah yeah it's just too quickly going over the say command or the say function in this case my my Mac your PC your phone is just so darn fast both are happening but too fast for my human eyes to even notice so we can solve this in a number of ways I could actually use a different puzzle piece altogether in fact MIT kind of anticipated this notice the first puzzle piece in purple is say hello for a specific number of seconds and you can specify not just the message but the number of seconds ARG go two inputs otherwise now known as argument to a function an input to a function is just an argument now um and that would be a fix here I could maybe a little more explicitly do this I could go under events scroll down a little bit and sorry under control in Orange I could grab a weight block and I could kind of insert it in the middle and this might actually help so I could click on the green flag da ID enter hello David and I could change the timing to be a little more natural but what if I want the cat to just say hello comma David all in one breath so to speak well for that I'm going to need to use a slightly different technique as follows let me go ahead and get rid of the weight let me get rid of the second say block and stop the cat with the stop sign let me go under operators here and let me somewhat cleverly grab this a join block at the bottom by default it's using apple and banana as placeholders but those are white ovals so I can change those let me drag this over the white oval for the sa function and let go and it will snap to fill let me go head here and type hello comma space instead of apple and what should I do instead of banana yeah so the answer return Val uh uh the return value so let me go under sensing again let me just drag another copy of it and you can use these again and again and again they don't disappear I want to drag answer over banana so that the second input to join is actually if you will the output of the ask block like that and it s Ms to fit so now if I go ahead and click the green flag once more David enter now we have the sort of behavior aesthetically that I cared about but beyond the Aesthetics of this the goal here really was to map it to again the same Paradigm which we'll see here the algorithm and the output and the input for this example are as follows the input to the say block was quote unquote what's your name the function of course implementing that algorithm in code was the ask and weight block the output though of the as ask block recalls not some visual side effect it is a return value called answer like a variable a special variable like X Y and Z and math but in this one we generally in programming describe variables with actual words not just letters but this output of the say block I kind of want to make room for it to make pass it into the say block as a second argument so let's do this let's take one step back and propose that now for the join block that I just used it takes two input hello comma space and answer the function in question is indeed the join block the output of this had better be hello comma David what do I want to do with the output of the join block well let me clear the screen let me move this over because now the output of the join block is going to instantly become the input to the sa block so that the output now in this multi-step process is the side effect of hello David so the fact that I nested these blocks on top of one another was very much deliberate if I zoom in here notice that hello and answer are on top of join join is on top of the say block and if you think back to like high school math this is like when you had parentheses and you had to do the things inside parentheses before the things outside parentheses it's the same idea but I'm just visually stacking them instead but outputs can become inputs depending on what the function there expects let me pause here and see if there's any questions about not so much like what the cat is doing but how the cat is doing this questions at hand all right well let's make the cat more catlike and do this let me throw away all the say block and just let go there and let me introduce at bottom left a nice feature of scratch whereby there's also these extensions that tend to use the cloud the internet to give you even more functionality and in fact I'm going to click on this extension up here text to speech and if I click on that I suddenly get a whole new category of blocks at the bottom text to speech they happen to be green but what's nice here is that I can actually now have the cat say something audibly so let me drag the speak block here instead of the say block I don't want it just just say hello let me stop that so let me go back under operators let me grab another join block because I threw the other one away let me change Apple to hello comma space again let me go to sensing let me drag answer to Banana again and now let me hit the green flag and let me type in my name d ID and in a moment I'll hit enter and hello David all right it's not exactly cat-like but it was synthesized but it turns out under these text to speech blocks there's some others set voice to Alto for instance seems to be the default but let's change this so notice that some puzzle pieces don't just take white ovals they might even have drop down so whoever created that puzzle piece decided in advance what the available choices are for that input per the drop down so I'm going to change it to squeak which sound or actually kitten sounds even more apt let me zoom out click the green flag type my name da enter meow meow that's interesting so it doesn't seem to matter what I type so how about David ma meow meow meow so it seems to meow proportional to how long the phrase is that I typed in we it can get a little creepy quickly like if I change kitten to Giant let me go ahead and hit play daavid Enter hello David so you can sort of for very non-academic ways like start to have fun with this but just playing around with these various inputs and outputs but let's actually make the cat do something more cat-like and indeed meow instead of saying any words at all so let me throw all of that away let me go now under sound let me drag the play sound until done and notice in the drop down here by default you just get the cat sound you can record your own sounds there's a whole library of dogs and birds and all sorts of sounds you can import into to the program I'll keep it simple with cat and let me click the green flag all right so the cat meowed once if I want the cat to meow again I could do this if I want the cat to meow a third time I could again hit play so this is kind of tedious if to play this game I have to keep clicking the button keep clicking the button to keep the cat alive virtually in this way so maybe I want this to happen again and again and again well let me just do that let me sort of drag and drop or I could right click or control click and then a little menu would let me copy paste or duplicate blocks but I'll just keep dragging and dropping let's do this cat's kind of hungry unhappy so like this like slow things down so it's adorable again so let me go under uh control let me grab one of those wait one second and I'll plop this here another one let me plop it here click play again cuter less hungry sure but this program is now I dare say correct if my goal is to get the catam meow three times but now even if you've never programmed before critique this program it is not welld designed even though it is correct in other words it could be better how might you think yeah so using a loop and why why are you encouraging me to use a loop even though it works as is yeah so to summarize we it's just easier to use a loop because I could specify explicitly in one place how many times I want it to Loop and moreover frankly anytime you are copying and pasting something in code or dragging the same thing again and again odds are you're doing something foolish why because you're repeating yourself unnecessarily and this is a bit extreme but suppose I want to change this program later so that I the cat pauses two seconds in between mouths well obviously I can just go in here and do two but what if I forget and suppose this program isn't like five or six puzzle pieces suppose it's 50 or 60 or 500 or 600 eventually I or a colleague I'm working with is going to screw up they're going to change a value in one place forget to change it in another so why are you inviting the probability of making a mistake just simplify things so that you only have to change inputs in one place so how can I do this let me zoom out let me throw most of this duplication away leaving me with just the play and the weight function let me now under control as well grab one of these I could for instance repeat as follows let me grab a repeat I'm going to have to kind of move these in two parts so I'm going to move this down it's too small but it will grow to fit the right shape then let me reattach it up here let me change the default 10 to a three and now I think I've done exactly what you encouraging which is simplify and I click play now meow and yeah so still correct but arguably better designed as a result I can keep things simple and change things now in just one place and it will continue to work but this is getting a little tedious now I claim like why am I re implementing the idea of meowing like wouldn't MIT have been better to have just implemented a meow puzzle piece for us because the whole thing is themed around a cat why is there not a meow puzzle piece why do I need to go through all of this complexity to build that functionality well what's nice about scratch and what's nice about programming languages in general is you can generally invent your own puzzle pieces your own functions and then use and reuse them so let me go ahead and do this I'm going to go under my blocks in pink down here I'm going to go ahead and click make a block and I'm going to be prompted with this interface here and I'm going to call this block literally meow because apparently MIT forgot to implement it for us and I'm just going to go ahead and immediately click okay and what you'll see now is two things one on the screen I've been given this placeholder pink piece that says Define meow as follows so anything I attach to the bottom of that Define block is going to define the meaning of meowing and at top left notice what I have under my blocks I now have a pink puzzle piece called meow that is a new function that will do whatever that other block of code tells the cat to do so what do I want to do here well I'm going to keep it simple for now I'm going to move the play sound meow until done and wait two seconds though let's change it back to 1 second to move things along and now let me drag the meow puzzle piece over to my Loop such that now what's it going to do it's going to meow three times and just to be dramatic out of sight of mind let me for for no technical reason just drag this all the way to the bottom of the screen and then scroll back up just to make the point visually that now meowing exists that is an implementation detail that we can abstract away not caring how it exists because I now know at a higher conceptual level if I want to meow I just use the meow puzzle piece and I or someone else dealt with already how to implement meowing so now let me go ahead and hit play okay so same exact code but arguably better design because I've now given myself reusable code so I don't have to copy paste those several blocks I can just use meow again and again but let's make one refinement let me actually scroll down to where I did in fact implement this let me control-click or right click on it and let me edit the pink block that I created a moment ago because I want to practice what I've been preaching about inputs so I don't want this function just to be called meow I want this function to also take an input and just for consistency with our use of n earlier which in computer science generally means number let me meow n times and just so that this puzzle piece is even more programmer friendly let me add just a textual label that has no technical significance other than to make this function sort of read left to right in a more English friendly way meow and times let me click okay and now notice this thing at the bottom has changed such that it's not only called meow there's explicit mention of n which is a circle which is exactly the variable shape that we saw earlier when it was called answer this is not a return value though this is what again we're going to call an argument an input to a function so let me do this I'm going to move this back up to the top so I can see everything in one place and I'm going to make one modification because my goal now is to make a new and improved version of meowing that actually takes into account how many times I want the cat to meow now so instead of using a loop in my own program under when green flag clicked I'm going to detach this temporarily I'm going to move this away I'm going to move this code over here and I'm going to reattach it here so focusing for the moment on just the left meow is now defined as repeating three times the following two functions play sound and waight but that's not quite right I want to get rid of the three so what can I do because I created this input to the meow function myself a moment ago I can actually drag a copy of it overr that is change the three to be generally an N so now I have a function called meow that will meow any number of times and what's nice now is my actual program that is governed by that green flag I can type in three I can type in 10 I can type in 100 and it will just work and henceforth I can again dramatically sort of scroll this down so we don't know or care about it anymore now my program is a single line whereby this notion of meowing has been abstracted away by just defining my own function or custom block questions then about just this idea this principle of creating your own functions to kind of hide implementation details once you've solve the problem therefore you don't want to have to think about that same problem ever again and that's the beauty of programming typically questions on what here we just did no all right well let's do this let's now make this a little more interactive in code let me go to this green flag let me scroll down and just throw all of this hard work away that we have copies on the courses website of all of these programs step by step if you want to review them in slower detail let's do this under control turns out there's other ways to Loop there's this forever block that will just do something forever so in the forever block there's some place for some other code and I'm going to move to the control section here and grab one of these if blocks so one of these conditionals let's plug that in Here and Now notice if and then there's this sort of trapezoid like placeholder that's going to probably fit what the if is a conditional forever is a loop say and so forth have been functions what was the other key term we used so a Boolean expression we need to put one of those yes no or true false questions here so what are those well I've been using scratch for some years so I know under sensing there's one of these shapes here touching Mouse pointer question mark the question mark literally evokes the whole idea of a Boolean expression being yes no it's way too big to fit but it is the right shape so let me drag it let go it's going to grow to fill and now let me go to sound let me grab that play sound meow until done and put it inside that conditional such that what kind of program have I just implemented here arguably what will this program do when I click the green flag well nothing at the moment but I'm not touching the cat so if I move the mouse pointer to the cat again again it's kind of like implementing the idea of petting a cat if you will because I'm forever just waiting and waiting and waiting is the mouse pointer touching that Sprite touching that cat and only if so go ahead and play that sound meow until done but now we can make things a little more interesting let me stop this and let me do something actually completely different let me throw all this hard work away let me go under extensions let me go to video sensing because lots of laptops my own included has a little webcam nowadays let me approve use of that there and you can see me in the frame and let me do this let me drag one of these when motion exceeds some measure and for through trial and error I figured out that 50 tends to work well let me um step out of frame here and program off to the side and if I go to play sound meow until done notice that this is an alternative to using when green flag clip this is a category of block that's constantly waiting for what we'll call an event an event is just something that can happen on the screen a click a drag a mouse movement and so forth so let me zoom out here and now if I can do this here we go no too slow still too slow oh wait did I click play Let's see try again there we go okay 50 is a little little too high apparently so let's make this a little gentler 10 okay well there we go there we go Okay so we've implemented now more physically the idea of actually responding to a cat to petting a cat so okay go damn it [Music] okay okay so this is a bug like now this is mit's fault so it's not stopping in response to the red um stop sign so what do you do in doubt most extreme you reboot for now I'm just going to close the window okay so now we've seen all of those Primitives that we saw in that pseudo code but incarnated in this graphical programming language and again without parentheses and semicolons and double quotes and all that punctuation that we will introduce before long but for now we have the mechanisms in place where we can do some really interesting things so in fact I thought in the spirit of sort of thinking back on olden times thought I'd open up the very first program I wrote when I actually took I was cross-registered in an MIT class and took a class that introduced but aspiring teachers to scratch and I implemented this program here called Oscar time which was a game that used a childhood song that I was a fan of and it allows you to sort of drag trash into a trash can but to bring this to life and perhaps in exchange for one stress ball could get one Brave volunteer who wants to come up and control this here keyboard I saw your hand first come on up come on up and you'll see thanks to the team we also have this amazing lamp post here being on Quincy Street as we are do you want to introduce yourself to the group hi my name is Anna um I'm from Richmond Virginia and I'm in well nice well all right come on over so here and you'll have a chance to play the very first game I wrote in scratch which admittedly is more complicated typically than we would expect of a student doing this for the very first time as in problem said zero but what I'm going to do is full screen this here I'm going to click the green flag and what you'll see on the screen are these instructions drag as much falling trash as you can to Oscar's trash can before his song ends and here we go oh I love trash anything dirty or dingy or Dusty anything raged or rotten or Rusty yes I love trash if you really want to see so as an continues to play Let's kind of tease this apart a little bit so one there's some costumes on the stage like that lamp post is actually never going to move but there's a couple of Sprites there's the trash can which seems to be a character unto itself there's this piece of trash that keeps coming back and back that is a Sprite there's now this sneaker which is another Sprite and in fact notice that Oscar of course keeps popping up from his Sprite once in a while so Oscar seems to have multiple costumes so I offer this as an example as you keep playing if you would very good job so far the song goes on forever this was a nightmare to implement to listen to this all day long but how do how do we implement the rest of this will notice that the trash every time she throws it into the trash can does reappear somewhere different so there's some kind of Randomness involved and indeed scratch will let you pick random numbers in a Range so maybe it could be negative - 240 maybe it could be positive 240 at the 180 point on the top of the screen so you can sort of randomly put things on the screen there's apparently what kind of construct that makes the trash fall again and again I think no one's listening to me they're all just watching you but what's making the trash fall from top to bottom so it's actually some kind of loop because there's a motion block inside of a forever Loop probably that just keeps moving the trash one pixel one pixel one pixel one pixel one pixel creating the illusion therefore of motion and if we can cramp the uh crank the song a little bit more you'll see that this is all synchronized now because they're trash Oh I love trash anything diry or stingy or Dusty anything the song keeps going forever seemingly and now notice more and more Sprites are appearing because they waited here we go [Music] climax all right it's a big round of applause for Hannah nicely done okay here you go here you go all right so this is an interminable song and indeed I spent like hours building that and just listening to that song on Loop was not the best way to program but the goal here is to really use it as just an intellectual exercise as to how that was implemented and we won't do the entire thing in detail because I will say back in the day when I was younger I didn't necessarily write the cleanest code and in fact if we see inside this and we poke around the bottom of the screen here you can see all of my different Sprites and the code is kind of complex like things just kind of escalated quickly but I did not set out and write all of these programs all at once for each Sprite I pretty much took baby steps so to speak and so for instance let me open up just a few sample building blocks here that speak to this that are written in advance so here's version zero computer scientists typically start counting at zero and let me show you this example here that only has two Sprites on the screen we have Oscar the trash can and we have the piece of trash and now notice what does Oscar do well let me go ahead and zoom in on this script as it's called a program is a script when the green flag is clicked Oscar switches his costume to Oscar one that's his default costume where the lid is closed then Oscar does this forever if it's Oscar is touching the mouse pointer change the costume to Oscar 2 otherwise change it back to Oscar 1 so that whole idea of Animation where Oscar's popping in and out it's just like a quick costume change based on a loop inside of which is a conditional waiting for the cursor like Anna did to get near the trash can meanwhile if we look at the piece of trash here notice that the trash is actually not doing anything in this first version cuz I didn't even Implement falling first so let me hit the green flag nothing is happening in this very first version but notice if I click on the trash and drag as soon as I'm touching Oscar there comes that trash can lid and it was just the result of making this one program respond to that input all right what did I do next well next after taking that single baby step I added one other feature let's see inside this version one again Oscar is behaving the exact same way but notice this time time the trash is designed to do the following first I'm telling the program that the drag mode is draggable that is I want the trash to be movable when the user clicks on it then I tell the piece of trash to go to a random X location X is the horizontal so it's going somewhere between 0 and 240 but all the way at the top of the screen 180 then forever the piece of trash just changes by negative 1 so it just moves down and down and down and without looking at the second script yet let me just hit play and notice without even doing anything and eventually once there was lots of trash falling like anim was struggling to keep up with this it's just moving one pixel at a Time Forever Until thankfully MIT does stop things automatically if they hit the bottom lest a six-year-old get upset that all of a sudden their Sprite is gone forever so there is some special casing there but what else is this trash doing let me zoom in here the piece of trash also when the green flag is clicked is forever asking this question if you are touching Oscar then pick a new random location between 0 and 240 at positive 180 and go back to the top so in other words as soon as this piece of trash is dragged over to Oscar like this and I let go it recreates itself at the top it's just sort of teleporting to the top and thus was born this feature and I won't slug through all of the individual features here but if we do just one more and see inside this one so now let me go ahead and hit play notice at the top left of the screen there's a score currently zero but now when I click the trash and let go notice that the score is being incremented by one and this in fact is how Anna your score kept going higher and higher and higher every time I noticed oh the trash is touching Oscar let's not only teleport let's also increment a variable and we didn't see this before but if I go to this uh Oscar SC scratch now you'll see that it is exactly the same but if I now go to the trash piece here and we go to when green flag clicked you'll see that I'm initializing a variable in Orange called score to zero but if we scroll down to the bottom Oscar is also doing another thing in parallel at the same time when the green flag is clicked Oscar is forever checking is the piece of trash touching Oscar if so change the score by one and then go to top which is another location on there that screen so in other words even though at a glance something like Oscar time might look very complicated and it did take me hours the goal especially with problem set zero is not going to be to bite off all of that at once but to take proverbial baby steps Implement one tiny feature so that you feel like you're making progress add another feature another and invariably you might run out of time and not get to the best version of your vision but hopefully it'll be good hopefully it'll be better but you'll have these sort of mental Milestones hoping that you at least get to that point because as you will soon discover everything in the world of programming uh unfortunately takes longer than you might expect that was true for me 25 years ago and is still true today well let me introduce one final set of examples here this one written by one of your own predecessors a former students let me go ahead and open up three baby steps if you will toward an end of implementing a game called Ivy's hardest game whereby it's now more interactive quite like Oscar time so at top right here notice and I'll zoom in we have this world that's initially very simple two black lines two walls if you will and a Harvard Sprite in the middle but when you click the green flag notice that nothing happens in initially except that the Sprite jumps to the middle but I can hit the up key or the down key or the left key or the right key but if I try to go too far even though it's not the edge of the world it's only touching that their black line it's still going to stop as well so intuitively how could you implement that type of program how could you get a sprite from what we've seen to respond to up down left right but actually move when I touch my arrow keys like what does it mean to move yeah exactly so much like with representing information at the end of the day all we've got is zeros and ones when it comes to algorithms at the moment all we have are functions and loops and conditionals and Boolean expressions and soon some more things too but there's not all that much we have at our disposal so let me zoom out from this and let me actually show you what the Harvard Sprite is doing it's doing this when I go up to the green flag here the Harvard Sprite is going to 0 comma 0 so dead center in the middle and and then it's forever doing two things listening for the keyboard and feeling for walls left and right now those are not puzzle pieces that come with scratch I created my own custom blocks my own functions to implement those ideas let's not abstract away for now let's actually look at these features and indeed to your instincts at left here what does it mean to listen for the keyboard well if the up Arrow key is pressed change y by one move up if the down arrow key is pressed change y by negative 1 if the right arrow key is pressed change X by one if the left Arrow key is pressed change X by negative 1 so take sort of all the magic out of moving up down left right by just quantizing it as plus minus this and that it's all numbers indeed at the end of the day but what else is it doing notice that it did indeed Bounce Off the Wall so my other custom function which I chose feel for walls to kind of evoke this idea it's asking two questions if you're touching the left wall then change X by one so bounce in the other direction else if you're change touching the right wall bounce in the negative One Direction and so what are left wall and right wall I mean I kind of cheated I just used two more Sprites these Sprites are literally nothing except black lines but because they exist I can ask that question in my conditional saying are you touching those other Sprites and I could have colored them any way I want but this is enough if I zoom in to implement this idea of going up down left and right and preventing the Sprite from leaving the that little world all right so if you'll agree that there's a way now to implement motion up down left right let's go ahead and implement this idea by adding a rival into the mix like a Yale Sprite and what the Yale Sprite is going to do if I click the green flag is this so Harvard at the moment is still going to be movable with the arrow keys up down left right but Yale for better for worse is just going to mindlessly bounce back and forth from left to right forever it would seem the operative word being forever so how is that working well let's look here's the Yale Sprite at the bottom let's zoom in on its actual code here the Yale Sprite starts at 0 0 it points in Direction 90 which means Left Right essentially and then it forever does this if touching the left wall or touching the right wall turn around 180 so I don't want the Gale Sprite to just stop by moving it one pixel to bounce off slightly I want it to wrap around and just keep going and going and going forever and that's it everything else is the same so one final flourish let's add a a more formidable adversary like MIT here whereby if I zoom in and hit play notice that if I move the Harvard Sprite MIT comes chasing me now now how is this actually working Yale is just kind of doing its thing bouncing back and forth now MIT is really latched on to me and it's following me up down left right so how is that logic now working well again it's probably doing something forever because that's why it's continually doing it let's click on MIT this too is pretty simple even though it's a pretty fancy idea initially the Sprite goes to a random position but thereafter it forever points toward the Harvard logo outline which is just the long name that your predecessor or former student gave the name for that Sprite and then it moves one step one step one step so suppose this were an actual game and in games like things get harder and harder the adversary moves faster and faster how could we make MIT even faster by changing just one thing here like how do we level up change the one to like two pixels at a time two steps at a time so let's see that let's go ahead and zoom out let's hit play and now notice that MIT is coming in much faster this time all right so it wasn't noticeably faster let's do this let's move 10 steps at a time so 10 steps faster than originally I mean now and now notice it's kind of twitching back and forth in this way why well probably if we worked out the math probably the MIT Sprite is touching the Sprite and it's bouncing off of it but then it's realizing oh I went too far let me move back wait a minute I'm still touching it let me move move down so you can get into these perverse situations where there is actually a bug be it logical or aesthetical but in this case we probably want to fix that so 10 is probably too fast for this to work particularly well but the final final flourish here really is to show you the actual version of a game that one of your predecessors a past classmate actually implemented before thereafter we will adjourn for cake in the transcept which is the cs50 tradition but can we get one more final volunteer to come on up to play Ivy's hardest game I'm seeing you're hand most enthusiastically there yeah come on down very happily in just a moment we will indeed adjourn but the goal here now is going to be to navigate a maze that's a little more difficult than the last let's have you first though introduce yourselves to your classmates in front oh hi y'all I'm Eric I'm from Philadelphia and I'm also from Hollis Hall one person from Hollis nice okay welcome all right so Eric go ahead and take the keyboard here it to will be all about up down left right as soon as you click the green flag and if we can crank the music can't touch this so notice the black walls are a little more involved than last time but the goal is to get to the Sprite all the way at right and just touch it at which point you move to the next level TCH the next level of course has Yale doing its thing back and forth but you've made it to level three but now there's two yet so another Sprite is in the mix that's randomly moving a little different in terms of Direction three I told you homey next level mit's in can't tou this look at my [Music] eyes lyrics the walls are now gone Princeton's in the mix I go and catch this while Wasing hold on P A littleit and let the noise go like that like that little two [Music] Princeton R them making them fat that's what I'm giving them now they know you're talking about the H you're talking about another life nice [Music] nice nice second to last level three Princeton last level break it down yes congratulations hear all right this then was cs50 welcome aboard cake is now served [Applause] [Music]