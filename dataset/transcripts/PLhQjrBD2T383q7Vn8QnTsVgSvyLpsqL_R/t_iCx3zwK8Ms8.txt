[Music] [Music] [Music] [Applause] [Music] [Music] [Music] [Music] all right this is cs50 and this is already week three our fourth and this week's focus is going to be pretty much entirely on algorithms which is exactly where we started the course recall back in week zero but in one of those algorithms recall involved a certain phone book first physically and then virtually and indeed in a phone book of course you have all of these names and all of these numbers presumably alphabetized by first name or last name and we looked for something someone back then namely John Harvard some of who and some of you might have called or texted even perhaps that number at the time but recall that among the goals of having that whole conversation about finding John Harvard or anyone in a phone book digital or otherwise was to talk about just how good the algorithm was it sort of went without saying in week zero that the algorithm has to be correct otherwise what's the point of writing it or implementing it in the first place but we also talked about design and can you make a better algorithm by thinking a little harder about it maybe harnessing some of your intuition and actually speeding things up as we discussed so the first algorithm recalling week zero one page at a time was perfectly correct but super slow and we described its slope with this straight line here and if that phone book had say n Pages where n just means number it was a one toone relationship because if you add more pages you need more steps the second algorithm recall where I went to two pages at a time was twice as fast so surely better potentially incorrect though if John Harvard got sandwiched between two pages but we proposed to uh solve that by just doubling back one page if need be if you pass the J section maybe hit the K section and therefore need to go back at least one page and that algorithm was fundamentally better its line was fundamentally lower than the first algorithms won because of course it takes half as much time to implement that second algorithm plus like one extra step just to double back but the third third and final algorithm in our very first week together recall was that so-called divide and conquer and today we'll give it a name again binary search by implying two because we were dividing in half in half in half again and again and we got this fundamentally different shape whereby even if we double the size of the phone book next year I proposed maybe Cambridge and Austin here in Massachusetts merging together so you go from like 1,000 pages to 2,000 pages one of you observe that that's not a big deal because you need just one more tear of the phone book to actually take a big bite out of that problem and go from 2,000 to 1,000 then to 500 then to 250 and so forth pages in the phone book so this week is really going to be about implementing algorithms not only correctly but also efficiently and really focusing on design there won't be new uh much new syntax in C we'll give you a couple of building blocks that solve concrete problems but this week is really about taking a breather after the past two weeks of fairly new fairly intensive C code and just solve some new more sophisticated problems together so let's consider how we can go about solving problems involving data like case in point phone books are a good example in so far as they represent a decent sized data set that ideally is in fact sorted alphabetically or otherwise and in the real world like we are searching for we are sorting information all of the time like odds are within the past hour or so all of us have used Google or some search engine in some form how does Google get a search results like that well they've probably used some kind of very clever layout out in their serers memory to get us answers really quickly so we'll begin to think about especially when data gets big how we can use this kind of Hardware but you uh and on top of which we'll write software to solve actual problems so here again is like a little black chip on top of what's otherwise called a circuit board or a logic board inside of our Max PCS and phones if though we abstract this away and just assume that if this big chip here represents like 1 gigabyte of memory 1 billion bytes or 8 billion bits well surely we can just arbitrarily but consistently number them like this is bite zero this is bite one bite two dot dot dot bite 1 billion all the way down here in the bottom so we can address our memory in this way so let's forget about the actual Hardware there and now talk about what really is going on inside of the computer's memory borrowing ideas from last week so if this is just a canvas of memory each of whose squares represents one bite of memory how can we go about laying out information be it names or numbers or web Pages or anything else well recall that we divvied this memory up into chunks last time and we called this an array and what was key about an array was that it was just a bunch of values back to back to back in memory so-called contiguous and it wasn't a huge deal last week that the these things were contiguous in memory back to back to back but this week it's actually going to really matter because it's because of that layout and because of last week's week two that we can actually solve problems efficiently in this week three so for instance here are a whole bunch of numbers and these numbers are stored in an array and this array is of size seven it would seem because there's 1 2 3 4 5 six seven numbers in this here array and of course you and I can see all of these numbers at a glance with sort of a bird's eye view but the catch is that computers technically can only look at one location in memory at a time now that's a bit of a white lie because computers are getting so darn sophisticated nowadays that different types fancier computers can maybe do multiple things at a time but for our model today we'll assume that a computer can indeed only look at one location at a time so for instance if you're searching for the number 50 among all of these values here well all of us in a split second can kind of spot it over there third from the right but a computer is going to have to look for it a little more methodically more algorithmically if you will step by step in order to solve that problem so a good mental model to have when it comes to what's going on inside of your computer is that these num numbers are yes in an array but they might as well be locked up behind closed doors whereby in order to see each of those values and find one of them the computer is metaphorically going to have to open up each of those doors one at a time looking looking looking for the number that we actually care about now it turns out we can treat this array of closed doors gym lockers if you will much like an array so this might be location zero location 1 location 2 dot dot dot location 6 six to be clear there's seven doors total but as always if you start counting from zero it's nus1 which refers to the rightmost or the last door so six instead of seven but there's indeed a total of seven doors here just for parody with the lockers we were able to buy online you might as well think of these as red do behind which are all of those numbers so if the goal at hand now is to sort of mimic what's going on inside of a computer I bet we could figure out how to find information among these doors and this is just a problem to be solved in the world of computing this is the problem of searching not surprisingly and what does that really mean well if we go back again to week zero where this is computer science like this is problem solving what's the input to this problem well we have an array of seven doors that might as well be locked up Behind These doors and we want to get as output a Boolean value like true or false yes the number 50 is here or no it is not so true or false respectively we'll get the job done and inside of this of course is going to be as always some kind of algorithm step-by-step instructions for actually solving this problem so how then would a computer concretely go about searching for numbers behind this door well maybe just for fun uh we went ahead here and uh printed out some Monopoly money some large versions thereof and suppose we want to find very specifically the number the dollar amount 50 behind one of these doors um could we get maybe one maybe two volunteers to come on up I saw your hand go up first second on the end there there and let me look over here over here behind the camera number two come on down okay come on over or maybe a round of applause to break the ice for these two come on up and we've got two algorithms ahead of you but come on over here if you want to introduce yourself to the world maybe a quick something about each of you hi I'm Jonathan I'm a sophomore in cabat house studying economics wonderful nice to meet you and hi I'm Claire I'm a Junior and Elliott studying economics and TDM all right nice wonderful glad to have you both here so behind you are seven doors and which of you would like to go first okay so first if you want to come come on over here behind these seven doors are now uh dollar amounts namely all of the available Monopoly dollar amounts and if you want we want you to find the number 50 you can go about this in a bunch of ways like you could go about just opening random doors but that's not necessarily very repeatable that's not very algorithmic step by step so let me propose that you do something super simple start at the left door and work your way to the right and just so everyone knows what's going on go ahead and show the world what number you've pulled out of each of these lockers and the first Locker is 20 20 that's not 50 that is correct not 50 500 yes so incorrect 10 10 not correct not correct 100 100 not correct one one not correct hopefully last door and a round of applause if we could for finding the number okay okay so if you don't mind before we transition to a better algorithm because frankly that was pretty bad but it wasn't incorrect in the sense that he was doing anything wrong he sort of just had some bad luck and frankly if I hadn't sort of led him to that path from left to right I could have proposed more clever that maybe start from the right and then boom the problem would have been solved but in general if data isn't necessarily cleanly laid out by us humans in this very manipulative approach like maybe it's going to be at the beginning of the array maybe it's going to be at the end of the array you really don't know so you might as well have one methodical approach step by step and just do it again and again so I think even though that felt increasingly awkward because you didn't find the 50 till the end that was kind of as good as you could have done in general and let me propose before we try a second algorithm if we take a look at some pseudo code here I dare say what you implemented with my sort of encouragement was something called linear search literally walking in a line from left to right and if we kind of take the fun out of searching for money behind doors we can make this more algorithmic with pseudo code english-like code but written in very CH language he did for each door from left to right if 50 is behind the door ideally then you would have returned true and that's when everyone applauded of course else if not you might return false at the very end of this this code so we got lucky 50 was there but if you hadn't you might have decreed oh no there's no 50 so I returned false but notice the indentation here just a highlighted key detail I'm only returning false once I'm done with that Loop for instance if I had poorly implemented this pseudo code like this indenting that return false and only doing it conditionally if 50 is not behind the door I know we're putting you on the spot here but do you want to conjecture why this would be better if you spot the mistake um if you put false right after else that means once we search the first door and we don't find 50 it'll just return false and the program will finish exactly so this code would indeed be a bad implementation incorrect because only if the 50 is behind the first door would it ever work correctly we would otherwise bail out and return false prematurely so this version here is indeed correct but can we do better well the numbers that were behind the doors for you were they in any particular order no they were randomized no so we kind of set you up for for failure in that sense so if you don't mind let's go ahead and pass the mic over and secretly behind me a moment ago Julia was kindly sorting all of those same dollar amounts behind the doors and the question at hand now for you is going to be find the number 50 but let's do this a bit like the phone book in week zero where let's start in the middle and if you recall from week zero then let's go left or right accordingly so what what's behind the middle door and we have uh it's 20 20 so not correct but what do we now know 50 is in which direction uh to the right all right so to the right so go to the middle of the right so that leaves you with these three Lockers in that middle door now it's 100 100 so too big so what do you now know uh it's going to be to the left has to be logically if it's there at all in between those two and now we get your Round of Applause much faster than before all right so this then if I can step over here before we give you a Parting Gift um this is where we left things off a moment ago and in binary in in linear search line from left to right we checked each door but just to make things a little geekier now and a bit more quantitative in nature that really is the same thing as slapping numbers on this problem whereby the first door we're going to call zero the last door we're going to call n minus one if we start to treat these lockers not as physical objects but as arrays instead so in that same spirit let me propose that when we found the number 50 this time we took a fundamentally different approach just like week zero when we did divide and conquer AKA binary search binary implying we split the problem in two and two and two by going left or right each time and the pseudo code that you might have arguably just implemented looks a little something like this if 5050 is behind the middle door well we got lucky and we can simply return true right away but if it's not if 50 is less than the value at the middle door we could have gone left even though you didn't need to else if 50 is greater than that of the middle door we could search right and you did do that but there's a fourth scenario here and we talked a bit about this in week zero do you spot what other scenario I might want to consider if it's either in the middle or to the left or to the right what else might happen so what else might happen was that four scenario yeah so it might not be there at all right I could have really set you up for failure by not putting the 50 there and in code though we need to handle that because I conjectured in week zero when you don't handle all possible scenarios that's when the computer crashes or freezes or just something goes Ary so if there are no doors left you sort of run out of possibilities logically we had better make sure we return false so before we give you both maybe one final round of applause um wonderfully um Monopoly makes its own Harvard Edition for Cambridge so we have a nice parting gift for both of you today thank you both for coming on up all right so just to now make that algorithm a bit more quantitative instead of just saying middle middle middle let's use a bit of array syntax here now too so this is the same exact pseudo code for that algorithm binary search and so the first condition is the same if no doors left just returned false but if 50 is behind doors bracket middle and again I'm sort of stealing some syntax from last week where we introduced square brackets for arrays but I'm still using pseudo code so this isn't C per se but by doors I mean the array known as doors bracket middle I mean whatever the middle number is the middle index is go there if you found it behind the doors bracket middle return true else as we enacted a moment ago if 50 is less than the middle door then go ahead and search what well instead of saying search to the left and search to the right let's make this again more precise today search the array of doors from location zero all the way through location middle minus one so what do I mean by that here was the middle door and even though this is not what we did a moment ago if we were to go left here's bracket zero the first door here is Middle minus one because if this is Middle minus one is immediately to the left and this is why this algorithm would indeed have us searching the left half equivalently whoops equivalently if 50 is greater than doors bracket middle then search doors middle plus one through doors and minus one well the end of an array if zero indexed that is you start counting at zero this is always n - one if this is middle middle plus one is here and this is exactly what you just did searching the right half of those doors so we have this translation then from sort of the intuitive pseudo code from week zero into now the more technical expression of arrays and array syntax here this week and that's something now we'll begin to build on over the course of writing and implementing some of these problems here today so if we now have algorithms that both solve the same problem just like in week zero which of those algorithms was better the first one which we called linear search or the second one which we called binary search they're both correct I would claim so which is better which is better design two and why do you say that more efficient okay so two is more efficient in so far as the second algorithm if I'm thinking back only took three steps she only had to open up three of the doors whereas the first algorithm linear search actually took as many as seven steps and in fact we'll see some math underlying this but it would be nice now if we could really compare the design of the efficiency of algorithms a little more rigorously than just saying one is better than the other let's see if we can slap not some numbers on it but maybe just some very simple arithmetic or algebraic formulas that allow us to compare two algorithms so that in the real world and in problem sets and in Pro projects in the future you can sort of make a more quantitative claim as to which approach is indeed better so when we talk about running time we literally mean that like how much time does it take for a program to run but we don't necessarily count in terms of seconds or ticks of a clock more generally instead we'll try to count the number of operations that an algorithm takes so for instance this was a way of analyzing the running time of three algorithms way back in week zero and I did introduce a bit of jargon whereby I was using expressions like n to represent n Pages or n divided by two to represent half as many pages and even though I waved my hand at weak zero log base 2 of n is uh mathematically how you would represent the idea of dividing something in half and half and half if you start with n pages so those are three formulas but it turns out that at least two of these algorithms from week zero they're pretty darn similar to one another indeed literally two of these are straight lines even though the slope is slightly different the other one is fundamentally curved and therefore different and indeed we saw better but let's get out of the business of worrying about like maybe like constant values like dividing by two we really want to care about when algorithms are sort of fundamentally better than one or the other so case in point here are those same two algorithms from week zero this was turning one page at a time this was turning two pages at a time honestly if I wanted to speed things up by a factor of two why don't I just use a faster Mac a faster PC right I nowadays I could literally wait like one year and next year's computer will be practically twice as fast it would seem than the first and so if we start to try to compare the efficiency of algorithms it would be nice if they're sort of resilient those comparisons to like what computer you use to run the code we want to take a step back and sort of approach things a little more mathematically but fairly lightweight nonetheless and so the way a computer scientist typically describes the running time of an algorithm is by using a capital O as a letter and using it to imply on the order of this many steps and I actually keep saying as a turn a turn of phrase uh wave my hand at a problem this is sort of the mathematical equivalent of like I don't really care about the very precise mathematical formula it is roughly on the order of this fast or this slow so what this means is that if you want to describe the running time of this algorithm this one or this one syntactically you literally write on a piece of paper or an essay or the like Big O and then in parenthesis a little mathematical formula that describes how the running time relates to the size of the problem just like this XY grid but it turns out and I'll claim we rarely care about denominators if they're just constants like two or three or four all we care about really is the highest ordered term so whatever the biggest mathematical component is in the expression the one that really matters is n gets big that's the one we care about because frankly if n is like uh two billion Pages two billion in size well 1 billion still feels pretty darn slow if it's going to take that many steps they might as well be just as slow as each other but this one here similarly if you remember your logarithms even the base doesn't matter cuz you can actually multiply one logarithm by a constant to sort of change the base and so here too we're going to get rid of the specific constant like two and here then is how we would describe the running time and in fact if you zoom out in your mind's eye and assume that the Y AIS is bigger and the x-axis is bigger if you keep zooming out zooming out zooming out these two lines are actually going to pretty much look the same once you've zoomed out far enough and that's what I mean by they're essentially themselves algorithmically the same as n gets big big big big these might as well be the same algorithms but this one is clearly not and we claimed in week zero that this one was better I claim again today that this one is better and now we'll begin to slap some formulas on the evaluation of these algorithms so that we have a better sense of what algorithm is better than someone else's and indeed in the real world when you talk about what makes someone a good programmer what makes someone a good engineer is sort of having an intuitive sense with practice and with time of how you should write your code so that it maybe has a better running time than some other algorithm because when you start working at Google or Microsoft or working in you know medical data sets or financial data sets and the data is really big and is really big you probably want to be as efficient as possible so this cure capital O is generally called Big O notation not particularly technical but that's indeed what it's called and here for instance is a little chart of very common runtimes you can have any mathematical expression but almost always in the context of computing at least introductory type algorithms this is kind of the list of possibilities even though there's infinitely many more so among the algorithms we've considered thus far what is the running time of linear search well it's on the order of n because if there's n doors like those behind me in the worst case consider how many steps might it take me or take you like it will take n steps specifically seven but n in the general case and so big O is very commonly used when you do want to think about the worst case because honestly who really cares if you got lucky and the first first door you opened had the number you're looking for that doesn't really generalize and you know that's not a good argument within Google well hey once in a while someone will get lucky and will really return them a search result quickly you want the general case to be fast and so linear search really in the worst case like who which customer is going to be the least happy with our Google code linear search sort of describes that an upper bound so to speak on how many steps it might take what about though best case running times or lower bounds on how fast an algorithm might be oh sorry I should have not spoiled this uh what's the running time of binary search if the running time of linear search is Big O of n well the running time of binary search by contrast is going to be log base 2 of n or more generally log event she could have gotten lucky our volunteer by just opening the middle door and voila maybe 50 was there it wasn't but in the worst case she only had to look at Big O of log and doors in total and that gave us roughly three doors in this case all right what if we want to talk about best case running times just because it would be nice that in certain situations how fast can our code actually run how good is our algorithm well in Computing computer scientists use a capital omega symbol to represent a lower bound so big O is upper bound big Omega is lower bound and you can use the same kind of mathematical formula so here's that little cheat sheet again but with an Omega prefix which again means lower bound and same question in linear search where you look at the doors left to right right in the best case how few steps might it take to find a number I'm seeing just one because we could get lucky and because we go from left to right could be that we find the number right away so that's in big Omega of uh one in this case one step otherwise how about binary search what's the lower bound on how quickly we might find a value same thing right because we could just get lucky because by starting in the middle it might happen to be right there so the lower bound on binary search 2 also happens to be in Big O of one because we just simply get lucky all right what if those two are one and the same one last piece of Greek symbology here Capital Theta here is used when Big O and Omega are exactly the same thing which won't always apply but sometimes an algorithm performs uh at this rate as well as at this rate and they're one and the same depending on the algorithm itself so here's a little cheat sheet here and how about linear search so linear search in the best case takes only one step in the worst case takes as many as end steps so those are not really one and the same so Theta is really inapplicable here and binary search 2 this is sort of inapplicable because in the best case it might take me one step hence the big Omega of one but in the worst case and it's not even that bad might take me Big O of log n so Theta doesn't apply here but we'll keep an eye out today and see if there aren't certain algorithms that will look at that might actually have those values being one and the same and all of this symbology and that's it really for definitions for now is what's generally called asymptotic notation it's notation that you use when talking about the running time of algorithms over time like as the input gets larger and larger and larger how do these algorithms perform how can you measure their efficiency okay any questions on Big O Omega or anything prior we'll come back to Theta before long any questions yeah in front sorry say again isar oh is binary search efficient in with respect to when searching random oh is really good question is binary search efficient when searching random data as was the case with our first set of doors and indeed those numbers were all over the place they were not sorted from smallest to largest or largest to smallest so what is the answer to that is binary search efficient when the data is random it doesn't work at all it doesn't work at all and so that was sort of the Hidden cost of the two algorithms that we acted out and literally I had ulia come up and help me she did more work to enable us to use binary search because only for the second exercise with the lockers was the data actually sorted so binary search just does not work if the data is random because you would open a door see a number like the number 20 and now you would make a decision whether to go left or right based on the number you've seen so you simply cannot use binary search when the data is unsorted AKA random in that case then how do you sort the data that's going to be one of the problems we solve ultimately today get the data sorted help Googles of the world sort their data first so that we can find web pages and other things more quickly yeah in back oh any questions no all right so let's actually translate some of this to a little bit of code here how could we go about implementing something like linear search well let me do this let me go over to VSS code here let me propose to create a new program called search. C so I'm going to do code search. C and in here I'm going to use the cs50 library at the top so I can get input I'm going to use standard i.h so I can print stuff out on the screen I'm going to use int main void because for today I don't really care about command line Arguments for this particular program and let me start with an array of value suppose I want to implement in code the idea of these lockers containing those random values initially and Implement in C the very first algorithm we enacted with our volunteers which was searching from left to right well it turns out in C I can create an array recall by saying I want integers I want the array to be called numbers and then inside of square brackets I can specify how many elements I want maybe I want three like last week but in this case I think I want seven this week to represent each of these lockers but turns out you can initialize in array without even using get int or the like you can just specify in empty square brackets that that whole array should equal the following inside of curly braces so this is one new use of curly braces but it's a handy trick when you want to create an array that has specific values like 20 500 10 5 100 1 and 50 which just happens to be the exact order in which the dollar amounts previously were behind those lockers so what does this line six do at the moment it creates for me an array of size seven and initializes it to that sequence of values from left to right it is not strictly necessary to bother putting seven there and it's probably best not to because the computer specifically the compiler will figure out how big the array should be based on what you typed inside of those curly braces and you're just inviting a mistake if you put a number over here that's supposed to match the total over here at some point you're probably going to air all right so if that gives me then array of size seven let me go ahead and ask the user what number do you want to search for much like I verbalized before so int n equals get int and I'll prompt the human for a number as with this kind of prompt how do I now Implement linear search well based on the constructs we explored in week zero and week one we had conditionals and loops and variables and Boolean expressions and the like what is probably like the feature of a programming language that we're going to need to search from left to right to implement linear search a four Loop probably or a while loop but a loop in general why because I could use like seven conditionals and I could say if the um numbers bracket 0 equals equals this value then return true else if numbers bracket one equals equals this number then return true but that's not very general purpose if we're going to have all of these conditionals let's just have one that asks the same question question by just changing some variable and a for Loop is often the Paradigm so four in I equal 0 I is less than 7 i++ and this code alone sort of sets me up to implement what our first volunteer did from left to right with the lockers what's the question I want to ask well does the array of numbers at the current location I equal equal the number n that we're actually looking for so does the number behind the first door second door third door actually equal 50 for instance or whatever is typed in and if so let's go ahead and print out something clear like found back sln else I don't think I want to do this printf not found so let me for a moment sort of poorly implement this what have I done wrong with this code yeah in the back yeah I don't want the the if in I want the if inside the for Loop but not the else inside the for Loop why because that would be the equivalent of starting at I equals z opening the door and then concluding I have found or not found the number without even allowing us a chance to keep going because we're going to SP spit out sort of unilaterally not found even though we just haven't found it yet so I don't think I want to do that but I think what I can do for instance is as per the slide a bit ago if I at the end of my Loop get all this way then I think I can print not found but I think logically even this might be imperfect so let me go ahead here and do make search enter seems to have compiled okay so new syntax errors do/ search enter what number do I want to search for I'm going to go ahead and type 50 and hit enter and still I have a logical bug it's saying found but also not found why even though I move that line of code outside the loop which is correct but there's still something wrong here yeah yeah the iteration still ends up leading us to this final line why because we're going to go all the way from zero to the end of the array again and again and again hopefully printing out found when we find it but there's nothing stopping us from then executing line 16 before the program actually ends but recall last week we had a solution to this even Maine can return a value and even though in we week one it was sort of secretly returning the number zero unbeknownst to us it turns out we now had the ability as of week two to explicitly return a value anywhere in main that we want and the convention a little paradoxically is to return zero upon success because that means all is well and then return anything other than zero like a positive integer if anything has gone wrong and we use positive integers because it could be this thing that goes wrong this thing this other thing lots more can go wrong than can go right when writing code so I think what I could do here is after printing found I could return zero to Signal success even though the human's not going to see anything different and down here I could actually return one to signify failure and recall with the little command trick I could do dollar sign question mark and actually see what that value is but for our purposes what we really care about is that main returns when we are done solving this problem either inside of the loop or ultimately outside so let me try this again make search do/ search let's search for again the number 50 enter and indeed it is found and only found let's do this again/ search let's search for the number two which is not in that array and I should see and only see not found in this case so this then would be the code for linear search any questions on what we just did here yeah a really good question what if we don't initialize the array well honestly in programming a very good answer to that question is just try it out and see what happens so let me create an array of size 7 with no values inside of it let me reopen my terminal window do make search and the compiler doesn't seem to mind that if I go ahead and now do do/ search enter I'll be prompted for a number I'm going to presume to search for 50 even though I don't know what's in there enter and at least it was not found here let me go ahead and try again let me search for the number two not actually found search for the number one not actually found and I could poke around all day long but it turns out I'm probably just getting lucky here why well this Loop no matter what is going to check seven locations but I have not put anything in any of those seven locations but recall from last week we sometimes saw those garbage values sort of remnants of memory that of course exists but maybe had been used for some other value previously at the moment I think I'm just getting lucky that among the first seven locations in the computer's memory I just didn't end up with a garbage value 50 or two or one but if we played this game for a while I bet I could come up with a number that actually works and let's see at the risk of a demo not going according to plan let me do/ search let's search for zero still not there let's search for three four okay we're going to have to do this all day long to actually find the values uh there's four billion possibilities but at some point we would get lucky and it would say found but only by chance so in short do not do that since it is wrong all right other questions on the code that we've just written all right so let's transition into maybe a better version of this what if the numbers are actually sorted and frankly what if they're not actually numbers at all let me go back into this code let me throw away the contents of Main and let's do something maybe now with strings instead just so it's more like searching an actual phone book so I'm going to create an array of strings called strings for lack of a better name and much like a certain game with which uh you might now be familiar we might have a string for Battleship and Boot and Canon and iron and thimble and Top Hat though this does vary by country based on which version of Monopoly you actually have then let's go ahead and prompt the user for a string s using get string and ask them for a string to search for and then let's do a four loop again four in I equals 0 I less than 1 2 3 4 five six values I'm hardcoding six and I don't like that but we'll come back to that idea in general of figuring out what the length of that array might be but for now I'm just going to hardcode it but that's not indeed good practice i++ inside of the for Loop now let me go ahead and do this if the E whoops if the E string or the strings at location I equals equals s then let me go ahead and print out out as before found let me not make the same mistake as before so let me immediately return zero to Signal success but if we don't find it anywhere in that array let's go ahead and print out not found and then let's go ahead and return one just as before so the only thing that's different now is I'm using strings instead of integers but I'm otherwise looking for the E string that might very well have the same value as s what I have typed in all right let me go ahead and open my terminal again run make search again so far so good/ search let's search for maybe the thimble enter huh it's not found all right maybe it's too far away let's search for again uh battles ship enter not found uh how about the top hat enter not found and I could do this three more times but I'll claim that it's never going to find any of these strings does anyone have a suspicion as to why or how we might solve why is this not working yeah yeah well said so it turns out and this is super subtle equals equals is not how you can compare strings and we'll see why in fact in Greater detail next week but for now equals equals works fine for integers for Longs for chars and a bunch of other data types as well but it doesn't actually work for Strings and for today's purposes it's really because strings can be different lengths and equals equals is only going to compare two values but a string might be three characters four characters five characters depending on how many characters I have typed in equals equals is not powerful enough or wise enough to actually solve that problem however this is such a common thing to do like in our phones and on Google and the like to compare strings that humans have typed in that there is in fact a solution for this and so in fact we'll introduce today another uh function from the string. a header file that we introduced last time recall that inside of string.h was the Declaration for uh Sterling St Ln which would figure out the length of a string based on the null character and everything we talked about last week but within the same Library as per cs50's documentation there's another function called stir compare or St CMP for short and if you were to pull up the documentation for that particular function you will see that its prototype actually takes two strings as input called S1 and S2 though we could call those any two things but what's noteworthy about this function is that its return value is sort of Turner it can return one of three different things to us the function can return an INT less than zero if S2 comes before sorry if S1 comes before S2 it will return zero if S1 is the same as S2 and it will return an inch greater than zero if S1 comes after S2 so stir compare is more power powerful than just saying yes or no these strings are equal it can actually be used to alphabetize strings as well because what it's essentially saying is alphabetically S1 comes before S2 or S1 and S2 are the same or S1 comes after S2 alphabetically and alphabetically is a bit of a white lie it's technically atically because what's being used is the asy values so lowercase characters are going to be treated different from uppercase characters so we say atically because it's literally comparing the asy codes but for now I'm going to avoid that problem by just using lowercase everywhere but if I want to use this function let me go back over to my code here and instead of doing equals equals I have to use a function here called stir compare passing in one string like s bra uh like strings bracket I and then the second argument aks2 is going to be the string I want to compare against but I want to check the return value of that function and again what value should I check for if I want these things to be equal so zero was the operative return value so what I want to do is this so this looks at a glance like way more complicated than it really needs to be but all it's doing is calling a function called stir compare passing in two strings as input generally known as S1 and S2 comparing them and if they are exactly the same character for character left to write stir compare perrit documentation will return zero I don't care about less than zero or greater than zero CU I'm not trying to sort anything I'm just trying to return true or false yes or no we have found this string so I to use that function just like Sterling I need to include string.h at the top let me open my terminal window let me rerun make search so far so good/ search now let me search for thimble in the exact same array crossing my fingers and voila now we have found thimble and Just for kicks I'll do it twice more Battleship which failed previously but this time not Top Hat failed previously but not this time I'll search for something like a car which is not in the array enter and that is in fact not found so a subtlety because strings as we'll soon see all the more are indeed a bit different from just comparing simple values like integers chars and the like questions on what we just did with stir compare or searching for this thing linearly in this way no all right well why don't we graduate to like more of a actual phone book right now I'm just kind of searching for arbitrary strings let's make something that's a little more involved but uses these exact same ideas let me go ahead and code up a file called phonebook doc at the top of the file I'm going to include those exact same files so include cs50.h include standard io. include proactively this time string.h I'm going to create my main function no need for command line arguments today inside of main I'm going to give myself now two arrays just so we actually have both names and numbers so for instance I'm going to do this an array of string called names uh and in that array I'm going to have three of us so inside of curly breakes I'll have Julia who kindly volunteered earlier as well me and how about John Harvard as always whose numbers we'll search for whose number we'll search for then let me go ahead and keep track of not just the names in this phone book but also the uh numbers so string uh numbers and then equals and then the numbers I'm going to put here are going to be for instance how about + one- 617495 uh 1,000 uh Julie and I will have the same Harvard directory number so plus one 617 495 1000 and then John Harvard will have his old number + 1 d2750 which just for an Easter egg you're welcome to text or call sometime all right so now I have two parallel arrays if you will from left to right that are both mapping names in one array to numbers in the second array and actually if I want to keep this thing sorted that's kind of on me and I don't really care about that for now but if I wanted to sort this notice that I'm actually going to need to move Julia's name there and move ulia's number to the end here but otherwise we still have an array of size three for each of names and numbers let's go ahead now and search for someone's name and therefore find their number so let's prompt the user for a string called name using get string and ask them what name do you want to search for in this phone book just like before let's use linear search to keep it simple for in I equals 0 I less than three this time because there's three people involved i++ then inside of this for Loop let's do the same correct technique as before if the return value of stir compare passing in two values what are the two values I want to pass in to stir compare here in order to check if we have found a person's name what could the first one be feel free to shout it out what am I searching for the user typed in name but I want to compare it against yeah I think names bracket I so like if the I name is the same thing as the name the human typed in and I know that because stir compare will return zero for me then I can go ahead and say just as before found and Just for kicks now let's go ahead and actually print out what that person's number is rather than just say found quote unquote by outputting numbers bracket I so this is to say if we find in names bracket I the person's name that we're searching for then go ahead and print out that same person eyes number and so that we don't accidentally say not found later let's return zero immediately otherwise down here let's say not found with no number of course and then return one to signify error so if I hide my terminal window this is sort of a simple implementation of a phone book on like an iPhone or on an Android phone when you're searching for your contacts top to bottom or left to right so let me go ahead and run this in my terminal I'll do make phonebook enter so far so good/ phonebook and if I search for John by his name properly capitalized enter I indeed found John Harvard's number to be plus1 949 5 this then is correct what though is arguably poorly designed about this program even if you yourself are still newish to programming what's bad about this design here might you say any instincts what's bad yeah I good so I don't like that the fact that I'm using this so-called magic number which means just hard coding a value that you're trusting is not going to change or that you'll remember to change it I don't like this so that's a really good observation what else might you not like instinctively even if again these concepts are new and often yeah yeah we're again on sort of the honor System here that we have these two arrays and the only is on me the programmer to make sure that they line up and case in point when I manually went back a moment ago and moved ulia to the end of the names array I had to remember to move her number to the end of the numbers array and that just strikes me as very fragile so to speak right it's just too easy for me or a colleague to screw up this code by forgetting that sort of lower level detail we're just trusting that names and numbers do stay aligned and they have the exact same number of people in them and the exact same numbers of number exact same number of numbers in them as well so we have an opportunity now to sort of do better than this and besides arrays which we've already seen do solve a lot of problems by letting us use one variable to store Bunches of things wouldn't it be nice if there was another type of variable that's not int that's not string that's not Char that's not float or any of those that we've seen already wouldn't it be nice if there's like a a person data type in C where I can actually create a person in my code and a person in this world shall have a name and a number Heck if we were implementing students maybe a student could have a name a number an email address a Harvard ID number or Yale ID number or the like you could imagine encapsulating so to speak a Bunches of bunch of different types of data inside of one larger data type and generally when we talk about data structures we mean exactly that some kind of container for multiple types of data so a custom data type if you will so for instance if I wanted to create an array of people wouldn't it be nice if there's a data type called person so I could use code like this give me an array of people and I don't know how many yet but give me an array of people Each of which is of type person so instead of string instead of int I'm saying person and in English I'm pluralizing the name of the array as obviously people instead but that doesn't exist with C like there are no student data types there are no people data types there are no Professor data types any of these things that you might imagine in the real world don't come with C all you get are strings and ins and floats in those lower level features but if we know a person for our purposes will have a name and a number well why don't we just give them a name and a number but somehow encapsulate this name and number in a bit of new syntax and so the new syntax we will introduce today is that of creating your own type that is a structure specifically and we can you we'll see more of these over the course of the term and even though this looks a bit cryptic what this chunk of code here is saying is Define a type that is itself a structure inside of which is both a name and a number which are both strings in this case and call that whole new structure person so as soon as the compiler gets to the semicolon a person data type does now exist and inside of that data type is two things a name and a number now as an aside I deliberately use string here for both name and number I use string in my code a moment ago for those phone numbers why did I use a string instead of an INT or even a long for my phone numbers like wasn't actually a mistake yeah yeah like The Hyphen the country code maybe parenthesis if you format your number differently and so A good rule of Thum actually is that even though you and I in the real world might call certain thing numbers like social security number in the United States or phone number or ID number if there might potentially be other punctuation or symbols in that number and frankly more generally if it would make no intuitive sense to perform math on something you call a number and I can't think of a scenario where you'd want to perform math on a phone number you probably should store it instead as a string instead and use actual integers actual Longs for things that mathematically or computationally make sense to be treated as literal numbers instead so if I now have this new feature whereby I can define a custom data type in my phone uh for my phone book I think I can Implement a brand new version of this PR program that's going to be a bit more verbose but it's going to allow me to solve this problem better so let me go back to vs code here and you'll see in this code where we left off I'm going to go ahead and delete all of this just for now and I'm going to whip up a slightly better version I will claim outside of my main function I'm going to do exactly what we just saw on the slide I'm going to define a structure inside of which is a name of typ string and a number of typ string and I'm going to call that whole thing thing a person turns out style 50 and particularly the program we're using underneath the hood prefers weirdly that you put person on the same line as the curly brace so just FYI if you run style 50 and you see that it moves as such inside of main I'm going to now give myself an array uh of type person called people of size three so still I'm not going to solve all of today's problems I still don't like the fact that I'm hardcoding a three but I just want to demonstrate for today's purposes how we can use this here feature so I now have an array of three people and each of those people is by definition a person and a person we now know contains a name and a number so how do I initialize this array it's not as simple as just using like get string once I clearly need to use it twice but I won't even do that I'll just hardcode the values for demonstration sake now let us update the first person in the people array so this is week two syntax and set the name of that first person equal to quote unquote David semi colon then in that same person structure go into their number field and set that equal to + one 617495 1,000 semicolon so what here is new well of course people bracket zero isn't really new like we did that last week if the array is called people and you want the first element you use bracket zero but what is new today is this dot operator once you've created a structure inside of the computer's memory if you want to go inside it and access the things that comp POS it like name and number you just use a DOT like this and that means go inside the first person and access their name set it equal to quote unquote David and do the same thing now for their number so even though yes this stuff is new here the only new operator so to speak today is really that same dot all right let's go ahead and initialize the other two people just so we have an array completely defined people bracket one. name will be John as before people bracket 1. number will be John's number which was a little + 1 949 468 275 and then lastly people bracket 2 uh name equals quote unquote ulia and then people bracket 2. number equals the same as mine plus 1 617 495 1,000 so now even though this is more of a mouthful and let your mind wander to the reality that like we could just use a loop to do this a little more cleanly and use get string and make it interactive but I really just want to demonstrate the type Def and the struct and this new DOT operator let's now search for someone's number so let's ask the user for a string called name using get string as before prompting for that name then inside of a for Loop for in I equal 0 I less than three again don't love that but we're focusing on one problem at a time not this other one i++ inside of the for Loop now same as before if the return value of stir compare passing in the current person's name and the name that the human just typed in returns a value of zero then inside of that let's go ahead and print out found percent s back sln and plug in people bracket I but I want to see their number so I do do number instead now I can return zero for Success down here I can print out not found to indicate failure and down here I will return one so the only new stuff in this program really is the fact that I have now invented a new data type called person that we can now use in our code and I'm accessing the individual fields or attributes of that new structure by using this new DOT operator which goes inside of that custom structure all right if I didn't screw up let me go ahead and make this phone book so far so good/ phonebook enter and now if I type in John enter I have in fact found John's number and if I go ahead and search for someone else for instance like Brian who's not in the phone book he in fact is not found questions then on any of this feature via which we've now implemented really something closer to the phone book albeit using linear search and not binary search question yeah in front you say that a little louder ah what if two people have the same name a corner case if you will uh this code will not work necessarily correctly because it will return to me or print for me whose number only the first one that it actually find so that would be a mistake and I think we'd need to address that with a bit more complicated code so solvable but not for now a good observation other questions on this here code no all right well let's then uh tee up an actual solution to this problem namely if I want to use binary search like I can't yet if unless I manually sort those arrays just as Julia came up earlier and kindly sorted the dollar amounts that were inside of these lockers now she and I kind of coordinated in advance so she knew exactly what to put in what but if she were just handed a list of numbers or a stack of papers Each of which was a different denomination of Bill like there's not necessarily obvious how we go about solving this problem sorting the values and after all even though the phone book that I tore in half in week zero and the phone book I keep referring to on my phone and yours is presumably sorted by first name or last name so you can find names and number quickly well how much effort is required in sorting those names and numbers so case in point if for instance I handed you all of these sheets of paper on which are these different dollar amounts and they weren't necessarily in any particular order instead I simply hand you a stack of$ seven of various denominations like this and say find me the number like 50 and they're sort of randomly organized what's the algorithm for finding the number 50 well you could just kind of sift through them one at a time AKA linear search and you'd eventually find it correctly or you could take a moment sort them all and then much more quickly get me the answer I'm looking for but would anyone in this room realistically whether it's seven pieces of paper or 700 pieces of paper would you bother sorting them only then to find me the answer yes uh yes no would anyone sort them I mean I'm kind of setting you up for contradiction like no it' be stupid to sort them why because you if you're only being asked one question find me the 50 why are you wasting time sorting those values in order to find a number that you might as well just sift through quickly and find it by Big O of n running time the first place but suppose I hand you those bills or suppose I hand you a big database of names and numbers and I expect that you're going to want to search for someone again and again and again like your phone Apple or Google probably are sorting all of those names and numbers why because you're not going to look up one person's number in the lifetime of your phone you're probably going to maintain the thing sorted the whole time so that every time you look up someone's name and number that operation is in fact quite fast and so that invites the question then just how efficiently can we actually sort values and what does it then mean to actually sort these values well the problem of sorting kind of looks like this if our input and output Paradigm is to be believed the input to the problem would be unsorted data so like randomly ordered bills or randomly ordered names and numbers the output though we want to be sorted specifically then if we deal with like an array here's an array of numbers from 0 through 7even completely unsorted so same idea as the dollar bills but I used smaller numbers cuz it's a bit easier the goal at hand is to get them from 0 to 7 in increasing order but for that we need some algorithm to actually do the Sorting the step-by-step instructions and it turns out there's going to be Bunches of ways we can do that but maybe just to set the stage before we uh take a break and have the most delicious Hello Panda chocolate biscuits today can we get eight volunteers to come on up and I can offer you an extra snack in the form of these little Mario uh mushrooms how about 1 two okay three four five how about six yes you who just put your hand down seven on the end there and let me find some how about uh eight in the Harvard sweatshirt all right come on down come on down and if you at volunteers before we do Hells if you want to grab a number from Julia on the side of the stage those of you with numbers come on over to the middle of the stage here and line yourself up in this order from left to right so hopefully we have 1 2 3 4 5 six 78 volunteers good line yourselves up from left to right in the order you see above you and Julia has your numbers for you all right line up here okay line up over here F number five you're over here okay 7 2 5 4 1 603 okay okay how about some quick introductions from right to left hi hi I'm Becca there we go hi I'm Becca I'm studying electrical engineering and I live in Wigglesworth hi I'm thees and I just graduated from North Eastern in Masters in Information Systems welcome hi I'm Owen I live in stouten Hall and I'm want to study CS nice hi I'm bahara I live in the and I'm planning to study biomedical engineering nice hi my name is Atul I'm in Wigglesworth and I'm planning to study economics in CS hello I'm zor I'm from India I'm studying computer science at Clark University nice man hi I'm Jasmine I'm from Shanghai I live in theer and I plan on studying CSN econ nice and hi I'm L from China sh I Liv in D wonderful let's three we have three attempts here to sort these numbers go ahead sort yourselves from 0 to 7 go one of you had it easy all right correct what was their algorithm what was the algorithm could someone explain step by step yes what they just did okay okay so to summarize those of you who had small numbers generally came this way those of you with big numbers generally came that way and step three was and then they generally figured it out okay so that's correct and that seems to have been a fairly organic process but let's take a more of a methodical approach here can you reset yourselves to match that same order so unsort yourselves again and let me propose that we try a couple of different approaches step by step so here we have some data that is unsorted and there's a few different ways I think I could sort of wrap my mind around this if I want to get the smallest numbers on the left the biggest numbers on the right what I think I want to do is maybe do exactly that like let me find the smallest number so seven at the moment is the smallest number but wait a minute two is now the smallest so I'm going to remember that not five not four one is now the smallest number I'm going to remember that six zero oh zero is now the smallest number and three so I think so long as I'm using at least one variable in my mind to keep track of what the smallest number is that I have seen I can select number zero and if you don't mind following me here we can put number zero at the beginning of this array but but but before you move we could have everyone scoot To the Left Right by taking a step but that's kind of wasteful I think right that means like a lot of work for a lot of people just to make room for number zero what would be smarter if I want to put zero on the left here yeah maybe I can just swap with number seven like you're in the wrong place anyway so could you please go over there instead where number zero was and number zero come on over here and now we have begun to sort the list I haven't solved the problem entirely but to use the vernacular of week zero I have taken a bite out out of the problem and frankly the problem is now smaller because if zero is in the right place now I have only seven problems remaining instead of eight so maybe I can do the same algorithm again Allah our familiar loops and select the next smallest number so two at the moment is the smallest so I'm going to remember that 5 4 one is now the smallest I'm going to remember that 6 7 3 okay so one is now the smallest so if you don't mind joining me here we're not going to move you all but I think we're going to evict number two now and have you go over there instead thereby swapping the values let's do this once more so I can ignore zero and one so the problem is now size five sorry I'm off by one the problem is now size six because we have eight volunteers and not seven my apologies five is now the smallest oh four is now the smallest two is now the smallest so I'm going to remember that but I am still going to keep going because at least for the moment I'm assuming sort of small brain here I only have one variable with which I'm keeping track of numbers and even though everyone in the audience with your bird's eye view remembers that two is obviously now the small number the only way I would remember if two is now the smallest is if I were using one two like multiple variables but I'm keeping it simple so I'm only using one variable in this story to keep track of the then smallest value now that I know it's two let's pull you back out even though we're undoing something here five let's move you here so that you two effectively swap now I'm going to do it a little faster so uh three come on out and swap with four now let's go ahead and do four let's go ahead and swap you with five selecting the now smallest element let's now go ahead and select five and swap you with six and even though I'm kind of making a bit of a mess here I'm doing the exact same thing again and again I just got a little unlucky Here and Now six and seven let's go ahead and swap you and now seven I'm all done so I think now they are sorted and that clearly took way longer but I think if we just did it like this like this like this it would be not only correct it would be step by- step and replicable and there would be no more sort of magical figured it out at the end but let's take one final stab at this before we break if you could go ahead and unsort yourselves to look exactly like that one final time and as you do this here we now have the exact same order as before so why don't I take different types of bites out of this problem because maybe I just think about the problem a little differently and as we've said since week zero there are often multiple ways to solve the same problem and you might think differently for me so here's maybe how you would think about it instead of going back and forth and back and forth looking for the next smallest element let's just solve the problem in front of me literally seven and two are the first two elements of this list but they are clearly out of order so what could I do let's just swap seven and two I have fixed at least one problem now now let's look at seven and five they are out of order so let's swap those two seven and four you are out of order let's swap you two s and one you are out of order let's swap you two s and six out of order swap you two s and zero out of order swap you two s and three out of order swap you two now I have improve the situation why what's the most glaring Improvement who is in the right place like seven is in the right place so even though my algorithm was fundamentally different I looked at pairs of people adjacently and I swapped them if and only if they were out of order I did take a bite out of this problem I have solved the problem of seven and so now if I do this again I can essentially ignore everyone at this end of the list because the biggest number thus far has sort of bubbled up for to the top so I bet I can do the same exact thing by just taking these small bites out of the problem two and five you're good five and four swap four uh five and one swap five and six good six and zero swap six and three out of order swap I don't have to even look at seven because I already solved that problem now I've taken a second bite out of the problem now even though I'm going back and forth back and forth in a different way I'm focusing more locally on pairs of problems two and four are good four and one swap four and five good five and zero swap five and three swap don't have to touch six or seven anymore so I'm nearing the end here two and one swap two and four stay two a four and zero swap four and three swap don't have to look at 5 six s anymore now back here 1 two you're good two Z Swap 2 three stay the same don't have to look at four five six or seven anymore down over here one Zer swap now I could just stop but again I don't have as the computer this luxury of this bird's eye view I only know if I'm done by going through the full algorithm one and two good two and three good three and four good four and five good five and six good six and seven good but I'm going to do one last pass because I previously made a swap and I think what I could do is stop if and only if I make no further swap so let's do this again 0 1 1 2 2 3 3 4 four five five six six seven now I would be crazy to repeat that process because why bother going back and forth across the list if I've done no work so I think I can conclude that the lists are now sorted so it turns out that what we have just done is Implement two different algorithms two of many different algorithms via which you can actually sort values on the screen um after our 10-minute break complete with cookies we'll come back translate this to code and something more algorithmic but finally a big round of applause for our volunteers and come on over this way see you in 10 all right we are back so let's sleap some names on the two algorithms that we just did with our volunteers the second and the third algorithm in particular that were much more formulaic the first of which we're going to call selection sord and I very deliberately was using language like let me select the smallest element and select the next smallest element selection sword does exactly that and let's make it a little more rigorous now in the context of these same doors so recall that anytime we've talked about the lockers for searching for for information the leftmost door is going to be bracket Z the rightmost door is going to be bracket n minus one where again n is the number of doors and if we start counting at zero as always n minus one is the end which means mathematically this is n minus 2 and so forth from right to left so those numbers zero and N minus one should generally stick in your mind anytime we talk about arrays so how might we Implement in pseudo code what I walked our volunteers through more methodically for that second algorithm well one way would be this 4 I from 0 to n minus one in other words initialize a variable or a a finger if you will and point at the first person first and then generally work your way through the list from left to right in order to get it sorted what do I want to do on each of those passes well I want to do exactly what I did as as with our volunteers find the smallest number between numbers bracket I starting at zero and numbers bracket n minus one so in other words if you start counting I at zero like any old for Loop and C you're going to compare everything between bracket 0 and bracket n minus one then the next time around you're going to compare everything in bracket 1 through n minus one then bracket 2 through n minus one and that's why in the first algorithm I was able to ignore everyone I had sorted behind me already I was constantly shrinking the problem and as soon as I found the smallest element recall with our volunteers I swapped that smallest number that I was remembering in my mental variable with numbers bracket I and again if you start at zero that's why we evicted the first person then the second person to sort of make room instead of creating a whole bunch of work for ourselves and all of our volunteers by like having everyone shift over each time we try to at least do a little more efficiently than that all right so what really was happening maybe at a slower Pace with selection sort if we had numbers like this well if we consider this left most element initially to be bracket I in general but of course it's still zero and then one and then two and the end of this list is n minus one what did I do on my first pass with that first algorithm that we're now calling selection sore well I first kept track in my mind of the smallest element I have yet seen from left to right and the first element is going to be by definition the smallest element if I've looked at no others so I'm going to highlight seven as being equivalent to remembering seven in my mind but then I found two so I updated the variable five is not smaller four is not smaller I eventually found one which is smaller so I remembered that number instead six is not smaller zero is smaller so I remember that instead three is not smaller and then that's why the next step recall was to ask seven to move move the zero to the leftmost place and then put seven back where zero once was we could shift everyone over but I was trying to make the point especially with our array that we only have a fixed amount of space so you can't just kind of like make room for someone we only had eight locations in total on stage however we could have shifted everyone but it felt like undo work the reality is it's not going to make a huge difference to the analysis of the running time of this algorithm but it did feel like unnecessary work at the time after I've done one pass of selection sort I've really only taken one big bite out of it I still had another seven and then six and then five bytes to go so the next iteration of this algorithm would indeed update I so that now we're looking at I through n minus one here and we would do the exact same thing again and again and again until we're all done with that problem to see this a little more visually give me just a moment here to pull up a animation thereof I'll flip over to this screen in just a moment but for selection sort let me propose that we visualize this as follows I'm going to go ahead and pull up on my screen here the following comparison sorting algorithms which is a nice visualization that some friends of ours at another University made and this array here represents numbers small bar is small number big bar is big number it just gives us more of a graphical representation of the same so ultimately I want all the small bars over here all the big bars over there and notice that there's clearly more than eight of these and they happen to be randomly sorted what I'm going to do at the bottom of my screen here there's some little playback controls I'm going to go ahead and speed up the animation a little bit and I'm going to go ahead on the top now and click selection sort and what's going to happen iteratively from left to right is that they are using pink just as I was using sort of my mind to remember which is the then smallest element and you'll see that it sort of fixates in pink which the then smallest is and then moves it to the left moves it to the left moves it to the left and this just goes on and on again and again but you can really see perhaps visually now how much time we're wasting I mean just like I was going back and forth and back and forth across all of our volunteers look at how many times the same bars go from Blue to Pink from Blue to Pink because we're touching that is we're looking at the same elements again and again and again and until we're finally done so selection sort as algorithms go it's actually not very efficient it's not very efficient it doesn't have a very fast running time really because of all of those extra comparisons so in fact we can sort of generalize this here if I go back to where we left things off and we originally had this array of numbers well if I've got eight numbers to begin with each pass is going to take like the first pass is going to take n minus one steps right if I've got n elements but I want to compare looking for the then smallest element I have to compare one against like n minus one other element so if I want to do some back of the envelope calculations here as to how many steps or more specifically how many comparisons selection sort has me make I would say that on the first pass from left to right I did n minus one comparisons why because I started over here where there are eight humans and I looked for the smallest smallest smallest element and I did so by comparing them n elements a total of n minus1 times to compare them ultimately so that's nus1 step steps the first time but that got me to having zero in the right place so then I had seven steps and then six steps and then five steps and so forth so if I generalize this with n instead of worrying about the specific number of human volunteers we had that's like saying n minus one steps the first time plus n minus two steps the second time plus n minus three steps the third time plus dot dot dot Plus finally one step when I'm all done solving the problem so how can I sort of work this out well if you remember like the cheat sheet at the back of your math book A series like this actually sums to * nus 1 all ID 2 and sort of trust me or take that on faith but that's what it equals now we can sort of apply some high school style um multiplication so we've got like n^2 minus n by Distributing the N all divided by two and If I multiply or if I divide that out I've got n s / 2 minus n /2 but here's where ASM totic notation is our friend I don't really care at the end of the day precisely how many steps selection sort takes I want to know on the order of how many steps it takes why because again I might have a fast computer a slow computer what I really care about is when n gets really big what really impacts the performance of this algorithm and I dare say that if you take a really big number and square it that's a way bigger deal than just dividing by two or dividing by two in other words the highest ordered mathematical term here is the n squar that's the one that's really going to matter when we're talking n equals a million a billion a trillion that's going to dominate all of the other characters so if I use my ASM totic notation to describe the upper bound on the running time of selection sort ah it's on the order of N squ I don't really care about the Precision when it comes to describing running times so n squ it's a lot and you can see it visually with that visualization all of the pink all of the pink all of the pink is because we were doing so many darn comparisons again and again so is there a categorization we can do here well with selection sort it would seem that in the worst case that algorithm might take us as many as indeed n squared steps but what about the best case what about the best case here when it comes to selection sord well could it be Omega of one could we get away and just get lucky with one step to sort the thing would it have to be more using the same code well consider then these doors here as being again representative of exactly what's been sorted could we get away with Omega of one or would it have to be something more well here's that same cheat sheet as before does anyone want to conjecture other than the person with whom I had a chat during the break with as to what the lower bound on the running time of selection sort might be maybe n s why do you say that yeah really well said even in the best case where the numbers just happen to start sorted which could happen in some perverse scenario the source code doesn't take into account that being possible in my pseudo code here there's no allowance for hey by the way if array is already sorted exit or quit early instead it is going to blindly do this n minus one times and then do this and then do this blindly so literally if I had eight volunteers come up and they sorted themselves in advance 0 through seven I would have taken the same number of steps even though nothing interesting would have been happening at least according to the source code we could clearly come up with better source code that is in written in pseudo code to solve that problem better but at least as written it does not do any better than that so we would say that selection sword is in big Omega of n^2 and now just to bring in the other Greek term the capital Theta if we have upper bound of n^2 and lower bound of n^ s you can also now conveniently say that selection sword is in Theta of n^2 because they're one and the same it's just a third term we can whip out what about the second algorithm now like clearly if it was the the second algorithm I proposed maybe it is in fact better in some way and not just because it might be a different way of thinking about the problem maybe it's better designed well bubble sort similarly treats our volunteers as this array from element zero to n minus one and here might be the pseudo code with which we could capture what we just did though I'm going to simplify a little bit for the sake of discussion and I'm going to tolerate some of the unnecessary footwork of going back and forth simply to keep the pseudo code simple but I'll stipulate that even if we were to optimize it a little bit Visa this version turns out that ASM totically it's still going to be in bigo of the same thing but we can do a little better on our lower bound repeat the following n times just like scratch for I from 0 to nus 2 so in other words if you think of our human volunteers I might be my left hand pointing at location zero first and then I want to compare each pairwise person so I want to compare person I to person I + one and that's what's really going on here if numbers bracket I and numbers bracket i+ one so if the person my left hand is pointing at and the person my right hand is pointing at are out of order then go ahead and swap them but I do this a whole bunch of times it would seem I repeat this end times and then inside of this loop I also iterate from 0 to n minus 2 well why is that well n minus 2 we don't normally talk about n-2 but if I'm comparing my eight humans and sort of walking down the array like I was I want to make sure that my left hand does not go to n minus one because n minus one is always the last person so where would my right hand be pointing at sort of empty space so I need to be careful and if I'm comparing things side by side I want I my left hand to go up to n minus 2 the second to last person or second to last element of the array so my right hand doesn't go over the end of the array itself so subtlety but that's why I tried to call it earlier the N minus one n minus 2 just to give you a mental model for that all right so technically speaking we can optimize this a little bit and if we really get into the weeds I only have to repeat this n minus one times why because once I get to the last the end of it like the per the last person is sort of naturally sorted already I don't have to worry about fixing one person they will have bubbled to the right location all right so if we have this list of numbers just as we had our array of volunteers what how do can we think about this visually well left hand is I in the story right hand is I + one and what did I do again and again and again I compared them and if seven and two are out of order I swap them s and five swap them s and four swap them s and one swap them them s and six swap them 7 and zero swap them 7 and Three swap them and notice just as with our humans seven bubbled their way up all the way to the end leaving me with seven more problems to solve but at least I took a bite out of the problem and in fact on the next iteration we would sort of come back and start over but strictly speaking we don't have to go all the way to the end this time so bubble sort fundamentally sorts the array but does it do it any faster well here is how again we might write pseudo code like this and let me propose two ways of thinking about the bubble sort running time it turns out when you have pseudo code in front of you or in the future actual C code or actual python code once you have an eye for it you can literally look at your code or someone else's and reason through how many steps each line of code should take so for instance how many steps will this first line take where you're repeating something n minus one times like this one's kind of a g gimme it literally will take n minus one steps CU it's just saying what it is all right what about the loop inside of this Loop and technically in C you could use two for Loops you could use two while Loops I'm just using English vernacular that is kind of simple as possible here but what about this for I from 0 to nus 2 well this is technically a total of n minus one steps because if you start at zero and then one and then two and then three dot dot dot all the way to n minus two you have counted a total of n minus one times so the Outer Loop by this analysis is going to take n minus one steps but every one of those interior steps is going to take n minus one steps so there's some multiplication going on here do this inner loop this many times but do that this many times too and now how many steps does it take to uh check if two numbers are out of order well that's just like comparing two numbers left hand and right hand so that's like one step and sometimes I swap them and all right swapping them means like this person has to come out this person has to come out then they have to SW SW so that's like another three steps so maybe this is like one step if we just kind of keep things simple maybe it's four steps I don't really care it's a constant number of steps no matter how big this array is I'll claim that you can swap people in constant time might be one step might be four steps but it has nothing to do with the length of the array it's only going to take the same number of steps to do that kind of swapping so now you can multiply this out n minus1 * nus1 times to keep it simple one or four whatever I'm going to ignore that factor we can then figure out how many steps this whole algorithm takes in fact if I sort of write this out as before nus1 steps * nus1 times that gives me if I sort of do foil or whatnot n^2 -1 n -1 n + 1 combin like terms n^2 - 2 n + 1 and here too like I don't really care about this level of precision if I wave my hand now the details ah this is on the order of n^2 also so to be clear if we compared selection sord and bubble swort technically they're going to be slightly different numbers of steps but the reality is if you run these algorithms long enough with big enough values of n they're both going to be super darn slow because the dominating factor is still n s now I can do one optimization in fact but let's first consider what the upper bound is in bubble sort the upper bound apparently is on the order of n s steps but as written to it would seem that this algorithm as written also is going to be Omega of n^2 because it's never taken into account hey wait a minute is the array already sorted in which case stop sooner we don't have any language for that here but what if I add a super simple conditional here I could after every iteration from left to right just ask myself did I make any swaps on that pass through the volunteers if so there might still be work to be done but if not why am I going to crazily repeat myself because if I didn't make any swaps one time I'm definitely not going to make any swaps the next time it's going to be stuck in some Loop so I can sort of short circuit my logic by just saying hey if no swaps on one of those passes quit you are done and if I do this now such that now I do maximally one pass if the list is already sorted to notice that the list is sorted what could you say bubble short it's lower bound is using Omega notation Omega of n it has to take you at least n steps logically to figure out if the array is sorted it cannot be Omega of one like if you're looking at eight elements let alone n elements there is no way logically to take one step and conclude that all n elements are sorted that makes sort of no sense but it is indeed an Omega of n because you just need one pass to conclude that everything is indeed in order so it seems that bubble sword is actually a little bit better let's see how it actually plays out visually let me go ahead and go back to my uh visualization from before I've rerandomized it and I'm going to click this time bubble sort and you'll see that it's going to solve the problem in fundamentally uh with the fundamentally the same outcome but notice that the work it's doing is a little different the pink indicates now which two pairs of elements are being compared again and again it's sort of nonobvious what's happening over here but clearly the biggest numbers are bubbling their way up to the end of the array just as our human volunteers we had number seven and then six and then five and then four but again here too you can see visually how many times we we are retracing our steps to ask a different question but again touching or looking at the same elements in memory again and again and again and this isn't even this many elements what are there like a hundred or so elements here like my God this is taking forever to sort this many elements maybe this is why then if you just need to answer a question once you just sift through the papers find me the number 50 and don't bother sorting all together but if you sort it once and then you have millions of customers like Google searching and searching and searching maybe it's wor wor spending that time up front and then amortizing it so to speak over the lifetime of the data itself okay I don't have to keep stalling because now that algorithm has concluded so to be clear with that optimization in bubble sort we can make it sort of better than selection sort but uh ultimately it's going to uh be still on the order of N squared steps questions on selection or bubble sort or sorting more generally yeah oh good question what happens if I press bubble sort now knowing that it is already sorted let's see if this visualization implementation is the Smart version with that additional conditional or if it just goes back and forth and back and forth ooh not well implemented notice that they are just blindly doing the first version of my code where there's no additional check did I do any swaps because even though you're seeing pairs of pink none of those bars are actually moving so this is both Big O of n^2 and Omega of n s AKA Theta of N2 AKA poorly implemented in this case missed opportunity for them to have done this I don't know if you need to be convinced that it's not going to do anything but all right it' be like holding in a sneeze if we don't go to the end almost done almost done almost done and no useful work was done but it's now indeed sorted all right can we do better than selection sort can we do better than bubble sort yes and there are dozens hundreds I mean maybe thousands of different sorting algorithms out there and in fact bubble sort and selection sort can be useful in the real world I mean I have actually in like research projects quickly whipped up in code and implementation of one or the other because it's just so relatively easy like first time through it like you're going to make mistakes you're going to have buggy code but they're relatively easy algorithms that you don't have to think hard about and in fact sometimes it's faster to whip up a bad algorithm and just let the code run then spend more time writing a better algorithm only for it to be done like this it's kind of a wash sometimes in the real world but in practice what we're going to find is you and I except for something like a homework assignment are not going to be in the habit of writing sorting algorithms anyway we're going to use a library like a lot of those other functions but you'll understand what algorithms are actually doing for you underneath the hood so what is a Technique we can bring to bear on this problem that might help us think about the problem a little bit differently and maybe help us solve the problem better and by better I mean let's stop repeating ourselves by touching those elements again and again and again let's really try to minimize the number of comparisons we're doing because that's what was getting computationally expensive in terms of time so here for instance is an algorithm we've seen before namely searching for things behind doors so this was binary search same as before whereby instead of looking for 50 I'm more generally looking for a number behind the middle door or to the left of the middle door or to the right of the middle door even though I didn't call it this earlier it turns out that this algorithm as we used earlier today is an example of what's called a recursive algorithm a recursive algorithm is one that calls itself or put more plainly in the world of c and frankly in the world of mathematics a function is recursive if it calls itself now we've used Main in code and we've called get int we've used Main and we've called get string what if main called main for instance that would be an example of recursion but generally frowned upon to have main call Main but we could certainly have another function that we write that maybe does call itself toward a useful end so why is that well notice that in this algorithm from earlier binary search it's already implicit that this search algorithm is using a search algorithm because I left it unstated well what does it mean to search the left half well implicitly to search the left half means shorten the list by half and then do all this again logically just apply the same logic to a smaller data set and because when we went left or right or left or right both this weekend and week zero because we kept shrinking the problem it's okay if you keep doing the same algorithm again and again the problem's getting smaller So eventually you're going to have no doors left or eventually you're going to find the number you're looking for so these cases here where you have very specific cases like if there are zero doors left or if I'm found the number I'm looking for those are generally what are called base cases where the thing sort of bottoms out logically and you get back an answer at that point no matter what these two lines that I've highlighted are generally called recursive cases whereby you don't get an answer yet you have to do more work by generally shrinking the size of the problem and doing the same logic again so a recursive algorithm or a recursive function is one that calls itself that uses itself but hopefully on a smaller and smaller size problem all right so with that said here is the same PUD code from week zero when I was searching the physical phone book looking for John Harvard for instance trying to call them if the number is there notice that in week zero I actually used very deliberately a loop it was not called that per se until we slapped some terminology on this algorithm but I literally said go back to line three go back to line three and then we said you can call these things loops and it means sort of visually you're going back and back and back but this could be Rewritten this algorithm from reek zero we could do something like this instead of saying open to the middle of the left half of the book and then go back to line three which really just means search the left half or search the right half why don't we just say that so let's collapse these two pairs of lines from week zero and just say search the left half of the book search the right half of the book I can now get rid of the blank lines and kind of tighten the algorithm up and now it's a shorter uh chunk of pseudo code even though it's sort of left unsaid well what do you mean search the left half what do you mean search the right half well who cares I don't need to tell you how to search half of a book I've told you how to search a whole book so just use the same logic to search half as many pages half as many pages half as many pages so whereas the previous version of this code here is an iterative version of our code in so far as it uses Loops this version now is a recursive version of that same algorithm so sometimes you can solve problems with iteration that is Loops or with recursion and sometimes one problem is just better suited for one or the other and among our goals in the coming weeks is to help you identify when you might want to use one technique or another but generally iteration tends to be the more comfortable approach but let's see this in context there is I've claimed recursive algorithms recursive code as in here there's also recursive physical structures in the world like here's that pyramid from Mario this one being pretty short and of height four let me get rid of like the distractions of the background this physical structure is recursive in some sense why well this pyramid PID of height four is really just a pyramid of height three plus one more layer of bricks well what's a pyramid of height three a pyramid of height three is really a pyramid of height two with one more layer of bricks what's a pyramid of height two it's really just a pyramid of height one with one more layer of bricks what's a pyramid of height one just a single brick so that last statement is sort of a base case I at some point I can't just keep like dragging things out and telling you telling you how one is based on the other at some point I just have to say pyramid of height one it's just a single brick stop but everything else can be recursively defined in terms of a pyramid of a smaller size so if actually I want to do this implementation let me actually whip this up in two different ways let me go back to VSS code here in just a moment and in VSS code here let's go ahead and make something called say iteration. C just to make clear what kind of technique it is so in VSS code I'm going to go ahead and say iteration. C and in this program I'm going to write code that prints out a pyramid like this of height four for instance or anything else so let me go ahead and at the top of this file include cs50.h so I can ask the user how big it should be includes standard io. so I can actually use printf let me go ahead and in int main void just tee up the beginning of a program that's going to ask the user for a height of a pyramid using our friend get in and then I'm going to assume for the moment that there is a function called Draw whose purpose in life is to draw a pyramid and going to pass in that height done so this now invites the question we have how do you implement the draw function well a couple of different ways let me do it iteratively with a loop so let me go ahead and Define a function that doesn't return anything because I just need to have side effects printing on the screen I'll call it draw it takes as input a value like n for the height that I want it to draw and then inside of draw what am I going to do well this is easier than problem set one was because of the the direction that the pyramid is heading so this I can do fairly quickly as 4 in i0 I is less than n i ++ and then inside of that Loop so that's going to give me row row row row I want to now print out um I want to print out the number of bricks for a given row well I claim with a quick glance int J equals 0 J is less than I + 1 j++ and then in here I'm going to go ahead and print out a single hash then out here I'm going to go ahead and print a new line so I did this super quick but let me convince you that it probably is correct here I'm iterating from zero up two but not through n so if I want a pyramid of height four this is like giving me the first row the second row the third row and the fourth from top to bottom because that's how the screen Scrolls but then inside of each of those rows how many bricks do I want well on the very first topmost row of a pyramid no matter its height how many bricks do I want there the very top I just want one like the single brick well if I start counting I at zero I don't want to print Zero Brick so I need to do a bit of arithmetic here I need to do I + 1 so 0 + 1 ensures that this inner loop J gives me one brick and then two bricks and then three bricks and then four so I just need to be a little clever and think about the arithmetic but I think that gets the job done that prints out Hash Hash Hash Hash one at a time but on at the end of each row I move the cursor to the next line so even though I did this pretty quickly and it might have taken you much longer to do problem set one as expected I think this will give me what I want so long as I avoid making a past mistake I need to put the Prototype of this helper function at the top so let me open my terminal window make iteration enter so far so good/ iteration enter let's do a pyramid of height four and it seems to in fact work and I can do this even bigger let me do a pyramid for instance of height maybe 12 enter and it seems to be working indeed with iteration well what if I instead want to use recursion as a technique instead bet I can actually do that because again what is a pyramid of height four well it's like saying print a pyramid of height three and then add one more row well what's a pyramid of height three well print a pyramid of height two and then add one more row what's a pyramid of height one two well print a pyramid of height one and then add one more Row the only problem that's interesting is how do you print a pyramid of height one well just print a single brick so curiously that kind of thinking will actually give us a fundamentally different solution so let me do this let me shrink my terminal window and close iteration. C let me open a file called recursion do c just to make clear what technique I'm using let me include cs50.h at the top let me include uh standard IO Doh at the top int main void again and in here again int height equals get int and then ask the human for the height then go ahead and call an imaginary draw function passing in that height which doesn't yet exist but now let's make it exist this function will again return no value because it's just going to print some side effects to the screen it's called Draw and it takes in the height call it n or whatever you'd like inside of this function let's go ahead and um consider what our base case is and I could say if the pyramid is of height one go ahead and print one brick but you know what even easier how do you print a pyramid of height zero you do nothing so I bet I can be even more clever here and just say if n equals equals 0 oops equals equals 0 then go ahead and just return don't return a value because it's void don't print anything if you want a pyramid of height zero you got it I don't have to do any work whatsoever if I really want to be careful I can say if you somehow do something crazy like give me a negative number I'm also not going to do anything because that makes no logical sense but that's just more of a a finer detail how now do I print a pyramid of height n according to my logic from earlier what would you have me print first as a pyramid of height n again it's kind of circular logic but how can I print a pyramid of height N I think I can draw a pyramid of height n minus one right which doesn't even seem logical because I haven't even solved the problem yet it would seem but if again you believe me that a pyramid of height four is really just a pyramid of height three plus one more row that is what I've expressed thus far print a pyramid of height three but now I have to print one more row well the one more row is actually trivial why because when I have a pyramid of height four what should the width be of the bottommost row four so it's nice n equals n like it's exactly what we want so I can do this pretty mindlessly in code for n IAL 0 I less than n i ++ and then in this for loop I think whoops in this for loop I can just print out a single hash mark and then at the bottom of that I can print out a new line so weirdly and let me add my um prototype up here void draw int and semicolon let's focus on the draw function here I feel like I haven't even solved the problem that you asked me to solve like one I plucked off this arbitrary problem like if you want no pyramid fine no pyramid it is return without doing anything then I'm sort of cyclically saying well if you want a pyramid of height n we'll just go draw it yourself as a pyramid of height n minus one but then the last thing I'm doing and this is where the magic IC actually happens I am also saying once you're done doing that other thing recursively give me one final row and where this works out logically if you sort of reason through this in your mind suppose you want to print a pyramid of height four initially well this does not apply because four is bigger than zero this does apply so you print a pyramid of height three that puts you logically back in this function how do you print a pyramid of height three not applicable well you print a pyramid of height two then we get back here doesn't apply how do you print a pyramid of height two well you print a pyramid of height one okay let's go back here doesn't apply how do you print a pyramid of height one well you print a pyramid of height zero that gets us back into here now this applies and I do nothing so it rewinds logically in your mind if following along and I just said to print a pyramid of height one I first print a pyramid of height zero okay did that didn't require much effort what do I then do then draw one more row and if n at this point in the story is indeed one this for Loop is designed to print one hash then the function will end and if you rewind in your mind's eye how did we get there well I asked to print a pyramid of height two but I first asked to print a pyramid of height one but all I have on the screen is a single hash but I add another row to that and if n equals 2 now that gives me two hashes then this finishes now we rewind again now I print another row three hashes now this finishes and rewinds now I print the fourth row so sort of in this weird mind-bending way by not answering the question but sort of kicking the can down the road by saying no you go do this so long as you take one bite out of the problem one row it logically all just kind of works out in the end so if I haven't made any typos let me open my terminal window here make recursion SL recursion Let's Do height four it actually does work let me make my terminal window even bigger and do it again SL recursion 12 it does actually work so which is better well in some cases of solving problems it just helps to write code recursively when what you were trying to do itself is recursive in nature and even though you probably haven't thought about any of the pyramids in Mario as being recursive they actually now are because again pyramid of height four is just a pyramid of height three it's just a pyramid of height two it's just a pyramid of height one it's just a pyramid of height zero plus one more row plus one more row plus one more row plus one more row we'll see future problems where in the data structures we're using in the computer's memory are sort of laid out two-dimensionally those kinds of problems too may very well lend themselves to recursion even if you can also use iteration or for Loops as well recursion is such a a common technique but a challenging technique in the real world that there's even little Easter eggs out there in fact let me go ahead and uh give me just a moment to pull up a browser and then I'll switch screens if I pull up say uh Google here any old Google window and you want to learn more about recursion so recursion enter you'll notice this little Easter egg that the Geeks at Google have had latent in google.com for years does anyone see the Cs joke at hand yeah what's that yeah it's asking you did you mean recursion well I'm pretty sure that's what I type so hahaha Let's click recursion now we're in night mode for some reason but did you mean recursion haaha haaha I mean that's that's maybe the kind of laughter at warrants but like this is a joke like it's recursion in the that Google is telling you to Google recursion again and again but of course the second and third results or whatnot are actually uh Real Results but you can try that at home by simply searching for recursion so again all it means for a function or an algorithm to be recursive is that if it uses or calls itself but so that you don't get into some infinite Loop like Google which ironically is sort of buggy and that it will never stop you have a base case where you just pluck off the easiest of the problems height zero height one whatever it is so that the interest interesting work is left to the recursive calls where you call yourself again and again all right any questions though on recursion versus iteration okay we've got one algorithm to go because I don't like selection sort or bubble sort yet even though bubble sorts seem to be a little better with that optimization my God even just a sort 100 elements that code felt very slow on the screen when visualized well let's introduce one other algorithm for sorting even though there's many more out there but merge sort is an algorithm that I claim is going to be faster even though it to will probably by Design bend your mind a little bit it's a little hard to wrap your mind around at first glance but among its ingredients are going to be recursion so the algorithm for merge sort is essentially this three lines of pseudo code which in and of itself sort of hints at the sort of mindbending sort the left half of the numbers then sort the right half of numbers then merge the sorted halves so like that is literally merge sort if you are handed a whole bunch of numbers like an array of numbers like we were earlier before the break how do I go about sorting all of them well first sort the left half then sort the right half then merge the sorted halves and the first two lines here feel kind of obnoxious like I ask you to sort in numbers and you say well you go sort these numbers and then sort these numbers like I haven't actually given you a solution to the problem but there's some magic in this last step merge the sorted halves so what do I mean by that well first let's consider the base case if I give you nothing to swort you can pluck that one off trivially just quit if there's only one number or hex zero numbers you're done and so that case is easy but the recursion is clearly manifest in these two lines because this is an algorithm called merge sort and if I'm telling you to sort the left and sort the right well you're probably going to use the merge sort algorithm to do that but the problem's going to get smaller and smaller so let's focus on what it means to merge two sorted have so wonderfully during the break we replace the lockers with these here shelves and on these shelves are two sorted lists of size four the whole list is not sorted CU notice I got 1 3 4 6 but I've got 02 5 7 over here suppose though I want to merge these two sorted lists together each of size four into one bigger list of size eight how can I go about doing that well this is what it means to merge two sorted lists you point at the first element of the first list maybe with your left hand you point at the first element of the right list maybe with your right hand and you compare those two values and obviously if I'm pointing at one over here and zero over here which is the smaller of the two well of course zero so what do I do I take it physically here I'll light it up for dramatic sake and I'm going to put it into its appropriate location up here now my left hand is still pointing at the one on this list my right hand is going to move to the right and point at the two same thing how do I merge these two sorted lists one of size four one of size three well I compare what I'm pointing at the one and the two let me go ahead now and pluck the one off and put the one at the very top there now my left hand and right hand are pointing at three and two respectively I compare two of course is smaller so I grab this light it up and put it up there now I'm putting it three and five three of course comes next I turn its light on and I put it in its right spot up here now I'm pointing at three four and five four comes next so I do this now I'm pointing at six and five five corbs next so I turn this on and pop it up here six and seven notice I'm down to one element in each list I'm almost done merging I pluck off six now I don't have to any more work to do with my left hand my right hand finishes here and I have merged the two lists together how many steps did that take well there's eight elements total 0 through seven and every time I made a comparison I moved my left hand or the right hand so ultimately I moved each of the eight elements once and only once so that's end steps to merge two lists of size n/2 plus size n over two and that's it so that's what I mean Toge two sorted lists but there is something subtle about what I did here that was pretty straightforward seems pretty easy to merge two already sorted lists but why am I using shelves all of a sudden this is very intentional I didn't just use a single table like where we had the lockers a moment ago yeah not yes I'm not shuffling the numbers around I'm not swapping things around in the same memory as are a human were I'm kind of cheating and using some extra space if you will literally twice as much space I started here and then I used sort of a a separate array that was blank for me sort of allocated but not used to store that and this speaks to a fundamental trade-off we're going to start to see almost always in Computing if you want to improve the running time of something you got to spend some resource you have to increase the amount of space maybe that your algorithm uses you have to increase the amount of time that you the human developer put into figuring out the problem case in point when I said earlier some sometimes I take shortcuts and I'll whip up a very stupid simple sorting algorithm why because my time I'd argue is valuable when I'm trying to solve a problem and I'd rather spend time on other things so I don't spend much developer time but that means my code is going to be slower as a result so space time development time money um any kind of physical resource energy nowadays is something that you can either increase or decrease and have an impact on these other measures as well so that's only how we go about merging two lists how do we go about sorting left and right well for this let me ask um Julia to join us up here on stage so that all act things out digitally on the screen very cleanly we'll also mimic what we just did here physically with this uh with the physical uh numbers in order to sort an actual list of values that starts off completely unsorted so the list we're going to do is this arbitrarily 6 3 4 1 270 we're going to start with them all on the top shelf ultimately and we'll see by acting out how we can go about sorting eight elements that start off completely unsorted and the three steps we're going to use are these sort the left half sort the right half and then merge the sorted halves together so those numbers again that Julia is putting in place are 63 4 1 then 5 2 70 we have not rehearsed this so we will see how well we both do together at this all right so here is the array of numbers at top physically represented here you can look at whichever demonstration you prefer let me make clear that this is really an array and indeed there's only so much shelf space like ulia can't just kind of Steal space over here to the right or over to the left like we are limited in space but she does have extra space here and technically here and here if she really wants it all right how do I go about sorting a list of size eight well what was step one sort the left half step two sort the right half step three merge the sorted halves that's all you have to remember so here's the original list how do I go about sorting the left half sorry how do I go about sorting the original list I go ahead and I sort the left half so ulia is kindly going to act this out by just using some additional space I'll do it digitally here this now is a list of size four how do I sort a list of size four well I've got an algorithm for that sort left half sort right half merge the sorted halves so let's do this let's go ahead and sort the left half of this list of size four and now how do I sort this thing well this is now a list of size two how do I sort a list size two sort the left half sort the right half merge the two halves this is where things get kind of stupid temporarily okay done sorting the left half done sorting the right half but what's the magical third step merge the two together how do I do that left hand right hand trick six and three are being compared three of course comes first and then six so I have merged those two together and so now we have a sorted list of size two but this is still unsorted that's still unsorted so what came next how did I get get to this point I sorted the left half I sorted the left half I sorted the left half right half I merged so what step comes next sort the right half of that original half this is where it's hard to sort of keep track of but if you take on faith now I'm going to sort the right half how do I do that sort the left half of that right half done easy sort the right half of that right half done that was easy let's now merge together left hand right hand which comes first one obviously so I sort the one or I merge in the one now I merge in the four now at this point in the story I've got a sorted left half I've got a sorted right half what comes next merge the sorted halves how do I do that left hand right hand one comes first so I merge that in three and four three comes first I merge that in six and four four comes first now no more right hand so I merge in the six and now not coincidentally you see that we have sorted the left half just like the short demo I did earlier that was a lot of work a lot of talking we still have another half to go but I'll do it can more quickly let's see how quickly we can do this how do I sort now the right half of the original list after sorting the left half well what do I do I go ahead and sort the right half all right well what does it mean to sort the right half I'm going to go ahead and sort the left half of the right half all right what does that then mean sort the left half done sort the right half done merge the two halves two and then two two I have two okay good and then five okay good and now the left half of the right half is sorted now I sort the right half of the right half so I got the seven Z and I sort the seven done zero done now I got to do the merge step pointing it left hand and right hand the zero comes first then the seven now I have sorted the right half of the right half what's the third step merge those two halves so I point left and right zero comes first then two then five then seven and now I've sorted the right half this is like a really difficult Price is Right kind of thing here all right so now we've got the sorted we've sorted the left half we've sorted the right half what's the final final step merge the two halves and this is exactly what I did before so dramatically as the lights come on with each of them pointing at left and right zero comes first then one okay okay what comes next two comes next then three then four then five then six and a huge round of applause for Julie if we can once we hit and seven [Applause] thank you okay so she and I will debrief as to WEA we need to both of these visuals moving forward but hopefully it makes clear that all we're doing is like this mindless fairly bite-sized problem solving of sort left half sort right half merge the two halves and if we now consider just how much faster or slower that is like than an algorithm like um selection sword or bubble sword let's see if we can't analyze this just a little bit we ended up having an entirely sorted array but how did we actually get there well if we um consider what the possible buckets are for ASM totic running times here let's consider the sort of breadcrumbs we might have left along the way if I didn't keep deleting things as I went so we started with these numbers up here and at one point or another we did all of this work that's pictured on the screen even though it only was up on the screen briefly so in other words we started with one list and then how many times did we divide it in half one time two times three times so sort of we did this dividing and conquering of the entire list three different times so we could get to this like these leaves if you will and even though we won't we'll talk about this more in future weeks if you've ever drawn like a family tree where you might have like Grandma and Grandpa and then parents and then children and so forth it's sort of like an upside down tree whose branches grow downward where the leaves so to speak like The Descendants are at the very bottom of the tree and that's terminology will come back to in the coming weeks but how many times could we chop up this original array into smaller and smaller pieces three times for each of these elements here moreover how do we how many steps did it take to merge those lists back together well that's going to be the operative question it turns out that the number of times we were able to divide the original list in half and half and half to get to those very single stupid problems of single numbers was log base two of n you can do a bit of a sanity check here whereby if you just do the mental math if we had eight elements originally and the answer to this question is three well that actually kind of works out because log base 2 of 8 actually is three which describes exactly how many times we chop the problem up into smaller and smaller pieces but again there was some merging going on whereby we actually wanted to merge those then sorted lists together so how did we go about doing that well every time we merged we only looked at or physically touched the number once before putting it into its place so my hands were constantly working their way through this list such that when we had the Singleton done one 1 2 3 4 5 6 7 8 work was done when we did this work it was 1 2 and then 3 4 and then 5 six and then 7 eight steps as well to merge those together then it was 1 2 3 4 5 6 7 8 in other words no matter what conceptual layer of this tree we are in it was taking me n steps or eight specifically to do that merging so what that then invites is What's the total amount of running time involved here well if you're doing N Things log base 2 N times the total Math works out to be n * log of n so that is to say merge sort unlike selection sort unlike bubble sort is in Big O of n log n which even if you vaguely remember your logarithms log n is smaller than n so n * log n is definitely better that is smaller than n s so if we consider our sort of cheat sheet here of the possible running times that are common merge sword is in Big O of log n however nothing I or Julia did took into account whether the list was already sorted or not so it's fair to say that the lower bound on merge sorts running time even if the darn thing is already sorted is also um n log n now that's not as good as n but at least in general it's way better than N squared but here again is a trade-off if you want to have this nice recursive solution using merge sort you might not get a lower bound running time unless we go and add more sudo code that maybe does something silly like check the list first if already sorted quit and you just kind of special case it with a conditional but that's sort of a lower level refinement that we won't bother with today but merge sort then is an N login as are frankly a lot of sorting algorithms that you would use in the real world or use in a library and so as our final flourish today what we thought we would do is compare these three algorithms that we focused on selection sword bubble sword and merge sords in particular what you're about to see is a visualization of some random data uh three different different times the top chunk of data is going to be sorted with uh selection sort the bottom data is going to be sorted with bubble sort and the middle data is going to be sorted with merge sort and the goal here will be to actually assess and feel and hear what the difference is when you put a little more time a little more thought a little more effort into designing your code not only correctly but well and thus efficiently in order to solve problems more efficiently so if we could dramatically dim the lights we will hit play on this final flourish [Applause] [Music] [Applause] oh [Music] all right the music just makes sorting fun but that's it for cs50 we'll see you next time [Music] [Music] [Applause] [Music]