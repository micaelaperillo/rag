[Music] [Applause] [Music] [Music] [Music] all right this is cs50 and this is week four on memory wherein we reveal topic that's actually fairly distinct to cs50 nowadays as an introductory course known as pointers indeed today is the day you can tell your friends that you learn something about pointers and in turn how computers work underneath the Hood um I will say that this is the kind of topic this is the kind of lecture where probably won't all sink in the first time around think back to that fire hose that we showed in week zero in fact all these years later I still remember where I was on campus when finally today's topics finally clicked for me it was in office hours in Elliot House dining hall in the back right hand corner which is only to say as you approach this week's material this week's problem set four um take comfort in knowing that it is challenging it's meant to be challenging but as we sort of Ratchet things up and up and up over the past few weeks we will start to plateau in just about a week and then it's sort of smooth sailing there on out even though it might not feel that way initially this week but this week we'll focus all the more indeed underneath the hood at like how information is represented like this your photograph of the bowl of stress balls that we have most every week but recall that anytime you have an image like this it of course is composed of pixels and those pixels or dots each have some bits or bites associated with them that prescribe what color those dots should be but there's only a finite amount of information in there so if we sort of enhance enhance enhance like you don't actually see the 5 Z more and more clearly you only see it larger and in fact at this size you can actually see the the dithering so to speak which is sort of this cloudiness that looms over the image and you can kind of see the outlines of the actual pixels all of those hard vertical and horizontal edges are the pixels the dots that compose that image so this is actually an example of an in fact on this last slide here can you see them even most clearly on the screen as we go and go and go so how do you go about implementing then or representing something like an image well there's Bunches of different file formats out there for images like there's GIF there's jpegs there's pings and there's others as well but the simplest of them like a bit map image is literally just a map of bits horizontally and vertically conceptually so for instance here is a grid of bits zeros and ones and suppose for instance that uh maybe o represent zero represents black and one represents white can anyone with their human eyes see what this is a picture of even though it's just zeros and ones can you see it yeah so it is actually a smiley face because if the zeros are black and the ones are white this is what's actually Laten in that image it's hard to see at this size of course but if we were to shrink that down and actually use Square pixels black and white it would probably pop out all the more clearly of course it's not that useful to store things with single pixels because you can only represent two states like zero and one like black and white and so here might be that same image actually zoomed in such that you can see all of those individual pixels but when it comes to color we of course need more than a single zero or a single one to represent each of those pixels we probably need like 24 maybe three bytes worth for some red some green and some blue and recall that that's in fact one of the uh ideas we implement we uh talked about in week zero how do you go about representing images for instance so more generally this is actually kind of an art nowadays if only for fun to actually use small dots and and compose things on the screen and wonderfully just before we began today two of your classmates bravely volunteered and in fact let me invite them to come up and introduce themselves before we reveal what they have made on this canvas here using Post-it notes Square paper as their pixels hello my name is Selena I'm a freshman in Wigglesworth I'm thinking of studying Robotics and possibly in secondary in AFS welcome hi I'm Jeffrey I'm a freshman in the hall and I'm thinking about concentrating in econ and CS all right welcome and allow me hang on to the microphone if you would I'm going to go ahead and reveal what they kindly did on very very short notice before class began and here is what they came up with a grid of pixels two colors here what is it that we're looking at you tell what it is shall we say it's well should we make we can ask the audience what is it they made because they're they're a little um a little insecure about their pixel art Saturday ladder again a flamingo wa is it a flamingo no no they said a palm tree on an island oh it's a palm tree on an island all right maybe a round of applause for Palm Tree on an island if we could thank you here we go so suffice it to say when you do have just thanks very much if you have just a single color to use black or white you're using one bit art it's actually kind of hard to paint a picture but if you do have actually more colors at your disposal and an even bigger grid can you do more interesting things and so in fact um we invited fol some past students to do exactly this we shared a Google spreadsheet whereby we use the cells instead of as long default rectangles we just turn them all artificially into squares so that you can use sort of the paint bucket tool and just paint different pixels onto the screen and among the pieces of art that some of your predecessors came up with were this here A scene from Mario using a a grid of multicolor pixels uh this one here of scratch the cat uh this one here in honor of the Harvard Yale football game coming up in a few weeks time uh this one here using uh a bit of the same and in fact if you'd like to play along at home just for fun if you go to cs50. lart you can make a copy in your own Google account of that blank spreadsheet and just play around if you'd like to experiment as well but this is really meant to motivate one of today's topics which is indeed how we can start to manipulate data at a lower level including images and other things and images of course can be among other ways be represented with RGB some amount of red some amount of green some amount of blue before we dive into that though let me and augment our vocabulary a bit today by adding another base to our system so we have binary of course which is base two we have decimal of course which is base 10 today we're going to introduce one more which is useful in today's Concepts as well as others as we'll see down on the line known as heximal where you actually have 16 digits at your disposal and if any of you are artistically inclined or you might have dabbled in web development you might actually be familiar with hexadecimal notation itself already here for instance is a screenshot from Photoshop whereby if you use the so-called Color Picker to manually choose a color that you want to paint onto the screen you see a lot of information over here but Salient to today's conversation is this here where there's a hash sign and then typically six or sometimes three digits in this case 0 000000 0 means that the color I'm going to get here is actually black so it's sort of no Red no green no blue hence the zeros means you're going to get black meanwhile if I play around with the same uh Color Picker and I instead do FF FF FF either all caps or in lower case I actually get a color that we're going to see today is going to be white which is like a lot of red a lot of green a lot of blue all the frequencies of light coming together to give us what we know as white light but now we can kind of play with this because it's no coincidence that these are indeed six digits of sorts even though they're letters of an alphabet and not numbers yet per se for instance ff0000 would seem to mean a lot of red and no green no blue and indeed that's why we get red according to photoshop itself 0000 ff0000 gives no red a lot of green no blue and of course that's the color Photoshop would give us and lastly 000000 f F gives us indeed blue because that's no red no green but a lot of blue so the zeros would seem to make intuitive sense here if you have no red no green no blue but what's with the FF like ff of course in English are letters of an alphabet not numbers well it turns out that photoshop and people in the world of images and people in the world of computer memory tend to use a different system all together they don't use binary and no one really in practice uses binary except the computers we use because you can't do or see much with zeros and ones alone we humans in the real world use the decimal system again 0 through 9 which is just very conventional but in the context of computers and specifically memory and files and images we tend to use heximal which gives us another six digits in our vocabulary and I'm deliberately calling them digits even though they appear to be letters but this is just a convention we just need we need we want six more symbols so we have 0 1 2 3 4 5 6 7 8 9 I don't want to say 10 and I don't want to write 10 cuz that would be two symbols on the screen so the world years ago decided all right when we want to represent 10 with a single digit let's call it a and then B for 11 and then C and then D and then e and then F where F happens to be 15 so this is what's known as heximal notation and it's really the last of the notations or systems that we'll use you can use uppercase or lowercase the software you use kind of decides what convention to use but they mean one and the same so heximal hex implying 16 in this case otherwise known as base 16 all right so just a bit of jargon out of the way how does it actually work mathematically like the exact same way as in week zero the math is a little different it's not going to come to intuitively in the same way but the system is the same if you've got two digit values here like here are some placeholders The Columns represent the 16th to the zeroth place the 16th to the one place that math is easy this is the ones place this is the 16's place instead of in our human decimal World ones 10 100s or in the binary world 1 2 48 same idea just different powers uh in for each of the columns all right so this number 0 0 represents the number you and I know is zero in heximal 01 represents the number U and I know is one and it goes from there pretty straightforwardly 0 five 06 07 08 09 translates to exactly what we know in decimal like the number n because it's 1 * 9+ 16 * 0 gets a little more interesting when you're using two digits but you're using heximal because now if I want to count as high as 10 in decimal I would represent that in heximal as 0 a 0 B is 11 0 C 0 d 0 e 0 f and there's our F and F I'll stipulate just represents the number we know as 15 so 1 * F gives us 15 plus 16 * 0 all right dot dot dot we're not going to do the whole range of numbers here but I don't want to call this 10 in heximal just like in binary even though you might see 1 Z you don't say 10 you would say 1 Z same in hexadecimal so this is 1 Z but if I translate this pair of digits to decimal what does this represent so this is 16 because I've got 16 * 1+ 1 * 0 and on up and on up and on up we can sort of do this for quite a while it gets interesting only once we get to the end using heximal as I've defined it what's the highest we can count with two digits then in heximal FF would be the highest because F seems to be the largest digits so this is actually 16 * 15 + 1 * 15 actually gives me 255 so that is as high as I can count in HEX aimal from 0 0 to FF otherwise known as 0 to 255 and if you don't believe me quick little math will give us that again 16 * 15 + 1 * 15 as well all right so how is this useful doing out this math well we have uh the following con oh actually why is this useful so it's very common to use two digits of hex maybe possibly more why well it turns out that to represent the numbers 0 through 15 let me spread these apart now just to be deliberate about it 0 through 15 how many bits do you need well zero you can use any number of bits how about 15 like how many bits sorry how many bits do you need to count to 15 so it turns out it's four right because in binary that would be what to the e Place Plus The Four's Place Plus the two's Place Plus the one which I think gives me indeed 15 so why is heximal useful well it turns out that you can represent a single hex digit whether it's zero or f using four bits no matter what and so why do we tend to use two heximal digits well it's just useful to be able to describe a single bite otherwise known as eight bits using two digits instead of eight so in binary we'd have to use eight in heximal we can just use two and it's just useful visually heximal is useful as a result all right so when are we going to see this and why are we going to see heximal well here's like a grid of the computer's memory just abstracted away as uh bite bite bite bite in rows and columns well here is how we might number those bytes as I've stipulated for several weeks now we could call this bite zero this bite one bite two dot dot dot all the way to bite 15 but by convention we don't use decimal and we definitely don't use binary instead a computer scientist would think of the addresses the locations of the count of bytes in memory as still starting from zero 1 2 3 on up but as soon as you get to 89 a b c d e f again just a convention there's nothing really intellectually interesting here other than we're using a different base system instead here's how the others might play out and it gets a little confusing because this one zero is not 10 if it's in heximal but clearly there's some potential ambiguities here like it's pretty obvious now that if you see an A through F okay it's probably heximal but if you see 10 or 11 or 12 well it's maybe not it might not be 10 or 11 or 12 those might be heximal even though 1 a 1 B is so this is an ambiguity and so what we're also going to see today that the way humans have mitigated this potential ambiguity is when you write things in heximal by convention you put a0x before them a zero and typically a lowercase x that does not mean anything mathematically it's not an extra zero say it just means to the human reading this here comes a heximal number and now there is no ambiguity so we're going to see a lot of this today generally we won't care about the numbers but that is what we're going to be looking at is heximal so any questions on heximal which again is just another way of representing numbers any questions on heximal okay so let's see this in practice and start to tease apart what's going on underneath the hood of our computer all of this time when we actually uh start to use variables and more so here's a single line of code give me an integer called n and I initialize it to the value of 50 so fairly straightforward so let's actually do something with this kind of code let me go into vs code here let me go ahead and create a program called let's call it addresses uh. C because I want to look at the locations in memory the address of things in memory and let me stipulate too as we've said in the past just as mailboxes in the real World houses and buildings in the real world have unique addresses like we were at 45 Quincy Street Cambridge Massachusetts 02138 USA similarly does your computer's memory have addresses but they're super simple numbers like 0 1 2 dot dot dot all the way on up so I've created a program now called addresses. C let's just play around with some familiar code let me include standard i.h let me do int main void so no command line Arguments for this let me declare that variable n set it equal to 50 and let's just print out n so this is like week one stuff super simple and prob and presumably familiar by now whereby I want to print out using the percent ey placeholder the value there of n all right hopefully if no syntax errors I can do make addresses enter so far so good/ addresses enter and I see as expected the number 50 but what's actually going on inside of the computer's memory in this case well we can actually see that over here let's look at this grid of memory here for today's purposes I don't necessarily know where in the computer's memory at this point the N is going to end up so let's just arbitrarily say the computer finds room for the INT in the bottom right hand corner of my screen the size of it is deliberate because recall that integers tend to be how many bytes on most systems nowadays four bytes by convention AKA 32 bits if you multiply by eight so who knows n might very well end up in the bottom right hand corner of my screen here with the number 50 stored there now it's not literally the number 50 there's literally 32 zeros and ones in the computer's memory that are turned on and off to represent the pattern that gives me the decimal number 50 so again that's sort of week one style stuff but we're thinking about now the computer's memory in fact even though we refer to it as n in my code it's got to live somewhere and the address at which it might live for the sake of discussion is maybe something notationally written in heximal like ox12 3 completely arbitrary in practice it's probably a bigger number than that but for the sake of discussion let's assume that that 50 the variable n just so happened to get placed by the computer at location ox123 can we see that in code we haven't yet thus far but if I propose here maybe going back into VSS code in a moment maybe we can actually use some slightly new syntax and poke around the contents of the computer's memory but before we do that we do need a few new building blocks and there's not much new syntax today but we're going to go pretty darn far in terms of capabilities with just a few new symbols it turns out that in C if you use the Amper sand Operator just one of them not two two means and logically just like two vertical bars me or if you use just one of them as we are going to today that is the going to be the so-called address of operator so you can write Ampersand in the name of a variable and the compiler essentially will tell you where that variable is in the computer's memory Technically when the program is running you will be told where it is the star operator or single asterisk is not multiply in this context it's going to be the dfference operator which is going to be a trick via which we can have an address and go there sort of following a breadcrumb following x marks the spot on a map and going to that location in memory and just see what's there is it an INT is it a Char is it a string or something else so these sort of reverse the effects of each other this tells you the address of something this tells you how to get to something so the addressive operator and the D reference operator so to speak but we need one other building block and this one's going to be useful in the context of printf recall that print F has all those format codes like percent s for string percent I for integer percent f for float turns out there's another one percent P which is going to allow us to print what are called pointers which are uh really for now synonymous with addresses in memory so using just those new building blocks let me propose that we do the following leveraging this notion of a pointer I'm going to change my code in just a moment to still have the same single line here in n equals 50 but then let's create a second variable called P just for convenience but let's declare it as a pointer a pointer is simply a variable that stores the address of something so it's a a variable that stores the address of something like ox123 or some such value how do you use it syntactically it's a little weird especially since we've used star and the ersan in other ways already but you say that I want a variable called P the type of this variable is going to be a pointer so to speak how do you express that well I want it to be the address of an integer so you say int but you make clear that it's the address the address of an integer not an actual integer per se by putting a star here of all the things we have in will CNC I will concede this is sort of the most confusing way to do this ideally there would just be a variable called pointer and you just write it and you get a variable that's a pointer but in the way in the case of C you actually specify that this variable P will indeed be an address that points to an integer so just have to kind of let that ingrain in yourself this one's a little easier Ampersand n how would you express that in English based on my previous definition the address of n ersan n just means get the address of N and because code recall is read and executed right to left in this case this says wherever n is get the address of it like ox123 and assign it to the variable P what is the variable P it is a pointer so to speak that is the address of an integer so it's a little it is Arcane it's a little weird but this is kind of as low level as we can get with C with just telling the computer exactly what we want to do so let's see this let me go back to vs code here and quite simply after clearing my terminal let me go ahead and print out using percent p uh the following address of N and then we'll enhance this code to actually introd actually no let's do this exactly as I did let's go back into vs code here let's declare int star P equals ampan p and then print out not I itself not n itself but print out using percent P the value of P itself so what is this going to do for me it should print out the address of n all right so in my terminal window make addresses enter huh I messed up because I did something stupid I forgot the semicolon as you might have one or more times the past few weeks let's do this again let's make addresses enter damn it uh I screwed up a second time I want the address of n not the address of P all right so I'm doing well so so much for remembering this concept from the dining hall of Elliot house all right so make addresses enter oh my God thank you all right so now it works hopefully SL addresses it's not going to be as simple in the actual computer is ox123 it's probably going to be a bigger number and indeed it's a much bigger number but there is an address of some sort might be different run on a different system but it turns out that the variable n is stored at location ox7 FF f3c 2925 C which is just a really big number that if we did all of the math on paper pencil computer would be a really big decimal number why the server has lots of gigabytes of memory billions of bytes so of course it's probably going to be a big number like that now I don't strictly have to create p in fact let me do what my instinct had me doing a moment ago let me delete p and simply just print out directly what is the address of n let me go ahead and recompile the code make addresses do/ addresses and I actually do get a different address this time why because I've run the program again and things got organized in memory a little bit differently so these numbers are not going to remain invariant unchanged but every time you run the program things might deliberately or for other reasons get moved around but all I have done is asked the computer explicitly what is the address of N and that's what I'm seeing all right so just to recap then what these lines of code are doing previously when I had both n and p this lad line is just asking what's the address of n storing the address thereof in this variable P but there's some disagreement in the world as to how you should write this syntactically and just so you've seen it in case you see a video or a tutorial or book that disagrees this is really the conventional way to write the star that means hey computer this is a pointer to an integer the address of an integer you could also write it this way and some people do this I do think it's a little conf uh this can get you into trouble in certain cases some people do this with spaces on either side which even looks more like multiplication but it's not not all three will work but the recommended the conventional way is indeed to do this even though I do concede it looks a little weird but it'll get more and more comfortable over time all right so if you're with me that what we've just done amounts to just figuring out where in the computer's memory a variable actually lives I think we can poke around further to see even more of what's going on in fact let me go ahead and propose this let me propose here that we go back to VSS code here clear my terminal window and let's go back to the version before where I explicitly did have P so int star P equals ERS send n and then again printf quote unquote and what I had before was percent P back sln comma P so this printed again the exact same thing the address of n but what if I actually want to print out n itself just like I did in week zero well in week zero oh sorry just like I did in week one in week one I could have just done as I did a few minutes ago this and this would print out in the old school way the value of N and just as a quick check make addresses do/ addresses and there's my 50 as expected but now that I have these two other operators whereby I have both Ampersand and star I can kind of poke around with them play around with them in ways that should hopefully with some practice make sense so for instance I could do this again int star P equals the address of n well I could print out n literally as I'm doing now or I could use the location of n called p and go there with the second of these two operators the D reference operator the D reference operator the single star means go to this address and so now when I go back to VSS code and I do make addresses do addresses enter I still get 50 I'm kind of jumping through hoops proverbially here because this is sort of the stupid longer more complicated way to print out the value of 50 but it just speaks to the relative power that I have by just figuring out what the address is and then going there but the confusing part I do think about this for for me and for for most folks learning this is the following the designers of C decades ago made I would say the unfortunate decision to use the star in two different ways and three different ways in total one multiplication we saw that in week one since but notice that there's two different uses of this star operator here it literally means go there dreference the address that is follow the breadcrumbs and go there but when you declare the pointer when you create the pointer you also use a star but you also use the type so what's confusing at least to me is that we're using the star in two different ways both of which are related to addresses both of which are related to pointers but when you create a variable or uh declare a variable for the first time you specify not only star but the type of the pointer just like any other variable declaration but when you use the pointer subsequently you do not mention the data type again the compiler is smart enough to remember okay got it you wanted a pointer to an integer the compiler will remember that for you you do not need to remind it so admittedly confusing but on line six we are declaring the pointer and assigning it a value and on line seven we are dereferencing the pointer so one sort of uh one creates the pointer one goes to that their address so in terms of what's going on inside of the computer's memory let me propose that if we revisit the same grid and we propose that 50 ended up down here the value n is actually technically at ox123 what exactly is p the second variable well I could draw it as follows In My Memory Maybe by chance it ends up here sort of higher up on my slide but this is the variable called p and the value of p is simply literally the address of n why is p so big well it turns out on most systems nowadays pointers that is addresses are 64 bits or 8 bytes so they just use a lot of bits why well you and I have gigabytes again of memory nowadays and if you're counting up to the billions of bytes you actually need more than four bytes or 32 bits because recall from week zero even the highest you can count with four bytes or 32 bits is 4 billion but some of you probably have maxer PCS that have 5 GB 6 gbes 8 gab or more of memory nowadays that means we need 64 bits to count that high so we can actually label every memory location in order to access these spots so what is p it's just a variable whose value happens to be an address what is n well it simply happens to be an integer at that address what questions do you have on this yeah are you able to use more than one pointer in main absolutely just like variables you can create as many as you want including arrays thereof how do you differentiate them by way of their name so I'm using p because it sounds like pointer but I could call it Q or r or s or t or use an actual English word to uh to describe my variable I'm just using p for short just like any variable yeah does the pointer have an address itself a good question does the pointer have an address itself short answer yes because anything in your computer's memory has an address and odds are it really has eight addresses associated with it so maybe we refer to it by the first one or something like that there actually exists but we won't do this today pointers to pointers which answers that question but here I'm leaving it abstracted away and just calling it P but it absolutely has an address other questions yeah you may have already said this but when we're like referencing p in the code do we do P or a good question when you're referencing p in your code do you dreference it do you use star p short answer yes if you want to go to that location and that is usually as we'll see this week and next week how pointers are useful you want to go to that location and do something there it is rarely if ever helpful to literally print or see the actual address because who really cares especially if it changes every time I run my code we we as programmers don't care where things are but that we can get to those locations a good question yeah Theory right sorry theual phys memory yes without going too down this Rabbit Hole today this we're talking really about virtual memory this Maps underneath the hood using virtual memory to physical memory but for all sense and purposes we're talking about one in the same today old computers simpler computers simpler times okay so how can we now um sort of think about this well that is literally what's going on in the computer's memory but as I just said rarely do we actually care that it's specifically at ox123 and in fact the name pointer kind of conjures up a nice metaphor here let's sort of ignore all of the bites of memory that we're not even using or talking about anyway and who really cares about ox123 let's just abstract that away as we've done in the past with literally an arrow when drawing or talking about these things and just think of p as being a variable that literally points to another location in memory so indeed whenever a computer scientist is talking about or arguing about or designing something that involves memory they're not going to get into the weeds of doing Ox anything they're just going to use arrows to draw things uh on paper or digitally and in fact next week when these sort of all comes to a head when it comes to memory we're going to build things in computers memory known as data structures fancier structures than simply arrays we're going to do one-dimensional structures two-dimensional structures and we're going to use pointers as sort of a thread with needle to connect this location with this one with this one then this one and start to create two-dimensional objects if you will inside of our Macs our PCS our phone's memory as well so to make this super clear we actually do have a nice metaphor maybe if Julia wouldn't mind coming up I keep saying that you can think of addresses in memory as being akin to physical addresses in the real world like mailboxes for say this building again 45 Quincy Street in Cambridge Massachusetts and here then is a a mailbox that has the name p so this is appropriate because if a pointer is a variable that stores an address this here mailbox called P would seem to be I'll say storing in a dress meanwhile Julia has a separate mailbox here that's actually called n so it's like a variable in memory we're kind of cheating because technically the pointer would be twice as big as this mailbox but Home Depot only has so many different sizes so they look the same physically but n according to the story lives at address ox123 so if I am the computer and I am executing code that looks like Star P go to the address stored in P that's akin to like a person opening up a mailbox looking inside seeing that what's in there is not an actual value you care about per se but it's kind of like a treasure map x marks the spot if we sort of abuse the metaphor which just means if I want to go to the address in P that means I look in computer's memory and just to be dramatic we can do this too we got a little big foam finger this is like the computer pointing at the actual location ox123 and voila there is the number 50 that we care about and for those following along at home maybe avert your eyes here in Sanders we can similarly do this with the Y foam finger as well to dreference that as well and the crowd went wild for those of you watching from New Haven today with Applause so thank you to the Julia though for this particular demo yes yes we will we will enhance the Applause in the final version of the video so um let's now revisit admittedly a bit of a white lie that we've been telling for a few weeks now and I kind of tripped over this in week one but then sort of waved my hand and solved it real quickly by introducing the cs-50 library but I'm going to propose that we revisit what a string actually is now we use strings in week uh one we then began in week two to talk about strings thank you is just being in Array of characters so that was the first reveal but even then we kept using the word string but it turns out that strings do not exist in c as a data type strings are not a cs-50 thing per se but there is literally no keyword in C called St r i n string it's a concept that exists in C so nothing is that we've said over the past few weeks has anything to do with cs50 per se almost every programming language you'll encounter in the real world supports strings in some way but my claim today is that the keyword string is actually made up for us for convenience over the past few weeks now why is that well up until now we have been creating strings in code with lines like this string s equals quote unquote high in all caps semicolon what that would according to week 2's discussion of memory is it would give us four bytes in memory for Hi exclamation point and a fourth bite to be clear for the null character n the back sl0 which is just 8 Z bytes and we were therefore were able to manipulate that string as though it were an array so s bracket Z is the first character s bracket 3 is the very last character specifically that null character well really we can start to think about strings a little differently still today in fact let me go back over to uh vs code here clear my terminal window and let's stop playing around with integers like number 50 and instead let's do this let's give myself a string s equals quote unquote High exclamation point and then let's go ahead and print it out just like in week one with percent s back sln comma s let me go ahead and increase the size of my terminal window do make addresses and here is the very same mistake we glossed over in week one error use of Undeclared identifier string did you mean standard in now maybe that does sound familiar but it's kind of a a red herring this has nothing to do with standard in per se string is Undeclared because it doesn't exist in C by default and in fact it thinks maybe this is a typo standard in is a thing that exists in programming languages but string I said in C does not but this fix for me recalling week one was to very quickly say ah we'll come back to that and at the top of my code I went in and added one more include cs50.h and somehow if I clear my terminal rerun make addresses that solved everything and string was brought into existence but how exactly was that the case well we'll see today what's actually going on underneath that hood as well so what have I just done with this code I've simply printed out the string s but notice I claim what's really going on if I visit the actual memory in the computer is yeah it's an array but if an array is just a chunk of contiguous memory certainly we could figure out what the btes are the addresses are of each of those characters Hi exclamation point and the null character and again for the sake of simple discussion suppose the H is at ox123 stands to reason that I is going to be at o x124 exclamation points at ox x125 and the null characters at o x126 the specific numbers don't matter but what does matter is that they are one bite apart and that is literally what I've meant all these weeks when I say contiguous back to back to back they're literally one bite apart so once we know this can we sort of Leverage this to play around with and see strings perhaps in a somewhat different light well let me go ahead and do this let me go back to vs code here after clearing my terminal let's leave string S as is but let's print out a few different things let's actually print out what is inside of s percent P back sln is how I can dis lay an address AKA pointer and let's print out the value of s let me go down to my terminal and do make addresses enter addresses and what I see now is a seemingly random but a much bigger heximal address so it seems that s is not a string per se because I literally just told the computer to print it out with print F albeit using percent P instead of percent s but percent P just means show me the address of variable and it seems that s's technical value is Ox 59 fb1 1699 d004 now that is the longer version of what I just proposed for discussion sake is ox123 well let's be a little more pedantic here let me go ahead and print a couple of more things let me print out another address using percent P but let me print out uh the address of the first character in s using my array notation and then let me do some quick copy paste just to see a few more of these let me print out location one location 2 and location 3 so we're really kind of making use of this Arcane looking syntax today lots of percent PS but that just means show me address address address address and so forth s bracket Z is from week two just show me using array notation the first character the second character the third and the fourth and Ampersand is new today just means show me the address of that character not the actual character so if I go back down to my terminal window window make addresses again I'm going to see five values in total now z/ addresses gives me this let me zoom in and what's noteworthy is that the very first one is identical to the second one which seems to imply that s is the has the same address as the first character of s but that sort of makes logical sense because what else would it be if not the first one and so what we're seeing here now is a hint that we're percent p is printing out literally the value inside of s what was percent s doing all this time it was thanks to printf's implementation decades ago going to that address and printing character character character character and stopping only once printf finds what the back slash zero the null bite so some person years ago literally implemented printf they literally are using S as an address going to that address somewhere with a star operator in their code and then using a for Loop or a while loop iterating over character character character and character from that address onward until it sees the so-called null character all of this been sort of been happening for us automatically but that's really all that's going on if I go back into the visualization of my computer's memory here's that same simplification using smaller numbers ox123 one24 and so forth and what is s then when it's declared in memory well it's a pointer which means it takes up8 bytes so am doing this to scale but what is s really doing it's storing the address of the first bite of the actual characters it's storing nothing else s is not storing the last bite it's not storing the length it's not storing anything other than the first byes address but that's okay why because how does the computer functions like print F know where the strings end just to be super clear the back slash zero that's why we're wasting an extra bite all these weeks because someone needs to know or tell everyone else where strings actually end those of you who do have some prior programming experience in Java or in um python or other languages you can generally just ask a string like what is its length you can call a length function you can do dot length or similar those of you who've done this before that's because in higher level languages like Java and python there is more memory being used than just the address of the variable alone someone somewhere is keeping track of the link length of that chunk of memory but C is much lower level it's much more efficient it's much more complicated in that it leaves it to someone else something else to keep track of where strings actually end but like that's it and in fact oh I brought these just to be sort of unduly dramatic like all these weeks we've had these sort of training wheels on right like where we've had these simplifications of cs50.h and strings existing and now we're taking the training wheels off because like this is literally all that's been going on since week one not sure that added anything we this is all that's been going on since week one but again that's sort of the design of the course is to help you understand first at a high level so you can just get things working and start playing around now we're taking a peak underneath the hood to see what really has been going on all of this time and indeed who cares what addresses these things live at and so the way you would typically think about or Draw this on a piece of paper is literally just with an arrow s is pointing at a chunk of contiguous memory that is null terminated so to speak so where did string actually come from well here's how I've been declaring strings today and prior string s equals quote unquote High string being supposedly the type of my variable well it turns out that a string we have seen is really just an address but it's the address of what just to be super clear a string is really the address of its first character so its first character so its first char so I think the implication of this now is that if we get rid of those training wheels and we get rid of even the cs50 library we can actually start calling strings Char stars and this is what real Geeks call strings like oh a Char star in C is known to mean you're just talking about a string but you're doing it a sort of a lower level actual um vernacular which implies that the address is in fact that of its first Char the last address of its La the address of its last Char is implicit in that null character that we've been using all of this time so we've actually seen this kind of before in fact just recently we introduced the notion of persons and I said well if we wanted to invent our own data type and a person for instance would have a name and a number we introduced syntax like this which was kind of a mouthful but the only interesting part is what's inside of the data structure this in this case person was the name we gave to the data type this whole struct is what we wanted a person to be and the way we brought a person into existence in C was we defined a type using the typ defa uh keyword in C that's actually going to be the trick to what we've been doing in cs50 for the past few weeks we're using type def to Define our own type we want to create an alias for instance from one thing to another so just to keep things simple at first suppose that I'm really confused by int like it's an integer I get but why int why in suppose I want to create a synonym called integer for ins I could literally say type int integer semicolon and this will bring into existence a data type called integer which doesn't really solve a problem other than helping you remember that ins is really just short for integer but the syntax can be as simple as that it doesn't need to be multiple lines with structures and and person attributes like that so accordingly how can I define a data type for a string I can say type def Char star which is admittedly more mindbending but I want to think of it instead as a string so inside of cs50.h since week one has been literally this line of code a bunch of other lines too but this one liner because you're including it a top your code brings into existence the keyword string but it's just like doing an automatic find and replace between string and Char star that's all that's actually happening really underneath the hood okay what questions do you have on what a string actually is in this case it's all what's inside of cs50.h yeah uh a really good question here um am I violating my own convention I am not here I do I uh Ron Shin do you know if this would work without the space here we'll find out he's checking um so this is a different context I'm not actually declaring a variable here called string I am declaring a type called string it's possible it's allowed I don't know off hand so good question other questions yeah I'm back is it to use charar rather uh really good question when is it more useful you use Char star instead of string honestly after you exit cs50 you should not use string anymore and in fact among the things we're going to do next week is take the last of these training wheels off and take away the cs50 library so that you actually use only native C code per se so that there are no more training wheels physically or virtually otherwise so in the real world if you ever write C you would just use charar we use string only because I dare say introducing Char star and these memory addresses and like mailboxes all in the first week of C it's just too much when all we want to get working is like hello world or Mario or the like other questions yeah ah really good question in my VSS code here when I used the Amper sand I used it in front of each of the characters 0 through three but I didn't use it here a subtlety but the reason I didn't use it here is because s we now know is already a pointer it is a Char star so if it's already an address and percent P expects an address there's no reason to do Amper sand s it is already the address of a string specifically I can now take away the cs50 library from my own code Let Me Clear My terminal go back up here take the cs50 library away which was a bad thing earlier but if I now call this Char star s this declaration here makes more explicit that s is the address of a Char so percent P expects an address you can literally slot in s right there but s bracket 0 S bracket One S bracket 2 those are actually chars inside of an array so if you want the address of those characters you do need to use the Amper sand and in answer to the question that came up over here if I were to incorrectly use an Amper sand here that would be getting the address of the pointer not the address of the stream but we're not here to talk about that today other questions yeah and back yeah do percent s come from where does percent s come from so that percent s is supported by C and specifically print F so strings exist in a as a concept in C the word string does not exist but when you use printf now as I can here as another demonstration I can do print print f i don't change this now to percent C because I don't want to print a character I still want to print a whole string conceptually and I can pass in here s just as before so printf has always understood percent s that's not a cs50 thing the only thing that was a cs50 training wheel was the word string which we can now take away safely you just have to start writing charar instead other questions and back a good question so in your own code should you now start doing typ def charar string semicolon so that you can still use string like no I mean if you are if if after today or if after a few days from today you sort of understand what's really going on and you're comfortable with it there's no reason to like keep putting the training wheels back on yourself in perpetuity the simpler approach would just be keep using cs50's library for some amount of time and that too is fine even come final projects it's fine to still use these training wheels the goal of today and next week and Beyond is really to make sure you understand how you can uh write code successfully even without those same training wheels on all right so let's poke around just a little bit more with these capabilities in vs code here let me propose that we can dabble a little further as by doing something like this if I go into let's say uh addresses. c one final time I'm still going to create S as quote unquote high in all caps but now just to be clear let's print out this string manually just as we could have back in week one except now there is no string there's only Char star so I'm going to do percent C back sln quote uh quote unquote comma s bracket Z and then just for the sake of discussion let me just copy paste this twice so as to print out these two characters again I'm just playing around in the real world I should really use a for Loop or something like that but I just want to manually poke around with this new syntax so let me make addresses again/ addresses and I should see Hi exclamation point1 per line so that's just week one stuff but now let me propose that there's this other feature of C we can Avail ourselves are known lastly is pointer arithmetic so if every chunk of memory has an address and that address is just a number whether it's an hexadecimal decimal binary whatever they're just numbers I can actually do math on addresses and if I can start in one location I can go one bite away two bytes away three bytes away just by adding one or two or three it stands to reason so what's the implication of this well it turns out that I don't need to use square bracket notation anymore if I don't want to we introduced it in week two it is a feature of c and it is a very very common and useful convention and probably the convention to keep using but strictly speaking we don't need to use square brackets anymore to print out individual elements of an array for instance I could change this first line to not be S bracket zero but I can just say go to the first character of s because if s is a string otherwise now known as a Char star and Char star just means the address of a Char well if I want to print out the actual Char I can use star s to go to that address and where I will find x marks the spot a Char in the computer's memory but here's where the arithmetic comes in let me do another line print F percent C back sln comma go to s + one so I can literally do a bit of math on my pointer to go one location to the right I can do this once more print F percent C back sln comma percent s uh percent uh sorry star s plus two to go two locations to the right and I'm doing this only because I know Hi exclamation point gives me three locations in total but if I now do again make addresses do SL addresses I get the exact same behavior and in fact the square brackets we introduced in week two which again come with C is just syntactic sugar so to speak which is a term of Art in Computing which just is a more userfriendly way of expressing this weirder syntax the square brackets by the compiler are essentially converted into pointer arithmetic for me so that I don't have to write code that admittedly on the screen looks more cryptic than it would with just the simpler more userfriendly square brackets but all that those square brackets are doing under underneath the hood is effectively pointer arithmetic for you so if I want to play around one final way with all of the same code I can even do things that probably aren't the best idea but do speak to the power of this syntax and this language C for instance if I want to print out the actual string s we know I can do this already percent s and print out s itself because s is a string otherwise known as a Char star so make addresses just gives me high exclamation point but what if I only want to print out part of the string I could start partway in the middle of this thing what if I do this print F percent s back sln s + one so no star I don't want to print out a Char I want to print out a whole string what is a string a string is an address of the first character of the string still null terminated so when I compile this code printing out and actually let me get rid of the previous line when I compile this code with addresses and I run/ addresses what should I see on the screen now if I'm not printing starting at s I'm printing starting at s+ one yeah I think you're saying I like I exclamation point why because if these strings start at ox123 and go o x124 o x125 o x126 and I'm starting at ox123 + one that means start at the second character and I think yep I now see I exclamation point if I change it to two I now see after doing make addresses I think I should just see very excitedly an exclamation point and that's it I probably don't want to go even further than this because then who knows what's going to happen if I start printing beyond the boundaries of the actual string and that in fact is going to be one of the trade-offs here even though now with these simple operators like star and Ampersand we can now manipulate and understand memory at this lower level we can actually do a lot of damage and among the things we'll talk about today too after the break is recall the the crowd strike f a few months back where like systems around the world broke down including Airlines and the like that stupid stupid issue was the result of such a simple problem that after today's break you two will understand but in the meantime H in happier news let's have some little bites of blueberry muffins in the transcept see you in 10 no don't applaud we're not done see you in 10 a all right we are back and one aatam uh so this was the line of code I proposed in cs50.h it's not quite the line of code in cs50.h because as was asked stylistically the quote unquote right way to write this would indeed be without the space after the star so even though string is not being declared as a variable here but rather as a type stylistically and I just asked style 50 for the the correct answer it would indeed omit the space so this is what I should have said earlier and we'll fix that in the online version thereof but for now let's actually transition to taking a look again at the computer Compu memory and revisit some problems that we looked at indirectly over the past couple of weeks and better understand why things worked and now work the way they do so let me go over to VSS code here and I've written in advance relatively simple program I'm still using cs50.h and standard io. for this example I'm calling get in twice to get two variables I and J so two numbers from the user and I'm checking for a quality using equals equals so if I equals equals J I'm going to print same otherwise I'm going to print different so fairly straightforward and it should just work indeed if I open up my terminal window and I do let's whoops sorry um if I open up my terminal window do make compare because this file is compare. C I can then do do compare and type in two numbers like 50 and 50 and they're indeed the same or I can do it again 50 and 51 and they're in fact different and I'll stipulate that pretty sure this code is in fact correct but what if we make a change of sorts and actually compare not integers but strings what's going on well let's first consider what is happening with integers so here's my computer's memory now I've zoomed out a bit just so we can fit more on the screen at once and here might be where I and J end up in the computer's memory when running this program I here J here both of them four byes because both I and J are integers it stands to reason then when I compare I and J we are literally comparing 50 against 50 in that first scenario and indeed it's technically 32 bits and 32 bits but they're exactly the same if they're both storing and representing the value 50 all right so fairly straightforward but what about strings in fact we deliberately introduced stir comp or for string comparison because when I last tried to compare two strings it didn't actually work as intended when using equals equals so in fact let me go back to my code here and close my terminal window and just make a couple of changes here same idea but different data type so let's do string s equals get string U and we'll prompt the user for string s now instead of I then maybe a string T just to keep the variable name short for the sake of discussion and prompt the user for T here then let me go ahead and say if s equals equals T go ahead as before and print out same back slash n otherwise go ahead in my else clause and print out quote unquote whoops quote unquote different all right so same logic but different data types using strings for the type and get string for the function let me open my terminal window again make compare no syntactic errors but let me go ahead and do/ compare and type in something like uh how about high and high both in all caps but they appear to be different I can try again maybe my name David and David also different even though it seems to be the same so what's going on well you might already have an intuition and someone last time when we looked at a program like this did have an intuition but what if we make it more explicit now what if I change my strings to literally Char Stars which doesn't affect the functionality but takes off one of those training wheels I'm not going to get rid of cs50.h altogether because as we'll see I still want to use get string otherwise it's a pain in the neck in see to get user input but we'll come back to that but s now is not only a string it's more precisely the address of a character technically the first character of a string so what then is being compared on line that's yielding this different answer why are high and why are David different even if typed identically yeah it's two different addresses what's really going on if we take a look at the computer's memory now dealing with strings is the following here's that grid of memory maybe s ends up here and maybe uh the actual array of characters ends up here because notice when we're using strings technically we're storing the address and we're storing the actual characters and that's all been happening magically in one step for us one line of code but technically there's different chunks of memory involved and it might be at ox123 o x124 ox1 125 and O x126 all of that happens automatically with that one line of code when I create and initialize s meanwhile s is going to therefore store the address of that first character hence the whole idea of a Char star but what is T well maybe T ends up over here somewhere in memory maybe the other high that I typed in or later the David that I typed in ends up at maybe Ox 456 Ox 457 o x458 Ox 459 again who cares what the addresses are but they are back to back to back which is important but suffice it to say then what ends up in T is the address of that second string that I actually typed in and for all intents and purposes that's like s pointing to this chunk of memory T pointing to this chunk of memory so when I use literally equals equals to compare the two strings that is compare the two Char stars that is compare the two addresses clearly they're in different places it's like asking the computer are ox123 and Ox 456 the same well of course not those are literally two different numbers written in heximal or anything else so we needed a solution for this and that is why we introduced stir comp the function that actually addressed this properly if I go back then to VSS code here and instead of using equals equals I give myself access to our old friend now the string.h header file in that library is the definition uh the Declaration of stir comp so I can do stir comp passing in two variables s comma T and recall what is the return value I care about what a stir comp return if two strings are equal so it returns zero otherwise it's a positive or negative number which helps with alphabetization but that's not what we want here I want to make sure that the return value of stir comp equals equals z and what does that do for me well if I open up my terminal again make compare do/ compare and again type in high exclamation point Enter and high exclamation point Enter now they're in fact the same but if I type something different like hi and by those of course are different not on the basis of their addresses but on the basis of their actual characters and in fact that's what's really happening the way stir comp is implemented by someone else years ago is that they have some code some kind of loop probably that first defferences s and t respectively goes there and then in some kind of loop iterates over these two strings in memory checking whether the individual chars equals equals each other stopping once it hits back sl0 in either string and if they happen to look the exact same character by character then it returns zero it's a little fancier than that because it uses some less than or greater than to figure out if one comes before the other atically but it is doing the walking across this string so the person that implemented stir comp uses a for Loop a while loop whatever to do all that leg work for us questions on stir comp or what we've just revealed yeah good question is it subtracted the asy values of the characters not necessarily it's probably comparing them with less than or greater than literally because if you're comparing A and B that would be like comparing 65 and 66 if capitalized so you don't need to subtract anything per se you can just compare the magnitude of those values yeah a good question do we use two locations in memory for both the pointer s and the actual array of characters short answer yes and how that is happening is as follows if I go back to VSS code and highlight the lines of code that we just wrote for instance line seven the left hand side of the expression here creates those eight bytes in memory called s that will eventually store an address of the first character of some string the get string function written by cs50 handles the process of allocating the array for Hi exclamation point and the back sl0 and puts it somewhere I depicted it down here on the screen so get string allocates one chunk and your code here allocates the other chunk there are other ways to do this and in fact once we completely take away the cs50 library you have to allocate not only the left side but also the memory for the right side of this expression so to speak and we can do that in different ways and we'll come back to that soon all right so if we now know and appreciate that these two addresses are indeed different SNT it turns out we can kind of play around with create some new problems but also solve them as well so how might I go about uh for instance let's see seeing what we just did if I go back into VSS code here let me just do something simple and no longer compare these but just to make the point using our percent p uh format code now I can actually print out the actual values of S and P if I want to s and t if I want to convince myself of all this so I can print out sorry with percent p with the value of s with percent P the value of T and in this case even if I type the same thing watch again what happens make uh compare do/ compare I'll type in high I'll type in high and I should now see two addresses but per the depiction on the screen they do end up in different locations they're similar locations these numbers are actually pretty similar but notice they differ down here a b and an F puts them a few bites apart so they're actually next to each other in memory but they're not in fact at the same location so that's what's happening underneath the hood and just to be super clear it is rare if ever that you as a programmer will ever bother using percent P to print out an address generally we do not care where things are just using it for the sake of demonstration to make clear that we could go there if we so want all right well what if we we want to make um maybe manipulate these strings and actually change them in some ways let me do this let me clear my terminal close compare. C open up a new file called copy.c where by I might ultimately need to make copies of strings in memory and let me go ahead and do this let me include cs50.h so I can still use get string let me include um how about standard i.h as we often do let me include string.h as we off as we now do int main void for my main function and then in here let's do the same thing as before string s equals get string and prompt the user for that string then let's go ahead and copy the string as follows string T equals s then let's go ahead and capitalize the first letter of this string and it might be a little hazy but we introduced a library a couple weeks back called ctype.h which has a bunch of functions related to types and C one of whose functions recall is two upper which just uppercases a character so what I'm going to do here is I'm going to change the first character of T but not s to equal whatever the return value of two upper is passing in the first character T so I'm just changing the first character of T to be the uppercase version thereof now I'm going to go ahead and print out the value of s is percent s back sln and I'm going to plug in s and then I'm going to do the exact same thing for T so I can see both the before and the after version of my capitalized change let me open my terminal let me do make copy and I screwed up because I should be including not a C file but a header file so ctype.h at the top unintended mistake make copy again that worked copy and now this time let me deliberately type it in all lowercase Hi exclamation point because the whole point of T is to be uppercase if I hit enter now I see huh a curiosity both s and t Were Somehow capitalized for some reason even though I only changed on line 12 the first character of T why might that be why might that be let me offer a bit of a hint what if again we take off some of these training wheels s is just a Char Star as of today T is just a Char star after today so what's happening such that I'm seeing the change effect both s and t yeah yeah I'm really copying literally s and t which means both of those variables contain the same address so even though I'm following t address that leads me to the same location that s is pointing to so I'm essentially changing the one and only one copy of high exclamation point in fact we can see that as follows if I open up my computer's memory let me propose that s ends up over here maybe high and lower case ends up down here maybe at those same addresses as before ox123 therefore s contains ox123 meanwhile T is a separate variable that I declared with almost identical code but I then set it equal to S which is like literally coping the value in s into T if we now get rid of all these unnecessary addresses and just use abstraction it's as though s and t are pointing at the same place so it doesn't matter whether you follow s or you follow T when you dreference either as is implied by the square bracket notation means go there you're just changing the one and only copy of H and so whether you print s or t you print out the capitalized version thereof so what's the solution here well we actually need to be a little more clever when it comes to um making actual copies up until now super simple to copy integers chars floats Longs doubles all of those primitive data types super simple because code like that on line 10 would just work but whenever you're talking about something fancier like a string which isn't one location it's sort of a sequence of locations someone's got to do the hard work of allocating another chunk of memory copying the characters from old into new and somehow keeping track of all of that now we'll do this ourselves in just a moment but thankfully there's going to be a library that can make our lives easier instead so let me go ahead and do this let me propose that we in VSS code improve this code as follows instead of just blindly copying s and calling it t I'm going to actually use a new function called malok we haven't needed this before it's among the remaining Tools in our toolkit and see but Mal stands for memory allocation and it's a function that super simply lets you pass in as input a number how many bytes of memory do you want and it will hand you back a chunk of memory specifically it will hand you back the address of that chunk of memory specifically the address of the first bite of that chunk of memory free is the opposite once you're done with this memory you can call free and give it back to the computer so that you don't eventually run out of memory you can give things back when you're done so how can I now leverage this in my own code well let me propose that I Implement a copy a little more cleverly here let me go back to VSS code here and instead of using S equals t let me instead say t initially should store the address of a new chunk of memory that's big enough to store the characters of s the way I do that would be malok and how many do I need Hi exclamation point and the null character I could just get away with saying four memor give me four bytes of memory and store the address of the first bite in t that is what line 10 is now doing now that's kind of a stupid approach like I shouldn't hardcode the number four because who knows what the human's going to type in but we have other friends here we can say figure out what the length of s is add one more bite for the null character and ask malok for that many bites because now no matter how big or small s is we're going to ask for the appropriate number of btes what is stored in T at this point in the the story is the address of that chunk of memory specifically the address of the first bite in that memory now there's no null Terminator or anything everything in there at the moment is sort of garbage value so to speak until I put something there so what I'm going to do now is this after I allocate that chunk of memory I'm going to use a for Loop just like the authors of um stir comp had but for a different purpose for in IAL 0 n equals the string length of s semicolon and we've seen that technique before so we don't waste time calling Sterling again and again and again I is less than n and then i++ and inside of my Loop I'm going to copy into location I of T whatever is at location I of s effectively copying from left to right all of the characters of s into T at the very end of this I could do something but I think there's a I could do something to manually add a null character to the end of my new string T but I don't think I have to do that the one time this makes sense is perhaps now I'm going to actually iterate from I less than or equal to n because I actually want to copy the null character as well so if the string is Hi exclamation point new line I actually do want to go from zero to 1 to two to three and then stop normally I would go from 0 to 1 to two but I want to include the sort of of secret uh null character there so I think this for Loop will capture that for me I'm not going to change any of the rest of code so all I have done that's different now is explicitly allocate a new chunk of memory for T and copy everything in s into T but to use um malok I need a nude Library I'm going to go up here and include standard libh and again you learn through practice what's in what library or you can go to manual. CS c. and just look it up to figure out where in which header file something is and I'm also going to include um the same header files as before so the only change is to add standard Li let me open my terminal window make copy SL copy and now let me type in Hi exclamation point in all lowercase and I should see in a moment the output of both s and t but hopefully only one of them is capitalized T and indeed I've done it somehow so what actually just happened well if we actually go over to a visualization thereof here is my computer's memory when s exists if though I'm going to allocate new memory with malok that's like calling Malo getting some chunk of memory maybe it ends up here maybe it ends up somewhere else I'm just keeping in the same place for discussion and the first address happens to be Ox 456 well what gets stored in t the return value of malok and maloc Returns the first the address of the first bite of memory so what ends up in T is effectively ox 4 56 but who cares we'll just draw it abstractly as an arrow what does my for Loop then do well it iterates over s and t in lock step such that the H gets copied the I gets copied the exclamation point gets copied and because I use less than or equal to we also copy the secret null character as well then I use two upper on T bracket 0 here's T here's T bracket Z and so I think only the H and T is now capitalized it's not a particularly interesting exercise but it does demonstrate really with as few steps as possible how we can solve this problem of actually copying strings in memory by allocating enough space for them in that actual memory but there is a caveat a lot of things unfortunately this week onward can go wrong when it comes to memory like your computer could be out maybe you have an older computer maybe you have a really fancy program that has so many variables so many arrays that eventually you run out of memory it's possible that malok can fail something can go wrong and Malo will not in fact return to you the address of the first bite of memory available cuz if none's available it's got to return something else so in cases of error what Malo really returns to you is zero like I have no valid bites for you and zero itself is a number so that's a little confusing and this doesn't really help with confusion what malok returns if an error happens is null with two L's this was stupid design decision decades ago to call the character Zero n and the pointer zero n but this is where we're at so n is the address zero and it almost always signifies something went wrong we just need a special symbol to signify something went wrong when returning a value from malok so how can I use this unfortunately now just like in some of the problem sets thus far when you've started to add error checking when things can potentially go wrong your code gets a little more verbose but what I'm going to do here here if I go back to VSS code is the following what can go wrong well if T ends up equaling null that is if it has a bogus return value in it that is not a valid memory address then there's not much I really can do except like return one just to signify error I could print out an error to the screen I could inform the user somehow but if malok returns null I had better not proceed to try copying things from left to right into it because there is no memory there that chunk of memory on the screen at bottom right does not exist if malok fails of course so you don't want to go there and start blindly touching memory let alone capitalizing memory that's there so I have to start adding in some of these error checks in this case and in fact even this is a little naive it's probably not safe to even assume that the user typed in any string at all maybe the human just to be difficult or made a mistake and just hit enter so the length of the string is zero you probably shouldn't try capitalizing zero either and so what we should probably do down here too to be super safe is only if the stir length of T is at least greater than zero then go ahead and capitalize it otherwise do not touch that memory either in other words starting this week and next week and even when we get to python you should start acquiring an instinct to code defensively things can go wrong in your code in someone else's code and if you do not handle those situations with ifs or else ifs or the like your computer will crash the thing will freeze or the and again to tease the crowd strike example if you screw up and you don't check the boundaries of something the length of something who knows what can happen because if you touch memory that does not belong to you the typical Behavior again is to crash to freeze to do some undefined Behavior like that now I will say this is getting really annoying I mean I've written what like 30 some odd lines of code just to copy two strings that's a little unfortunate when this is probably a pretty common thing to do in the real world so it turns out there are Library functions like this to and in fact I can get rid of a lot of my code here for copying and I can actually just call a function stir copy St Str cpy for sure and pass in the destination pass in the source semicolon and that will do all of the for Loop or the while loop or however that person implemented it of copying one into the other the ordering is a little weird it is indeed destination comma Source but that sa saves me the trouble of doing all of that code myself self questions then on what we've done here the key details really being malok and one omitted detail which will come back to yeah us a really good question let me summarize um if you allocate two variables that are happen to be next to each other in memory but maybe you type in excuse me a very long string for one of them can one overflow into the other one short answer yes and we're going to talk about that briefly today the code I've written is not vulnerable to that at the moment and in fact among the things that get string has been doing for us since week one is it actually sort of crawls over the user's input literally taking like baby steps to make sure that we only allocate more memory more memory memory memory for every keystroke that you type in so theoretically there should be no way to crash get string unless you type in more bites than the system has even memory for but even that we should be able to detect because we are somewhat inefficiently but very conservatively trying to avoid the situation you described but it is too common in life is again with crowd strike you'll see that humans will make mistakes when it comes to the length of memory or rays that we have now I alluded to there being one mistake or Omission here did I somehow not practice what I preached a moment ago about malok and its cousin I never freed my own memory so technically this program has what we would call A Memory leak whereby I'm asking for memory online 911 via malok but I'm never giving it back to the operating system now this is a bit of an overstatement because technically when the program quits it should automatically give everything back but a lot of programs in the world keep running again and again and again really forever like a clock program or a web server or an email server in the like and if that code that you or someone else has written asks for memory asks for memory and never hands it back freezes crashes eventually because the computer will somehow run out of memory so it's an easy fix at the very bottom of this program once and only once I am done using te in the first place I can simply free te and C itself or really the functions that we're using keeps track of how many bites you asked for you do not need to when freeing it it will free that bite onward that you requested so free sort of does the opposite of then malok all right unfortunately we have so much power at our disposal now lots of things can go wrong but thankfully there are tools that help you find these mistakes so that when your if and when your program crashes you don't have to just kind of stare at the screen or ask a TF or another human for help you can actually use software tools that other people wrote that detect these common errors and one of these programs that you're now going to have access to besides print def besides debug 50 besides the rubber duck is a program called valren which is a command line program that's whose output is a little scary looking but it will allow you to look at your program for memory related errors so let me go ahead and propose this I'm going to open up a program that I I wrote in advance here called memory. C and quite simply in vs code it looks as follows I have including standard IO I'm including standard lib so that I can use malok and this program does nothing useful it just demonstrates as simply as I can a bug on line six I'm allocating a variable called X that's going to be a pointer to an integer and I'm allocating space for three integers so we haven't seen this before but it just kind of does what it says give me memory for three of these things what are these things well whatever the size of an INT is I know it's four usually so I could just write four * 3 but I'm going to generalize it size of is an operator in C that lets you figure out what is the size of this type of variable it's usually four but on older computers eventually on newer computers it might not be four so I'm not going to write four I'm going to say size of int so this whole line six gives me enough memory for an array of three integers and it stores the address of the first bite in a variable called X so what's X1 going to be 72 what's X2 going to be 73 what's X3 going to be 33 even in these four lines of code there's two bugs can you spot any of them yeah what's that yes so I did not zero index my array so that's sort of week two type mistake this should be X bracket 0 x bracket one x braet 2 and there's a second more subtle mistake yeah I don't have what I don't have room oh I don't have room for the zero but that's okay because I'm dealing with integers only I'm not strictly trying to treat this like a string but good eye but only relevant to my if I'm dealing with strings or Char Stars it's subtle but we also talked about it like three minutes ago yeah I didn't free the memory so I called malok but I didn't eventually call free at the end of my function so at least two mistakes it would seem now you can reason through this and there's only four lines of code So eventually you'd probably figure it out with some time and practice but could a program help me spot these mistakes well debug 50 is not relevant here per se unless your program crashes debug 50 can probably tell you on what line it crashed but not necessarily why what we need is a memory related program called valren and to do this to use it I'm going to do the following I'm going to run make memory and if I dotmemory at a glance nothing seems to go wrong it didn't even crash but it's still incorrect and especially if I have these kinds of bugs in larger software it's definitely going to crash eventually so let me do this instead let me run this program called Valen on dotmemory so just like you run debug 50 on something you run valren on/ memory let me increase the size of my terminal window because there's going to be a lot of ugly output here for a moment and hit enter and you'll see a whole bunch of cryptic output and a lot of numbers which largely aren't useful for us until we get to the error messages so I ran the command up here I saw all this crazy output but what's Germain well here I have invalid right of size four it's a little technical but that just means I'm changing something that involves four bytes well what does that mean well apparently my mistake is in memory. C line9 and it's elaborating with some cryptic addresses which again I don't really care about but I do care about this uh by after a block of size 12 is allocated so there's 12 like evidence that there's indeed an array of three ins which total 12 bytes so that's consistent but what's going on it's at line nine well how did I somehow Touch four bytes that I shouldn't well if I go back to my code by shrinking my terminal window look at line nine it did not like as you observed the last element of the array because I one indexed instead of zero index so okay I think my fix is going to be to change this to 0 one and two so 0 1 and two but let's go back to the errors cuz there was another one on the screen if I ignore anything I don't really understand in this summary here's something 12 bytes in one blocks are definitely lost in Lost record one of one more verbose than ideally it would be but that problem seems to relate to memory. C line six so I'll admit vr's output is sort of a big complicated mess but there are little hints of diagnostically useful information like invalid right of size four and the line number of the file um 12 bytes and one blocks are definitely lost in memory. C and line number so those are the kinds of things you want to look for even if at a glance it is and will look confusing so let me go back to now line six and oh line six even though it's not obvious what's wrong with this line if I'm somehow losing 12 bytes well it must be a memory leak so let me just have the intuition to go in and say oh eventually I have to free x because X is pointing at that chunk of memory let me now clear my terminal window down here make memory again do/ memory and it doesn't seem to crash still but it is more correct even though at a glance it seems fine either way let me do now valr of dotmemory let me increase the size of my terminal window clear the screen and hit enter and now there's slightly less output but what I really like is the sound of all Heap blocks were freed whatever that means no leaks are possible and even though there's still a lot of output there I don't see anything glaring anymore so vren 2 this week and next week will be your friend and all it's doing is helping check for memory related mistakes in your code questions then on valr yeah in front can you set a condition before you free the memory you could in this case logically there's no reason to because this program is so relatively simple that I do want to free it no matter what but you can absolutely have conditionals in there which you might in more complicated programs all right well let's play around slightly more with with these garbage values to which I alluded earlier let me actually close this let me code up a file called garbage. C just so we can make the point that there can be these so-called garbage values in a computer's memory that are really remnants of something else that has been at that location in memory before and I can actually do this pretty easily let me in garbage. C include standard io. let me go ahead and in uh do whoops standard iio H let me go ahead and do int main void inside of my main function let me just give myself an array of like a lot of scores to come back to like week two when we introduced arrays suppose I very um sadly have 1,24 scores to keep track of of the course of college I now might iterate over those as follows for INT I equals 0 I is less than 124 I ++ and then inside my for Loop let's just blindly print out those values percent I back sln score scores bracket I the problem though is that I have neither hardcoded those actual scores into this program like we did in week two nor have I prompted the user for the scores with get int or anything else so who knows what I'm going to be printing 1,024 times well let me open my terminal let me do make garbage sort of pun intended let me increase the size of my terminal window garbage and I should see 1,24 values that eventually will be my scores but who knows what they are now and enter it's a mix of some really good and some really bad scores it would seem some zeros some small numbers some big numbers my God some negative numbers which isn't good for scores but they're all over the place and if I scroll up I could count them there's indeed going to be 1,24 of them but they're garbage values and that I can't make uh head or tails of what they actually are as an aside this has nothing to do with C but the operating system Linux that we're using here does have commands that you can run if you are getting overwhelmed by output so for instance if I run garbage again if there's you know there's going to be more output than you can see at once and you don't want have to bother scrolling back through time you can actually do what's called piping it to a program called less which is the name suggest will show you less of the output at a time one screen full at a time so if I hit enter now I only see the first screen full until I hit space space space space and so forth and it will paginate the output for me and I can just hit Q when I'm done with that so it doesn't change my code change my program just a handy command line trick if you're ever overwhelmed by the amount of output there but these garbage values can really get us into trouble and in fact let me propose to consider another program that's a little arbitrary but it's going to use some of today's building block so here's a main function and at the top couple of lines here I'm doing this I'm creating a variable called X that's going to store the address of an INT I'm creating a variable y that's going to store the address of an INT so far so good I haven't assigned them any value yet but that in of itself is not problematic I can always assign them values later like any variable I'm now going to allocate enough btes for the size of an INT you and I know it's probably going to be four but I'm doing it dynamically asking for the size of an integer and I'm storing the address of the first bite in X but notice what I'm not doing is storing anything yet in y the next line of code here I'm sort of using um the uh Sentinel value 42 and storing that at the location in X so the D reference operator says whatever address you got from malok go there and put the number 42 there this next line says go to the address in y and put the number 13 there but I've highlighted it in red this time why this line will probably crash why intuitively we haven't gotten we haven't given y a value I didn't copy s's value I didn't malok anything for y it contains a garbage value maybe it's zero like we saw on the screen maybe it's a really big number maybe it's a big negative number who knows but that's like saying go there and like put this number 13 in some random unlucky location and again program's probably going to crash freeze or something else the other lines here are okay eventually I get around to copying X into y giving it a valid value and then going to y's value and assigning it the number 13 so that one line of code was the problematic one ultimately so what's nice about this code is that it actually happens to line up perfectly uh with a fun video that our friends at Stanford University put together that's about 2 minutes long and it introduces a character that's well known in computer science spaces as Binky so Professor uh Nick parlante of Stanford spent some time doing some clation to bring exactly that code and exactly that problem to life if we could dim dramatically the lights hey Binky wake up it's time for pointer fun what's that learn about pointers Oh goodie well to get started I guess we're going to need a couple pointers okay this code allocates two pointers which can point to integers okay well I see the two pointers but they don't seem to be pointing to anything that's right initially pointers don't point to anything the things they point to are called Pointes and setting them up a separate step oh right right I knew that the Pointes are separate so how do you allocate a pointy okay well this code allocates a new integer Point T and this part sets X to point to it hey that looks better so make it do something okay I'll dereference the pointer X to store the number 42 into its pointy for this trick I'll need my magic wand of dereferencing your magic wand of dereferencing uh that that's great this is what the code looks like I'll just set up the number and hey look there it goes so doing a d reference on X follows the arrow to access its Point e in this case the store 42 in there hey try using it to store the number 13 through the other pointer why okay I'll just go over here to Y and get the number 13 set up and then take the wand of D referencing and just oh hey that didn't work say uh Binky I don't think dereferencing Y is a good idea cuz uh you know setting up the point T is a separate step and uh I don't think we ever did it good point yeah we we allocated the pointer y but we never set it to point to a point d h very observant hey you're looking good there Binky can you fix it so that y points to the same point as X sure I'll use my magic wand of pointer assignment is that going to be a problem like before no this doesn't touch the point it just changes one pointer to point to the same thing as another oh I see now y points to the same place as X so so wait now Y is fixed it has a point e so you can try the wand of D referencing again to send the 13 over uh okay here it goes hey look at that now D referencing works on why and because the pointers are sharing that 1 Point e they both see the 13 yeah sharing uh whatever so are we going to switch places now oh look we're out of time but all right so Binky's purpose in life is really to make clear that bad things can indeed happen when you touch memory that you shouldn't including things that we now know as garbage values but there's even other problems but also solutions that we now have access to thanks to our Newfound understanding of memory and Inter turn pointers so it's been very common over the past few weeks especially last week to have to swap values like when we were doing bubble swort or selection sort we kept having our human volunteers swap locations and in the computer's memory or in our pseudo code we had to have two variables or two values swap locations as well um for this we thought we'd motivate folks uh we can offer you either a little Mario mushroom or question mark if we can get one more volunteer today to act a little something out with me here don't all raise your hands at once how about I saw the the Harvard shirt is it or that shirt yes yeah no you yeah come on down yes the one who wanted to keep using uh string as a type def before all maybe a round of applause to break the awkwardness here for the other volunteer had your hand up catch my eye next time too but for now we just need one of you and come on up all right you want to introduce yourself to the world hi my name is Gabe Gabe okay and a little something about yourself um I live in theer I'm a freshman nice all right well good to meet you come on over here where we have two glasses of water one is pink one is blue and each of these effectively represents like a variable that contains some value either pink or blue could you go ahead and swap the two values of these glasses okay that's technically just like moving the variables around in memory but I'd really like you to get the p pink water in the blue glass and the blue water in the pink glass instead so let me undo that um I you're hesitating why because if I pour the blue in the pink then they're going to blend together yeah and you're going to sort of overwrite the value with the other and so we're going to lose information in that case Okay Okay so this was a bit of a setup so let me get you a third glass or a temporary variable if you will and if you want to verbalize how you would solve the problem now with this third variable okay so I'm going to pour the blue into the new variable mhm and then pour the pink into my old blue cup nice and then pour the blue back into the old pink cup very nice I think that that warrants a round of applause if we could okay nicely done thank you okay which would you like oh uh this one all right so thank you to Gabe so all right this was all to make the point that swapping is not that hard and we all have kind of an intuitive notion of how to do it but we do need it seems like a temporary variable and that actually Maps pretty cleanly on the C code so how might we do this in practice well if we wanted to implement a actual function in C uh that does swapping for instance I might do if we want to actually do something in C that involves swapping I might do something like this avoid function cuz I don't need to return a value I just need to do some work function's called swap it's going to take in two values in a and in B and the goal in life here is to swap A and B it's actually pretty straight forward I could actually do lines of code like this calling A and B the two inputs like the pink and blue glasses temp or TMP for short for the temporary variable and just as Gabe did I can store in the temporary variable one color of liquid or the value of a I can then change a to be that of B and then I can copy the value from the temporary variable to B and at which point I don't care about temp anymore this code is correct it would swap those values just as Gabe did with the glasses of water but it's only going to work inside of the scope of Swap and this is the catch recall that when we introduced the notion of scope earlier a few weeks back we said that variables really only exist in the context of the curly braces in which they're defined or in this case as part of the V uh the arguments passed into the function so this successfully swaps A and B but if main or any other function is using swap it's actually not going to have any useful effect on the original values of A and B in fact let me go over to vs code here where while Gabe was doing that I whipped up this program in advance and it looks like a lot but it does something relatively simple I've got main which declares two variables X and Y values of one and two I'm then just printing out X is this Y is that I'm then calling a swap function and then I'm just printing the same thing X is this Y is that the whole point being hopefully it'll say the opposite the second time what is the swap function exactly what I just proposed earlier which is exactly what Gabe just did correctly with the glasses but as you might see where we're going with this if I go into my terminal window and say make swap do/ swap enter it doesn't actually seem to affect the values of X and Y it does affect the values of A and B and I can see this if I use our old friend debug 50 let me go ahead and set a break point inside of swap let me run debug 50 on/ swap enter and just to demonstrate what's going on here let me step through a few of these lines of code as follows so notice one at top left temp has some bogus value initially it's a garbage value it's like putting some random color inside of the glass but I kept it empty because in the real world we need space for the color liquid but a is one and B is two why because we passed in X and Y respectively if I now step over line 17 notice that temp changes to one if I step over line 18 a changes to two if I step over line 19 B changes to one so A and B per gabes algorithm were swapped correctly but if I continue running this program all the way to the end ultimately I got because of this second printf that X is still one and Y is still two so A and B were changed clearly per the debugger but X and Y were not so why is that that well it turns out that the answer to that too relates to memory and code like this at least if encapsulated in in function is not correct precisely for the matter of scope because we're changing the values of variables that are local to the swap function but has no effect on Main that's actually using this function and the reason for that is a term of art when you pass arguments to functions you're generally passing things by value you are passing in copies of those Val VAR values so when you pass in X and Y you're really passing in a copy of X and a copy of Y that you can do anything you want to and we're calling them A and B in the context of swap but that has no effect on the original versions of X and Y what's really going on though can be thought of again in terms of the computer's memory so here's a chip of memory let's kind of zoom in abstractly on the sort of grid as we keep describing this and consider that we can use this memory in bunches of different ways but the world has standardized how we use computers memories when running programs and we tend to use this part of memory at the top so to speak in certain ways and this type of memory at the bottom in other ways and if we understand what those ways are we can actually infer deductively why this function is not working as intended so it turns out let's even get rid of the individual bytes because we don't really care about numbers for now it turns out that when you double click a program on your Mac or PC or tap an icon on your phone or run do/ something on your code space it the computer automatically loads the program's machine code the zeros and ones that someone else compiled or maybe you compiled into the top of your computer's memory so to speak it's not literally the top because who knows how the thing is oriented but just for the sake of discussion up here what else gets loaded into the computer's memory if your program has any Global variables defined outside of main by convention they go below the machine code that was loaded into memory what else if you end up using malok in your code that memory comes from this location here which we didn't do until today but actually it turns out that get string has been using Malo all this time since week one cuz that's how we're getting an arbitrary amount of memory for everything you might type in at the keyboard uh the Heap though so to speak grows downward so the more and the more and the more and the more you call malok the more stuff that gets filled up top to bottom in the so-called Heap but there's one last region of memory generally called the stack much like a stack of uh trays in the cafeteria or dining hall that sort of works its way up as you continue putting stacks of tray and tray and tray on top of each other the stack so to speak grows upward and the Heap and the stack are used differently the Heap is indeed used for malok but the stack is used anytime you call a function anytime you have local variables they use memory down here so in particular for the code I just wrote a moment ago where I had a main function and a swap function the stack gets used to implement this kind of logic as follows I first unbeknownst to me my computer does this for me I get a chunk of memory at the bottom of my computer computer's memory space that contains any command line arguments if we had int argc and Char uh and string argv like uh a couple of weeks back or if I have any local variables like X and Y uh if I then call a function like swap swap gets its own chunk of memory its own frame of memory above Main in the computer's memory so it's like putting down a main tray from the dining hall and then a swap tray on top of it from the dining hall each of them contains their own local variables X and Y here A and B here and you can kind of see where this is going already if X and Y live here but we're changing A and B here well obviously we're not changing X and Y down here well let's be a little more specific in the main function when I have two local variables like X and Y it's like having space for them in the computer's memory and initially I had values one and two respectively when I then called a swap function that had two local variables of its own technically arguments passed in which because I'm passing by value gets copies of X and Y called A and B but the values are going to be the same initially one and two respectively but then in the three lines of code that represent what Gabe did with the bottle the glasses of water does is we have a temporary variable a third still in the same frame of memory and I assed with this code here let me step out of the way this first line of code stored the value of a in temp like this the next line of code stored the value of b in a like this at which point unfortunately they're identical but no big deal because like Gabe we kept the temporary variable around and then we can store the value of temp inside of B now as an aside with respect to the debugger we pulled up earlier as well as a couple of weeks back when you've looked at the top left of the debugger window and you can see your local variables what you're seeing in the debugger is either these variables if you've set a breakpoint in main or these variables if you've set a breakpoint in swap the debugger is just showing you what variables in scope what does scope really mean it's a slice of memory at that moment in time effectively and we've been simplifying it verbally by saying what's between the curly braces but that's the simpler way of describing really this now we don't care about temp eventually what we do care about is having swap these values but unfortunately as soon as swap returns well Mains X and Y are literally left unchanged because we only passed in copies thereof so the fundamental problem seems to be that the swap function is long logically correct but it has not been given access to the uh locations of X and Y in memory what swap really needs is a treasure map so to speak that leads it to the actual location of X the actual location of Y so that using like the star operator it can go there and go there and swap the actual values inside of Main's frame of memory so what we really want to do is what computer scientists would call pass by reference or pass pass by address would be the same thing in this case whereby what I want to do is not this code per se which is logically correct but doesn't fundamentally change the caller's variables X and Y watch the Delta here this is correct and it looks crazy scary at a glance because there's all this new syntax but it's really just the same syntax from the start of today used a few different places what I'm saying now in this correct version of swap is that a is not going to be an INT per se it's the address of an INT and B is going to be the address of another int this is my sort of treasure map whereby A and B are going to contain the addresses of X and Y what am I going to do well temp is still just an INT it's still Just An Empty Glass but if I want to store the value at a in temp I have to go to a and store it in temp I have to go to B and go to a and put the ladder in the former the former in the ladder I have to the first and the second then I go and get the value of temp and put it at the address in B so exact same logic exactly what Gabe did just way more syntactically involved but again it's just using pointer declarations up here and pointer D referencing down here to go to those locations in memory and in fact if I make this change in my own code here let me go back to VSS code and let me hide my terminal let me make these changes so pass in the address of an INT the address of an INT D reference a d reference b d reference A and D reference B it's almost done but I do have to change one more line of code and based on what we've discussed thus far how does line 11 need to change I no longer want to pass in X and Y the address of X and the address of Y which involves the syntax Ampersand X and Amper sand y so again synta technically way scarier than it once was but it's just these simple building blocks get me the address of X and then go to that address as with the star operator so let me open my terminal window again let me do make swap enter it's airing now but why I've made a subtle mistake it doesn't like the fact that I've passed in the address but wait a minute let me scroll up what else needs to change the Prototype here so this also needs to be matching the actual implementation so sort of new mistake but I think now if I do make swap again does compile do/ swap I should see X is 1 Y is 2 and then hopefully indeed the opposite so this version of swap correctly swaps the value because now I have a correct understanding of what is going on inside the computer's memory and indeed if we look at this code now in the context of those the stack frames let's see what now happens so here is again the same setup main has variables X and Y equaling 1 and 2 swap gets called but what are A and B they're no longer the values of X and Y but the addresses of X and Y I don't care what those addresses are so I'm going to abstract it away with some simple arrows but these are sort of like the treasure map I keep referring to the breadcrumbs however metaphorically you want to think of it A and B now lead to X and Y so you're passing things in by reference so to speak and therefore swap can manipulate those values now as an aside uh pass by reference is is really the same idea as pass by value but the values you're passing in are the addresses instead of the actual value so it's sort of just context dependent as to how you think about that but passing by reference means really you're passing in by address all right so with that said step by step what's happening I'm going to a which is going to contain the value one and I'm going to store that in temp so what I should see in temp still is one now I'm going to go to B and what I should see at B is two and I'm going to put it at Star a which is the same thing as two here then lastly I'm going to grab temp which is one and I'm going to put it at B which is like following that arrow and changing that to one and this then pictorially is why my new version of the code indeed works as expected and better still when swap is all done and that frame of memory is taken away it's sort of it's still physically there but we don't care about it anymore so we might as well think of it as just disappearing the change has in fact permanently affected Ms version of X and Y questions then on this trickery yeah sorry a little Lou as returns a good question when a function returns does it stack disappear typically no you still have remnants of all of those values that were once there unless the compile or the computer has sort of scrubbing that memory which is not typically done for performance reasons and so there could be remnants of past things so as an aside your mind is actually going in an interesting adversarial way place because Suppose there was some function that you're calling that involves passwords for instance and the user types in their password and their password is stored at that location in memory even after that function returns if the code is not implemented with any kind of rigor in place you could somehow maybe if you have malicious access to the code access that memory location where there's the garbage value but that garbage value is useful because it's someone's actually password actual password and in fact that's a threat that has indeed happened from time to time so here then to recap the bad code but logically correct just doesn't get the job done the green code of course does get the job done for exactly those same logical reasons but there's another problem we've now created even as we understand how the Stack's working and I claim that the Heap is where Malo you takes memory from um having like two arrows pointing at you like does not seem like a very good design right because if you keep using Heep by calling Malak a lot you're going to eventually overflow the stack or if you call lots and lots and lots and lots of functions as you might with recursion or some other technique you might overflow the stack like a big stack of trays eventually kind of toppling over and touching things that it shouldn't either unfortunately like there's no real solution because you only have a finite amount of memory so it doesn't really matter if things go this way or this way eventually you're going to either run into other chunks of memory or run out of memory altogether so strictly speaking this isn't such a bad thing unless you let things get out of control and you don't keep track of how much memory you're using or defensively make sure you're freeing it as much as you can and there are terms of art out there like Heap overflow which means if you call malok too many times you might somehow overflow some other area of memory with the Heap some of you might know a popular website called stack Overflow well what is the atmology of that website stack Overflow is when you call so many darn functions that they overflow each other and maybe hit the Heap or overflow each other in some way you're overflowing the memory region known as the stack these are generally examples of what are called buffer overflows where buffer just means a chunk of memory that you're using for some purpose and so a buffer can certainly overflow another especially if you're treating it as a chunk of memory this big but you start poking around past the end of it it's like allocating an array for four characters but trying to print the fifth or the sixth or the H 100th or the thousandth if you've not asked for it you're overflowing the buffer you've been given so an array is just a buffer and YouTube and Netflix they all have buffers in the colloquial sense in that they might pre-download a few seconds or minutes of video storing it in a chunk of memory like an array or maybe somewhere on the heat but the point is a buffer is a finite size and you can potentially overflow it by going past the boundary of it past the end or maybe even past the beginning and thus was the issue with the real world a few months back with crowd strike so this is very popular security related software ironically that a lot of the world has installed on their servers to keep themselves safe for those unfamiliar unfortunately this very software crashed some months back taking down very important systems with it including Delta airlines' site and so many other companies and this cost the world millions of dollars probably in Lost labor and effort because systems went down sales were lost human time was incurred and it boiled down in retrospect to the stupidest of bugs if I might say if you read through their very long PDF their postmortem that describes what exactly went wrong which took a few weeks I believe to come out there was this paragraph here which actually sounds like a lot of big words sensors that received the new version of Channel file 291 carrying the problematic content were exposed to a latent outof bounds read issue and the content interpreter like the real interesting part is the last sentence the content interpreter expected only 20 values therefore the attempt to access the 21st value produced an outof bounds memory read beyond the end of the input data array and resulted in a system crash so literally even though you're only in a class like this for like a couple of months time now they had an array of size 20 and they wrote code that tried to access the 21st element they touched memory they shouldn't have the software froze or crashed therefore the systems that self froze or crashed and cost the world millions of dollars in downtime and other side effects because of one off by one error so it's a very possible danger to trip over and among the downsides of languages like C is that they make it very easy to do this there is nothing in C stopping you from doing this and a few other languages allow this as well other languages like Python and Java generally prevent you and me from doing this why because humans for years were writing so much darn buggy code that we realize wow we should probably build into the programming language defenses against this stuff so with the right language and the right knowhow you can avoid these problems altogether but in this particular case they had code that similarly was not sufficiently tested they didn't have a check 5050 to tell them a priori whether or not the code was correct and so they shipped this to computers around the world as an aside too this is one of the dangers of automatic updates if you have this on your phone or your Mac or your PC let alone your corporate servers if you update automatically your systems but the update itself is buggy you can therefore take down your whole system personally or professionally there's a lot of real world implications to that business decision they made it seems to update so unilaterally unilaterally as well so beware but these things happen very really in the real world okay so let's take things down back to sort of like cs50 land here here was the functions the training wheels that we've been using since week one and let's just consider for a moment how one of the most powerful of these does ACT let's consider for just a moment how one of the simplest of these actually works namely get int so it turns out in C it's not that hard to get an INT or a Char or a float relatively simple at least in a safe way strings are the scary one because who knows how many characters the user is going to type in and you would seem to have to decide in advance do I want room for one character four characters 100 a thousand what if I get the number wrong and they type in a really long paragraph ins and chars and floats are easy because they're four bytes or one b or four bytes you sort of know in advance so let me propose that we Implement a simple problem a simple program that really kind of implements the idea of gent int so first let me open my terminal and clear it let me open a new file called get. C because I'm going to implement my own functions for getting input I'm going to go ahead initially and actually still use cs50.h and I'm going to use standard i.h and then in main I'm going to go ahead and very simply as in week one do this int n equals get int and just prompt the user for n so nothing interesting there and then quite simply I'm going to print out using percent uh I'm going to print out using percent I the value of n passing in n so again week one stuff no memory uh no explicit use of memory or pointers here yet make a get doget type in 50 program for now seems to work but suppose I take away truly the training wheels not just for the keyword string but for the get int function as well and I take away this header file which means get int no longer works how could I implement this instead well without cs50's training wheels you can still solve this problem you can declare an INT called n and don't give it a value initially because you want it from the user I can then prompt the user with like a print f n colon space with no new line because I just want a a blinking prompt for the user which get in does for you automatically otherwise and I can use a function called scanf to sort of scan the user's input for some format string so so for some type of formatted text maybe it's an INT a float a string or something else so scan f is sort of like the opposite of printf print F prints something scan F reads something from the user thems all right so how can I use this I can call Scan F I can say what do I want to scan from the keyboard so to speak and I want to scan in an integer from whatever the human types where do I want to put that integer well I can't just say put it in N because you can't change I I want n to persist I want to tell it to go to the address of N and put it there wherever there actually is in memory so again just like with swap if I want another function to be able to change my variable can't just hand it the variable I have to hand it the address of my variable and scanf is designed to expect that now it's my last line I can print out uh n colon percent I back sln and now print the value of n so it's a bit of more of a mouthful I've got like two three lines instead of my one with get int but I think it'll work let me do make get doget and type in 50 for instance enter and it does seem to work and effectively this is what get int is doing gettin's a little smarter because for instance if you don't type in int and you type in cat or dog or bird or something else like un weird things will happen so we make sure that if you don't type in something that's actually an INT we prompt the user again and again and again using our own Loop so we sort of handle that error checking for you but if I want to do this with a string how might I go about doing this well let me go back into my program here after clearing my terminal and let me just kind of do the same thing but with strings I could say string s but we know strings don't really exist as a data type so I'm going to more explicit L say charar s like that's effectively a string or a placeholder therefore let me print out a prompt for that string just say s colon just because I want the user to type in a string for me and now I'm going to use scanf again what do I want to read from the user well I want to read a string and so just like printf I use percent s to scan a string from the human's keyboard and now after that I need a place to put it well I think I want to put it in my string S I don't need an amp perent here because s is already a Char star it's already the the address of a string if you will but now if I go and print this I'm going to say s percent s back sln just as before so it's the exact same logic but this line of code is now dangerous and this is why we give you get string and this is why more of the world should use libraries instead of doing this why is this line of code on line seven dangerous or undefined what it will do yeah little ladder it doesn't know when's going to end ites doesn't know where my string is going to end or more specifically it doesn't know how much memory is available for that string at the moment the only memory I've allocated implicitly is 8 bytes for the pointer called s so I have I'm ready to jot down in memory where I want to put the string but I never initialize s to anything previously when I wanted to initialize s to something I could for instance malok some space or I could even do something like I could specify that oh let's get out of the pointer business today and let's actually just say s is an array of like a thousand characters and that would mean I have a thousand places where I can put that chunk of memory so turns out there's an implicit relationship between pointers as we've seen today and arrays whereby you can treat one as the LA uh as the other but for now let me stick with this model of making clear that I did not call malok and so s contains a garbage value which is like saying put whatever the user types like over like there somewhere random it's a garbage value and that's probably going to cause the computer to crash not always and I don't know what to expect today but let's try this make get/ get enter let's type in Hi exclamation point I got lucky it still worked let's do something random like just type type type type type type a lot of characters that will hopefully overflow the buffer that doesn't even exist enter got lucky but if I do this again and again I know ideally that would have made an educational point but again and again and again eventually it will probably crash on me it's certainly Incorrect and I bet we could figure this out with valren if we start poking around with that tool as well so what's the solution here or what's really the issue well if we consider where we started if here's my memory let me actually put a lot of Oscar the grouches here to make clear that like before you use memory it's effectively garbage values like who knows what is there so in my first program when I created a variable N I actually used 32 of those bits or four of those bites to put a legitimate pattern of zeros and ones to represent the number 50 so that part was good but when it got to the string version I allocated space for the pointer 8 bytes as I said earlier but I never initialize s to anything to malok to like an array like literally nothing so s's value is literally this sequence of garbage value so who knows what it is pointing to there is certainly no memory allocated elsewhere like in the Heap for whatever the human actually types in so this value is effectively garbage and this is the best I could do with squiggly lines like who knows where it's pointing certainly nowhere valid and so in this case I got lucky it did not crash but long uh the more and run the code the bigger the input it is odds are this will in fact crash ultimately on me so how can I avoid this well if I go back into vs code I could just allocate space myself and say equals Malo of four but there's still going to be a danger there even if at the bottom I do free s because I only have allocated space for four bytes if the user types in five or 50 or 500 who knows what's going to happen I'm going to overflow my buffer of size four I do this another way I don't have to use malok I can use week 2 stuff I can again as before just say s maybe not a thousand but four that gives me an array which is a chunk of memory of size four but what happens if I overflow that buffer like bad things will happen and so this is why we still use and would encourage you to keep using get string because it avoids overstepping the boundaries of any buffer like we literally as I acted out before take these baby steps in code and every time you type a character essentially we call malok again and again and again and it's a little inefficient but we call Malo as many times as we need to grow enough space in the Heap for whatever the human types in whether it's one character four 4,000 or more it's just really annoying to write out and in fact the code is open source but it's a decent amount of logic just to do something relatively simple languages like Java and especially python make life so much easier with input and output and we'll get to that in a few weeks time any questions then on scan F and really why we've been using these training wheels yeah I only heard part of that is it would it be valid to use Malik and just allocate a really big number so that just kind of like kicks the can down the road but I bet whatever number you come up with I could if I copy paste enough or just type type type a lot I could overflow that buffer still by just typing in longer input and worse you're now wasting memory because you only have a finite amount of memory if one program is using all of this memory just in case some crazy user types in way too much I mean most of the time you might be slowing down the computer or at least wasting memory as well so get string does that too we only allocate what memory you need ultimately even though we end up allocating and freeing a lot of memory along the way really good question all right so let's transition then to a final topic that's going to set you up really for uh problem set 4 in which case you'll be exploring something specifically known as file IO or file input and output and we've deferred playing with actual files where you can save files and open files until now because you actually do need pointer syntax in C to do that with files in Python world's going to be easier in a few uh weeks time when you don't even need that complexity but for now we'll explore sort of the idea of file input and output as follows there are a bunch of functions that come with C related to files and here's just a uh short list thereof but you can kind of infer from the names what these do en code because they're operations you're familiar with in the real world like opening a file AKA F open closing a file AKA close printing to a file AKA F printf and a bunch of others as well so any function that starts with an F probably means that it operates somehow on files whether it's uh uh text files or binary files with zeros and ones these files uh these functions tend to be involved um we'll see with this how we can now like create some of our own files so let me go ahead and do this let me go back to vs code and let's make in the spirit of week zero my own actual phone book in C like let's write some code that allows me to save in a file someone's name and number so that it actually persists over time and I'm going to go ahead and call this phonebook Doc and in this file I'm going to include just to make life easier still for today because we've seen that scanf is not really your friend um we'll use get string again to include cs50.h standard i.h and also string.h which might be useful int main void again and inside of main let's do this let's first whoops let's first open a file called phone book. CSV most of you are probably familiar with CSV files they're like lightweight uh Excel they're like waight spreadsheet files that can be opened in Excel Google Sheets or apple numbers or the like it just means comma separated values or CSV so I can make a very simple file like this myself but the syntax is going to be a little new it turns out weirdly in see there's a data type called file in all capital letters for really no good reason um I'm going to then declare a pointer called file in all lower case but I could call it anything I want and I'm going to set it equal to the return value of calling F open for file open and I'm going to specify that I want to open a file called phone book.cgi I could do string but we know strings aren't really a thing so charar name equals get string and prompt the human for their name then let's do charar number and prompt the human for their number and then I want to save the human's name and number in this file like I'm adding friends to my contacts let's go ahead and do not print F but F printf passing in file as the first argument which is unlike printf printf obviously just goes to the string screen by default but f printf needs to know what file you want to print to I want to print out a string that looks like a string comma another string and then new line so just like print F lets you format what you're printing FR printf lets you format what you're saving as string comma string and then a new line the last things I'm going to pass in are the values for those placeholders store the name and store the number semicolon and then lastly let's go ahead and close the file so it's not that many lines of code but this is code enough to like prompt the user for a new name a new number save I could run it again new name new number save and just to make this clear let me go ahead and do this let me open up phone book. CSV which doesn't yet exist let me kind of split the screen here which if you haven't discovered you can do by just dragging the tabs up and around so I can see both at once let me do make phone book enter do/ phonebook enter and I'll do how about John Harvard enter and now let's see + 1 949 what's his number line uh Rin do you remember two does anyone has anyone texted this number yet you have it saved is is not important but I'd like to be consistent yeah thank you and the 2750 spells cs50 um so enter and now notice what happened to top right in my CSV file I added a name to the phone book now let me run the program again because there is a bug I'll put in my name now and I'll just pret I'll just do let's see plus one 617 495 I think we use 1,000 last time enter but notice John Harvard disappeared and that's because I chose to write to this file but there's another mode in which I can write data I can actually use a for aend which is probably smarter let me run my program a third time and put John Harvard back so John uh Harvard enter + 9949 468 2750 oh yes thank you someone caught my mistake before I did I didn't compile it again okay contrl C make phone book enter now let's rerun phonebook all right here we go John Harvard we'll put him back plus one 949 uh 468 2750 enter okay that's in there let's run it one more time for myself David ma plus one + one 6174 9 5 1000 enter and now it's indeed a pending to the file so if you've ever used Excel or apple numbers or Google Sheets and you're adding rows to the file or you're literally clicking like new contact on your Android phone or your iPhone effectively what's happening is Apple or Google wrote code like this to add F add more and more data to some file it might not be as simplistic as a CSV file where you're separating the values with commas and just putting it in raw text it might be some binary file with raw zeros and ones but it's the exact same idea and in fact if I go ahead and try to um improve this code I should note this too in the spirit of error checking let me add one additional line before we add one other example to the mix it turns out that just like malok things can go wrong when you try to open files maybe it doesn't exist maybe there is a typo maybe you are in fact out of memory so here too and for problem set four onward you should get into the habit of checking return values don't just assume that you've got a valid return value check instead per the documentation of this function if file equals equals null bad things just happen something went wrong and I should probably just get out of here and return one or some other value instead so again the lesson today is anytime pointers are involved from malok fopen and other functions as well do not trust that they are valid until you have checked whether they are null or not all right one final flourish here to implement the notion of copying a file as well we' we introduced uh We've uh you might have seen the CP command before for copy files from one to the other how might we Implement that ourselves even though it's been around for some decades now let me go ahead and open another file here called copy.c or actually we'll call it we did copy earlier did we yes let's go ahead and create a new file called cp. C to implement our own version of the copy command in this file let me go ahead and include standard i.h and let me go ahead and incl include um another file standard int. because it's something you'll see in problem set 4 and I'm going to go ahead and in int main I'm going to use command line arguments now int argc string argv as an array but we whoops but we know strings don't exist so technically main can henceforth be written as Char star argv still an array thereof so we're just getting rid of the word string and here's how I could open one file and copy it into another recall that copy works like this CP Source destination so it's the opposite of the stir copy function confusingly but CP copies the source file to the destination so you can change the name or give it any name you want so how might I use this knowledge let me create a pointer called Source SRC for short and open a file called hm well what should the file be called let's expect the user to pass in an arv1 one whatever the file name is per the usage at the command line then let's open it up in read mode specifically then let's go ahead and have a destination pointer called DST for short that equals the return value of opening the second file that the human typed the name of at the prompt and we'll open that in write mode I'm not going to do a pen mode because I want to literally copy everything I don't want to add to an existing file and then what do I want to do I'm going to propose that we do this bite by bite and there's many different ways to do this but among our list of functions from earlier are functions like f read for reading from a file F write for writing to a file as well as FR printf which prints to a file but if I actually am dealing with binary data I might actually want to do this I might want to declare a variable of type bite which by convention especially in the windows world is capitalized as bite give me one variable of type bite and let me do this while I read from the file passing into that bite a bite from the file so give this function the address of that bite so we can go put eight bits in it then let's read in the size of a bite which I could just write as one but I'm going to keep it Dynamic I'm going to read one such bite at a time and I'm going to read from the source file and I'm going to keep doing this so long as the return value is not zero this is a mouthful but allow me to just stipulate for today's purposes that line 11 just starts a while loop that iterates over the file called Source bite by bite by bite by bite from left to right top to bottom so to speak and how do I save each of those bytes to the destination file while I can do F passing in the address of that bite so we can go to the location the size of it so it knows how big it is how many there are which is still one but send it to the destination instead and then at the end of this code let me hide my terminal for a moment let me go ahead and close for instance the destination file and let me go ahead and close the source file and ultimately I think this is enough to again iterate over all the bytes in the file one by one bite one bite at a time and write them bite by bite by bite and minor tweak technically because I want to do this literally there's no text involved there's no Unicode I just want this to be a raw copy of btes technically I can specify read the file in binary and write the file on binary don't try to do any kind of interpretation of characters treat it as raw zeros and ones and just so you've seen it technically in see there is no such thing as a data type called bite this is again a thing in the windows world and we will give it to you in problem set 4 but I can actually create a type using typ def uh I'm going to in have it um be equal to something called u8 uh uint 8 T uh where that just means unsigned 8bit integer but more on that some other time or never perhaps but for now that just gives me a bite of eight bits in a manner consistent with what Windows computers do and if I didn't mess this up let me open my terminal window make CP for make the copy program CP I want to run CP so it's my version of the copy command not the built-in system one let me go ahead and copy a file like uh what was the file we started with addresses. c and how about we'll call this cop um how about we call this um backup. C and if I open up addresses. C here we'll see the file with which we began class earlier if I open a backup. c we'll see exactly the same file if I hold them side by side these happen to be text but they could have just been raw zeros and ones I've indeed implemented the CP command correctly in this way now how though does this Loop work let me go back into cp. C recall that I had this Loop here let me close these other files there was this Loop that somehow just new to advance to the next bite in the file even though there's no plus one there's no for Loop explicitly it's just kind of reading and reading and reading until F returns zero well the reason for that is that these file reading and writing functions behave a bit like a YouTube video or a Netflix video whereby once you start reading from them that like watching them the sort of uh cursor advances from left to right so as soon as you read a bite the file itself keeps track of where you are in the file kind of like an old school cassette tape once you start playing it physically the device is moving so it knows where to read the next bytes from and where to uh write the next bytes to and this is all going to be Germain as we introduce ultimately a specific file format this week in problem set 4 known as a bitm file or BMP for short in the world of bitmap files you'll see that you can represent images like this but these images are really just going to be a grid of pixels top to bottom left to right and among the goals for this week is to implement some Instagram like filters via which you can actually manipulate these images so for instance among the filters you'll Implement is first one that converts any image even a photo you yourself took into black and white by throwing away color information somehow and just retaining some form of gray scale you'll Implement and it's a bit hard to see on this screen but a sepia tone sort of an old school photograph uh photographic style you might be able to invert or flip the image on its axis here so I've just reversed the sides of the bridge same photo just flipped around in the computer's memory by moving like these bites over here and these bites over here or if you really are feeling more comfortable you can do Edge detection and write no I said that wrong or if you're feeling really com no wait everyone has to do this sorry let's let's stick The Landing we have like one minute left so if uh what you'll also be challenged to do is blur the image too whereby you're going to make it look fuzzier by sort of combining pixel value so that it's not quite as crisp as it originally was and if you're feeling really comfortable you can even do Edge detection whereby you can figure out where the outlines of physical objects are in the screen by writing more sophisticated code optionally to render images such as this here so ultimately this whole week is going to be about file input and output recovering images that might have been deleted or corrupted as well but we thought we'd end on a final pointer note this is another one of these Comics that now computer scientists should be able to understand the humor of hopefully okay lots of laughter all right that's it for cs50 we will see you next time [Music]