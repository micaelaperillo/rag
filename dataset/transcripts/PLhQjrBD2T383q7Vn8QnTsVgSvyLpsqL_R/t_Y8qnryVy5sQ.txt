[Music] [Applause] [Music] [Music] [Music] all right this is cs50 and this is week two our third together uh last week of course we introduced C on the heels of scratch and it might have indeed felt like things escalated quickly but that's really because there was a lot of new syntax especially if you'd never programmed before but keep in mind that Visa V what we did in week zero like there weren't that many new ideas last week we just kind of translated them literally to another language there were still functions and loops and conditionals and variables and things like that even though the syntax was and will remain for some time until you get ample practice under your belt quite different now today what we're going to do is try to take some of the magic out of what we did last week so even though it might have seemed complicated there was some sort of magic like somehow you write some code you literally type make and then and a program somehow gets made assuming there's no errors within the code well today we'll take the the the hood off of that process give you a better sense of what's going on because at the end of the day and by the end of the course there really won't be any surprises and even if you won't feel an expert at every little detail you'll at least have this bottomup understanding of what's going on so that once you're out of this class and in the real world and maybe dabbling or doing full-time programming you'll have a much better technique and mindset for actually solving real world problems so in fact one of the real world problems we thought we'd begin with today is a specific domain like this like reading level so like if you look at a block of text at what reading level is someone reading is it may be kindergarten first grade middle school high school or the like there's certainly a range there and while all of us might have an instinct for what makes something easy to read versus harder to read we'll see this week if we can't quantify that a little bit and by thought we'd do this by way of some examples in fact if we could uh give us some mood lighting here we'll introduce three of our volunteers who stood up early in class if you'd like to each say hello hello uh I'm Eric I'm from Philadelphia and I'm in Hollis Hall hi I'm Elizabeth I'm from Baltimore and I'm also in Hollis Hall but no one else seems to be from Hollis Hall this year okay I'm Jesse I'm from South Florida and I'm in Canada wow all canid all right so the first exercise we thought we'd do is have uh Eric open the envelope that he had in front of him inside of which is a reading snippet from a book with which many of you might be familiar and we'll ask Eric to read this aloud and then we'll ask you at what level Eric seems to read he's turning on the POV glasses we'll give you the microphone and read away One Fish Two Fish Red Fish Blue Fish wonderful to Eric so what what level do you would you say that Eric is currently reading yeah first grade okay and why first grade words are's yeah so the words are really simple there's not much complexity and if we look at it textually there is indeed very short sentences very few words in each and so if we adopt a heuristic we could assume that you know this probably suggests with high probability that this is a lower reading level and in fact the the correct answer at least according to an algorithm you will explore in problem set two this week is actually before grade one so maybe kindergarten or the like but let's go ahead and do a second example here if Elizabeth you could read one of your favorite texts congratulations today is your day you're off to great places you're off and away all right so also Dr Seuss and does someone want to conjecture at what level Elizabeth reads Advan Advanced okay so give me a number though a grade level perhaps more advanced for sure someone else yeah in the middle third grade so third grade and why what's your instinct behind that okay so still shorter sentences but longer words and indeed the right answer at least according to one measure is indeed amazingly third grade so let's do one final one with Jesse here if you want to read your favorite text for us turning on your second pair of glasses it was a bright cold day in April and The Clocks Were Striking 13 Winston Smith his chin nuzzled into his breast in an effort to escape the vile wind slipped quickly through the glass doors of Victory Mansions though not quickly enough to prevent a swirl of gritty dust from entering along with him all right and one final query of the audience at what grade level does Jessie seem to read 10th ninth 11th 12th okay so we're trying all numbers the correct answer according to one measure is indeed 10 and why you probably have an instinct for much longer words longer sentences full paragraph and indeed that would seem to correlate with a higher reading level indeed but if we go back for just a moment you can sort of see this with your human eyes at a glance but if this were actually digital like in a Word document a Google Document or a very simple text file how could you actually go about writing code that applies the heuristics that came intuitively to all of you here and actually spit out with prf for instance and see an actual number so that's going to be among the goals for this coming week's problem set in the meantime maybe a round of applause for for our three volunteers so beyond reading levels we thought we'd explore this week other problems as well and in fact very much current and omnipresent nowadays is the art the science of cryptography the art of scrambling information so as to communicate securely whether it's a private message you want to send or maybe credit card information or a password or the like among the challenges for this week too after this week's uh introduction is going to be a to apply these lessons to actually building some form of cryptography yourself and here for instance is an example of a message so-called Cipher text that's been encrypted that is scrambled somehow to make it harder to read now there is a bit of a hint baked into this it's not the most sophisticated algorithm but does anyone want to conjecture what this secret message would seem to say so it does happen to say this is cs50 and indeed we're leaking information there but why is it this is CS 50 well you might have kind of guessed that it sort of has the right number of letters and words but what comes before you T what comes before I H what becomes what comes before j i and so there seems to be it's not just random it seems to be there's a pattern here and in so far as if we keep playing that game each of the letters on the screen is sort of one away rotated or shifted from the actual letter I claim it represents you know I bet using some very simple arithmetic we could write code to do just that but we don't yet have in our toolkit so to speak is the ability to manipulate text in programs the ability to manipulate what we called last week strings we could print a string like hello world we could get a string like David but we didn't necessarily have the ability to sort of analyze it letter by letter or do more interesting things with it and that of course is what the whole world does when analyzing text searching a database searching the web itself is actually analyze some of the text on the screen so we'll equip you with exactly that so it will become clear among other things why this indeed says this is cs50 so how do we get there well first let's understand some of the magic that took place last week and recall that this was the process that was sort of distilled into a very simple command literally make make hello make Mario or whatever program you're trying to make the input to that process was source code might still look sort of cryptic to you but it's at least English likee the output of that process was machine code zeros and ones that really makes no sense to humans unless you pull out a paper pencil and somehow convert it back to something else but the compiler is sort of the algorithm step-by-step instructions for converting source code to machine code embodied in a program that you can run so that was compilation converting or translating source code to machine code and the code of course that we played with mostly last week was something like this simplest program you can perhaps write in C simply to print out hello world but the computer of course only understands the corresponding zeros and ones so how do we actually get from SCE code to machine code that is to say what's actually happening underneath the hood when you run a command like make well up until now you literally after making a file like hello.c you would type make hello cross your fingers hope there's no syntax errors no typos of any sort and then to run it you would do do/ hello it's a little weird that you have to do that but dot means the current folder and slash just means run the program called hello in the current folder this is the command line interface equivalent of like double clicking an icon on your Mac or PC or tapping an icon on your phone it just runs it with the keyboard instead but I did reveal briefly last week that make is not actually a compiler it is a program it is a useful program but it automates the process of running an actual compiler for you what is that compiler well there's many different compilers in the world but the one we use in class that's free and open source and therefore very popular in the world is actually called clang sort of fore language and so really what's happening when you run make hello or any other such command is that make in turn is running another program for you called clang the catch though is that this program by default is not nearly as userfriendly it doesn't sort of say what it does let alone uh give you a useful output because the output it gives you is actually a file by default called a.out for assembly output whatever that means which is to say if you use clang directly instead of make you don't get a program called hello you weirdly get a program called a.out so let's actually see that but then let's fix that sort of step backward so here I am in vs code I've hidden my activity bar in the file browser but I'm going to go ahead and run codeh hello.c and I'm going to very quickly recreate last week's program with including standard i.h and then inside of in main void I'm going to put printf quote unquote hello comma world back sln and semicolon and now instead of running make I'm going to do clang uh uh hello. C enter so notice I did do hell clang hello.c the name of the file I didn't just say make hello the name of the program so that's one change Here and Now what was actually made well what was the command for listing files in a folder so LS for list and you'll see that not only do I have hello. C there I also have a.out and in fact if I open up my file explorer at left they are those same two files hello. C and a.out so the here on after it's all the same/ a.out enter still works as exactly as I intend it's just sort of a stupid default name for a file so how do we go about making this program just sort of more userfriendly more aptly named well instead of running clang and then the name of the file we can actually provide more arguments to clang and I haven't used this term in this context before but there's a new term of art we'll explore today called command line arguments and all that means is that when you run a command in your terminal window you can type not only the name of the command or program you're running like LS or make or clang you can give arguments that is input to that program and I didn't use that phrasing last week but when you run when you run for instance make hello the argument the command line argument you're passing to make is indeed hello and if there was a second word that'd be another argument a third word that'd be a third argument and so forth so command line arguments are inputs provided to commands at the so-called command line in your terminal window so that's it just a term of art but instead of running make hello I just ran of course clang hello.c that gave me the wrong file name as output but there is a fix here we simply need to know from its documentation from a class from a book what other command line arguments clang supports and indeed if I look that up or pay attention here I can somewhat cryptically change my command to be clang - o in lowercase hello then hello.c and this is a very common technique in commandline environments whereby when you want to modify the behavior of the program by providing more arguments you use things like Flags or switches here called uh different things by different people but- o means output a file called hello when you compile hello.c eventually you memorize these things but it's not sort of not intellectually interesting other than this is how you can provide not one but now three arguments to a program then that gives you indeed /hello so let me go ahead and do that I'm going to go ahead now and clear my terminal window run now clang - o hello and then hello.c enter similarly nothing seems to happen if I type LS now though you'll see fre files and in facto works exactly as it did last week in fact I don't need a.out so there's different ways to delete things I could go into my file explore I could rightclick or control-click select delete explicitly or we didn't see this last week but you might have learned it since you can actually do RM for remove a.out enter And even though this is a little verbose remove regular file a.out it's just asking you now for y or n for yes or no and I can say y enter and now if I run LS one more time I'll see just those two files so that's how I might remove or delete a file obviously just be careful when doing that if the file's otherwise important so let me pause here and see if there's any questions on what we just did or what a command line argument actually is soon today you'll have the ability to use and create these things yourself in your own programs all right so seeing none that doesn't feel all that compelling right okay so we saved a few keystrokes instead of typing make and instead of typing clang I have to do- o hello but that's again one of the upsides of make it's fine it's not that hard to do Dash o hello but why bother when you can use another program make to sort of automate that process for you and just save you time and indeed that's what these command line environments are all about just saving the programmer or the technical person time as you get better and better with these things all right but now let's consider another ramification of what make actually does for us by taking a look for instance at this same program but consider what's going on underneath the hood step by step if we add a couple of more lines of code so recall that the second program we wrote using uh C last week was this whereby I added the cs50 library and then I used a function we wrote for you called get string I stored the return value of get string in a variable called name for instance uh of type string and then we used this placeholder technique last time whereby I plugged in the value of the person's name uh based on whatever they themselves typed in now there's a lot going on here but today we'll sort of Peel back the layers of like what's happening line by line line in why we have to keep typing stuff like this at the top well recall that when you ran uh compiled that program last week all you had to do was run makeo but that's because whenever you use thirdparty libraries code that other people wrote like cs50 then these commands when you use clang directly just get slightly more annoying if you want to compile that program from last week with clang directly you can do- o hello to specify the file name you have to specify hello. to compile that file but now somewhat annoyingly you have to do- l cs50 no space in between to specify that you want to use the library called cs50 why because that's specific to us it's not globally available in the whole world so the system doesn't know about it unless we've pre-installed it so this just tells it to support the cs-50 library as well now as an aside some of you for problem set one probably use the math Library maybe to round some values or something like that it turns out that you can also do- LM in order to use the math library but the math library is so darn popular and it actually comes with C that you don't have to actually do- LM but it's the same idea it's just so common that they automate that process for you but for third party libr you have to do this now at this point this is really starting to take or increase the tedium of compiling your code this is why we just say make hello last week which automates the process of generating hidden for you this entire command underneath the hood but that is what's happening to get a file called /hello so we're back to where we began but what does it actually mean now to be compiling this code in the first place so we keep saying and I will keep saying to compile your code to compile your code to translate source code to machine code but that's actually an abstraction so to speak it's like a simplification of a multi-step process that the computer's actually doing for you and this too will be briefly sort of a deeper dive to look at this lower level of what's going on but then again after today we can sort of take for granted that this just works but you'll understand hopefully better what's really happening underneath the hood so again there's no magic so it turns out that when you run make and in turn it runs clang four separate things are happening Each of which does something a little different for you pre-processing actual compiling assembling and linking it's just the world kind of combines all four of these terms into compiling by convention so let's consider the first of these what does it mean to pre-process a file well even though we haven't used this word for here is one of the programs we wrote last week it was a little longer but this was a program that three times called a meow function which I had ultimately implemented quite simply with this meow uh function of my own that just says print F meow and recall that I did a couple of things at the top of the file I included standard i.h because I need print access to printf but I also did this and what did we generally call this second line sorry uh a prototype the Prototype was just the first line of a function semicolon so nothing in between the curly braces and recall that that's just kind of a hint to the compiler that this function doesn't exist as of line two but I promise it eventually will and that was to avoid having to move the whole function from the bottom of the file to the top because you can imagine once you have three four 30 40 functions it's probably going to be hard to put all of them above the other so this is a way to just tell the compiler in advance to expect that this thing will exist so what is now going on in the very first step of compiling well we called it pre-processing and anything that starts with a hash sign like this is what's technically called a pre-processor directive now big mouthful but that just says that there's something in that file that you want to get essentially copy pasted into this one so what's really happening now is and let's actually consider sorry let me double back here let's actually consider a simpler example for a moment namely the second program again whereby we used get string to get the human's name and we just said hello to them this one had two pre-processor directives so let's consider what's actually happening here what did we say was inside of cs50.h last week get string but more specifically the Prototype forget string a little bit of a hint that tells the compiler what it looks like what's its name what's its input or arguments and what's its output or return values so this file Technically when you run the pre-processing step just like the the compiler goes into that file cs50.h finds the relevant code and essentially copy pastes it into this current file and in fact it's not even that sophisticated it essentially copy paste the entirety of cs50.h at the top of your code so you don't have to manually copy paste anything yourself meanwhile this second line standard i.h this of course is there for printf's sake but printf has a prototype it's got a name it's got inputs it's got outputs so that you don't have to go and find that file and copy paste it the pre processing step goes into that file for you finds the relevant code and some other stuff and effectively copies and pastes it there as well that then is pre-processing it just saves you time so that you can reuse functions that someone else besides you perhaps wrote and use and reuse them and automate the copy paste process anything starting with a hash sign therefore gets pre-processed okay what happens next the compiling step which is which is again the catchall term for all of this but when we say your program's being compiled what we mean now is this here's that same code after it has been pre-processed and when you actually compile this code this means it gets translated from one language C in this case to another language we haven't talked about and after today we're not really going to talk about it but it gets translated from C into something crazy looking called assembly code and now if you take other courses in computer science lower level courses so to speak you'll actually learn a language that looks a little something like this which at a glance is even even more cryptic than C which is why we don't spend all that much time on it in this class but there are some interesting terms that I can highlight here so even in this weird looking language called assembly there's a mention of main there's mention of get string and there's mention of printf and there's some other things worth highlighting here they're a little more Arcane but there's some mention of pushing moving subtracting uh calling and so forth even though there's some other letters like Q in there as well but it turns out that inside of your computer is that CPU the central processing unit Intel inside or uh M1 or M2 or M3 from Apple those CPUs the brains of your computer at the end of the day they don't understand C they don't understand scratch they do understand zeros and ones but what they really understand are specifically these commands these commands have corresponding patterns of zeros and ones but if you're actually building a computer and you get the the manual from Intel there will be documentation for all of the lowlevel commands the instructions that an individual CPU actually support and this might differ between Macs and PCs and phones and other devices but this is what happens when you compile your code from C into this lower level language called assembly code all right we'll never again see this I think for the most part so what's the third step the third step is to finally convert the assembly code to actual zeros in ones because that's indeed what the computer understands so here is that exact same assembly code once it is assembled that means the computer outputs this that most humans wouldn't understand unless again they pull out that same manual but the computer will understand this and the very last step is what's called linking so what do we mean by linking we'll take a look at this code again and just from inference like how many files are presumably involved in the process of compiling this whole thing and I mean compiling in the greater sense like going from source code to zeros and ones total how many files are implied by this screenshot okay three why three I saw two here but why three because we have the main program the main program like hello.c and then we have cs50 cs50.h and of course standard i.h so there's three different files involved and even compiling the simplest of programs like this now I'll stipulate that somewhere on the server's hard drive there is not only A.H file which has those prototypes there's also a cs50.c file there's also a standard iio C file as well which contains all of the actual code that we or other people wrote It's not necessarily called exactly that but there are C files containing all of those lines of C code so what really happens now in the fourth and final step of building your program compiling your program is this hello.c cs50.c and standard I.C wherever the lad to r on the server we pre-installed all this stuff for you you only wrote in the story this file when you finally uh compile and once you have pre-processed compiled and assembled your files you essentially have three sets of zeros and ones Each of which corresponds to each of those files this is the code you wrote once it's compiled to zeros and ones this is the code that cs50 wrote this is the code that came with C standard io. C itself so the fourth and final step is literally linking what does it mean well you've got three sets of zeros and ones you've got to somehow mash them together link them together and linking does exact L that so this is such a mouthful to say that you write C code and ends up zeros and ones but each of the steps can be very cleanly broken down like that so you understand exactly what's going on underneath the hood and now if you consider the command we talked about earlier - o just specifies what file the uh Linker outputs at the end of the day is it hello is it a.out is it something else and DL cs50 more specifically doesn't just mean- L Library it means- l link so Link in cs50's library to ensure you have access to those zeros and ones you don't have to do it for math you don't have to do it for standard IO but you do have to do it for third party code that other people altogether wrote for you okay done with that deep dive questions confusion on any and all of that yeah in the front I'm not a lot of things WR C but I only want one a really good question if you only want access to one function and not all of them in a library like CS 50s can you extract just a subset it depends the compiler ideally would do some of that for you and it would only dynamically Link in what you actually need if though by default you sort of statically Link everything in you get all the zeros and ones this is actually now a more sophisticated answer to a question someone asked here last week which was about the efficiency of all of this and unfortunately by default you would typically get bigger and bigger files if you're linking in too much stuff unnecessarily so yes that's absolutely an optimization that is possible but the compiler should be handling most of that for you uh not you the programmer generally worrying about it yeah ah really good question in the prototype for print F why was there an INT before let me come let me come back to that and we'll talk a little bit about something related in spirit today main actually all this time also has the word INT in front of it we'll we'll explain that one first all right so what can we take then away from this well if that is all compiling can we actually reverse the process can you go about decompiling code that is to say if you have a program installed on your computer or your phone and it therefore contains all these zeros and ones can you maybe reverse engineer it that is converted back to source code well is that possible well sort of in fact here's an example of a program written in C that's already been compiled down into machine code and by compiled I mean it's already been pre-processed compiled assembled and Link and these are the zeros and ones well it turns out that if you break these zeros and ones up into chunks of like eight or maybe 32 or 64 you could very tediously or using some software to automate the process look up in Intel's manual what all of those patterns of zeros and ones represent and you probably Could reconstruct the fact that you know what I bet this thing says hell hello world like there's enough pattern in there to figure out something like that and surely if it says hello world we could generate source code that does the exact same thing but what if there's some kind of loop in there and hello world is actually getting printed two times or three times or four times or an arbitrary number of times I don't know if I could decompile the code quite as effectively why well once I have it down to the levels of zeros and ones I don't know if the programmer used a while loop a for Loop a do while loop like there's ambigu in that process ultimately so while you can reverse some processes at some point it becomes harder or ambiguous to do so and this is a relatively short program even though there's some more zeros and ones not pictured when you're talking about something like Microsoft Word or Excel there are millions of zeros and ones inside of that and honestly in the amount of time it would take you to figure out tediously what those zeros and ones correspond to in C or some other language you're probably smart enough to just start writing the program yourself in the other direction and that's sort of the supposition when it comes to intellectual property and protecting your software's IP rights the reality is like the people who are going to be so good as to reverse engineer it probably could just recreate the software itself so there's a bit of push back there inherent but later in the term we're going to talk about other languages HTML CSS and JavaScript that stuff is not compiled into zeros and ones in any way like this so that code is actually revealed to literally anyone on the internet we could go on Harvard or Yale's website right now look at the JavaScript code that powers parts of it and actually see what's going on but more on that in just a few weeks time so um today is all about debugging ultimately too like finding and fixing mistakes in your code and debugging actually um does indeed mean removing mistakes from your code there is um mythically a sort of story behind that so this is uh rear Admiral Grace Hopper from the United States Navy who uh had her PhD from Yale and actually is known for many things but among them is for working on the Harvard mark1 computer that looks a little something like this in black and white it's now housed across the river in the science and engineering complex at Harvard which you can visit if you hop across the river someday um but in the Harvard Mark I another successor to this large Mainframe computer um uh Dr Hopper was responsible for keeping the log book and pictured here is if we uh zoom in here the first actual case of a bug being found some kind of moth was physically found inside of the Harvard Mark I disrupting its operations and that's not literally what we mean nowadays when it comes to bugs and software and this really just popularized the term it wasn't the origin of the term itself but that's among the stories that gets tossed around typically when talking about bugs and of course debugging so among the goals for today is to actually make your life easier when it comes to solving problems this weekend onward cuz odds are you were a bit in the dark if you had some staken your code last week you could have of course asked the duck you could have asked a teaching fellow or teaching assistant you could have struggled through it but let's actually give you more Tools in your toolkit to solve problems so here for instance was one of the simpler problems we did last week and we'll keep it simple so we can focus on the debugging techniques and not the complexity of the code and recall that this example was all about just printing like a column of bricks using hash symbols otherwise known as asky art well the first debugging Technique we gave you and encouraged you to use last week was of course this virtual rubber duck or even a physical rubber duck in fact on the way out today after class we have not only these ducks but like hundreds of others if you'd like to walk home to your dorms with a rubber duck and we'll bring them to those of you at Yale uh you may at uh Day end um but the virtual version of this is of course powered by artificial intelligence and not only will the duck uh listen to your questions it will try as bets as can in English or some other human language to respond but the general idea of rubber duck debugging or rubber ducking is to talk to an inanimate object like this or nowadays an AI and again per week zero in that process of sounding out your confusion and telling the duck like a teaching assistant what your problems are odds are that proverbial light bulb will go off and you'll realize some illogic some mistake you've made at which point you can actually solve it yourself but when the problems get harder and when the material is especially new it's not going to necessarily come to you off the top of your head so let's give you some more techniques it turns out that one of the most common and useful ways to debug code is literally with a function we've used since week one printf because printf lets you print anything you want including the contents of what's inside of the computer's memory so to speak inside of your variables and functions and the like so let's go ahead and do this let me switch over to vs code here let me go ahead and create a new file that deliberately is called buggy. C so code buy. C and this will be relatively simple includes standard i.h int main void and then inside this let me aspire to print out this column of bricks here of one two three bricks top to bottom all right back in my code I'm going to do 4 in uh I equals z i I want three of these so I'm going to naively do I less than or equal to three i++ and then inside of my for Loop I'm going to do print F quote on unquote uh uh hash sign back sln close quote semicolon so if you're already pretty comfortable with seeing for Loops at this stage you can probably see the bug already but again the focus here is on techniques not the actual code it looks like I've done something stupid though because when I do compile this code and I'm going to do make buggy instead of bothering with clang because we now can sort of stipulate that we know there's more going on there but we don't need to care about it every time/ buggy is not going to print three it's going to print four of those hashes instead all right so how do I go about wrapping my mind around what's wrong well I remember from class I'm supposed to start counting from zero if I want to go up to three it's less than or equal to three so we could probably reason through this without much effort but let's suppose that this is representative of more sophisticated problems well print F here can be your friend if you want to see what's going on inside of this loop I would propose that you temporarily maybe add a second printf that says something like this I is and then I'm going to use a placeholder percent I back sln close quote comma I so if I just want to wrap my mind around what's going on every iteration of this Loop let me just literally print out the contents of that variable so let me remake this make buggy do/ buggy enter okay now let me enlarge my screen what has happened I is zero I get a hash I is one I get a hash I is two I get a hash oh I is three I get another hash so the solution here is is one of a few things I could either regress and start counting from one but in general I would propose do what programmers do start counting from zero so if I leave I at zero what is the correct fix here so just change it to less than three instead which again is sort of the convention even though it's by no means the only way to do this if I go ahead and do that let me clear my terminal window and make it larger temporarily make buggy again/ buggy okay now I got it I is zero I is one I is two and I only get Hash Hash Hash so printf is your friend just remember certainly in the context of a class like homework and the context of the real world once you're done using printf to debug your code go in and delete it so it's not printing out uh you u a confusing message to the auto grader the correctness tests or the like there all right so that's how you might use something like printf but what if I did something a little more sophisticated let me do this let me change up this program and get rid of the for Loop and let me for the sake of discussion just make it a little more complicated let me go ahead and uh create an integer called H for height let me ask the human using get int for the height of the column of bricks that they want I immediately have to go in and add the cs50 library because if I want to use get int that comes with cs50 not with standard i.h once I've done this let me go ahead and call a function that doesn't yet exist but will print column of height H and this is sort of where we concluded roughly in week one whereby I factored out some of the functionality for printing a row of bricks today I'm flipping it around to say print a column because now I'm going to do this void print column and then the input that this will take is going to be the actual height but I could call that anything I want so long as it's an INT and here I'm going to recreate the correct code for INT I equals 0 I less than not three but height if I want genericize it i++ and then inside of the loop I'm going to go ahead and quite simply print a single hash and a new line so that it gets Hash Hash Hash Hash one per line but there's technically a bug here let me hide the terminal window and scroll back up what one mistake have I still made I'm missing the Prototype right because if I compile this as is the clang the compiler as we now know won't know what print column is because when it sees it for the first time on line 7 it has never seen it before so the solution of course is to copy paste and this is the almost the only time copy paste is acceptable and encouraged that first line of the function itself all right let me open my terminal window let me run make buggy it seems to work/ Buggy enter and it's gone ahead and done let's see three this is the correct version so just a bit of a sanity check that it's working as intended now now let's break it let me hide my terminal window let me make the same mistake as before and let me say that printf for now is your friend but by week three week four week five in the real world you're not going to want to just start printing everything out because you're going to be printing so many darn things you're going to have to then go remember to delete the stuff it's going to mess up the output there are better tools and even though this week it will take you more minutes to play with and get comfy with what I'm about to show you this will pay off in hours over the course of the firm and in the real world spend a few extra minutes this week playing with a proper debugger which is going to introduce you to more sophisticated techniques for debugging your code we are going to run now a program called debug 50 which sounds cs50 specific but that's only because it automates the process of starting VSS codes built in debugger for you so this is not a cs50 thing this is representative of a debugging tool you would have in the real world available to you and uh vs code is among the most popular so let me go back to my own code here let me open my terminal window and let me confirm Now by recompiling buggy enter and running do/ buggy now we're back to the problem where if I type height of three I'm getting four hashes so how can I wrap my mind around why that is the case without using printf well what I'm going to do now is this I'm going to run debug 50 and then I'm going to run the name of the program/ bugy so debug 50 is a program that expects its own command line argument what program do you want me to help you debug I'm going to go ahead and hit enter and hm I made my first mistake looks like you haven't set any break points set at least one breakpoint by clicking to the left of a line number and then rerun debug 50 so what is a breakpoint well let me hide my terminal for just a moment a breakpoint is sort of a stop sign that you can add to any one of your lines of code and tell the computer break execution at that point that is run my code but pause temporarily here so I can poke around so what I'm going to do is because the first line of Juicy code is at line 8 notice if I hover in the so-called gutter of vs code there's this little stop sign or Red Dot that appears I'm going to hover over line eight and as directed I'm going to click and it gets even redder that is a break point it says run my code but stop at this point so I can poke around let me reopen my terminal window clear it and do this again debug 50 bugy enter all right so a whole bunch of stuff seems to be happening automatically it's a little confusing at first glance I'm going to zoom out just so we can see more of it here I'm going to go back to the terminal window cuz notice there we go in my terminal window I have a blank window now because why line 8 is about to prompt me for input so what has happened here well let me go over here to the code this is still my buggy. C file notice that there's a play icon here there's some arrows there's a stop icon and some other stuff notice that line as hoped is highlighted because execution has been paused on line 8 before it executes let's now actually see what's going on at the top though there's some Curiosities all of my variables in this program that are currently in scope that is accessible between these curly braces are summarized here where did 32766 come from any Instinct for why H apparently has this weird value even though I haven't even typed in anything let alone such a big number yeah how about over here yeah I think that's a reasonable way to think about it maybe it's like a previous program used the same memory inside of the computer for something else maybe it was an integer maybe it was a string or something else so what you're seeing is actually what we're going to start calling a garbage value it's like remnants of what the memory was previously used for it has no significance to us it's not a big deal because as soon as I let the debugger proceede one more line the value of H is going to be changed to whatever the human run uh actually types in but what you're seeing is what's really going on inside the computer you're certainly using and reusing the memory inside of your computer all day long cuz you can't you don't want to run out so you need to reuse it so the debugger is letting us see that so now notice the arrows at the top of the screen I can either hit play to say like just keep running the whole program or I can do something like this step over so this second Arrow here step over will actually run run line eight but then pause on the next line for me and we'll see what else we can do in a moment so I'm going to click step over and now notice in my terminal I have been prompted for a height let's go ahead and type three enter now I've typed in three what happened at top left now the local variable so to speak local in the sense that it's inside of these curly braces is in fact what I would expect which is three notice now that line nine is highlighted it hasn't printed anything yet so let's step over line 9 to and see what happens with this value of H let me click step over again the highlighted line becomes 10 which is almost at the end of the program but unfortunately I see 1 2 3 4 damn like it's still buggy in this case and honestly this wasn't really enlightening setting the break point there I really have just slowed down the process of seeing my mistake but it's still in fact there so let's actually just run the program to completion I'm going to hit the play button but I could just as soon hit the stop button cuz they're equivalent cuz the program is essentially over all of that is going to close but my break point is still at line8 I'm going to do this I'm going to leave that there and going to run debug 50 once more let's actually step over this line as before to get my input of a height of say three but now on line nine which is highlighted let's not step over this because obviously that's just going to print out the same wrong thing instantly let's step into this function why this one CU I wrote print column ironically I also wrote get int but I'm pretty sure get int is not incorrect correct I'm pretty sure print column is incorrect so let's step into it the icon for that is the third icon here the second Arrow step into click and now notice that execution has jumped into the print column function nothing is printed yet because I haven't even started the for Loop but now I can actually poke around here and notice this this isn't even crazier value for I but for the same reasons it's just some garbage value left over from whatever this memory was being used used for previously but the moment I click step over now the second icon now notice at top left I is zero and we're about to print a single hash let me click step over once more and watch the terminal window at the bottom I currently have no hashes but now I have one hash now the highlight's back on line 14 let's step over that and watch as I do at top left I's value is going to change from 0 to one because that value just changed now I'm highlighting line 16 let's click step over and watch the terminal window there's my second hash let's step over line 14 watch I at top left I = 2 let's go ahead and step over line 16 there's my third hash let's now step over line 14 again watch the I at top left here's where you can see that oh I equals 3 but wait a minute line 16 is highlighted I'm about to execute the darn thing again oh that's why I'm getting the fourth hash and if I do this one more time step over line 14 watch what happens to I I now disappears altogether why because I've jumped out of the four Loop because I became four four is not less than three so we're done with that for Loop and now if I go ahead and hit play it's just going to run to the end of the program which is essentially already that because the curly brace was already there so kind of tedious to walk through a program in this way but notice it has given me the ability to step through my code line by line by line at a normal person Pace not at like a Mac or PC's pace which is of over in the blink of an eye to get rid of a break point you just click on the little stop sign again it goes away and your code will run as usual even in the debugger questions then on this technique of debugging questions okay use debug 50 okay use the rubber duck that too should be helpful over time but let's actually now take these ideas out for a spin and actually see what's going on in the actual computer's memory with these new techniques so recall from last time that when you write code you can use like strings like get uh like hello world you can use integers like the number 50 or 72 73 33 that is because C like a lot of languages supports different types of data and think back to week zero when we stipulated that everything is zeros and ones so how does the computer know if that's a number a letter a color an image a video a sound well it's context sensitive and I simplified in week zero and said well if you open something in Photoshop the zeros and ones are going to be interpreted as numbers as colors but that was a bit of a white lie the better answer is when you open in Photoshop a bunch of zeros and ones the programmers at Adobe the people who wrote that software specified in the code that those zeros and ones should be treated as colors and not as numbers and texts per se so in the world of C there are these data types and we had this list up last week and we focused particularly on string and uh string an INT we introduced briefly float for real numbers with decimal points Longs which are even bigger than integers so you don't avoid but you at least postpone integer overflow by using more bits and here for instance is how big these data types in C typically are nowadays technically it varies by computer or device but typically it's safe to assume these values here so a Boolean a true or false takes up one bite even though that's Overkill you technically just need one bit but C uses a full bite an integer is typically four bytes four bytes is 32 bits that means you can count from 0 to 2 to the 302 power that's 0 to 4 billion or if you want to support negative numbers negative -2 billion to positive 2 billion along is eight bytes that's in the quintilian depending on whether you want negatives or positive values as well um float is four double is eight a Char a single character is one that's going to be jern M today and a string I'll propose is is sort of unknown because it depends how long the word is if I type in d a v it would seem to be of length five at first glance or hi or just two a string is going to vary based on the actual contents of the memory and here then is a picture of memory so this isn't a scale at the moment but this is what might be inside of your laptop or phone or desktop and it would look similar in spirit like a green circuit board or logic board with tiny little silver or gold traces that are essentially like tiny little wires that allow zeros and ones to flow back back and forth and there's these black chips that actually store the zeros and ones um as your computer's memory so if we actually zoom in on one of these black chips I'll propose that no matter how big this chip is I bet we could come up with addresses for all of the bytes they're in so if this thing is like one gigabyte 1 billion bytes doesn't matter how we number them but for the sake of discussion maybe this is the first B this is the second bite this is the third bite this is the billionth bite for gigabytes so you could imagine if You' got this many bites you can slap some numbers on them just like on a a building in the real world you can slap a unique address on it like 45 Quincy Street uh Cambridge Massachusetts 02138 USA is where we are now in the world of memory let's keep it simple 0 1 2 3 and so forth so let's actually redraw this as a grid of sorts whereby each of these squares represents a chunk of memory so if you were to store a Char in the computer's memory that's one bite so so maybe if the human were just to type in a single character maybe it would be stored up there in the top left corner or who knows somewhere else if you were to store an integer which is four bytes typically maybe it would be stored there but they are necessarily contiguous can't use one bite here one bite here one bite here for data types like integers and strings and chars they're all going to be back to back to back so that's four what about a long or a double for that matter you might need eight bites those are all going to be contiguous here well let's actually go ahead and Abstract away the hardware because it's not really that interesting that there's a physical circuit board let's think about memory more abstractly it's just like a canvas kind of like in Photoshop where every little dot can store some bite some set of eight bits let's zoom in here and consider what could go inside of those bites so for instance how about three lines of code like this out of context but suppose we whip up a program real quickly that allows me to calculate like my average on like three homework assignments or three quizzes or three exams in this class or any other suppose I did you know so so on the first two score one was 72 score two was 73 score three not so good 33 what's my average grade as of now well I think we could whip this up pretty easily for instance let me go over to VSS code here and let me go ahead and create a new file called how about scores. C and in scores. C I'm going to go ahead and do maybe a little something like this include standard i.h int Main void and inside of main let's do int Score 1 equal 72 int score 2 equal 73 int score 3 equals 33 and now let's just print an average so and I'm going to make a comment to myself print average so I remember what's going on comments are just for the reader not for the computer's sake print F average colon just to format it nicely uh I want as many partial points as I can get so I'm going to use a float instead of an INT back slash n and then to compute the average just like in the real world I think I do score one plus score 2 plus score three in parentheses all divided by three and then a semicolon so let's see if this works I'm going to go down to my terminal window and do make scores which will run clang for me but I screwed up already let me make this bigger I'm not sure we've seen this error before let me rerun it more simply what did I do wrong here even though it's cryptic yeah I'm back or just stretching just stretching yes and there I'm missing a parenthesis I don't think so not bad Instinct but I'm not in this case I think I'm balanced the format is wrong so the format code is wrong I'm using percent F but it wants me to use percent D which technically means decimal which is a synonym for percent I for integer but I actually no no no like I don't want it to be an integer like if I get partial credit like I want to could be rounding up not down so to speak so there's actually a more subtle error and remember the issue last week of truncation whereby if you've got int plus int plus int divided by int what do you get back you get an INT so you don't even round properly it truncates everything after the decimal point so one way to solve this problem would be to say all right really I want to divide by 3.0 so long as you get a floating number involved then the math will work correctly or I could do what I did last week too I can cast the three to a float but frankly it's pretty equivalent and few keystrokes fewer to just say 3.0 as my denominator and again to be clear the reason for that I don't want integer Division I want a floating point value so if I'm getting partial credit it's point something that's not thrown away all right let's try again make scores enter seems to work now scores enter and my average is indeed thank you you 59 and 1/3 still kind of failed but like at least it's not 59.0 truncated down all right so that's one way of doing this but what's actually now going on inside of the computer's memory well here is the computer's memory abstracted away is just squares when I create score one as a variable that's like asking the computer for four of these squares call it score one and plop the number 72 there when I ask for score two that's like getting another four bytes of memory probably next to it but not necessarily and when I create score three that gives me another chunk of memory also four bytes with the number 30 3 again because there's no other variables as of yet in this program they probably will end back end up back to back to back but that's not necessarily a requirement depending on how you implement the code well what is the computer really doing in the memory there well it's really putting three patterns of bits three patterns of 32 bits because again by default integers tend to use four bytes or 4 * 8 32 bits total okay so if that's what's going on inside of the computer's memory it is would seem to be correct and indeed my math was correct but what is badly designed about this program it's super simple there can't possibly be too many shortcomings but what's bad yeah you want yeah really well said so if I want to add in more scores like next week a fourth score then a fifth score then a sixth score well I can just kind of modify the code and add a line line line here but then I have to add like variable variable variable here like it's not very wellmaintained and honestly if you kind of let your mind extrapolate what if I've got like 10 scores or a 100 scores over the course of like years of college does it really seem like good design to have int score 45 int score 46 in like there's got to be a better way than coming up with these stupidly named variables where I just manually add a number add a number add a number wouldn't it be nice to just call all of them them collectively scores and not have to create individually all of these unique names and frankly I don't have to call them score one score 2 score 3 I could have called it a b c or something arbitrary like that but that's even less clear it would be nice to just call them all collectively one thing well it turns out that there is a way to address this and to do better than this in code we're going to introduce the first of our data structures this week in class whereby we can introduce the notion of an array an array is is a block of is a sequence of values back to back to back in memory an array is a sequence of values back to back to back or contiguous in memory all of which are the same data type so in in int or Char Char Char or something else along those lines and the Syntax for creating a single variable that contains not one but any number of values is relatively simple in C you simply specify what type do you want the values to be int what do you want the name of the variable to be score scores plural just for clarity and how many integers do you want to be associated with this variable called scores you use square brackets which is something new now but the square brackets indicate hey compiler this is an array of three integers that will give me access to all three back to back to back in memory so if I want to now initialize each of these values to numbers the synex is pretty similar to before but I don't have to come up with new variable names for each of them I can instead keep using this square bracket technique as follows to initialize the first score I can say scores bracket 0 equals 72 semicolon the second one is scores bracket 1 the third is scores bracket two they are zero indexed so to speak as before we're almost always going to start counting from zero in C and in most other languages so zero is the first one is the second two is the third but notice these aren't separate variable names now they're all called scores but I am indexing into the array by jumping to a specific location the first one the second one or the third one first middle last so to speak so if I want to use this technique now let me actually go back to vs code here and let me modify my version of scores as follows I'm not going to quite do what you recommended over there a moment ago which is to sort of avoid um repeating myself a few times but I am going to clean this up I'm going to say int scores bracket 3 to give me an array of three values then I'm going to manually say scores bracket 0 equal 72 scores bracket 1 equal 73 scores bracket 2 equals 33 semicolon and then down here I have to change my formula to be scores bracket 0 scores bracket 1 scores bracket 3 so I sorry scores bracket two and then divided by 3.0 for the same reason as before if I open my terminal now clear it make score again seems to compile do/ score still gives me the same value but it's a little better designed I've got one variable now with three spots in it instead of three variables and God forbid even more if I want more and more of these values well what is now going on in the computer's memory well these three lines of code now look fundamentally the same four bytes four bytes four bytes but the names that the computer is giving them is scores bracket 0 scores bracket 1 scores bracket 2 and to clear it's one variable but this is saying go to the first location location zero go to the second location AKA location 1 go to the Third location AKA location two gets a little confusing that everything's off by one but you get used to it over time so if that's what's going on inside of the computer's memory let's actually Tinker with it further and toward this end of making it even better ultimately let me propose that we go back here and maybe modify this as follows instead of hard coding my three score 72 73 33 and then having to like update this code next week and then update it in two weeks by adding more and more uh scores to it what would be the right programming technique here to like just prompt me again and again like loop again right we don't have to write all of these lines of nearly identical code so let me do this let me get rid of these three lines which look like copy paste except for the changing number let's do four in I is z i less than three so I'm not going to screw up this time not less than or equal to but less than three I ++ then inside of this four Loop let's go ahead and use this syntax scores bracket I equals let's actually ask the user now for their score rather than hardcoded at all using get int like this so we're using the square brackets now in a few different ways even though the rest of the code is now the same in this line of code I'm declaring the variable called scores to be an array of size three integers kind of a mouthful but that's all that's going on there when I use the array later I don't have to say int ever again that was just to tell the computer once what types of values do I want to put in here Hereafter I can just say scores bracket I well what is I well on the first iteration of this loop it's going to be zero and then one and then two like magically it's going to plug into those square brackets exactly the number I want 0 1 2 on up get in is going to be called 1 2 three or more times based on however many times I Loop so I don't have to type 72 73 or 33 in my code at all now the code is still imperfect I'm still kind of cheating that I've got the three here I've got three of these here I've got the three here the three here this is still poorly designed but it's better poorly designed in the sense that I've got this magic number three everywhere that I am going to mess up at some point if I change it to a four I bet you I'm going to miss one of those locations so we should probably improve that as well well let me go ahead and just confirm that I didn't make things worse make scores I did what did I do wrong here error call to Undeclared function get in yeah I didn't include cs50.h that's be that's why the compiler just doesn't know what a get int even is so that's an easy fix let me go ahead and type that in here clear my terminal rerun make scores okay now we're back in business/ scores now I'll type them in when prompted by get in 72 73 33 and I'm still getting the math correctly but I can do a little better so let me hide my terminal window let's get rid of this magic number three um how can I do this well I could do something like this int and maybe capital N uh equals three for a number that's not changing but actually there's a technique if you want to tell the computer don't even let me change this number what can I write on line six before int const we haven't used it much but this is just a of protecting you from yourself or protecting your code from some dumb colleague who goes in and tries to change a number that they are not supposed to so const in n equals 3 means this variable shall be forever the value three what can I then do with this well I'm going to change the three here to n the three here to n and down here it's kind of a step backwards I don't want to do n just yet but I can cast this to a float to make sure that that three is treated as though it's 3.0 now now I capitalized n just by convention generally when you use constants humans tend to like capitals why because it just jumps out to the reader wait a minute like this is capitalized for some reason that usually means it's meant to be a constant just as a a little visual heuristic this is still imperfect cuz I'm still assuming that n is always going to be three but one problem at a time let me open my terminal make scores do/ scores 72 73 33 code still seems to be behaving correctly except for notice this time we're seeing a bit of an artifact now suddenly I lost a one what 10 100,000 10,000 1 millionth of a point so the rounding is a little different but that's because fundamentally when dealing with floats they are going to be imprecise maybe not very imprecise but slicy slightly imprecise thus far we were getting an additional three there not a two that's just a side effect per last week's discussion well let me go ahead and do this instead of typing this one out myself let me go ahead and uh grab sort of from the the uh oven already cooked a program called scores version 5 which I wrote in advance which now has everything so this is a lot on the screen all at once but let's focus on what's similar I'm including cs50.h and standard i.h I'm declaring a const notice though that I've put it at the top of my file instead of inside of Main and that's okay it is sometimes okay and a good idea to put your uh constants out outs side of functions so that if I do want to change it somewhere it's obvious where to change it it's not buried in some function it's at the very top of the file where it's more obvious to the reader notice now I've introduced a function called average more on that in a moment because the problem I still had was even though I had three three three in a variable I was still manually adding scores zero scores one scores two what about scores three four 56 as the program grows well how am I solving this well notice this in Main now I'm giving myself access to ncore so whatever n is make the array big enough and this is a cool technique with arrays if you don't know when you write the code what the size is just use a variable and the computer will give you an array of that many spots the for Loop is exactly the same here exactly the same here I'm just prompting the user again and again for each of their scores the only thing I've Chang now is fix the final problem instead of just printing out the average of score0 Plus scores 1 plus scores 2 / 3 I'm actually asking a helper function so to speak another function that I wrote called average that takes two values one is n because it's got to know how many values to average what's the denominator and then the array itself and this is the only new piece of syntax now with respect to arrays is how I'm passing this in let's focus on just the math for a moment how do I calculate an average when I don't know in advance how many values there are so I can't just do this plus this plus this all divided by three well let's create a variable called sum let's then iterate over the length of that array let's use some of last week's syntax to add to that sum the value at location I location I location I as I goes from zero to 1 to two on up and then lastly how do you C calculate the average well whatever that sum is divided by the length of the array cast it again to a floating point value so the only thing here is a recollection from sort of grade that to calculate the average you just add add add add add all of the numbers in the numerator and divide once by the denominator so I've used some C code with a variable and a for Loop to do just that the only weird thing I'll I'll um call out here is this notice how I wrote the average function it's called average it returns a float which we haven't seen before but it stands to reason if we can return ins and if we return nothing like void I could probably return a float and that's correct this is the output of this function that is why I can return a value but this is weird not only does average take two arguments one of those arguments as of today is now an array so I could call these arguments anything I want a b XY but I'm calling them more usefully the length of the array and then the name I want to give this array but I could call it anything I could call it numbers but I called it array for the sake in class of making super explicit what an array is but this is the weirdness when a function takes as input someone else's array you don't have to know in advance what the size is so you just say Open Bracket close bracket and leave it at that but you need to make sure that that caller the function who created the array also tells you with a second argument how big it is this is not true in Python this is not true in JavaScript and certain other languages that some of you might be familiar with but in C if you pass an array as input you don't have to the the function doesn't have to know how big it is but you have to tell it how big it is by giving a second argument and that's it for this use of square brackets we've used it to create the array to access or index into the array and now to pass the array so square brackets almost always are going to hint there's an array going on here I suppose we should run this to be sure that I didn't screw it up so make uh let's do this uh uh Copy Source 2 scores five so we haven't showed you this yet but if I have a file secretly called scores 5.c and I want to re uh name it to scores. C I can use the CP command for copy for short it's going to prompt me overwrite scores. c yes and so now if I open what was always called scores. C I now have exactly the same file as we walked through a moment ago so let's run this now make scores scores uh 72 73 33 and we still get the same correct average but now the code is arguably not only correct it's better designed even though things kind of escalated quickly because to make this code better designed I needed to generalize it to handle not three but ultimately any number of exams or scores by changing the three to a four or a five or 100 or anything else and Heck if we really want we could ask the user how many scores do you have already by calling get in one more time and then avoid the constant itself okay that was a lot just to calculate a very bad score questions yes a really good question what happens if you try to access a point in the array that hasn't been given a value yet we will see that actually soon you can go there but you don't know what you're going to expect uh so just to be a little dramatic why don't we go ahead and have some delicious uh animal crackers take a 10-minute break and when we come back we'll start building on these examples all right now that we have this new tool in our toolkit of arrays let's see how we can like sort of take it out for a spin and sort of rethink and also solve different types of problems starting with a super simple message of high which is where we really began over the past couple of weeks too so suppose I wrote some code in an actual program soon that just stores three chars and I'll call them simply C1 C2 C3 initialize them to hi I exclamation point which not un uh not coincidentally is exactly the the numbers we've been playing with 72 73 33 recall from our so-called asky charts from weeks past so what's going on with code like this well let's go ahead and try it out let me open up a new file called how about high. C and in vs code I'm going to quickly do include standard i.h int main void and then inside of main let's give exactly those three lines so Char uh Char C1 equals quote unquote H Char C2 equals quot quote I Char C3 equals quote unquote exclamation point and just to be clear why am I using single quotes instead of double so it's a character not a string so strings are double quoted individual characters are single quoted all right so with that said let's actually just poke around these variables so let me go ahead and use print F and print out three things three placeholders percent C percent C percent C back sln and let's plug in the value of each of those variables C1 C2 C3 just to see what's going on well this one won't be all that enlightening but if I do make high do/ high I should see literally Hi exclamation point but I'm not printing it as a string I'm printing it as Char Char Char back and back from left to right all right so can I maybe improve this a little bit well let me go ahead and Tinker like this if I actually want to see the numbers that the computer is storing let me first kind of add some spaces here for clarity and look let me add some spaces here for clarity and let me change the placeholders from C to I because it turns out that if characters are just numbers per our discussion of asky and then more broadly Unicode what's really stopping me from just telling the computer treat this sequence of bits not as a Char anymore but as the integer that it actually is so we can use print f with percent i instead to do exactly that so let me rerun make high high and what should I see now when I hit enter probably 72 73 33 which we keep using and indeed that's all that's going on underneath the hood so to speak of these three characters in fact if we take a look at this code now in the context of the computer's memory a Char recall is one bite by definition so we need three such bytes for three chars so that might end up being I I exclamation point here or who knows maybe elsewhere in memory with those three variable names now in uh describing those three locations well once I've got that in place what's really going on underneath the hood well obviously it's actually storing 72 73 33 and if we really go down lower level to where we began week zero technically what's inside of the computer's memory is these three patterns of zeros and ones but again who cares about these zeros and ones but they are there but it's easier to think about them as numbers or in the context of uh actual words uh characters instead so what is a string well we introduced a string last week as being a sequence of characters but it turns out that we actually really know more so now what a string is so for instance here is an example of declaring a string called s and setting it equal to the value of high let's actually put this into some code let me go back over to VSS code in high. C and let me just tweak this code by really throwing away all of these lines let's do string s equals quote unquote in double quotes Now High exclamation point and then print out percent s back sln and print out s itself and just so I have access to it more on this another time let me proactively include cs50.h at this stage so all I've done is exactly this line string s equals high and let's just print it back out just like hello world before it make high do/ high and indeed I see Hi exclamation point but what's going on now inside of the computer's memory well just like the sequence of Hi exclamation point what is a string well a string is a sequence of characters yes which means back to back to back contiguous in memory so if this is the computer's memory and I have created a string called high it is indeed going to be called s and it's going to have Hi exclamation point back to back to back in the computer's memory well what's noteworthy here is that this looks awfully similar to stuff we've been doing thus far like in fact if a string is yes a sequence of characters could we slap another name on what a string actually seems to be as of today an array of characters right that's a sequence of values contiguous in memory well that's pretty much equivalent to what I've been calling a string so I bet we could think about high as really being three locations called s where this is really s bracket 0 S bracket 1 s bracket2 and it's not that hard to even reveal this with a bit of code let me go back to vs code here let me leave line six alone but let's go ahead and do this instead of printing out one placeholder percent s let's print out percent C percent C percent C back sln comma and there's no C1 C2 C3 now there's only s so let's print out S braet 0 S bracket 1 s bracket 2 close parenthesis semicolon go down to my terminal window make high do/ high it's the same darn thing so all of this time as of last week when we were playing with strings we actually already were using arrays we just didn't call them that but a string is a sequence of characters and array is a sequence of values so really a string is just a more precise type of array specifically containing characters well what's really going on inside the computer's memory then is indeed this you've just got one variable called s but it's got indeed three locations but the difference here between strings now and what we were playing with previously scores where we had one two three scores and we had to keep track of the number of scores with a variable like n or by literally typing three into my code if I only have one variable in this program s and yet it's somehow working how does the computer know where s starts and where s ends like when I print out percent S as a placeholder why is printf not just printing out everything that's in the computer's memory how could we solve this well like at the end of the day there's no magic like all we have is this canvas of zeros and ones and if you want to keep track of something you have to spend some of these bits you have to use some of these bites so it turns out that the way a computer keeps track of where the end of a string is even if that string is three characters the length of the string the length of the array really that's storing the string is technically four it's one plus whatever the actual length of the phrase is so if s begins here it's obvious to our human eye that s ends here but how does the computer know that it spends one extra bite always for Strings unbeknownst to you and it fills them with all zeros and so technically s is yes length three Hi exclamation point but it uses four bytes because of this special value this Sentinel value this terminating character that indicates hey the string stops there now this kind of invites the question well how do you represent all zeros more on that another time but for now we're just using all zero bits as a special signal that string stops here now we let's stop talking about bits all the time this is really just the number zero so technically whatever the string is the last bite in a string will always be zero this though is a little not uh ambiguous like is this like zero bits or is this like the number zero on my keyboard like do I want to see the zero so typically the convention is to put a backslash in front of the zero to make clear that this is a special character this is a special character like back sln like some of the other characters we've seen that just indicates the string and end here it's the same thing as all zeros but it avoids that visual ambiguity so we can actually see this if this is at what's actually going on underneath the hood we can actually see the fact that this is there let me go back to VSS code here and let's just kind of get a little curious instead of printing out three of these things let's go ahead and do this let's print out percent I percent I percent I as before and this is no different from earlier make high do/ high there are those three numbers but let's kind of get curious and print out one more placeholder percent I and print out s bracket 3 which I'm assuming will exist because as indicated a string always gives you one extra bite for that special terminating character make highh high voila like there is the zero unbeknownst to us last week and unbeknownst to us before break it's always been there with any string underneath the hood the variable keeps track of where the string begins but zero indicate where the string ends questions on this technique or this implementation detail yeah what would happen if you went to the next good c a good question and honestly there's nothing really stopping us so let's try going one more location so s bracket 4 let me go ahead and do make high do/ high 37 comes next whatever that is if we do one more sent i s bracket 5 let's do make high do/ high enter 105 comes next so these are actually unpredictable and are actually representative of those same kinds of garbage values that I alluded to earlier that don't really belong to us like I really shouldn't be poking around places where I I I haven't asked for the computer to give me memory but odds are those that those are sort of evidence of other values in this program or maybe remnants of the memory having been used prior but the only one we can trust will exist is one greater than the String's actual length really good question all right so what is this thing called well it's conventionally this thing is called null so n l single L we'll see another version of null that's spelled a little differently and we've actually seen it before even though we kind of waved our hands at it here was the asy chart from uh week zero in fact and we focused on Hi exclamation point but here's the First Column and notice location zero in the asy chart has always been what humans call or null which is just a special Sentinel character a terminating character that says string ends there all right well what if we have multiple strings for instance like one string s called high with a value of high and one string t with the value of by let's actually play a little with that and see where things end up in memory so let me go back to vs code let me get rid of this long printf and let me give myself another one string T equals by exclamation point and I'll print out both of these print f quote unquote percent s/n comma s and then print F uh percent s back sln comma T semicolon and now make high do/ high and we'll see as you would expect just high and buy on the screen what's going on inside of the computer's memory though well odds are we're going to see two chunks of memory in use S and T respectively maybe s ends up here which is the whole thing here technically this is s braet 0 1 2 3 but who really cares at this point it's just a string called s storing this value and though this is up to the computer and the context in we write the code odds are by will end up right next to it in memory it's too big to fit on the screen so there's still another character here but it's indeed here so even though you and I only ever write High exclamation point or by exclamation point the back SL zero the null character ends up being added automatically for free and fun fact fun fact this is what the double quotes are implying when you use double quotes that's a visual cue to the language oh this is a string let me terminate it with back sl0 you do not want to backs slash zero for a single Char because single would mean one character so single quotes distinguish that for the computer as well all right so now that we know this we can actually sort of solve other problems as well in fact let me go ahead and do this let me go ahead and syntactically play around here so if I know that have two variables here let me sort of draw some inspiration from the scores example if I have a whole bunch of strings I probably don't want to call it like s t u v and so forth let's just give myself one variable called word whoops one variable of type string called words let's give me two of them for the sake of discussion and then let's have the first word so words bracket Z equal quot unquote High let's have the second word words bracket 1 equal quote unquote by by so just like I did with the scores let's just consolidate all of these arbitrary variable names into just one that's a little more descriptive like scores or in this case words how do I now print these well instead of printing S&T I can print words bracket zero and I can print words bracket one and if I go down to my terminal make high again/ high still says the exact same thing but here's where things get kind of interesting you can compose these ideas in different ways like this is not something that's useful but it does speak to the fact that there's no magic like now that you have the square bracket notation you can start poking around wherever you want For Better or For Worse so for instance suppose I want to print out the three-letter word high well I could change percent s to be percent C percent C percent C for Hi exclamation point but wait a minute how do I print out characters well this is kind of a neat feature if words is the array and words brackets Z is the first string in that array well what is a string it's just an array itself so if you want to go into the first character of the first word you can actually do this syntax use brackets twice the first set of bracket says what word do you want the second set of bracket says what character you want because again this is an array of strings AKA an array of arrays so let's do words bra 0 bracket 1 word Z bracket 2 and then down here I know this is a four-letter word so again this doesn't really solve a problem it just demonstrates what's going on here's a four-letter word let's change this to words bracket 1 location zero words bracket 1 location one words bracket 1 location 2 words bracket 1 location three so again not something that's really compelling to use but it does demonstrate that there's no magic all that's happening is percent s is saying go print a bunch of characters until you see the back SL zero percent C is letting me manipulate these things manually so make high do/ high exact same thing as before by just building on the assumption that these strings are really just arrays okay so how do we actually leverage this idea and sort of figure out dynamically how long these strings are because I bet anytime we want to start iterating over the length of text maybe to determine like the reading level of a chunk of text we're going to have to be able to read the thing from left to right and stop when the sentence or the paragraph actually ends so how might we do this well let me actually go back over to VSS code let's create a new file called length and let's write a program that figures out the length of a string for us so length. C shall be the name of this file let's go ahead and include cs50.h at the top let's include standard i.h at the top int main void and then inside of main well let's do this let's ask the user for their name String name equals get string and then prompt them for their name with Name colon quote unquote then let's go ahead and figure out the length of this string so how can I figure out the length well Bunches of ways but Loops come to mind if I want to iterate from left to right so let me propose that we first initialize any variable to zero I'll call it n for number but I could call it length or count or whatever then let's do a four Loop or no Let's do let's do a while loop actually like this while the name array at location n does not equal the null character go ahead and increment n and then at the very bottom here let's just print it out print F of percent I back sln n all right so there's a bunch going on here but it's a relatively simple idea what do we have so we're prompting the user on line six for their name pretty straightforward per last week line eight we're just saying start a variable at zero so like all fingers are down or the stress ball bowl is empty this is the only line that's a little weird to see for the first time but it's just doing this line n is saying while it is the case that the name String at this location does not equal the null character increment n so it's like using a finger and pointing at the string from left to right asking itself is this null is this null is this null and if it is not null then it's going to increment n so if the first letter is H at location zero well H is not equal to the null character so n gets incremented once so the expression High has at least a length of one I does not equal the null character so n's going to get incremented again the length is now at least two exclamation point does not equal null character n is now three but what comes after hi I exclamation point the null character so the character at location three name bracket three which is the fourth total location cuz we start started counting at zero is the null character this does not get incremented anymore I've only got three fingers still held up we're going to see the value three so this is a very mechanical kind of clunky but very correct way of figuring out dynamically the length of a string by just looking looking looking looking and figuring out where it is how does prf then know when to stop printing characters on the screen when you just hand at the name of a variable it is literally doing the same thing it is looking at your string left to right and checking is this null is this null is this null and as soon as it is null it stops printing words on the screen it's been doing this for us since last week so if I open my terminal window now do make length enter length type in a name like David enter and I do get back the number five not six because I'm not including the null character I'm stopping once I hit it and therefore I get five syntax is a lot but any questions on this here all right well let's make one tweak and then make it even simpler so in my code here wouldn't it be nice if I could just call a function that figures this out for me so for instance suppose I want to get the length of the name well let's just give myself a variable called int length set it equal to the return value of a magical function that doesn't yet exists called string length and pass in the name to that function and then go ahead and print out with print f exactly that length with percent I comma length so wouldn't it be nice if a string length function exists well it's not that hard to create one if I have a function called string length that Returns the length of a string I want this function to return an INT So that's its output or return type the name is going to be of course string length what's the input to this function going to be well it expects a string as input and I can call it anything so I'll keep it simple I'll call it s for string and then inside of this function honestly I think I can kind of copy paste that code from before I just need to change name to S and instead of printing n what do I want to do with the very last line here yeah so return s hand it back to whoever is using this function so that it gets passed from right to left stored in this variable and then printed there's one thing I have to do again it's kind of silly but copy paste the Prototype at the top of the file so that the compiler knows about it but I think now I've created my own string length function that can just figure this out for me and as before with scratch sort of out of sight out of mind I never again need to implement a string length function if I've already done it once but let's not be dramatic let's just undelete all of these blank lines let's now compile this code so make length again I messed up what did ah I don't want to return S I screwed up I want to return n which is the number s is the string so that's what it's saying here and we'll come back to in a couple of weeks what these words like pointer and conversion mean make uh length there we go/ length David I still get five well wouldn't it be nice if like someone had solved this problem for us already and it turns out there is so recall from last week there are some standard libraries that come with c not just cs50 not just standard IO not just the math Library there's actually a string Library that's got a bunch of string related functions in it that are super helpful in fact in the manual pages or Man pages for the string library at a URL like this which is cs50's version you'll see exactly the um uh an option called the sterl function St Len for short there's the documentation on the screen and sure enough there exists a function called Sterling that does exactly this so in fact I can actually wonderfully enough get rid of most of the code I just wrote by deleting that as well as its prototype I do need to include one more header file so string.h but instead of calling string length I can call ster Lang and now my program's done so here this is sort of evidence of like why we stand on the shoulders of programmers before us like someone else already solved this problem it's sort of intellectually interesting to understand how they solved it but why bother Reinventing the wheel again and again when you can use a library function to do exactly that so this version of the code I think make lengthlength DAV ID enter still works but it's like three lines of actual code now instead of you know a dozen or more that it was for a moment all right questions on any of this questions in back no all right so let's do a different sort of problem but still sort of borrow code that others have written before so besides the Sterling function in the string Library there's another oddly named Library called the ctype library which is related to C types so converting from one thing to another or detecting things so in the C type Library whose document is here you'll actually see a whole bunch of functions so if I go here you'll see things like is Al num it checks whether a character is alpha numeric is Alpha check whether a character is alphabetical uh is digit check whether a character is a digit is space check whether a character is white space and so forth to Upper to lower to convert a chart to lowercase to uppercase there's so many functions that someone else wrote that actually seem at a glance pretty useful but how might those kinds of things be implemented well here's that same asy chart as before and notice this kind of curiosity here are the start of the uppercase letters here are the start of the lowercase letters and just take a look at like a we know from last week zero that a is 65 and apparently lowercase a is 97 quick Mental Math how far apart of those numbers 97 minus 65 that's right 32 so they're 32 apart but notice the pattern how far apart are 98 and 66 99 and 67 and so forth they're all 32 apart and this is actually wonderful for the real Geeks in the room like you can just change one bit out of eight and turn a number from uppercase to lower case and back but for the rest of us notice that 32 is the constant here that explains how you get from uppercase to lowercase and back well we could leverage this and Implement our own function that somehow plays around with the cases of letters so in fact let me go back to VSS code here and let's create a new program this time called string.c just to play around and in string.c I'm going to go ahead and include my same header file so cs50.h uh and in standard io. and I'm going to use string.h and then in int main void I'm going to go ahead and do this let's prompt the user for a string s by using get string and just ask them for input whatever that input actually is let me just preemptively say print f uh quote unquote output and let me just go ahead and whoops close quote close parenthesis semicolon and now what I want to do is convert the user's input uh actually for now let's do it simple let's just print the exact same thing that the human types in so we're going to keep it simple just to make sure we have the framework for a program good to go so four in I equals 0 I is less than Sterling s uh let's go ahead and do I ++ and then inside of here inside of here let's go ahead and just print out that character so print out Percy back slash no let's no back slash n Percy quote unquote s bracket I so I think this code here will print out the E character of s from zero to one to two for however long it actually is and at the very end of this program let's go ahead and print out just a single back sln so this doesn't do anything that interesting yet but let me go ahead now and run make string I messed up because I'm typing too fast uh this semicolon goes on the outside let me do make string do/ string and I'll type in DAV ID and I get the exact same output so not all of that all that interesting but before we start playing around with uppercase and lowercase let's actually kind of clean this up slightly this program is correct if my goal in life is to just print the exact same thing as output as I was provided with input but it's arguably not welld designed yet for a very subtle reason even though I am very cleverly practicing what I preached a moment ago using the Sterling function from the string library now this is super subtle but on line nine recall how a for Loop works like you initialize I to zero then you check the condition then you do something then you increment then you check the condition you do something you increment then you check the condition you do something and you increment what might rub you the wrong way design wise about the story I just told given that Sterling is involved in that decision making yeah is the same every time you're cating it again perfect really good intuition like the length of s is not changing so why am I wasting everyone's Time by calling the Sterling function again and again and again I is changing so that part is correct but why am I calling this function and notice because I have written Sterling uh is s it will call the function again and again and again it's not going to very intelligent be like oh well it hasn't changed necessarily let me just do that for you unless you have a compiler that has a feature like that enabled but at a glance this just seems very inefficient so how can I improve this well I can do this in a couple of different ways let me go back to the code here let me grab Sterling of s and let me do this like int uh length equals Sterling of s and then I could do this so this is arguably marginally better because I'm calling Sterling once storing the return value in a variable and then using it again and again now that's fine that's correct that is better designed but there is this is such a common Paradigm there's another way to do this instead of doing Sterling of s inside of the condition you can instead do this you can declare a second variable like length or heck I'll keep it simple n set it equal to the string length of s and then all in within your for Loop you can do the comparison by having initialized not one but two variables at a time so long as those variables are both the same type now I'm declaring two integers at once but the first part here before the first semicolon is only executed once because that's the initialization so again subtle but it sort of speaks to efficiency because I'm not calling the darn function again and again when the string s is never actually changing in length so subtle but arguably better designed now with that said can we go and actually use this knowledge of the asy chart can we use this technique of optimizing with stir length to sort of combine things and start changing things to and from uppercase and lowercase well let's try this let me go ahead and open up a new file called uppercase Doc and in uppercase do c let's go ahead and use those same files include cs50.h include standard i.h include string.h and now in int main void inside of main let's go ahead and do the same kinds of things but a little bit differently string s equals get string and let's ask the user for input we'll call it before so what's the string before we do anything to it now let's go ahead and proactively print out the word after just so that we can compare it and I'm going to very cleverly use two spaces just because before is longer than after but I want them to line up perfectly above each other so I'm adding two spaces there just for Aesthetics now let's do this let's iterate over the characters of s and check if it is lowercase let's turn it to uppercase otherwise let's not touch it at all so how can I express that four in I is Zer I less than the string length of s i ++ and then in here but wait a minute let me learn from what I just said let me avoid calling Sterling again and again and again let's just call it n equals Sterling of s and then compare I against N N's not changing I is changing so that condition is now handling the logic I want inside of the for Loop now I have to ask a question is the current character the E character of s lowercase if so change it to uppercase now that's kind of a mouthful but I can kind of use last week's building blocks and this week's understanding of arrays to express exactly that so if it is the case that s braet i so the I character in s is greater than or equal to lowercase a uh and s bracket I is less than or equal to quote unquote Z then I want to go ahead and change S bracket I to uppercase I don't know how yet so I'm just putting a comment putting in pseudo code else if it's not lower case then just print s bracket I now let me go back to our little cheat sheet here so we only have the beginnings of it highlighted at the moment but we know that the difference here is 32 but more interestingly we know that s uh sorry that lower case starts at 997 and if I look in the Shaded part it goes to 122 so technically I could actually do this arithmetically with numbers and I could go in here and say is greater than or equal to 97 and less than or equal to 122 that's fine but honestly because we know from the previous example a Char is just an INT an INT is just a Char and you can format them however you want you can also manipulate them mathematically however you want so it's arguably better design and clearer to you clearer to the TF clear to the reader the colleague that oh you're comparing the asky values not some random number that I don't remember from class years ago so greater than or equal to lowercase a less than or equal to lowercase z expresses exactly what we want so I'm going to pluck off the easy one first how do I just print s while I do print F percent C uh comma s bracket I that means just spit it out unchanged it's not lowercase so there's no change to it let's just spit it out whether it's already uppercase or maybe it's punctuation or a number whatever now this part is the last part how do I go ahead and change a character from lowercase to uppercase well I know minimally I'm going to want to print some character so let's just proactively do percent c as my placeholder I kind of want to print s bracket I but I want to change S bracket I to low to uppercase what could I do mathematically to a lowercase letter to make it uppercase according to the cheat sheet yeah just subtract 32 so subtract 32 here and now if I let's add one final flourish let's just add a back slash end just so the cursor finally at the very end of all this is at the bottom of the uh prompt let me go ahead and open my terminal make uppercase enter okay I did screw up did it again I'm going too fast semicolon on line 14 Let Me Clear My terminal rerun make uppercase good/ uppercase uh David with one capital the rest lowercase enter and voila now we've uppercased everything just by understanding the the underlying implementation details of what's going on honestly if you don't remember 32 we can even abstract this away like whatever the distance is between capital A and lowercase a like that's actually what I want to subtract I could do B or C or Z or whatever 32 is fine but it's arguably better to do little a minus big a cuz then you know it's going to be dynamic between the two even if you forgot from class what the actual difference of 32 is all right but this is a little silly that I'm doing all of this work just to change things to uppercase and check for lowercase how can I make this a little better Well turns out that ctype library is actually our friend here let me go back into this code here let me include my ctype library and it's not necessary but I tend to alphabetize things just cuz then at a glance I can see what La header files am I actually using and I'll know if something is missing let me me go into my code here and you know what instead of doing all of this it turns out that in the ctype library there was a function called two upper and if I read the documentation of two upper it essentially takes as input per its prototype in our own documentation down here a Char call it C and it Returns the uppercase version thereof it technically returns an integer but who cares we know that this is functionally equivalent to the same thing so let me go back to my code and honestly because I have now included ctype.h at the top I can just say to Upper of s bracket I let me open my terminal let me rerun make uppercase uppercase whoops dot SL oops uppercase daav ID and now it's still the same but even this is kind of silly because if I read the documentation for the two upper function more clearly it actually says that it will handle this conditional decision of whether the thing is already uppercase or not or whether it's lowercase or not so I can actually change all of this messiness into just a single line of code in my Loop print F quote unquote percent C comma two upper s bracket I now semicolon at the end let me reopen my terminal window uh make uppercase do/ uppercase daav ID yet again that too works so again like libraries are your friend or design designing a function once and then somehow reusing it which is another technique we'll introduce over time will save you time in the long run once you have invented one wheel you do not need another for the same problem so to speak okay any questions on this exercise here the goal of which to be clear was really to paint the picture of one how you can manipulate all of these lower level details Now by understanding the aski chart from week zero and now arrays from week two and solve all of these s by just using someone else's code already in the form of these libraries okay so let's come full circle to where we began so that we also touch ultimately on a bit of that um cryptography and the Art of scrambling information to better prepare you for actually solving some of these problems with your own code this notion of command line arguments that I mentioned earlier commandline arguments are again just words you can type at the command line to influence the behavior of a program so make hello hello is the command line argument uh clang hello. C hello.c is the command line argument hello- o hello hello. C- o and hello and hello.c are the command line arguments plural so how do we actually write code that accesses words at the command line because thus far we have not written any code any programs that can do that but make can and clang can and other programs can as well so how do we make our own well up until now this has been how we've implemented main we've just been asking you to take on faith that it returns an INT always even though that hasn't been useful for anything yet and we've always specified that main takes no input so just write void I've been literally typing this for every program as did you presumably for problem set one well it turns out that you can actually change the void in main to be something else if you want your program to accept commandline arguments words at the prompt when you run your own code and you can change this void it's a bit of a mouthful to be this whole thing instead now it's long at a glance but what is it it's two arguments one is an INT one is a string technically an array of strings so this is why we introduced that syntax earlier when you have an array being passed into a function you just use square brackets and no number inside so what this implies is that Maine can if you want take an integer and an array of strings now technically you can call these things anything you want a b x y the convention though is to call it ARG C and argv where ARG c means argument count how many command line arguments have been provided and argv stands for argument Vector a vector is often another word for an array although there are subtle differences but in this context it just means array argument Vector is an array of all of the words that the human typed at the command line so how can we use this technique well let's go ahead and do something like this let me go back into VSS code and let's go ahead and create a program called greet do c so in greet C let's write a program that just greets the user but instead of using get string let's just ask them for their name at the command line so they can type it all at once hit enter and be done with it they don't have to wait and be prompted and then hit enter so let's go ahead and include cs50.h let's ahead and include standard uh standard standard i.h int main not void let's do no let's do void first actually void just to compare and contrast what we did last week in the this what we did last week would have been literally answer equals get string prompt the user for what's your name question mark space semicolon and then print F quote unquote hello comma placeholder back slash in comma answer so this is week one stuff now and we saw this same snippet at the start of today make greet dog greet I am prompted for David and now I am greeted hello David so that's the old way of doing it what is now the new way you using this prototype for main instead using this signature which is essentially synonymous which means now what if main takes two inputs and still returns one output let me go ahead and in my second Incarnation here let's tweak this as follows let's get rid of all of this let's change the void to be int argc comma string argv Open Bracket close bracket to make clear it's an array not a single string it's an array of strings RS and then inside of this function let's do this print F quote unquote hello comma placeholder back sln like always but what do I want to print well if argv is an array let me do argv bracket zero maybe semicolon and that's it let me now open my terminal window let me again do make greet dog greet and this is going to look a little weird but here we Gog greet David you'd think this would now say hello comma David but it says hello. /g greet all right so wrong given my intent but what can you infer about what is stored in argv Z apparently by convention by having just poked around here the name of the program which hasn't been useful yet but if you ever want like to have documentation maybe built into your program or maybe like an explanation of how to use it it might be nice to sort of reflexively know what is my name and you can actually figure out the program's name dynamically even if the user renames the file by using MV or right clicking or control clicking on it you can figure out what your name is in argv bracket zero well where is the actual name that was typed in arv1 is where the actual words begin that the human like me typed in so let's recompile this let's do make greet again SLG greet David and now I think I'll get a proper hello comma David I'm not using get string I'm not prompting the user I'm doing it all in one breath bre unfortunately if in the current moment I forget to provide a name let's just run/ greet enter so null and this is not n l this is a different type of null n this just means no value so this is not very pretty maybe we can defend against this and we can let me go ahead and close my terminal window let me temporarily get rid of this line of code and let's conditionally print that greeting out so if the argument count equals equals 2 then you know that there's the name of the program which is always going to be there no matter what automatically for free and another word is there like the name of the human typing the program then let's go ahead and okay let's print out hello so and so else if the user has not provided their name or they provided too many words let's just go ahead and give them a default value like hello comma World semicolon let me open my terminal window clear the terminal make greet again/ greet uh David still works as before because the number of arguments in argv is two the name of the program and whatever I typed in but what if I try to be a little more formal greet David men enter it just ignores that because now the argument count is presumably three and we didn't handle that so I can't even greet people with last names but that's fine similarly if I just dog greet and no name that's also not two so we again get the default value but at least now there's no way this code is going to print out null weirdly because I'm at least hand Ling and checking how many characters there actually is you can do other things with this too now if I were to sort of iterate over all of the words typed in I could do this for INT I is zero I less than r c i++ so a relatively simple for loop I can print out percent s comma n and then argv bracket I so what am I doing here well let's just try I did that fast but let's do make greet SLG greet David ma what am I going to see on the screen name my name my last name if I type in more words so maybe I do David middle initial J Ma I just get one per line so again there's really nothing intellectually that interesting going on here we just have a new integer conventionally called argc that tells us how many arguments there are there is a new array called argv conventionally that's just the array of words that were typed in so we can use last week's techniques with for Loops which are the exact same idea of Loops from week zero to just iterate over these things so again the syntax is new it's going to be hard to remember it even screwed up multiple times but it's just going to come with practice what's important is to understand the ideas underlying this and why these things work not like where the quotes and square brackets must be because that will come indeed with practice all right so this is actually um actually a fun way to demonstrate this is this this is not uh sort of educationally redeeming but it's fun to show let me actually maximize my terminal window it turns out that there's a lot of programs that come with systems like the operating system we're using called Linux which is again the operating system running in the cloud under underneath the H of vs code in your terminal window asky art which is a phrase I've tossed out there a couple times is like using the uh characters on your keyboard to depict things people places things animals or the like well we can actually use kind of a fun program called cow which again is really just for fun but it does take command line arguments and just for fun I thought I'd share these so if I want to go ahead and run coway let me do coway moo enter and apparently this program's purpose in life is to print a cow using asky art and then put the word you type as the command line argument in there if I change the word to be longer like moo enter the asky art sort of adapt so someone spent like a bunch of hours to figure out how to format this dynamically to make things look nice they also added some other features whereby with additional command line arguments it doesn't just have to be a cow saying things it can be like a duck so the program is still called coway but if you change the um mode to be that of duck and then say something like quack you'll see three command line ARG now and thus when I hit enter now we have a cute little duck quacking and perhaps especially fun is this c-f uh dragon like Roar enter and you get this crazy thing that took someone way too long to create so again no nothing educationally redeeming here other than hey kids here's an example of command line arguments just to do silly things like this it's a very common technique to more efficiently provide inputs to programs so there's only one last thing to distill about Maine which we've been asking you since last week to take on faith is why does Maine return an INT even though we've not been doing anything with that we didn't even know what the return values were initially well it turns out that programs can have exit statuses and we've not seen these visually yet but even though we've seen programs with side effects printing out moo or quack or raar on the screen technically programs can also return sort of secretly numbers and those numbers are useful usually to the programmers or to the computer to signal more methodically whether something succeeded or failed so case in point um if you've been using Zoom sometimes when things are wrong you might see weird Zoom error message like this like an error code 1132 that means nothing to the lay person but odds are there's one or more employees at Zoom that know oh shoot they're seeing error code 1132 that is because we wrote code that returns this value in certain situations that indicate failure um this is a little different but more of us are probably familiar with other numbers in the real world like 404 whereby you go to a web page where the file the URL is wrong the file's been deleted you're in the wrong place 404 is similarly a number that to a computer indicates what has gone wrong because some human decided 404 shall mean file not found for instance so it's a little different from C code but same idea numbers are used to standardize what can go wrong in programs so if we look back at C here is the way we defined C most re uh main most recently and we're now taking command line arguments it turns out though that as before main still and should always be returning an integer even though we've done nothing with it even if you don't have command line arguments so in fact we can take a step backwards there and consider exactly what this int does for us let me go back to VSS code shrink down my terminal and close our old example let's make one final program here called status. C because these integers are called status codes for instance let's do this int oh sorry include cs50.h include standard i.h int Main and I'll stick with void because I'm not I'm we're sort of done with uh command line Arguments for now no we're not uh we will do int main uh int main then int ARG C string arv with square brackets and now let's actually use exit statuses to indicate that something went wrong as as opposed to just printing something on the screen so I'm going to do this if ARG C does not equal two so I'm inverting the logic now instead of equaling to if it does not equal to let's go ahead and tell the user yes missing command line argument back sln but so that the computer knows that something went wrong too let's also return any number other than zero within a certain range so it turns out that one is a good place to start otherwise if all went well and I can say in fact hello comma placeholder and then plug in argv bracket name as before let's explicitly indicate to the computer that all is well and successful and return zero and even though this feels a little backwards like usually one is true or yes and zero is false or no turns out that zero means success by convention and any positive number and sometimes negative numbers means failure why is this well if everything successful like it's either successful or not but there are dozens hundreds thousands of things that you know that can go wrong in computer systems that's why we're using every number except zero to describe erroneous situations so I'm going to keep it simple and use one and zero I could use 1 132 to be like Zoom I could use 404 to be like a browser but we'll keep it simple because I want to indicate failure or success respectively unfortunately you don't see this by default if I do make status enter do/ oops SL status and then I will not provide a command line argument I'm just going to go ahead and hit enter and I'm told missing command line argument but I don't see a number one similarly if I run/ status and I type in David I see hello David but I don't see a status of zero but there is a way at your keyboard to see what the status code is and we cs50 will use for automatic grading for instance we will look at the status code with which your program executes to determine oh was this successful or not in the real world when you're automating tests to make sure the industry code works you might secretly check is it a zero is it a one is it 1132 is it 404 these status codes are very useful for automation even though practically speaking for you and me they won't be as useful dayto day but you can type this esoteric command Echo dollar sign question mark and see what the exit status was of the most recent command that you ran so for instance if I go into my terminal and again let's just rerun make step status to recompile it/ status and let's not provide a command line argument enter I see the error but if I now type this command Echo dollar sign question mark enter I should see one because that is what I returned if by contrast let's clear this I rerun uh status David enter I see hello comma David if I Echo dollar sign question mark again I now see Zero and just to emphasize the zoom a like if I do 1132 that's actually too big to be used here that would show me 1132 but really it should be a smaller number in the context of these programs but that indeed is what's going on underneath the hood so we will very often in programs and problems that's prescribed that what you should have main return this number or this other number in certain cases so that one we're sort of be doing things the conventional way and two we can also automatically detect exactly what has happened all right so let's come full circle to the last of the real world domains namely cryptography and even though the way we encrypted this is cs50 earlier it's pretty simple like we just changed every letter by one position we now all these minutes later have the ability to analyze text if a human types in something with get string you now have the tools to iterate from left and right to infer how what's the reading level of this person how do I convert this Cipher text to plain text so to speak or vice versa we have the ability now to manipulate text already now and two so how might this be useful well encryption is the process of scrambling information but in a reversible way it's sort of useless if you just scramble it and can't get the original back so encryption is meant to be reversible so here is the mental model you might have whereby your inputs and outputs as always become plain text which is the original message in English or whatever human language the cipher text is The Scrambled version thereof what's in the middle the Black Box this week is always an algorithm implemented perhaps in code but a cipher is the type of function that enciphers information from plain text to Cipher text so it's just some terms of art here but the catch with the cipher is that it must rely on a secret and so there's a secret value generally known as a key that is provided to ciphers as a second input after all if all of us were using the exact same Cipher in the exact same way we could all decipher or decrypt each other's messages if it all works the same way but not if we all choose a secet secret key like a big random number that only I and the recipient know then you guys can use the exact same algorithm but without my key you're going to be trying all day long to figure out what my key was at least so long as we pick a big random enough value so how does that work given the plain text given a key we can encipher the information to spit out that Cipher text so for instance if the input plain text is high exclamation point and the key for the sake of discussion is super simple and one what can we do well the output would be IJ exclamation point if you are using an encryption algorithm known as the Cesar Cipher so back in the day when the whole world was not really familiar with encryption algorithms yet because we're talking hundreds of years ago they didn't have to be that sophisticated because if no one else was thinking to do this you might as well just add one to all of your letters or something like that so generally it's believed that Caesar was among those who used rotational or ciphers like this whereby a becomes b b becomes C or maybe you use bigger numbers and rotate more than one place it's pretty secure if you're the only one on the planet doing it at that time meanwhile 1 plus high would give us i j exclamation point because I + 1 gives us I H + 1 gives us I and I + 1 gives us J and in this scenario numbers punctuation just gets passed through unchanged which is why I leaked the number 50 before even though this is CS was properly encrypted meanwhile if we want want to make things a little more sophisticated we could use 13 and in fact a special case of the Caesar Cipher with an input of 13 on the Internet is called rot 13 r o t13 which just means rotate the letters 13 places so adding 13 to H and I gives us u and v if you got too close to the end of the alphabet you just wrap around from Z to A and in fact that's going to be one of the challenges for this coming week's problems is to figure out if you're encrypting something with letters of the alphabet that are a little later how do you indeed wrap around around so you get back to A's and B's and C's meanwhile if we do something that's a little more compelling like you wanted to pass a note to someone in class yesterday year and you're worried about the teacher intercepting it and that message is super sensitive like I love you well you probably want to use something bigger than one maybe 13 because a teacher upon seeing this written on a sheet of paper probably isn't going to try and probably isn't going to Care to decrypt it but they could right if we're only using a relatively small key of one or 13 or 14 or 15 they could if they cared just brute force their way through it and this is actually a technical term much like in yester year sort of using a battering ram to like brute force your way into a castle door for instance Brute Force digitally means try one try two try three try four dot dot dot try all possible keys and eventually the plain text is going to pop back out if you have enough time so the world has much fancier encryption algorithms nowadays than this but we begin by using this as representative of those the math has of course gotten more sophisticated this is not a good key to use right there's this internet joke for sort of people in the know online and on Reddit like oh what's what uh rot 26 is twice as secure is rot 13 why is that funny right it's the same thing right a to a b to B right this just literally gives you the same message so don't believe everything you read for instance uh online so what about decryption well in the case of the Caesar Cipher it's just the opposite instead of adding one or adding 13 you subtract one or you subtract 13 so for instance here might be a message a little different from the one with which began whereby if we subtract one from each of those we can decrypt this so for a final flourish here and for a taste of what lies ahead for problem set two uh what happens if you subtract one from U what do you get T and then H and then I and then s and then ooh w a s t s and this was cs50 we'll see you next week [Applause] [Music]