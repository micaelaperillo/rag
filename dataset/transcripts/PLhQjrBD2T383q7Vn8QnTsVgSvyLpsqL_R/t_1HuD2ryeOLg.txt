[Music] [Applause] [Music] [Music] [Music] I'm going to show you some magic it's the real thing I mean uh it's all the real thing all right this is cs50 and this is a family weekend here at Harvard College we have lots of parents and siblings and other relatives here in the group and this is meant to be a familyfriendly lecture on artificial intelligence or AI my name is David men I am your instructor today and in cs50 for some time we have had this tradition of giving every student in the class A rubber duck like this one here whereby at the third or so week of the class we hand these out and the idea is that if students are struggling with some concept or they have some bug or mistake in their code they are encouraged to literally talk to the rubber duck and in that process of verbalizing what confusion and questions they're having invariably that proverbial light bulb tends to go off now some years ago we actually virtualized this rubber duck and implemented a software version of it whereby students for instance could open up a chat window in cs50's programming interface they could uh begin to converse with this here virtual duck I'm hoping you can help me solve a problem and then randomly once twice or three times would this duck quack back in response uh we have anecdotal evidence that this was sufficient educationally to actually prompt the student to figure out what was going wrong because they had already verbalized their confusion but much to the surprise of some of your uh these students predecessors just over a year ago did the duck literally overnight in Spring of 2023 fre start talking back to them in English and that is all because of under underlying the hood now is indeed some artificial intelligence so among our goals for today is to give you a taste of artificial intelligence and in turn cs50 itself but to also give you a sense of how this technology itself works because it's certainly not going anywhere it's only going to become all the more omnipresent most likely so hopefully at the end of today's hour you will exit here all the more of a computer person but the Talk of the Town has been specifically something called generative AI like AI as a field of computer science has been with us for decades but it really has made exponential improvements in recent months and in recent years but the focus of late has been on degenerative AI whereby we're using some form of artificial intelligence to generate stuff and that stuff might be text that stuff might be images that stuff might be video content and so much more in the years to come in fact the Tom Cruz that you saw greet us just a moment ago was not in fact the real Tom Cruz but a so-called deep fake which we introduce today's class with playfully of course but there's actually serious implications suffice it to say when it comes to information disinformation in the world but for today we'll focus really on the underlying technology and knowhow so want to make this as participatory too as we can and so over the past couple of years lots of Publications the New York Times among them uh has sort of tested people's ability to discern uh true from false reality from artificial intelligence and the New York Times for instance uh put together a sequence of images that we thought we'd share with you I'm joined by cs50's preceptor here up on stage Julia who's going to help guide us through a sequence of multiple choice problems if you will the first of which is going to be this one here two images one left one right which was generated by AI left or right and if Julia you want to switch over to our special software we'll see the votes coming in looks like 80% of you are voting at the moment for right though left is making some progress here 4% or so unsure I think that's pretty close to the right winning let's see what the correct answer is if Julia we could switch back to this the answer was indeed the one on the right and why is that who someone who voted right why did you say right feel free to just shout it out yeah why right why right it's more clear okay so it's more clear seems a little more Vivid maybe a little too good okay so a pretty good heris but still you know 20% of you got that wrong so let's try one more left or right which was generated Now by AI left or right which was generated by AI let's toggle over and see what the responses are looking like this time looks like you just switched your most confident answer here so 70% just under are voting now for the person on the left 30% person on the right about 5% still unsure if we toggle back to the two photographs unfortunately trick question both of them were generated by AI so it's getting harder already indeed and it's only going to get to say impossible before long well let's turn our attention to text because clearly that's what underlies something like cs50's own rubber duck here was a headline from The New York Times some months ago did a fourth grader write this or the new chatbot and a chat CH chatbot is just a piece of software that Converses with you textually and invariably soon via voice uh as well this test is textual and I'll read it aloud essay 1 I like to bring a yummy sandwich in a cold juice box for lunch and sometimes I'll even pack a taste treat a piece of fruit or a bag of crunchy chips as we eat we chat and laugh and catch up on each other's Day essay 2 my mother packs me a sandwich a drink fruit and a treat when I get in the lunchroom I find an empty table and sit there and eat my lunch my friends come and sit down with me so one of those was written by a fifth grader one of those was written by AI which was written by AI essay 1 or essay 2 let's see the votes as they come in so similar percentage so maybe it's roughly the same group of people for each of these votes having switched last time and now stayed in the lane about 76% essay 1 23% essay 2 fewer people are now on Shore so that's progress two two three% so still indeed progress let's go back and take a look the answer in this case was essay 1 was the AI and here too it's not necessarily obvious but I'm not sure how many fifth graders say they catch up on each other's day in middle school for instance so this two though is only going to be more of a challenge thank you to uh cs50's preceptor Julia here as we and maybe a round of applause for having choreographed that so perfectly thank you Julia so where do we begin so in cs50 in Spring of 2023 we indeed began to embrace artificial intelligence in some form we were not sure quite how we weren't quite sure how well it would work this has all been very much an experiment but chat GPT itself as you might recall only came out about 23 months ago in November of 2020 22 and how quickly the world seems to have changed already but at least in our educational context this is sort of the premise from which we begin all of cs50's work and development with AI is that Chachi PT and Bing and Claude and tools like it they're just too helpful out of the box educationally as you yourselves might have experienced they're all too willing to just hand students answers to problems which is great if they just want to get that answer but if they want to learn the material certainly if a teacher wants to assess their understanding of the material all too willing to just hand out answers rather than lead students to successful outcomes and so we actually put two years ago almost in cs-50 syllabus that it's not reasonable to use chat GPT or similar tools we can't prevent it technologically but we do um communicate both ethically and through policy that it's indeed not allowed and thus not reasonable but we do think it reasonable to use cs50's own AI based software including that virtual rubber duck in several different forms only one of which you've gleaned so glimpsed so far which indeed is designed to lead students to Solutions but indeed not hand them to them outright so we thought we'd share with you then a taste of how this duck is implemented but then in turn how artificial intelligence is making all of this work and here for more of the engineering folks in the audience the computer persons is an architectural diagram of what that cs50's team has been building over the past couple of years including cs50. which is like the central server that runs all of this it provides of course students with a very userfriendly interface including a rubber duck but we also have a local Vector database as they're called these days where we actually after every lecture convert For Better or For Worse everything that comes out of to out of my mouth to text then run it through a database of ours so that it can then be searched not only by students but in turn this underlying Ai and all of this is built on top of third party tools so we have not reinvented the wheel we have not built our own langu large language model as these things are called as we'll soon see but we're building on top of things called apis application programming interfaces which are third party services that the open AIS Googles microsofts and others Prov IDE so you can build your own tools educational in nature in our case here now as for what this looks like for instance this is just one of the views your own student uh or child can perhaps give you a better sense but this is the chat interface as students experience it in cs50 similar in spirit to chat jpt and indeed for now we do have disclaimers that it's not going to be perfect there are things called hallucinations that we on occasion might suffer from as well more on that soon but here is a representative question that a student might ask um bless your hearts but unfortunately this is about as detailed as the questions get sometime my code is not working as expected any ideas and so the duck upon seeing not only that question but the student code actually and with a wave of a hand I'll stipulate today the duck debugger or ddb doesn't just answer the question outright but responds with something like this it looks like you're trying to add two integers but there's an issue with how you're handling the input what data type does input return and how might that affect your addition so ideally behaving like a good teacher a good tutor and interactively having the Stu conversation with the student not always perfect but pretty darn good already out of the box and surely as industry progresses it's only going to get better and indeed the conversations will only get richer and more involved for students now besides our students here at in uh Cambridge besides our students um down the road in New Haven at Yale we actually have a very rich history of open courseware in cs50 where everything we do curricularly and technologically is freely available to anyone around the world teachers and students alike so to date since spring of 20 23 we have some 201,000 students and teachers already using this here duck that's averaging 35,000 prompts or questions per day a total of 9.4 million as of this morning so not only our own students here but really the world is starting to embrace these tools whether it's off the shelf like chat GPT or ducks like ours here so the overarching pedagogical goal though and the utility as our own students probably know by now is really to provide this students with 247 office hours oneon-one or duck on-one opportunities for help with the course's homework assignments and more um and to approximate really what is the Holy Grail I dare say educationally a one: one student to teacher ratio which even at a place like Harvard or Gale where we have the luxury of lots of teaching fellows or teaching assistants many of whom are students themselves we still might have in-class ratios of 1 to 6 1 to 10 1 to 20 which is great but if as you think about this as we often do even if you have just six students in a room at office hours and that office hour is indeed an hour that's like 10 minutes per student which for the struggling student has never been historically enough time necessarily for that in-person interactions and so with software now we hope to continue to leverage the exact same humans we have but allocate those same resources ideally to the students who need it and benefit from at most while allowing those students more comfortable to indeed interact virtually if they prefer um any time of the day with this duck so as for what then is powering this duck and uh similar Technologies underneath it is sort of a new term of art that you might have heard in the real world that have prompt engineering so we've got these AIS out there chat GPT among them and it's become a skill sort of a LinkedIn thing dare say For Better or For Worse uh to know prompt engineering which essentially means how to ask good questions of an AI generally in English but really in any human language it's a little bit hackish this is not really an engineering skill as much as it is just getting acclimated to what kinds of patterns of questions tend to induce the AI to respond to you better it's like being good at Google searches this is not something that's probably going to be a necessary skill before long because the software is just going to get better but in essence what prompt engineering means is that someone somewhere has at least written for the AI a system prompt a set of instructions usually in English that tell the AI how to behave what domain of information to focus on and so forth so for instance in the case of cs50 when we built our duck on top of open ai's apis we literally tell open AI this in cs50's so-called system prompt quote unquote you are a friendly and supportive teaching assistant for cs50 essentially coercing the underlying version of chat PT to behave in a cs50 specific way but our second sentence in our so-called system prompt is this you are also a rubber duck and that is enough to coer some degree of quacking or other similarly adorable Behavior but we further go on to tell the AI answer student questions only about cs50 in the field of computer science do not answer questions about unrelated topics do not provide full answers to problem set as this would violate academic honesty and then in essence we say answer this question and we copy and paste whatever the student has typed into the window their question which is generally known as a user prompt much like you might type into chat GPT so that not only does the underlying AI know what the question is it has this system prompt for additional context so that it behaves unlike the default and more like a pedagogically designed rubber duck in our case in fact let's see how we might implement this in code let me go over to uh a program I've got running on my machine here already which students know as VSS code uh Visual Studio code which is the programming environment we and lots of folks in Industry use I'm going to run a command called code chat. py and I'm going to implement the simplest of chatbots here live in a language called python that we just learned a few days ago I'm going to go ahead and say uh message equals input uh maybe something like what's your question question mark and what this line of code is doing for the the parents and siblings in the room this is what's called a variable similar in spirit to mathematics like XYZ but I'm using an English word instead input is a function like a verb that will tell the computer what to do for me in this case get input from the user and in quotes here I have the prompt or the question that I want the computer to ask of the human then I'm going to go ahead and do this print quote unquote quack quack quack so in essence this was like version one of our rubber duck and if I run this program with a command in my the bottom of my screen python of chat. and hit enter you'll see that the cursor is now waiting for me to provide my user prompt if you will uh how about what is AI question mark and that was it for sort of version one but I dare say if you'll humor me and let me just type somewhat quickly a little more advanced code that even R cs50 students this past week have not yet seen I can actually turn this into an artificially intelligent duck as well so let me clear the bottom of my window and hide that for a moment and let let me start doing a few things that I'm going to wave my hand at to some extent but I'll explain a few of the lines as we go so I'm going to first import some functionality relating to the underlying operating system I'm then going to import from a EnV a environment a function called load. NV which is just going to make it easier for me to talk to open AI without having to like log in and do a bunch of stuff that I did in advance of class already and I'm going to call that function called load. EnV right away after that I'm going to import from a live Library I already installed called open AI which they make freely available to us and anyone else I'm going to import a a feature called open AI capital O Capital AI I'm then going to create another variable called client which refers to like the software I'm writing and I'm going to set that equal to whatever that functionality that feature does for me open AI feature and I'm going to specify that the API key that I want to use is equivalent to whatever is in my operating systems environment in a special variable uh called API key which again I configured before class just saving myself the trouble of logging in with a username and password here all right what do I do next let's first Define a system prompt now in a third variable and that system prompt will be reminiscent of what we actually do in cs50 you are a friendly and supportive teaching assistant for cs50 period you are also a duck period and that's it now I'm going to go ahead and create a fourth variable called called user uh user prompt set that equal to the input function which we saw briefly earlier and I'm just going to say again what's your question question mark but now I'm going to do something whereby I'm talking to open ai's API passing to open AI my system prompt and my user prompt together so it behaves in the way I want I'm going to create another variable called chat completion set that equal to this function which is a mouthful client. chat. completion . create open parenthesis then on a new line just so it doesn't look messy on the screen I'm going to say that the messages I want to send to open AI is this list of messages for students from this past week messages is thus a named parameter but it's just a parameter to a function and the square brackets mean this is a list the list I'm going to provide has two things two python dictionaries sets of key value pairs the first is going to say a special keyword here roll colon system and then the content for this role is going to be the system prompt variable that I defined earlier so this is passing to open AI the system prompt then I'm going to pass in one more of these things where the role this time is going to be that of quote unquote user then the content of that is going to be the user prompt which the human typed in after that I'm going to specify one other named parameter which is to say the model I want to use is something called GPT 40 which is the latest and greatest version with which some of you might be familiar in the real world I know it's a mouthful but we're almost done now I'm going to go ahead and create a final variable response text to literally look at the text that comes back from open AI I'm going to set that equal to the chat completion variables choices attribute the first element therein starting at zero the message therein and the content thereof and then lastly finally I'm going to print out that response text now I don't normally write this many lines of code all at once in class uh so I'm going to cross my fingers big time now reopen my terminal window run python of chat. py I'll increase the size of my terminal just so we focus on this hopefully I made no typographical errors all right let's ask again what is AI question mark enter oh I okay some of you knew that thanks a lot okay so response text oh the last line too okay all right so that's a bug as we call it in programming let's run this again python of chaty okay what is AI question mark there we go AI or artificial intelligence refers to the simulation of human intelligence and machines that are programmed to think and learn like humans dot dot dot some other educational stuff and Quack at the end which was generated for us so thank you so suffice it to say we've spent a lot more time the whole team of cs50 spent a lot more time building the the fancier version of chaty that is cs50. a itself but that is it in essence as to how people like us are building on top of today's AIS to build very specific applications that hopefully leverage them for better instead of for worse but how did open AI make all of that possible how do these large language models chat GPT and un turn cs50's duck work well let's consider ultimately what has been getting developed over the decades now underneath the hood that defines what AI is but before we go in that direction let me propose that we look at not only generative artificial intelligence which is again the use of AI to generate content as we just did in text but specifically artificial intelligence more generally so here's where we uh take a spin through the world of AI so AI has been with us for years even though we only really started talking about it every day in the past couple of years any of us who've been using Gmail or Outlook or the like the spam filters have been getting pretty darn good it's pretty rare at least with most big mail programs nowadays where you have to manually deal with Spam it's often going into your spam folder but there isn't some human who works at Google or Microsoft who's looking at all of your email or even all of the email coming in and saying spam not spam spam that would just not be feasible nowadays so somehow AI is inferring using some kind of techniques or algorithms step-by-step instructions for solving problems what is spam and what is not it's not perfect but but hopefully it's usually correct and indeed that's the behavior we might want handwriting recognition on tablets and phones and the like this has been using AI for years because no one at Microsoft or Google knows what your specific handwriting looks like it looks similar though to other people that have trained the AI watch History the Netflix uh and other streaming services are getting pretty darn good at recommending based on things you have watched and maybe upvoted or downvoted similar shows or movies that you might want to watch as well that too has been Ai and then of course all of these voice like Siri and Alexa and Google Assistant they don't know your voice specifically but it's pretty similar to other hum voices and so they learn and figure out how to respond to not only the Google and Microsoft employees but to your and my voice as well and then of course we can actually go way back to things like the very one of the earliest arcade games which which uh some of you might have played as a kid this be here being pong it's sort of like a tennis game where two people move the paddle up down and up down and bounce the ball back and forth so it turns out that games a nice domain in which to start talking about AI because one it's fun but two it also tends to have very well- defined rules and goals like maximize your score or minimize the other person's score in fact here's another incarnation of really the same idea this was a arcade game that came out later called breakout exists in many different flavors but in this case here things are sort of flipped around there only needs to be one player and the idea is with this paddle you bounce this ball against the bricks and the bricks disappear once you break them and therefore the goal is to get rid of all of these bricks but even just based on this screenshot like odds are all of us as humans have an instinct for which way the paddle should move if the ball just left the paddle and went this way which way should the paddle be moved by the human left or right I mean obviously to the left if this thing is going to bounce or reflect off of that first brick so there's a very well-defined heris stic that even we have ingrained in us already maybe we can translate that to code and something a computer can ultimately do well the first way we'll try thinking about this actually comes from like the class before us 10 or decision trees or from strategic thinking more generally whereby you can actually draw a picture like a a tree in programming that we've seen in week five of cs50 where you have some root node where you begin and then all of these different children via which you can decide yes or no do this thing so a decision tree for something like uh the game we just saw could be drawn like this is the ball to the left of the paddle if so then go ahead and move the paddle left which is what everyone's Instinct here was but if the ball is not to the left of the pad then you should ask a second question you shouldn't just blindly move to the right cuz there's actually three scenarios here even if non obvious is the ball to the right of the paddle that too has a yes no answer if yes then obviously move the paddle to the right but if no then you should probably don't move the paddle and stay where you are so not very hard but now you can imagine especially if you're in cs50 or you're a computer person we could probably translate this to some kind of code in some language because it's very much based on conditionals if else if else so to speak so what does that do for us well uh we could translate this to pseudo code English like code that we might write in cs50 while the game is ongoing if the ball is to the left of the paddle then move the paddle left else if the ball is to the right of the pad that's a typo second bug sorry if if Ste at the ball is the right of the paddle move the paddle right else don't move the paddle so there's this perfect translation from decision trees as a concept and as a picture to the code that we've been writing over the past several weeks in any number number of languages but let's try a slightly more sophisticated game that most of us probably grew up playing on like pieces of paper and napkins and the like that of Tic-Tac toe for those unfamiliar it's a 3X3 grid you play X's or O's as two different people and the goal is to get three in a row three X's either horizontally vertically or diagonally and whoever achieves that first wins unless it's a tie well tic-tac-toe lends itself to a pretty juicy discussion of decision making because there's a lot of different ways we could play even the simp list of these games so for instance if we are considering here this board where X and O have each gone once let's consider what should happen next in particular if we translate this into a decision tree whoever's turn it is should ask themselves can I get three in a row on this turn because if yes well then they should play in the Square to get three in a row period but if they can't get three in a row on this turn they shouldn't just choose randomly they should probably answer another question for themselves like this can my opponent get three in a row on their next turn because if they can then I want to block them by playing in the Square to block the opponents three in a row but here's where things get interesting if the answer is no where do I go well if there's only one space left it's pretty obvious go there if there's two left which is better if there's three left which of those is better and the further you rewind in the game the less obvious it gets where you the human should go that said there is an algorithm for solving this problem optimally in fact I'll I'll I'll disclose now if you ever lose tic-tac-toe you are objectively bad at Tic-Tac-Toe because there is a strategy that won't guarantee that you'll win always but there is a strategy that will guarantee that you will never lose you can at least force a tie if you're not going to win so with that set up and sort of Bubble Burst perhaps let's consider how we can go about answering the question mark part of the tree especially when the game starts super early like this where does o go to play optimally well what we could do is this recognize first that with this particular game we have these inputs and outputs that can be represented mathematically more on that in just a moment but the goal of teaco then can be said to be to maximize maybe or minimize the score maybe X wants the biggest score possible or o wants the smallest score possible for instance specifically let's do this let's talk about an algorithm in Computing called Minimax and as the name implies this is all about minimizing and maximizing something which is really what tictac toe we can see is all about for instance here are two sample Boards of tictac to to on the left is one in which o has one on the right is one in which X has one and in the middle is one that's a tie doesn't matter what numbers we use but we need to agree so let me propose that if o wins we're going to call the board a negative one value if x wins it's a positive one and if no one wins it's a zero as such it stands to reason that X's goal in life now is clearly to be to maximize its score and O's goal in life is to minimize its score we could flip the numbers around it doesn't matter but we sort of reduced a fairly fun child to game now to boring mathematics if you will but in a way that we can now reason about it and quantify just how easy or hard this game is as each of X and Y Aspire of each as X and O aspire to maximize or minimize their score respectively so here then in the board is in the middle here is one little sanity check what is the value of this board on the screen per my definition a second ago I heard one I heard zero I heard minus one great we're seeing the range of answers the answer here is going to be one because I do see that X has one and I proposed earlier that it's if x has one the value of the board is a one so again if x wins it's a one if o wins it's a negative one those are the correct answers for Tic Tac Toe here too and a tie means uh zero so let's back up one step here is a board that's got only two moves left suppose now that it's O's turn where should o go now you might as a uh you know expert Tic Tac Toe player have an immediate Instinct for this but let's break it down into some decisions so if it's O's turn o can ask itself well what is the value of this board because I want it to be Nega -1 or barring that I want it to be zero well what's it going to be well if o goes in the top left hand corner what's the value of this board we're not sure yet because no one has one well if then X goes invariably in the bottom location there darn it now X has one so the value of this board way down here is by definition one there's only one way logically to get from this board to this board so we might as well by transitivity say that the value of this board is one even though it has hasn't been finished yet because we know where we're going with it so that then invites the question is this board any better so if o goes bottom middle what's the value well the only place X can go is top left and now the value of that bottom right board is actually better it's a zero because no one has one logically the value of this board might as well be considered one a zero as well because that's the only way to get from one to the other so now the decision for o is do I want value one or do I want value zero O's goal as I defined it is to minimize its score 0 is less than one so o had better go to sorry o had better go to than the bottom middle location and the value therefore of this board is ultimately going to be zero so this is to say if you play Like O just did you won't always win but you will never lose because you can choose between the right paths in the tree now the problem is even if you're on board with that algorithm let's go one step back such that there's not two places left but three unfortunately the size of this decision tree is essentially double in fact it's an exponential relationship because now there's 1 two three spaces in the board if we remove one of those and we go to four moves left the tree doubles again remove another the tree doubles again and so the initial Board of decisions that you might need to consider for tictac toe actually gets really really darn big more so than you might imagine in fact in the world of tic-tac-toe if we implement it exactly like this if the player is X for each possible move that is in a loop in cs50 speak consider every possible move calculate the score for the board and then choose the move with the highest score just like I did so this is the pseudo code for what we just walked through verbally if the player is O though for each possible move calculate the score for the board and then choose the move with the lowest score so in other words if both X and O are sort of thinking as many steps ahead as they can they can either win or force a tie and I claim never lose according to this algorithm but here's the rub how many different ways are there to play Tic-Tac-Toe you might have bored of it years ago as a kid but you surely did not play all possible versions of tic tac toe with your brother or sister growing up for instance why there are 255,000 ways to play a 3X3 grid of tic-tac-toe back and forth back and forth which means that's a really big decision tree certainly for a kid to keep in their mind let alone waste the time sort of figuring all of that out to be fair computers no problem considering 255 different 255,000 different ways to play a game they have lots of memory they have very fast processors nowadays dropping the bucket for a computer big deal for a human but what about other games that are more sophisticated than tic taac toe some of you might play chess and we'll keep chess simple if you consider only the first four pairs of move so one player goes than the other then again then again then again so four pairs of moves how many ways are there for those two humans to play the first four moves of Chess over 85 billion ways because of the various permutations on a normal chess board if you're familiar with the game of Go 266 quintilian ways to play that game there's no way with our current computers that they can possibly think that many steps ahead and then make Allah a decision tree an optimal decision so even the IBM Watsons of the world with which you might be familiar playing Jeopardy years ago and the like they were really doing their best to approximate correct answers but they were not taking all day long or all of our lifetimes to Crunch all of those numbers to get through those numbers so here really then is the motivation for actual AI everything we've talked about thus far the world called AI or they called the the computer the CPU player but it was really just code written with ifs El ifs and else to get dictate how the ball moves how the paddle moves who goes in tic-tac-toe in what order and the like it's all very deterministic but today it's really about artificial intelligence learning and figuring out on its own how to win a game when it can't possibly have enough memory or enough time to figure out deterministically the perfect answer so thus was born machine Mach learning where now we're not writing code to tell computers exactly what to do but we're really writing code that tries to teach computers how to figure out the solutions of pro to problems even if we ourselves don't know the correct answer and so machine learning is indeed about trying to get computers to learn from public from available data and in fact what we feed to them as input is training data of some sort and there's different ways we can train computers one way that we thought we'd introduce today it's called reinforcement learning and it's actually relatively simple in fact could I get one volunteer who's comfortable coming up on stage on the internet okay come on down come on over here maybe a round of applause because this is always awkward all right we have no microphone today so just talk near me what's your name Max Max and you want to say a little something about yourself hi I'm Max I'm a a senior in high school I'm here for family weekends nice well welcome come on over here and we're going to teach Max how to flip a pancake so we've got an actual pan here and we've got a fake pancake here and what I'd like Max you to do is to figure out and how to flip this pancake up so it goes up and around but stays in the pan and I will either reward or punish you so to speak by saying good or good or bad each time that was actually very good okay do more of that that was bad do less of that getting worse um didn't really flip one more try all right a round of applause thank you to Max here come on we have a little a parting gift for you here too if you would like thank you so the point here is that even though that sort of peaked early there and did really well with the first one but I was sort of rewarding and punishing Max by giving some kind of feedback like good or bad or somehow reinforcing the positive behavior and not reinforcing the bad behavior if you will so this is actually representative of what we mean by reinforcement learning and if you're a parent you've done this in some form presumably with your kids over time to get them to do more good behavior and ideally less bad behavior but how might we do this then with code well here for instance is a visualization of a researcher working in a lab with not Max this time but an actual robot and we'll see over time that the more we reward and reinforce good behavior the better even a robot controlled by software can get over time without being programmed to move up or down or left or right but just try movements and then do more of the good movements and less of the bad movements so the human is going once just to show it some good movements but there's no code here in question there's no one way to flip a pancake correctly and so the first time does worse than Max the third time still not so good fifth time not so good but it's trying different movements again and again that's 10 trials the human is now fixing things again 11 trials no getting a bit more air 15 trials still bad but if we start to fast forward to 20 trials now just another angle the same so all of these movements can be broken down into X Y and Z movements so when we say do more of that it can do more of the X more of the Y more of the Z but it's really trying to infer and now it's sort of picking up what to do more of and it seems to be repeating the good behavior such that after 50 such trials the robot is able now to do this again and again and again so that then is reinforcement learning so max you were well taught growing up it would seem for that particular exercise but let's consider now the implications of using reinforcement learning in other contexts and see if this is uh solves all problems for us well here is a very boring distillation of a game that's like a maze whereby this might be the player in yellow here the goal is to get to this green exit and then the rest of the floor may or may not be Lava whereby there could be some red lava pits that the yellow dot does not want to fall into so the best this player can do is really try randomly up down left right and when it falls into a lava pit do less of that but if it doesn't do more of that so for instance suppose that we know with the bird's eye view here where the Lava Pits are suppose that the yellow dot gets unlucky and trips into the one first so now we say don't do that and so it can use a little bit of memory as represented by this darker red line like let me not go there again that was a bad decision to make so now I have a new life just try again so the yellow dot now tries this maybe it tries this maybe it then oh falls into the same lava pit not realizing cuz it does not have the same bird's eye view of as us that it fell into a lava pit again so let's remember with a bit of memory or Ram do less of that again again again lava pit that's okay let's use a bit more memory to reinforce that bad behavior negatively again again again okay bad but we're making progress again again again and now I think the yellow dot you know just by luck might find its way to the green output and so this is a success we've now won the game but we haven't necessarily maximized our score why that was a correct solution but get there in much less moves yeah it could get there in fewer moves by going more like a straight line even though it still has to go up down left right it didn't really know need to take this circuitous route but the problem is if that you only reinforce the good behavior and then you stick to your guns you may never maximize your score by just following the path with which you're most familiar and so there's this principle actually in Computing whereby ideally this thing would know that yes this is a correct solution as per the green Recollections but what if we start exploring a a little bit nonetheless whereby each time I play this game even if I know how I can win let me just with like 5% 10% probability try a different path um this is something you can actually practice in the real world as soon as I learned about this principle in Computing I realized that oh this explains my own behavior in restaurants whereby if I go to a restaurant for the first time I choose something off the menu and I really like it I will never try anything else off of that Restaurant's menu because I liked it well enough but who knows if there's an even better dish on that menu problem is I tend to in the real world exploit knowledge I already have I really reinforce that first process of learning but I rarely explore but maybe we can find better solutions to problems by just exploring a little bit maybe we'll fail sometimes but maybe we'll get lucky too and so here in pseudo code is how we might distill this idea let's choose some Epsilon value just a variable to like 10% whatever it is to sprinkle a little bit of Randomness in here and then if a random number we choose is less than that value which will not happen often if it's so small make a random move instead of going right and following the path already traveled go up this time and see what happens else make the move with the highest value so to speak so sometimes you will fall into another lava pit but again if you do this again and again and again over time probabilistically you might in fact find a better path and if you let your mind wander for a moment and consider why tools like chat GPT are wrong sometimes maybe they're doing a little bit of exploration for just me and darn it they gave me a wrong answer as a result you can think about uh it being a little bit like that in the real world and so now if we try again sprinkling in a bit of Randomness I might very well find a path that ah as you noted gets me to the green exit all the more quickly so we can still reinforce good behaviors and punish bad behaviors but by sprinkling in a little bit of Randomness in there we can instead uh ensure that maybe over time we will find an even better solution now we can see this in other contexts as well as if we revisit breakout let me go back now to a video version thereof whereby you might think that over time the best way to play Breakout is again move the paddle left and right very deterministically like we proposed earlier with the screenshot and you will just gradually work your way through the blue then you can work your way through the green then you can work your way through the yellow and so forth but what this video is of is a computer learning by reinforcement learning what to do more of so somewhere there's a human probably giving it feedback that that was good do more of that or maybe don't do that or it can be baked into the based on the the color of these bricks and I dare say if we give more points to the top bricks and fewer points to the bottom that's equivalent to rewarding the best strategy and maybe punishing the worst strategy because you really want to get to those higher bricks first but here sort of to the surprise of the researcher if you will the AI a little creepily finds out that the best strategy is to sort of let the game play itself and you can perhaps see where this is going now it's sort of in hands-off mode it's getting all of the highest score on its own and it only would have done that if maybe a tried a few things randomly and like oh my God I found a better strategy now than just mindlessly going back and forth and forth and so this sort of exists in so many different domains not just restaurants but games in the world of these large language models and more but what we've seen thus far is that these are examples of really reinforcement learning there's got to be some point system associated with this maybe a human supervising the whole process and indeed in the context of learning anytime you have a human providing feedback whether it's the the fellow in the video of the pancakes giving feedback to the robot or someone kind of working behind the scenes at Google initially trying to teach the servers what is spam and what is not the catch with supervised learning is that there's only one of that guy and there's only a finite number of humans working at Google doing this and once the data exceeds what a human can do or wants to do we probably need to transition from supervised learning to unsupervised where we still write the code that ideally teaches the machines how to learn but we don't have to tell it constantly what is good what is bad what is correct what is incorrect heck let's let the software figure that out too and take us out for Better or For Worse of the picture Al together so what we're really transitioning to as a society now if you will is something called Deep learning which goes beyond the reinforcement learning the supervised the unsup the supervised learning that we just saw but deep learning is often grounded in what we might call these here neural networks and a neural network is really inspired by real world biology whereby governing our human neural system are all these little neurons that have some kind of physical connections to each other and somehow there's like electrical signals traveling through us such that if I think a thought that's how I know to like stick out my hand or Shake someone's hand or the like there's some kind of control system going on here so here's a picture uh pictor a rough picture of what a neuron might look like here's a pair of them being close enough to somehow communicate being computer scientist we're going to abstract this away and really just think of each such neuron as a circle and if they have a uh means of communicating we're going to draw an edge between them turning these into really mathematical grabs so these are nodes in our cs50 speak and these are edges in this case but it's still the same idea there's something communicating with something and heck we can think of this as maybe the input and this now is maybe the output we can really con uh map this biological world to the Computing world suppose you have a world of two inputs though that's fine maybe based on this put input in this input this here output can give us some answer to some question well what does this mean well let's make it more real let's shrink that down and move it at left let's come up with a a cartisian plane here with X and Y coordinates and let's assume that in this world there exist dots and those dots are either blue or they are red and it would be nice in this world to be able to predict based on the XY coordinates of some dot if it is going to be blue or red so you can imagine this representing other types of questions to which we might want answers so here's our y- axis here's our x- axis if I only have a limited amount of training data though two dots one blue one red the best I can really do is sort of of guess at what defines red versus blue in this world so maybe I can think of this neuron is representing X this neuron is representing Y and the output I want is an answer red or blue dot based on X comma y well how do I come up with this well I you know best guess maybe it's just a straight line so maybe everything to the left of this line is going to be blue in this world everything to the right is going to be red so what I really am trying to figure out here and learn here is what is like the best fit line that somehow separates the red from the blue well what I'm really trying to do then then over time is adjust this the more training data I get the more actual dots in the real world I might need to modify my best guess here and so blue is now over here so I think I want to maybe tilt this line and come up with a different slope for it and if you give me more and more dots I bet I can do better and better and sort of refine the line might not be perfect but this is pretty darn good I got most of the blue at left and most of the red at right and frankly if I want to really get it correct you're going to have to let me do more than just a straight line I'm going to need to somehow use some quadratics or something to have curly lines in there to capture this perfectly but if you see where this might be going if I've got x's and y's I'm trying to find the best fit line and what I'm trying to do is think of this as representing a neural network what I'm really trying to do is something like this can I come up with mathematically a value for a and a value for B that gives me an answer C that is either red or blue yes or no if you will well how might I do that well again not to dwell too much on sort of grade school math here or high school math but ax plus b y plus C is sort of that of a line of some sort and maybe we can just arbitrarily say that if you give me an X and A Y value and you've given me enough training data to figure out what a should be and B should be and C should be if the answer to that mathematical expression is say greater than zero I'm going to say the dot should be blue and if it's less than or equal to zero I'm going to say it should be red instead it doesn't matter it's just like Tic teoe we just have to agree how to represent these games or these questions mathematically to which we can then get a Boolean answer yes or no red or blue and so what these neural networks are really trying to do is based on lots and lots of data just plug in a whole bunch of parameters coefficients if you will of those x's and y's so that when you pass in inputs like these you get back a correct answer over here and what's funny about neural networks at least right now among Computing circles is that even the best engineers at Google Microsoft and open AI who are using neural netor Works to given your input or your question produce an answer there to Allah chat GPT even though there's Millions if not billions of numbers involved underneath the hood no computer scientist even the head engineer can point at this and say oh well this node represents such and such and this Edge is this value because of this reason it's all sort of a black box in the sense of abstraction and so because we're just throwing lots and lots of data at these things the computer is figuring out what all of these interconnection should be mathematically and what we're really just trying to do probabilistically is with high confidence spit out the right answer but even we humans don't really know how these work step by step underneath the hood and there in lies this idea of machine learning so with that said how might we apply this to some real world domains well maybe you're in meteorology and so given a humidity level and pressure the goal is to Output a rainfall prediction maybe you can do that with a neural network by feeding in your computer with a whole bunch of of sample humidity sample pressure values and historical rainfall amounts and just let it figure out how to represent that kind of pattern uh alternatively in the world of um advertising if you know how much you spent in a month and what month that is I bet if you give me enough historical data I can crunch those numbers somehow and predict what your sales are going to be based on that data not 100% correctly but probably confidently correctly most of the time well what we have then in chat GPT and what we have then in cs50 is stuck is what's called a large language model whereby the inputs to these neural networks have been like all of the content of the internet so thing Google search results and reddits and stack Overflow um dictionaries and encyclopedias and any such works that it's just been consuming as input and what these large language models are trying to do is figure out based on patterns and frequencies of text in all of those inputs well if someone asks me how are you question mark probabilistically based on all of this data I bet 99% of the time I chat PT or cs50's duck is supposed to reply good thanks how are you so not always the correct answer but probabilistically and that's why chat gppt is sometimes wrong because there might be misinformation on the internet maybe there's a bit of exploration sprinkled in randomly but it's not always going to give you the right answer but probabilistically it's going to and this stuff is truly hot off the presses in 2017 um Folks at Google um proposed what is generally now called attention which is a feature that underlies AI whereby you can sort of figure out dynamically what the relationship is between words in an English paragraph or an English text or really any human language and giving weight to words in that way has actually fed a lot of these new large language models in 2020 did open aai published its GPT model and most recently in 2022 did chat GPT itself come out and what underlies what we're talking about here is technically this big mouthful generative pre-trained Transformers whereby the purpose of these AIS is to generate stuff they've been pre-trained on like lots of publicly available data and the goal is to transform the user's input into ideally correct output and if you see where I'm going with this that's the GPT in chat GPT which itself was never meant to be like a branded product it's a little weird that GPT has entered the human vernacular but what it does is evokes exactly these ideas so here's a sample paragraph for instance uh Massachusetts is a state in the New England region of the Northeastern United States it borders on the Atlantic Ocean to the east the state's capital is dot dot dot essentially inviting us to answer now this question well historically prior to 2017 is it was actually pretty hard for machines to learn that oh this mention of Massachusetts is actually related to this mention of State why because they're pretty far apart this is in a whole new sentence and unless it knows already what Massachusetts is and technically it's a commonwealth it might not give much attention to these two words too much weight to the relationship thereof but if you train these gpts on enough data and you start to break down the input into sequences of words for instance well you might have a an array or a list of words here in cs50 speak you might be able to figure out based on your training data that if you number all of these words from like 1 to 27 or whatnot in this case you could represent them mathematically somehow as an aside the way that these large language models are representing words like Massachusetts literally is with numbers like this this is 1536 floating Point values in a vector AKA list or array that literally represents the word Massachusetts according to one of these algorithms let's take a step back and Abstract it away as little rectangles instead and use these little edges to imply that if there's a bolder edge here that implies that there's really a relationship in the training data between Massachusetts and state one of those words is giving more attention to the other as opposed to is which is maybe a thin line because there's not much going on there between Massachusetts and is as opposed to those two nouns in that case all of this input all of these vectors are fed in to large neural networks that have lots and lots of inputs far more than one and two and three the output of which ideally then is the answer to this question or a whole answer to your question and so when you ask the duck a question you ask chat jpt the question essentially the software is sort of navigating this neural network trying to find the best path through it to give you the most correct answer and ideally it's going to get it correct but it might not necessarily do it every such time and so in fact there are these things and we'll end we'll re begin known as hallucinations where sometimes chat jpt and admittedly even cs50's own duck might just make something up and tell you such very confidently um those are indeed known as hallucinations and what I thought we'd end on is a note that actually was published quite some time ago perhaps in your childhood as well from Shell Silverstein here The Homework Machine from which we have this here poem The Homework Machine or The Homework Machine most perfect Contraption that's ever been seen just put in your homework then drop in a time snap on the switch and in 10 seconds time your homework comes out clean as can be quick and clean as can be here it is 9 + 4 question mark and the answer is three three oh me I guess it's not as perfect as I thought it would be so for told decades ago what we're now here talking about but this then was cs50 this was then AI this is the URL at which you parents and siblings and others are welcome to take the course so to speak in any way feel free though to come on up with any Hells or questions that then is our class and we will see you hopefully next time [Music]