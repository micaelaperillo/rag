[Music] [Applause] [Music] [Music] [Music] all right this is cs50 uh this is week one because of course last week was week zero and this is the week where we'll actually start programming in a much more traditional way that programming language we promised called C of course we started with with this and hopefully by now with problem set one you've had a little bit of fun even if you've played with it before and the goals of scratch Beyond sort of making things feel very accessible and user friendly is really to elucidate some of the fundamental concepts that we'll see again today and really every week subsequently like functions and conditionals and loops and variables and so much more and in fact among the goals of scratch is again to kind of plant these visuals in your mind so even as today onward feels all the more like a fire hose especially when it comes to really weird cryptic textual syntax the ideas are still going to be the same so today this program hello world becomes this instead and in fact just to color code things temporarily I dare say that what I've colorcoded here in Orange which looks probably to those of you who've never programmed pretty cryptic is the equivalent of the when green flag clicked orange puzzle piece like this what remains is just one line in purple with a bit of white which is what ultimately is going to get the screen today to say hello world on the screen scen and of course we had a name for something in purple in fact if we rewind to week zero this block in purple represented what type of functionality a a function itself an action a verb that gets the computer to do something so what looked like this last week is about to look like this let's take away the color coding and focus really on what we're going to now start calling source code so this is what programmers do in the real world this is what software developers software Engineers do in the real world they write code that looks like this and clearly it's a little English like but it's not English in the way you would compose an essay or an email clearly there's some patterns and some special syntax to it that we'll highlight ultimately today the problem is though that computers of course don't understand source code they only per last week understand like zeros and ones that is it the so-called binary system so somehow we've got to get what already looks cryptic into something that looks at a glance even more cryptic the zeros and ones the computers do understand and for today's purposes just know that built into your Macs PCS and phones there is a built-in understanding of what these patterns mean maybe it means a number maybe it means a letter but today maybe it means an instruction like print something on the screen or save something or load something that is to say computers use patterns of bits not only to represent all the stuff we talked about last week numbers letters colors images sounds and all of that they also use patterns of bits to represent fundamental functionality print things play things much like those same scratch blocks but no computer scientist really unless they take out a paper pencil or write a program or use a website to convert this can sort of read this and know what's going on that's why we humans are actually going to use not machine code as it is called the zeros and ones that computers understand we are going to start writing source code and last week you already wrote source code but in the form of dragging and dropping those puzzle pieces so this too is going to be the Paradigm that sort of guides us through the entire semester problem solving programming is really about input becoming output and we'll focus today then on a certain type of input becoming output someone has to get the source code that's written in a language like C into the machine code the zeros and ones that the computer actually understands so source code today is going to be our input machine codee's going to be our output and we're going to give you today a special program called a compiler whose purpose in life is to translate one to the other and there's compilers for different languages in the world we're going to focus on one that supports today's language known as C and here as proed is the programming environment we are going to use it's tailored to cs50 which is to say we've pre-installed certain software that you might find useful during the term but for ontents and purposes the tool you will use for cs50's problem sets henceforth is a very popular industry standard tool called Visual Studio code or VSS code for short we are using a cloud-based version of it that lives at literally this URL cs50. deev you can sign into that so long as you have a free GitHub account with which you uh for which you signed up presumably already and that will give you access to not only an industry standard programming environment but again a an environment that has some cs50 specific things pre-installed and at the end of the semester or even in the middle if you so you're so inclined you can actually download for free vs code onto your Mac PC you can disconnect from the internet and you can actually program on your own computer caveat though is that you tend to hit technical support headaches in the very beginning of the term so we suggest you do that later in the term once you're already comfortable with this cloud-based environment here and here it is this is what program pramming shall look like whether we're using C now or python in a few weeks or JavaScript or SQL thereafter so here is what looked what is vs code configured as follows at the top right you'll generally have one or more tabs for code much like tabs in a browser and this is where you'll write code that looks a little something like this and in fact this is exactly the code that you saw a moment ago what vs code does among other things is it actually highlights your code for you it colorizes it in what's generally a uh in an Illuminating way so I did not choose to make this red I did not choose to make this blue and this purple the computer sort of automatically does that for you as we'll soon see to sort of draw your attention to different ideas in the program itself that all happens automatically at the bottom here you're going to use a more advanced interface today onward known as a command line interface in the form of a terminal window so you can still use your mouse or trackpad and click and drag and do things like that in this environment but you'll find and many programmers prefer uh that it's much more ient ultimately to use your keyboard more often than the mouse or the trackpad so we'll introduce you to that text based terminal window there up here at top left you'll have a file explorer so what's nice about VSS code is that not only will you have textual commands with which you'll get comfy you also have like a normal Mac or PC or phone nowadays like literally files and folders will visually appear appear to you so you can play with or manipulate them there and then lastly this is sort of like the menu the so-called activity bar that just has icons for various features including cs50's duck so in fact if you poke around you'll see ultimately a duck icon when you log in which is your own cs50 specific chat bot of which you can ask questions throughout the process so now that we've got vs code here let's go ahead and actually consider what it represents so this is generally for jargon sake a graphical user interface which means buttons and icons and menus and all of that we all take that for granted on almost any device nowadays that's abbreviated just so you know as guey GUI but built into vs code again is what's not only the terminal window by name but conceptually this is a command line interface so not a graphical user interface but a command line interface whereby there aren't icons to click on or double click on rather if you want to run a program you use the command line interface or CLI to type the name of the program that you want to run and so this will feel like a step backwards initially today because we all sort of sort of tap and point and double click at things nowadays but again it's going to give us more more power more efficiency ultimately Beyond this so with that said let's go ahead and actually use it for just a moment um during class you're welcome to follow along but suffice it to say will generally go somewhat quickly really you're going to learn how to program by way of the pro the problem sets each week um I'll introduce and focus on the concepts the ideas the sort of Primitives that will get you started but only through actually doing the problem sets is the muscle memory and practice going to come so not to worry if it doesn't all sort of Co down easily the first first time around so here is the codee that I claim is equivalent to last week's hello world program let's actually go ahead and do this in the programming environment so I'm going to go ahead and switch over to VSS code itself which is now running on my Mac here it's not just a screenshot and I'm going to go ahead and do the following to get started with programming I'm going to write literally in my terminal window the word code and I might have to give it focus by clicking down in that quadrant of the screen and then I'm going to give the name of the file that I want to code and in this case I'm going to that we call it hello.c in the world of scratch when you downloaded it you might have noticed the files are all called like sb3 or some such file extension when writing code in C you literally name the file something do c by convention but notice some other details especially if I zoom in everything I've typed thus far is lowercase there's no spaces and so this is going to be important and unfortunately computers are not forgiving and odds are one of the first stupid mistakes you'll do is misc capitalize something misspell something add too many faces or the like not to worry like in time that kind of muscle memory will come with practice so let me zoom out let me now just hit enter and you'll see at top right the code tab that I promised so I'm going to go ahead and type out this program pretty quickly because I've done it before include standard. int main void and then some curly braces as they're called and then print F quote unquote hello comma world back slend close quote semicolon all right so that's a lot but that too will come in time with practice practice but this is the exact same code that we saw just a moment ago indeed if I zoom in it's color coded just as in the screenshot and thus I have written my first program VSS code will automatically save for you but you can also hit control or command s to ensure that it's saved but notice what's happened at top left not only do you see my code over here you see a visual icon just like on a Mac or PC that yes this file now exists in your account and that too is what you're getting with VSS code for cs50 you're getting your own sort of server in the cloud it's called a container nowadays so there's some virtual dis space somewhere in the cloud a iCloud or Google Drive that's going to store all of your files and at the moment because I refreshed my account before class I only have one file in my own account what's this what's this well this is like my ID number for GitHub not really a big deal that's just randomly generated by GitHub Urban Adventure is the name of my programming environment today otherwise known as a code space this is just a GitHub thing which is again one of these cloud companies instead of choosing like random letters and numbers to uniquely identify all of our programming environments it's popular in the tech industry nowadays to just put together random English words that sometimes sound kind of cool but it's just by coincidence not something I chose yours will be different all right so like I've written some code I created hello.c I typed in all of that code I confirmed visually at left that it was created I'm going to hide my file explorer henceforth just so we can focus on the code how do I actually run this program well on a Mac or PC we would be in the habit of like opening the folder and double clicking on it or on your phone you would take it out and tap on an icon but not here here we're focusing primarily on the command line interface within this whole environment so I'm actually going to have to introduce a few commands you saw already the code command which for our purposes is vs code specific that just creates a new file called hello.c in this case but I need two other commands to actually run this program the first nicely is called make and then I specify what program I want to make and then a little weirdly I have to type do/ hello but just to take a step back make hello if this is about to be my second command that I type what does that step represent perhaps given what I said just a minute or so ago that's going to translate your source code into ones and zeros perfect so make represents the compiler so to speak the program that converts source code to machine code I have to do that for now manually by running make hello now make is kind of smart and even though I'm saying make hello not make hello.c make it smart and it's going to say oh if you want to make a program called hello I'm going to assume that there is somewhere in this folder a file called hello.c so you should not type make hello.c you just type make hello and then this third command even more cryptic what might it do if this is step three of three run the machine code that's going to run the machine code it's going to tell the computer in this folder sort of the dot implies this current folder and do SL just means means something in this current folder run the program called hello so that's it like there's three steps to writing a program in C you create the file as with the code command but there are other ways to do that too and you don't even have to use VSS code you can use dozens of other alternative programs in the world you run the compiler which in this case is called make a little white lie make is not actually the compiler but more on that next week but make is going to re uh trigger compilation of this code and the last step three is to execute or run the program called hello so let me go back to vs code here and you'll see that my code is still at the top my terminal windows at the bottom I hid my file explorer just because it's not that interesting anymore and I'm going to do what you proposed which was m- a k space hello all lowercase enter and ironically thankfully nothing happened and that's actually a good thing in this environment if nothing seems to happen like you probably did good if anything does seem to happen on the screen you probably screwed up and you've made some mistake so seeing nothing is generally a good thing but what has happened well let me actually go back and open up my file explorer and notice there's not only hello.c but there's a second file now hello which is the name of the program so hello is the program I want to run I'm going to go back to my terminal here and to run this program I'm going to dohe I'm going to cross my fingers as I often now do and voila my very first program in C how else can we see this file well down here in my terminal window let me zoom in you keep seeing a dollar sign that has nothing to do with currency it's just a weird geeky convention that you're prompt at a terminal window like where you type commands generally starts with a dollar sign sometimes it's a hash symbol sometimes it's an angled bracket depends on the system you're on but dollar sign is very common it just means type your commands here well I've typed code I've typed make and I've typed do/ hello but I can type other things too and more on these later like LS which doesn't actually spell something but is short for list l i St programmers tend to just be as succinct as they can so most commands are not full words they're often uh abbreviations if I hit enter now you'll see also two things you'll see hello.c and you'll see in green just to draw attention to it hello as well the asterisk here just means in the con in the programming environment this program is executable like you can actually run this by doing do/ hello the fact that this is just white here that just means it's some text file it's in fact source code so in other words LS list the file in my current folder or you can use your human eyes in the file explorer at top left and just look at what files exist these are one and the same one is a guey one is a CLI graphical command line and so forth and we'll start to take these kinds of uh ex these kinds of Paradigm soon for granted but let me pause here and see thus far now that we've written our first of many C programs any questions or confusion we can clear up it's okay if you don't understand most of the lines of code that's what today is about yeah I don't really understand the difference between hello and hello. what's the difference between hello and hello.c so hello.c is literally my source code it is a file that exists somewhere in the cloud that contains all of the code I myself wrote the hello file is the file that the compiler created for me by converting the source code to the machine code so inside of hello theoretically is a whole bunch of zeros and ones we can't quite see them but if I do this let me zoom out let me click on hello and notice that VSS code's going to yell at me this file uh the file is not displayed in the text editor because it is either binary that is zeros and ones or uses an unsupported text encoding whatever that means if I do open it anyway but I don't recommend this like Heed These Warnings you won't see zeros and ones but you will see sort of nonsense and this is because vs code is trying to interpret those zeros and ones incorrectly as asky text like English text but it's not they're instructions for the computer so as soon as you see scary red stuff like this like undo close whatever tab you open because odds are you can only break the program you just created it's not a huge deal you can recreate it but that's what's inside of those files yeah hello really good question what if we don't type uhhello we just type hello well let me do this let me hide my file explorer again cuz it's not that interesting here on out I'm going to clear my terminal window by hitting contr L just to be neat and tidy in class or you can literally type clear and it will clear it but again that's just to keep things tidy your TFS might do that in section two if I just type hello enter I'm going to get this weirdly bash hello command not found so more on bash down the line but this just means literally the command hello is not found because you need to tell the computer where it is sotello means run the hello program that is in fact right here by contrast you don't run slash for code for make or other commands that we'll soon see like LS because why those are installed in the system for everyone not just in your individual folder so that's the difference any programs we write it'll be do SL something all right so let's tease apart what is actually going on here and see if we can lean heavily today on scratch especially as the syntax gets weird perhaps a little overwhelming still the same idea so this last time of course was our scratch program that just said hello world I claim today that this is the nearest equivalent that a any programmer could convert scratch into C if we color code it accordingly inde D this sort of lines up with when green flag clicked is the orange and then the purple is just the equivalent of the say block so the say block we said earlier was a function so let's compare these things side by side because there's actually some rhyme and reason to what MIT did with scratch as to why these shapes look like they do um and so forth so in scratch there's a function called say recall that it takes an input otherwise known as an argument or a parameter is another name and that's always provided in these white ovals one or zero or more white ovals in C we've already seen but let's do it a little more pedantically the equivalent of say is essentially the word print why did MIT say you say just because it's a little more kid-friendly but print is the idea in our environment it's actually not print it's print F because we're going to be able to format our text in interesting ways more on that in a moment but notice the opening parentheses and closing parentheses here sort of conjure up the idea of that white oval so that's kind of intentional on mat's part what though in C goes between these parentheses well literally the input or the argument you want to pass to the function like hello world but in C you have to be a little more pedantic because you don't have a nice little graphic like this purple block with the white oval you have to surround everything in double quotes those of you with prior programming experience in see you need double quotes not single quotes in this context and then there's this Arcane detail here back sln which we'll come back to in just a moment but that's essentially what's going on line by line from scratch to C there's kind of an equality between those two even though they of course look a little bit different well let's see what that backs slash n is doing just to highlight some details here so let me actually zoom in a little bit here and let me go up to my code and let me just sort of recklessly delete the back sln I'm going to let it autosave I'll zoom out in my terminal window now I'm going to run uh make hello to recompile the code from source code to machine code cuz I changed the source code nothing seems to happen that's good now I'm going to type do/ hello enter and there's a subtle bug since I made that change what looks wrong to your eye nowar sign yeah the dollar sign our so-called prompt is at the end of the line instead of on its new line I mean this isn't really a deal breaker like the code works and you can still type a new command but it just looks a little stupid like this was not the intent of the program it's sort of good practice to move the prompt to the next line and that's because the back sln is what we're going to call an escape sequence so it turns out in programming you you don't NE you have to tell the computer exactly what you want it to do so if you want a new line the equivalent of hitting enter on the screen you have to tell the computer to put a new line there what you do not do is this if I zoom out and I go into my code here and I'll zoom in on the code if you want to put a new line you don't do this why it's just confusing for the computer like wait a minute is that a typo did your lines just wrap do you want to put a new line there it just looks stupid and it makes it less line based the code itself so humans decided years ago if you want an actual line break don't just naively hit the enter key literally tell the computer put a new line here if you want to move two lines down just do two of those if you want three just do three of those well why the backslash again these are what are called Escape sequences and you don't literally want an N let alone nnn what you want is a new line which is represented in code AS simply back sln now for the mathematicians among you like what we're doing now by writing using functions like print f is just sort of like f ofx notation if you recall that from high school or prior where f is a function X is an argument or an input there to and we're using parentheses in code just like mathematicians would to write functions like these and the types of functions we're using right now still follow this model you've got input you want output in this case the input to print f for instance just like the say block is what's called an argument um the output though of the function printf is what we called a side effect and the easiest way to think about that is a side effect is just something that sort of like happens on the screen visually AUD it just sort of happens and there's that effect on the screen and we'll contrast this with other types of outputs from functions but for now we're focusing on just this which is reminiscent of course of what we did last week which is if you type hello world into the white oval use the say puzzle piece you get out the side effect of the cat appearing to have said hello world now as for those Escape sequences in C there's Bunches of them but very few of them will we actually use in practice back slash in is a new line back SLR is a little more subtle and it's kind of a feature of yester year it moves the cursor not to the new line but to the beginning of the line kind of like an old timey typewriter if you've seen how those work sometimes though you might want to print out an actual double quote but there's a problem of course if this is my code here and I'm already using double quotes as sort of special symbols to surround the text I want printf to say it would probably be a little word like if you wanted to say hello world with sort of finger quotes why might this not be a good idea if you think about this from the computer's perspective like why is this probably not the right way to do this yeah yeah exactly the computer is inde going to read your code top to bottom left to right and when it sees the first open quote okay that's fine it understands that but when it gets to the second quote it's going to assume oh wait a minute maybe you only want me to say hello comma and then it's going to keep reading and be like wait a minute why is there the word world here and then wait a minute now there's two more quotes it's just confusing it's ambiguous and computers need you to be again very precise so if you want a quotation mark to literally be displayed on the screen you would Escape so to speak which looks a little weird and takes some getting into the habit of but this just solves that kind of problem and similarly might you use single quotes in other contexts more on that soon and if you really want to bend your mind how do you actually print a literal backslash if you ever care to it's not that common a character to type but if you ever want it on the screen it seems that we're using backslash as a special character that says hey give me a new line or give me a carriage return or give me a double quote weirdly in programming if you want to type a literal backslash on the the screen you literally do backs slash backs slash but that's it for sort of weirdness for now but this is to say humans tripped over the same problems years ago they came up with Solutions and now we indeed have these conventions in code all right so let's tease apart some other features of this in every program we're going to write namely what's at the top of this file so at the very top of this file there is this cryptic Looking hash include uh or pound include standard i.h in angle bracket so this is a little weird we'll talk more about this next week too but this is what's called a header file any file that ends inh is not a um Source well any file that ends inh is what we're going to call a header file and inside of that header file is functionality that maybe came with the system came with the programming language itself so for instance I'm going to do this I'm going to go back to my code here and I'm going to make a very common mistake that you yourselves might make in the coming days where I just forget that line because I don't even understand it in the first place so I certainly didn't think to type it here now if I go back to my terminal window after clearing it and I run make hello because I want to recompile it because I've changed the source code I'm going to see a fairly cryptic error I mean there's more error on the screen than there is code up here but you'll get the hang of sort of reading it to try to figure out what's going on and I'm seeing this hello.c line three character five so that just means line three colon uh character five from left to right it's sort of a visual cue as to to where the problem is call to Undeclared Library function print f with type dot dot dot and then the rest kind of overwhelms me visually at this point but that's a hint if you do not include that header file at the top of the code you've written you do not have access what's gen to what's generally called a library a library is a collection of code that someone else wrote for you maybe it was MIT maybe it was the authors of the C language itself years ago maybe it was cs50 if we wrote some code for you library is a collection of code that someone else wrote for you and you access It Again by including header files that those same people wrote for you so if I go back to my code now let me clear my terminal window just to be less overwhelmed let me undo what I just did and put that file back can you perhaps infer just functionally what is inside of standard i.h that again someone else wrote what must be inside print F so some whoever invent printf decades ago probably put that code in this file and so by including it so to speak in my code I now have access to printf functionality so that's all and again C is lower level than scratch it's obviously text based which means you have to be a little more pedantic yourself as to what you want the computer to do for you and if you want to use someone else's code you indeed have to include it scratch didn't bother with this but we indeed do need to do this in the context of c um as an aside just to preempt some unnecessary headaches this word is not studio. every year a nonzero number of people um can't understand why their code's not working because studio. is not found it's standard IO stdio.h that's one one of the first frequently uh made mistakes otherwise all right so remember that let me undo now the unnecessary quotes I added here and let me propose that we show you where you can learn more so all of these libraries generally are document M like people wrote instructions for how to use them so you don't just have to listen and pay attention only in class you don't have to pull up a book there tends to be online documentation as well for instance for the standard IO header file and the documentation in the world of programming for C specifically are called manual pages or Man pages for short unfortunately they're really written decades ago for like the more comfortable among you those who have an I already for programming and so what cs50 has done at this URL manual. cs50. is essentially have more userfriendly versions of the documentation for this header file and others so for instance if I pull up manual. cs50. you'll see a web page like this and if I just scroll quickly you'll see a whole bunch of header filesh files and a whole bunch of functions beneath them and there's only a couple of dozen or so here and indeed per this checkbox at the top frequently used in cs50 we have sort of highlighted the functions that odds are over the next month and a half like you will probably want to to use if I turn off that less comfortable mode there's actually hundreds of functions that come with c and like no programmer knows all of these functions what they do is they read the manual when they want to find some new piece of functionality so I'm going to simplify this I'm going to scroll down though to standard i.h for instance here and you'll see more functions that we'll eventually get to but if I click on print F you'll see hopefully some fairly uh userfriendly instructions for how this thing works for instance under synop you'll see that we tell you what header file you should include in order to use it below that is something called a prototype more on that later but below that is a description and here is where we the cs50 staff have written in Lay person's terms explanations of how this function Works how to use it and so forth but if you'd rather see what the uh real world uses you can turn off that mode and you'll see much more arcely the original language so in short these are sort of like training wheels that you can turn on and off at your uh Leisure But ultimately is real world documentation as well so if we want to see something else for instance let me go back to the main menu and as we'll see today there are actually functions in a header file called cs50.h that for a few few weeks we're going to lean on heavily long story short it's actually kind of hard it's annoying in see to get user input ironically to like get the human to type in a word or a number like you have to kind of jump through some technical Hoops to make that happen and we'll show you how to do it like the real way in a few weeks but for now among the first training wheels is a cs50 library code that we wrote that will just make your life easier and indeed we're going to give you access to functions that simplify the process of actually getting input from the user so case in point we're going to give you access to uh functions like get string when you want to get a string of text from the user string is just text so if you want to get one character one word one sentence one paragraph you can call a function called get string we're going to give you another one called get int when you want to get an integer from the user like one or zero or negative 1 or anything else you can use that function as well and we'll see today too there's other functions you can use from cs50's library in a few weeks time we'll take these away once you sort of don't need them anymore and you'll see what those Library functions have been doing all along for you but for now let's focus on this perhaps the most useful of them get string and solve a problem that we did already pretty easily in scratch so recall in scratch this was a program that use two functions uh three in fact ask to ask a question of the user say to actually display something on the screen and join to combine the default of apple banana or in this case hello and whatever the human's answer was so this made our hello program a little more interactive last time how can we actually translate this into a similar Paradigm now so input and output as the story as always in this case we have arguments going into those functions but now we're going to introduce not side effects which is stuff stuff that happens visually we're going to revisit that blue circle called answer or the blue oval called answer that represented last week what we called a return value and this is what many functions will actually do for us they're not just going to display something presumptuously on the screen or play a sound or a video or something like that they're going to hand you back virtually a value text or integers or sounds or images that you can then do with what you see fit so the Paradigm we'll now have is much like in scratch if the input is what's your name and the function is ask and you get back a return value of answer we want to actually do this now and see so side by side what code like this in scratch is going to look like today onward is this instead of using the ask block you literally use cs50's function called get string it takes input so we put the parentheses on the left and the right to kind of conjure the idea of this white oval inside of that string you can put a prompt so to speak like what do you want the human to be asked in this case and I'm missing something still per the placeholders here what's missing so quotation marks so literally quotation marks on the left and the right and I'm going to be a little anal here I'm going to put a space at the end because I don't want to I could but I don't want the cursor to go to the next line hence no back slash n if I want the cursor just to sit there kind of blinking waiting for the user after the question mark I'm just going to put a space so it will stay there for me but this is just an aesthetic detail using the same idea as before so that that is the analog of this block but how do I get access to the so-called return value MIT just plopped it on the screen for us automatically in C we have to write a little more code to get access to that return value and the way we do this is on the left hand side of this line of code we come up with a name for the V for the return value you can call it anything you want but answer is a nice equivalent to what MIT did you could more generically call it X or Y or Z but that's not really useful and so um computer scientists unlike mathematicians will tend to use variables are a little more verbose like the word answer but in C it's again a little lower level you have to tell the computer what type of variable this is going to be so I'm kind of conflating variable and return value but they're being used in an intertwined way the get string function just like the ask block returns a value if you want to do something with it you need to put it in something called a variable which is denoted in text here but again per last week the computer doesn't know if it's looking at numbers or characters or images or sounds you have to tell it as the programmer that the zeros and ones that are somehow involved here underneath the computer's hood are in fact to be treated as text AKA string now there's one stupid subtlety still missing from this line of code does anyone know especially if you programmed okay all of you have programmed before yes sem semicolon so one of the headaches of C in a lot of languages is you actually have to finish your thought explicitly so the computer knows knows that that line of code is done and it's not a period like in English it's in fact a semicolon now you don't use these everywhere we'll see where you use them but that too is a very common mistake to overlook something simple but again in the coming weeks even though this might look very cryptic with muscle memory and practice you'll start to see these things instantly even if for a few days you sort of bang your head against the the screen so to speak not seeing what um the TFS and I much more readily see so let's go ahead and do this let me go back over to vs code here let me zoom in just a little bit and let me go ahead and do this I'm going to get rid of my single use of printf and I'm going to say the exact same thing string answer equals get string quote unquote uh what's your name question mark space close quote semicolon and now I want to print out that answer well let me do this incorrectly deliberately for the moment let me just say print F quote unquote hello answer if I want to plug in answer and I want to add a new line at the end semicolon so let me try this but there's multiple mistakes now in my code let's trip over them deliberately let me go down to my terminal window by clicking at the bottom of the screen let me run make hello again enter and oh my God there's even more errors now than there were before but not a problem let me click on this little triangle here which is just going to zoom in on the terminal window so it takes up my full screen and just generally all you have to do is find a few keywords visually that give you a clue as to what's going on or as before you can always ask the cs50 duck so here's the command I ran make hello somehow that induced all of these errors always read them top to bottom not bottom up so from top to bottom there's a problem on line five character five use of Undeclared identifier string did I mean standard in no no no I didn't there and then also like two errors generated too many errors are remitted what did I do wrong well it turns out what I do need to do at the top of this file let me click the triangle to zoom back out if I want to use the get string function to get a string I actually need to include another header file which is probably called include cs50.h technically any order is fine I tend to alphabetize because I just know therefore where to look alphabetically for a certain header file now that that's in place let me again run make hello enter and now we're back in business no error message so even though you might have more errors than you have code odds are it's just the computer confused and it could be something simple and an easy fix like that so just to be clear standard i.h because I'm including it I can use printf cs50.h I can use get string because the people who invented C and the people who invented cs50 wrote those two files so to speak respectively all right unfortunately even though the program compiles that doesn't mean it's correct it just means it's syntactically valid it's valid C code if I go ahead and run/ hello and hit enter now I'm going to be prompted for my name so I'll type it d a v d and notice there's a space to the right of the question mark as promised enter but it just says hello answer which of course is not the intent I wanted to say hello David so how can we do this well in scratch it took a couple of puzzle pieces but it was pretty straightforward if I wanted to say the combination of two phrases hello and something else I join those two and then pass that output to the input of say in C it's going to be a little different here just because it's an old language and this is how it's done still use printf because that's the same thing as say I got my parenthesis I got my semicolon good to go but inside of that this is where print f is different you want if you want to say something followed by something else in the world of C you tend to use placeholders so you don't just join things together as we will do in Python and other languages you say to the program you say to the compiler give me the word hello comma and then something else and the s s means put another string here it's sort of like leaving a placeholder in your code or a template where you'll actually plug in some values now if this is what I want to display I still use my quotes as before and I might in fact have a back sln if I want to move the cursor to the next line but this is where print f is a little different unlike say unlike uh unlike say which took one input print f is kind of like join it can take two or more inputs if you so choose you just have to separate them with a the comma so much like the join block has two ovals here that are initially white apple and banana until we dragged and dropped answer on top of it print F and really any function in C if you want to pass in multiple inputs that's fine if they're supported just separate them with commas there's no multiple parentheses there's no multiple ovals just separate them with commas and now notice a potential point of confusion what's different about this comma and this one just instinctively sort of minor detail but important yeah inside and outside so one is inside one is outside so the one that's inside the quotes is literally the English grammatical comma that you want the human to see the one out here is a c thing that's separating the first input to this function printf from the second strictly speaking you don't need a space there but it's a good practice stylistically to separate your arguments with single spaces just as I've done there so let me go ahead and now do something with this let me go back to my C code here I'm going to clear my terminal window just to get rid of that distraction and now I'm going to change answer to percent s and then outside of the double quotes on line seven I'm going to do comma answer and then after it auto saves I'm going to go back to my terminal window and just to make another deliberate mistake /hello enter what's your name David enter it's still broken but why I still have to recompile it so again you just get into the Habit when you change your code you have to recompile so you get new machine code in the file hello so let's do it again make hello no errors is good /hello enter what's your name again DAV ID and now hello comma David so again a lot of this is still cryptic but it's going to start to follow patterns like this functions like in math class f ofx are written function name parenthesis input comma input comma input however many you have they're going to follow these patterns but notice too on line six and seven I have finished each of my thoughts with a semicolon so what are the other commands that you can run in your terminal window besides something like LS well it turns out there's a whole bunch of them LS of course was simply short for list which shows you the files in your current folder but there's also CD for change directory which is the command equivalent of like double clicking on a folder to open it up in a graphical environment there CP which is short for copy which allows you to make a copy of a file or folder there's make dur mkdir which is short for make directory which is how you could make a new folder there's MV which is short for move which would allow you to move one file or folder from one place to another or simply rename one of those to a different name there's RM which is short for remove and there's RM dur which is short for remove directory so in fact let's play around with a couple of these let me go back to VSS code here let me go ahead and open up my file explorer and recall that at this point I've got two files hello.c which contains my source code and then hello which contains my machine code the executable program that I previously generated by running make well let me go ahead and propose that I'd like to prepare to keep all of my files and folders very orderly so if like for every program I write or for every problem on a problem set I write maybe I want to store my relevant files in a specific folder for that problem so suppose then that I want to put hello.c in a folder otherwise known as a directory called hello well I can't do that quite yet because I already have a program called hello so let me use one of those new commands RM space hello will delete or remove hello from my current directory so I'm going to hit enter I'm going to be prompted to confirm with y for yes or n for no remove regular file hello I'm going to hit Y and enter and as I hit enter watch the top left of my screen as the hello file would seem to disappear voila it's now gone so now I'm going to go ahead and use a different command let me go ahead and do MK dur for make directory and going to call the directory itself hello and watch again at top left what happens enter now I have not a file but a folder called hello and in this gooey the fact that it's a folder is indicated one by its icon and two by that little right-facing triangle which means I can expand it to see what's inside and in fact if I do that I'll see of course that nothing's in it because we literally just created it all right well what if I want to move hello.c into the new hello folder well I could just like on Mac OS or Windows I could actually in my file explorer click and drag one into the other but let's do this entirely within the terminal window so let me do this let me move or mvy for short my file called hello.c into a new destination folder hello and I can optionally put a slash at the end of hello just to make super clear that it's a directory but that's not strictly necessary but if I say MV hello.c hello with spaces in between assuming hello exists as a folder Watch What Happens at top left now it's a little more subtle but hello.c is going to move inside of the hello folder right now and indeed it's only slightly more indented but notice if I Collapse the hello folder notice that it seems to be gone because hello.c is now inside of that folder of course if I expand that I'll see it again if I go back to my terminal window and type LS for list now I don't see hello.c and I don't see an executable program anymore but I do see Hello in the slash there just Mak super clear to me the user that it's indeed a folder so how do I change into that folder well I can obviously use the graphical interface at left and click and expand and sort of see what's going on but there's no direct connection between the file explorer at top left and my terminal window at bottom right rather those are just two different ways to explore the underlying system so if I want to change my terminal window into this new directory I can do CD for change directory hello and then enter and now notice my terminal Windows prompt changes slightly there's still a dollar sign which indicates type my commands here but before that dollar sign just so that I have a reminder sort of breadcrumbs that visually remind me what folder I am now in I see that I'm inside of hello if I now type LS I should see the file I expect to be in there which is indeed hello.c now suppose I want to try out some of those other commands and suppose I want to maybe uh rename this file I really want this file to be called something else so maybe I might do something like this MV hello.c space and now a new name for the file well maybe I want to make uh save this as like an old version of my code because I wanted to start fresh with something new so I could do something like this MV hello.c old. C and Watch What Happens at top left hello.c of course gets renamed via the move command so I can use move to move a file into a folder or I can use it to rename a file or folder as I've just done here now suppose I want to undo that well I can't just type undo I can't just hit control C but I can do the opposite in effect MV old. c hello. c will now per top left change it back into that file if I want to make a copy of this file maybe as an actual backup because I'm really happy with this version and I'm worried about breaking it well I could do CP for short I can then do hello.c and then I can do something like backup. C or any other file name I'm taking care to use the same file extension so that if I do open this file later it still opens and gets highlighted and colorized in the same way but Watch What Happens now at top left when I type enter I now have two files in this hello folder and indeed if I type LS now I can see exactly the same so long story short there's this whole list of commands and even more than these that allow you to manipulate the underlying system in exactly the same way that you and I have probably done for years by using a mouse and pointing and clicking and double clicking but for now let's undo all of this because I haven't really written that many programs today and I'm going to keep things simple today and keep everything in my same folder so let's undo all of this let me go ahead and now remove backup C because I don't particularly care about that I'm going to be prompted to confirm as much then let me go ahead and move hello. C out of this folder and into the original folder and conceptually the original folder is what we would call the parent folder the folder that contains this hello folder and the way you can specify the parent folder like back up from Once you came is with dot dot so a single dot as we've actually seen do/ Hello do/ a.out means execute a program in this directory dot but dot dot refers to your Parent Directory so Watch What Happens at top left when I move this hello.c file out of this folder it shifts a little bit to the left to indicate that it's no longer in that folder I'm going to go ahead and type CD do dot which will bring me back to my parent folder or even more useful especially if you get confused or lost somewhere within your folders you can actually just type CD and nothing and that will whisk you back to that original folder no matter where you you are so it's a nice shortcut and it's a nice way of undoing any confusion you might have caused for yourself lastly let's go ahead and get rid of the hello directory with RM dur hello enter and that now disappears at top left as well now what I was hinting at here whereby I had my uh hello.c file in a folder and I was moving things around and renaming things and backing things up isn't strictly necessary because there's actually other features still inside of vs code that you're welcome and encouraged to play around with in fact if if I go to my so-called timeline at the bottom of my file explorer here you can actually see that there's been automatic backups made over time of this file so if you click click click through those backups you can actually see different versions of the same file slightly in the past which might save you the trouble of having to manually create files and in fact in the world of software development in Industry there's actually standard tools very similar in spirit to what we've been using GitHub for that allow you manually to make different versions of your code so that you can proactively keep track of all the changes you've made without manually renaming things as you might typically on your own Mac or PC all right let me clear my terminal window and ask if there are any questions uh yes over here yeah a really good question if we had something other than a string of text we had had an integer would you still use percent S no you would use something else and indeed percent I is what we're going to use and we're going to actually do that perfect segue to other types that c actually has so up until now we've been calling a string of text literally a string and this is common in many programming languages including Python and JavaScript strings in the programming world just mean text whether it's zero or more characters thereof but C does have other data types just a few of which we'll dabble with today but you'll use more over time we've already seen string for instance which is indeed a string of text but let's focus as well on like an integer as an aside there's other types too there's Boolean values like true or false there's chars which are single characters instead of full phrases or sentences there's doubles and floats which are real numbers something with a decimal point the equivalent of fractions and there's Longs which are integers but like longer integers even bigger integers than you might type by default so let's focus on an INT because so many of computer so many computer programs of course manipulate numbers in some way so what can we do with this well if we want to be able to get an integer lucky enough cs50's Library comes not just with get string but also get int so that's going to be a third function we now use in C and we need to know these what we're generally called format code so that placeholder I call before percent s is indeed for a string if we want to place a integer inside of something we're printing to the screen we are in fact going to use percent i instead so let's now actually use these building blocks get in and percent I to actually get numbers in some way to sort of solve a problem well what problem could we solve let's introduce another concept from scratch and programming more generally known as conditionals like those proverbial Forks in the road if something is true do this else maybe do this other thing so in scratch we might have had a puzzle set of puzzle pieces that looked like this if x is less than y then say or have the cat say x is less than y so sort of stupid program but it just demonstrates if we how we have two variables X and Y in the context of scratch we're comparing them with a Boolean expression we're using a conditional to then conditionally say or not say this phrase here depending on whether this a this question has a answer of true or false yes or no in C doesn't look all that different it's a little more cryptic but you say literally if you use parentheses similar to functions but confusingly by convention you put a space after the word if so you don't put spaces after function names you do put spaces after words like if and you use the parenthesis to conjure up this weird trapezoidal like shape so there's no real keys that kind of conjure that so C uses parentheses like most languages and then there's these weird curly braces which at least in English we don't use all that often but they're there on your keyboard English or otherwise and they essentially allow us to create this sort of hugging shape to the puzzle piece anything inside of those curly braces is going to be equivalent to anything inside of this yellow hug that's sort of grabbing one or more pieces inside so what do we put inside well this part is straightforward print F quote unquote X is less than y back sln semicolon so nothing new here the only bit of new code is this if construct instead what if you have an if else so a two-way fork in the road this is what that looked like in scratch same question If X is less than y then say x is less than y else say X is not less than y in C the code is going to be set up initially like this so two sets of curly braces to represent this pair of yellow bars and this pair of yellow bars and what's inside of them indented no less just like our pseudo code last week is two print FS X is less than Y X is not less than y so that's it so the only new stuff here really is now the else keyword which does not need parentheses because you're just saying else do this other thing but what if it's a three-way fork in the road and we'll stop after that here's a three-way fork in the road in scratch if x is less than y then say this else if x is greater than y say this else if x equals y then say this so this is a little more precise CU now we're handling equality not just greater than or the opposite in C it's going to look similar to before but we're adding this element here and at first glance especially if you've never program before it looks like I'm an idiot and I made a typo what looks wrong there's like two equal signs like not a typo so it turns out recall from earlier when we used the equal sign the first time around we used it in the context of getting a return value back from a function like the get string function handed me back the user's answer so unfortunately because humans decades ago decided hey let's use the equal sign to assign a return value from the right hand side of a line of code to the left hand side we sort of painted ourselves into a corner and like Oh shoot what do we do when we actually want to test for equality of two values on the left and right so what most languages including C do is use double equal sign so you can say double or equals equals or whatever but it is in fact syntactically correct what's inside of these three sets of curly braces same idea print F print F print F based on what English phrase you want to print out so this code both in scratch and C I'll claim is correct it won't run because we still need like the other stuff the the equivalent of the when green flag clicked but out of context this code is correct but there's a subtle weakness in design and we'll talk a lot about this this week and Beyond correctness just means the code does what it's supposed to do design is more subjective like how well have you WR written your argument in an English paper how well have you written your code is Design This code is not designed as well as it could be because I'm doing more work than I need to yeah and back yeah I don't need the x equals equals y but why logically exactly that's just a math thing like either X is less L than y or it's greater than y or the third and final option is they must be equal so it's subtle but why would you bother wasting time writing a line of code and expecting the computer to run a line of code that is just going to answer a question that logically you could have concluded already because if X is not less than Y and X is not greater than y then my God just print out X is equal to why because you know at that point logically it's true you don't need to waste your time or the computer's asking a third question unnecessarily in the in reality it's not a huge deal no one's going to notice in the real world on a Mac or PC that there's this extra line of code but it's a bad habit keep it simple don't write code that doesn't need to be there if logically You can conclude otherwise so in fact let's clean this up both in scratch and in see I can tighten this up so to speak use less code here less code here and honestly if only statistically the less code I write the less likely I am going to make mistakes so that to is probably a net positive overall the less writing less code is generally better than writing more code not unlike English essays too perhaps all right questions about this feature of C conditionals and this syntax yeah scenario oh a really good question and yes jumping the gun there are alternative ways to solve problems like these and the question was to summarize when when to use if else if else versus what's called a switch statement more on those another time but this is going to be true in general in programming not just c not just in scratch but every language there are going to be several dozens hundreds an infinite number of ways to solve problems among the things we're going to teach you though is indeed how to do things well or better than you might otherwise and we're going to introduce you eventually to another feature of the language that can even simplify this code too so for now let's actually use this then so let me go over to vs code again I'm going to go ahead now and clear my terminal window uh down here I'm going to ahead and close the hello. cab just so that we're going to create a new program and let's just do something a little simple using some operator so to speak and I haven't used this word by name but it turns out that there's lots of operators that come with C just like a lot of operators that came with scratch for doing assignment or less than or less than or equal to greater than greater than or equal to actually equal to not equal to now some of these are a little cryptic but there's no easily found key on your us English keyboard at least where you can do less than or equals or greater than or equals so what most programming languages do is you don't use a special symbol where there's like a an angled bracket and then a line below it you actually just use two characters so greater than or equal is literally this this less than or equal is literally this this we already saw that equals is this this and not equals is to use an exclamation point so this to is a thing in programming using the excl exclamation point pronounced bang is how you invert logically certain things so bang equals or not equals is how you would Express exactly that idea it's just a symbol on the keyboard that some human decided let's use this one to invert the idea but we're going to need one other thing for this program specifically variables which we've used already sort of because in scratch we got one for free we had that answer variable that stored the return value of the ask block but let's consider in general how you can and probably did for problem set zero use a variable of your own like keeping track of a counter or a score or the like and scratch if you want to create a variable called counter you can set it equal to some initial value like zero in C that code's going to look similar you literally just write whatever name you want to give the variable then an equal sign and then the value you want to give that variable and because the equal sign is the assignment operator it will behave essentially right to left and copy the zero into counter but this isn't enough for C remember that you the programmer have to tell the computer is this indeed a number is it a letter is it an image is it a sound you have to tell the computer that this is an integer otherwise written as int for short in C but there's one other stupid detail that's missing which is now semicolon to finish the thought here but this then is equivalent to this in s in in scratch let's do another in scratch if you wanted to increment the counter that is add one to it you could literally use this puzzle piece here and specify you want to add one in C it's going to look like this counter equals counter Plus one semicolon now at a glance this seems like a paradox of sorts like how can counter equal counter + one like I can't make that math expression true but it's not math in this case the single equal sign is assignment so this means take the current value of counter whatever it is add one to it and then copy that value from right to left into the same variable thereby changing it from one to two two to three and so forth this though is so common in programming to be able to increment or even decrement numbers by one or two or more is that you can tighten it like this this is the exact same thing a little faster to type saves you keystrokes maybe less chance for error counter plus equals 1 semicolon is the exact same idea better still this is so common in C and C++ and Java that there's a third way to do this to my comment earlier about solving problems in different ways the most canonical the most popular way is probably just to say counter plus plus semicolon which literally automatically adds one to that value only works for one if you want to do two or three or some other increment you have to use one of the other approaches but this simply does the same thing as this and if you want to invert it to negative 1 you change the plus plus to a minus minus instead so again just little things that we'll see and pick up over time invariably you'll have to look them up or check the notes or look back at the lecture slides but in time this will get familiar if you are not already uh familiar so let's consider just logically how we might implement this in code let's go back to vs code here and let me propose that we create a program called compare. C whose purpose in life is just to compare a couple of values I'm going to go ahead in proactively based on the previous chats include cs50's library from the gecko I'm going to include standard i.h from the gecko so I can use get int and printf respectively I'm going to just on faith type int main void and today we won't explain what that does more on that to come for now just assume it's like when green flag clicked but in this program let's do a couple of things let's declare an integer called X and assign it the return value of get int and let's just keep it simple let's ask the user not what's their name but what's X question mark semicolon now so that we have something to compare let's do it again but with Y int y equals get in quote unquote what's y question mark and I'm leaving again a space just visually so the cursor nudges over a bit followed by a semicolon at this point in the story My users will be prompted for X and Y respectively let's do something with those values How about if x is less than y then go ahead and print out quote unquote X is less than y back sln close quote semicolon all right and let me clode uh hide my terminal window for just a moment this is a 13 line program at the moment but really it's like five or six interesting lines the rest has been copy paste from previous programs notice a few details one I've indeed used my curly braces here and notice if you highlight lines you'll actually see little dots that can help you make sure oh there are indeed four spaces there I've been indenting just like we did last week with pseudo code strictly speaking it's not necessary but it's going to be way easier to read your code if you do at all of this white space so to speak then if you write and then submit to us as homework a program that looks sort of god- awful like this which is to make it much much harder for the human to read it for you to read it your colleagues in the real world to read it but the computer is actually not going to care in fact as an aside one of the tools we have built into VSS code for cs50 is this button at top called style 50 this is a program that we indeed wrote that will give you suggestions on how to improve the style of your code so it looks like the right way that programmers would generally write it as an aside the computer world is fraught with like religious debate so to speak as to like what code should look like and people in the real world will have really stupid arguments over how many spaces to use for indentation and what lines Cod should go on and so forth generally in the real world or in a class there's an official style guide that someone sort of autocratically declares this is how everyone should write their code so that just everyone's code in the company or course looks the same but you'll find in the real world uh reasonable people will disagree when you click style 50 it will be formatted as we ourselves recommend in cs50 and in fact let me zoom out here and this looks a little cryptic at first glance but on the left is the code that I just wrote and made a mess of by deleting all that white space on the right is the way the code should look if it is well styled so whereas correctness is all about does the code work the way it's supposed to design is about how well have you written that code is it efficient did you make good decisions style is purely aesthetic is it readable does it follow a standard can another human sort of easily skim it top to bottom left to right and understand what's going on so these green highlights are saying please add white space there and so I can actually change my code to match on the left hand side here if I realize oh my code's looking pretty ugly watch on line six at left is I hit the space bar two whoops sorry on the left 1 2 3 4 notice that the right hand side is starting to be happier with my code by getting rid of the green indicators and I can do 1 2 3 4 that fix that over here I can do 1 2 3 4 I can move this onto its own line by hitting enter and you know what if it's taking too long once you get into the habit of things you can just apply changes it will give you the suggestions automatically and we're done and on our way but for practice's sake I would get into the habit of doing things manually until it gets boring and tedious and at which point you might as well automate the process with a single click all right so let's actually run this code I'm going to go ahead and open my terminal window again and clear it for clarity I'm going to run make compare and hope that I didn't make any mistakes I don't seem to have yet do/ compare and now notice I'm prompted for X let's type one for y let's type two enter and X is less than y let's do a little sanity check so to speak let's rerun it compare what's X let's do two this time one for y and this time it said nothing so that's to be expected because I didn't have a two-way or a three-way fork in the road the only time this code should say anything is if indeed X is less than y so for those of you who might be more visual when it comes to learning here's a flowchart that represents this same exact program if you read it top to bottom you start the program with compare you are then prompted for x and y and you're asked this is X less than y and the fact that this is a diamond means this is a Boolean expression a question that the co the computer is asking itself if the answer to that question is true then quote unquote X is less than y gets printed and the program stops else if X is not less than y as in the second scenario the answer is of course false and nothing more happens but we can build out this tree so to speak by adding a bit more code so let's make it look like the second scratch example if I go back here it's not hard to just say else if X is not less than y let's say that X is not less than y back sln close quote semicolon let me now go ahead and rerun make compare enter do/ compare enter and again I'll do the second example two which is bigger and one which is smaller and this time I will see X is not less than y if then we were to look not at this flow chart but a slightly bigger one you can sort of visualize it this way everything in the left hand side of this picture is the same but if it's not true that X is less than y the answer is thus false this time we say quote unquote X is not less than y and we can do this obviously one final time just to bring the point home if I go back to my code and I even more pedantically compare these three values let me go ahead and do this so else uh I don't want an else actually so let's go ahead and do this else if x is greater than y let's then say x is greater than y in English and then finally have an else that says print FX is equal to Y close quote or rather back sln close quote semicolon so just to show this all on the screen at once this is identical now to that scratch version it's welld designed because I'm not asking the equals equals question unnecessarily if I go back to my terminal window here clear the screen run make compare enter and then do/ compare again enter what's X let's do one let's do two x is less than y let's run it again/ compare what's two and one X is greater than y once more time SL compare what's X1 what's y one and now X is equal to Y as an aside if I seem to be typing fairly fast you can actually kind of cheat with your keyboard if you go up or down you can scroll through all of the past commands that you've typed so it's actually excuse me very useful if you just hit up it'll re it will preite the previous command for you at which point you can just say enter or there's other fancy features built into this programming environment if you do dots SLS uh c m and then get kind of bored with typing out the whole English word you can hit tab for tab completion like in a web browser and it2 will autocomplete if it finds a file that starts with those letters so little efficiencies here questions then on the code here yeah sure Li a good question is there any downside you're just putting in all of the libraries like we saw in the manual pages a moment ago performance so generally speaking C is meant to be a very efficient language so much so that even though it's decades old still used omnes nowadays because it's so fast it therefore minimizes time it minimizes energy use so it's still being used heavily you would slow things down if you told the compiler by the way give me all of these other functions that I'm never going to use um so in short just don't do that because it's unnecessary but a good question other questions on what we've done here yeah in front what is it a ysc faster a ysc faster than in other languages let me answer that in more detail in week six when you'll see how much easier it is to write code in other languages because someone else is doing a lot of the work for you so as an introductory course we're sort of teaching you bottom up like how do you write code how the computer understand code eventually this kind of stuff certainly after like five six weeks of this it's going to get tedious doing some of these things we're going to switch to another language that takes away the tum and allows us to really focus on the problems to be solved once we've sort of graduated to that point yeah sure the to repeat the keyboard shortcuts you can just go up up up up up and that will go through all of your previous commands at which point you can just hit enter or you can use tab completion so you can start typing a word like code and c o d tab will finish the thought orcom tab will finish that thought just to save yourself some keystrokes and clearing the screen is control L which has no functional purpose other than keeping things neat and tidy in class so a design question so this code I dare say is correct let me zoom in a little bit here let me change the code to just do this even though we already saw from scratch that we probably shouldn't do this why should we not do this if especially I'm just more comfortable asking three separate questions like if x is less than y if x is greater than y if x equals y do this like it's a nice world to live in just ask your questions you don't have to worry about else else if else if Forks in the road you can just ask three questions but let's put a finger on why is this correct yes but not well-designed yeah and back again okay there could be cases that are potentially outside of these three because this is relatively simple math comparing numbers like we don't have to worry about that here but yes in general you might miss a scenario without using a catch all like else yeah so maybe more than one of them could be evaluated as true not going to happen here but yes you could accidentally create a situation where two things print or three things print because you didn't really think about the boundaries among these questions that you're asking again not applicable here but in general a good concern really good really what's concerning here in this example is you're slowing the computer down by wasting its time having it do work that is logically unnecessary even more so than the scratch in the first C example why suppose that I type in one for x and one for y because I wrote this code top to bottom this question's going to be asked no matter what the answer is going to be false this question's going to be asked no matter what the answer is going to be false this question's going to be asked and no matter what the qu the answer is going to be true we're okay there because we had to ask all three questions but suppose I did the first thing X is 1 Y is 2 then this first question is going to be true cuz cuz X is less than y 1 is less than two so this is going to print and yet then I'm wasting everyone's time asking hm is X greater than y even though it obviously isn't is x equal to Y it obviously isn't you're adding twice you're doing three times as much work in that particular case it's just not good design and again for those of you who think a little more visually we can actually make this picture to match here is a final flowchart for bad code bad design why because no matter what when you start the program and you want to stop the program you're going through all three of those darn questions no matter what whereas the previous flowchart got us to the stop bubble Faster by taking alternative arrows based on true or false answers so in short still correct but bad design and so again even for problem set one when we start writing C code consider not just getting the job done but how you might get the job done better uh than you might otherwise all right let's add a few other features into the mix um here we have those same data types that are supported by C let's focus for a moment on something a little simpler just chars single characters unfortunately for better for worse and see the language makes a distinction between strings of text which are generally words phrases um they can uh confusingly be single characters or even zero characters if you don't type anything in between the quotes but more on that another time but when you know from the gecko that you only want to get a A Single Character back from the user like why I for yes n for no for instance which is super common in programs you can get that using a Char n cs50's own function get Char so how might we use this well let's go back to vs code here I'm going to close compare. C and let's write a third program Al together let's call this one agree. C and this is meant to represent like terms and conditions where you have to check a box yes or no or something like that in this program I'm going to go ahead and do the following I'm going to go ahead and as before include cs50. so we've got it include standard i.h so that we've got it int main void because we have to do that for now more on that another time and now let's ask the user a question do they agree so I'm going to call get Char and then pass in a prompt of do you agree question mark with a space semicolon but as before with get string and get int those functions return a value so I want to assign that value from right to left to a variable which I could call answer again but honestly this program is so short we're just going to use the letter c which is conventional so C for Char I for INT or n for number are very common but one more thing what's still missing for my variable here the type I need to say this shall be a Char not an INT not a string a single Char all right now what do I want to do I can ask a question if C equals equals lowercase y then go ahead and print out just so we see something on the screen agreed period back sln as though they agreed to the terms and conditions else if C equals equals lowercase n Go ahead and print out for instance not agreed just so we see something on the screen so let me hide my terminal window and focus on the code there's a couple of details here that are a little interesting so one what did I do on line seven and 11 that is not consistent with what I've done before subtle so I'm using apostrophes or single quotes now instead of double quotes why it's a c thing when you're using strings you use double quotes when you use single chars you use single quotes So the argument to get Char that's still a string it's a whole sentence that I'm passing in so that is just like get in just like get string but when I get the answer back the return value and put it in this variable and I want to check what is that one Char I have to surround the Char I'm comparing against in single quotes or apostrophes both for the Y and for the N so this program is not super welld designed cuz it's not going to handle uppercase it's not going to handle weird inputs very well but let me open my terminal window make agree enter the code compiles okay/ agree do I agree let's try it y for yes okay let's try it again do/ agree n for no not agreed let's do it one more time let's very enthusiastically say yes in all caps and it just kind of ignores me but why well this is a feature of cs50's get function if you tell us you want to get a Char we're not going to tolerate a whole string of text from the user we're going to te prompt them again and again and again until they give us just one Char so what yes is three times too long so let's actually just do a single capital Y and see what happens return the program ignores me altogether so all right this is kind of a poorly designed program it's a little Annoying that we'll just ignore humans even if they type in y or n that just happens to be uppercase so let's improve this let me go ahead and add a couple more conditions else if C equals equals uppercase y then go ahead and print out agreed same as before and then down here else if C equals equals capital N then let's go ahead and print out again not agreed so this is now more correct it's still going to ignore bogus input that makes no sense if it's just like the word uh if it's a different letter altogether but this two code while correct in some sense is still poorly designed even if you've never programmed before what rubs you the wrong way about this code now be critical yeah yeah it'd be nice to just merge the lowercase and the uppercase y together the same thing for the lowercase and the uppercase and why if only because like literally lines 9 and 12 are identical lines 17 and 21 are identical and while not a huge deal you know if I go in and I change this sentence odds are over the course of my lifetime programming I'm going to forget to change this one even though I change this one or I'm going to forget to change this one and this one so you don't want the code to get out of sync potentially and you certainly don't want to repeat yourself so don't repeat yourself is a tenant of programming too if you can avoid that by somehow factoring out some commonality you should do so similar in spirit to math when you factor out variables or the like so let me tighten this up so to speak let me get rid of what we just did so that it's a little shorter as before and let me express myself with two conditions using the following syntax I want to check if C equals equals lowercase y or C equals equals uppercase y so you can actually use what's called a logical operator two vertical bars which means or and and we can do this down here or C equals equals capital N so same exact functionality but to your point we've now eliminated what like another one it was like what one before it's like eight lines of code now are gone which is eight fewer lines that I might screw up in this program less opportunity for mistakes or bugs probably a good thing so now if I run this let me open my terminal window let me run make agree enter SL agree enter do I agree capital Y now it seems to be handling both of those situations so just a little tighter as an aside we won't use it here but if you want to say and which would be nonsensical it a little confusingly is two Amper Sands means a logical and whereby the left thing has to be true and the right thing has to be true so it's two bullying Expressions at once this one makes no logical sense though because a character cannot be simultaneously lowercase and uppercase it's got to be one or the other so two vertical bars is logically correct that represents our notion here of or question no yeah would you not be able to write orog you could not write or so I'm saying or just because that's a little more normal but this is incorrect however sneak preview in the language of python you actually will literally say or among other things which gets a little more user friendly other questions on this here searching yes in back EAS is there an easier way to handle case sensitivity yes and we'll show you that next week in fact so we can combine this code to be even tighter all right let's do one final set of examples before taking a a cookie break if we could but let's go ahead and close agree. C here let me open my terminal window and let's go ahead and Implement a sort of uh virtual cat as we did last week I'm going to code up a file called cat. C and I'm going to implement this in a few different ways the first of them pretty foolish so here I'm going to include standard i.h no need for cs50. yet uh just yet in main void inside of these curly braces let's go ahead and do print f meow to get the cat to meow and then to save time I'm going to copy paste that two more times so this cat shall meow three times in total all right I'm going to go ahead and make the cat so to speak all goodcat enter and it meows three times just like our scratch cat last time I'll stipulate this is correct this is a really well implemented cat correctness wise but why is it bad design intuitively just like last week sorry I sorry say you keep repeating oh I keep repeating the code I mean I literally copied and pasted which is sort of your first obvious sign I'm probably doing something wrong if I'm copying and pasting because I'm literally repeating myself so to spoil it like odds are a loop is probably going to be our friend here and so in fact in in C we have those uh features as well so in the world of C we can Implement some of last week's same ideas in a few different ways these are a little more mechanical but suppose we want to repeat something literally three times scratch gives us a repeat a block with an input so easy C in a lot of languages it's going to be a little more mechanical and it's going to look ugly at first it will take some getting used to but it is a paradigm you will use again and again and again this will become very uh rote memory before long well the most direct translation of this scratch toe code to C is probably something that looks a little something like this whereby I initialize a variable here called I and set it equal to three that's the code equivalent in C of putting up three fingers then what I want to do is while I is greater than zero that is to say while I have at least one finger up go ahead and do the following and then once I've done that for instance say meow on the screen I want to go ahead and decrement I and then do this whole thing again now I could have called this variable counter for consistency with earlier but it turns out it's conventional when you've only got one variable involved in your code and all it's doing is something simple like counting you can go ahead and call the variable I for integer for instance but it would not be wrong to instead call I counter but notice too that in this so-called while loop as we'll start to call it there is this parenthetical and that parenthetical is actually itself a Boolean expression but unlike an if statement whereby the Boolean expression is evaluated just once and if the answer is true or yes you do that thing the Boolean expression in a while loop here in C is evaluated again and again and again every time you go through the loop to check if you should keep going through the loop so for instance if the goal at hand is to say meow well of course the comparable C function is going to be print F and I want to print out on the screen meow followed by a new line well what's going on well again I initialize I to three I then check is I greater than zero and of course it is because effectively in the computer's memory three fingers are up I go ahead and print out meow I decrement I which means to put down one of those fingers and then I check the Boolean expression again is two greater than zero of course it is so I print out meow and then I I decrement I putting down one more finger then I check the expression again is one greater than zero of course it is I print out meow and then I decrement I and now I'm down to zero I check again is a zero greater than zero well no and so the loop will automatically by the definition of how this C code Works terminate for me and proceed to any other lines if there are more lines of code that I've written so how do we actually implement this then in code and get it running well it's going to be pretty much the same idea let me go back to VSS code here I'm going to get rid of all of this copy paste and inside of my main function I'm going to do exactly what we saw in IAL 3 semicolon while I is greater than zero then go ahead and print out with print F meow back slash n and then be sure you decrement I and notice that lines eight and nine are not only indented they are inside of that while loop so to speak which means they will both happen again and again and again because what's happening in code here is those curly braces are kind of like the yellow pieces that are hugging the the um the other puzzle pieces in scratch it will keep doing this this this but every time through that Loop or cycle this Boolean expression will be checked again and again and again until the answer is false at which point the computer is going to jump to the last line and if there's nothing left that's it for the program no more to be done so same exact idea in scratch even though it's a little more mechanical so that's how we might implement this and you can think of it sort of these variables this is perhaps a little gratuitous but let's do this so if you have a variable inside of a computer's memory and that's a detail we'll get to in more detail before long you can really think of it just as like a container that stores values so for instance this clear plastic Bowl can be thought of as a variable it just stores values and right now there's obviously three stress balls in it so it represents the number three so what's really happening in code like this is we've initialized I to three which is this bowl we're then checking the question on line six is I greater than zero obviously so we proceed inside of the curly braces and we print out meow we then decrement I so for the sake of unnecessary drama like that's decrementing the variable so what's being stored in this Val this uh container now is one less we do it again check the count nope two is greater than zero so we keep going meow decrement I check the variable one is greater than zero so we print meow decrement I we check the condition again I is not greater than zero because Z is not greater than zero and so the rest of the code stops executing I'm not sure if that was any more infective than fingers on my hand but we had the bow we had the ball so same exact idea variables are just storing some value and incrementing and decrementing would just be adding or subtracting stress balls in this case but there's other ways we could do this in fact let me zoom in on my code here and it's not really conventional in programming to count down like nothing wrong with it it's just just not really a thing we would typically count up so we could alternatively do this set I equal to 1 initially so we count one to three like a normal person and we can change our condition if I'm going to count from one to three what should my comparison be in my Boolean expression here I is less than three less than or equal to three I think so if I is initialized to one we're going to go through this one time two times three times I is going to eventually get incremented to four but at that point four is not less than or equal to three so it's only going to execute a total of three times but there's still a bug in this code what other line needs to change yeah so line nine needs to become plus plus so this code is just as correct and honestly you could reasonable people will disagree your TF might say do it this way and not this way but like this is still correct but it's not the most conventional way as per last week computer scientists and programmers generally actually start counting from zero by convention for reasons we'll soon see so the better way the more conventional way arguably would be always start counting from zero count up to but not through the number you care about and so this form of the code is probably the most popular way to do it start at zero count up to three but not through three as with less than or equals than all three are correct can't really do counting up as easily with the bow without picking up the balls but the exact same logic applies and in fact this version of the code is so commonly done that there's a different way to implement it all there's a similar way to implement it all together in fact this code here same exact thing repeating three times because it's so commonly done that you want to initialize something to zero and keep doing something until like the value three you can actually use a different preposition for which is another keyword in C and it looks a little more cryptic but it just tightens things up this ex this is what's called a for Loop previous is what's called a while loop and honestly even though it probably to the Newbie still looks just as cryptic it's just a little tighter because you're expressing all of these ideas on one line you specify the variable you want to create and initialize you specify the Boolean expression you want to check again and again you specify what increment or decrements you want to happen and confusingly you do use semicolons here not commas you do not put a a semicolon here you of course don't put them after these things you generally only put them after functions thus far so we do have a one semicolon here but in short this you'll get more comfortable with this is how I for instance almost always write a loop but it's doing the exact same thing mechanically as this same thing as counting on your fingers same thing as counting the stress balls there's just different ways to express the exact same idea but there are ways to screw up so in fact let me go ahead and do this suppose that the cat we'd like the cat to live as long as as possible and we don't want it to stop meowing after just three or finite number of times how can you do something forever again and again and again well let me go back into vs code here let me delete all of the code from earlier and let me go ahead and say while something is true I'll come back to that let's just go ahead and print out meow back sln ideally forever but what do I want to put in here well if I want to do something forever I could do something kind of stupid like while one is less than two which is always going to be the case or while 50 is less than 51 which is always going to be I could just ask an arbitrary question but like arbitrary not good in general like you should have meaning behind your code so if you want the expression to be true all of the time just say while true because true is not changing anytime soon if it's literally true it's always going to be true the only caveat is to use this trick for now you will need to include the cs50 library which for today's purposes makes that possible but there's a problem of course if the cat's going to live for ever if I do make CatCat enter like you can very quickly lose control over your terminal window and you can see like the meows are flying across the screen at least based on the bottom from what we're seeing like this cat will never stop meowing and this is either a feature or a bug so to speak depending on how long the cat here should live virtually but how do you terminate a program that is out of control like this infinitely so one of the takeaways for today is uh control C is your friend for cancel or interrupt the program if you ever sort of lose control over a program because you've got intentionally or unintentionally an infinite Loop you can go into your terminal window hit control C sometimes multiple times if it's ignoring you and that will break out of the program and just essentially force quit it like in Max or PCS but let's make one Improvement here still the last thing we did with our cat in scratch before now we'll take a break in a moment was we defined our own functions and recall that we did that to abstract away the idea of meowing because scratch didn't come with a meow puzzle piece C definitely does not come with a meow function we have to implement it ourselves so quickly toward the end of week Zer we did this Define a function called meow that just plays the meow sound and now we have a meow puzzle piece we can use and reuse in C we're about to do this and this is going to look a little cryptic but it's going to lay the foundation for future weeks when we do this even more I've got a meow function weird mentions a void that just means there's no input and there's no output for this function it just does one thing simply and that one thing is print F meow so how do I use this here code here in scratch is how we used it last week when the green flag is clicked repeat three times the meow function in C it's going to look like this int made void and all of that and I can use a for Loop a while loop I'm copying and pasting the four Loop version of the code set I equal to zero make sure it stays below three incremented on each iteration or cycle and just call meow so what's nice here is that we have fairly simply a way and to create our own functions called meow or anything else that lines up perfectly with what we did in scratch we'll take some time to get comfy with the syntax and remember it have to look it up frequently for reference but let's go ahead and actually do this if I go back to vs code clear my screen uh let me hide my terminal window temporarily let me go ahead and invent this meow function um per the code earlier I'm going to go ahead and do this uh void uh meow void and again the two voids mean no input no output it just does one thing well print F quote unquote uh meow back sln and now down here I can use a for Loop so four and I know this for memory int I equal 0 I Less Than 3 I ++ and then inside of curly braces I'm going to go ahead and call the meow function notice when I'm creating the function up here I explicitly pedantically say void void no input no output when I use the function on line 13 you just say open parenthesis close parenthesis that's the equivalent of a scratch puzzle piece without a white oval you just put nothing there you don't put the word void so that's it let me open my terminal window let me run make cat to rerun to recompile cat and I think I have a working cat now this is correct the only thing I don't love about this version if I hide my terminal window is that when I start writing bigger and bigger programs it'd be nice if my main function which I told told you to sort of take on faith for today is at the top of the file if only because like literally the name main means this is the main part of my program it'd be nice if it's the first thing I see which is to say just to be pedantic it's very common to put any functions you write at the bottom of your file maybe alphabetically maybe organized some other way but you put main first by convention just like the when the green flag clicked it was the first thing you always started with last week but Watch What Happens now if I go into my terminal window and command or control J is hiding and showing it if you are curious but probably you'll just leave it open on your own all the time let me do make cat again and huh I've screwed up somehow all I did was move the meow function from top to bottom and I'm getting called to Undeclared function meow something something something well what's going on well C is pretty naive and simplistic it's only going to do what you tell it to do and it's only going to do things top to bottom left to right and unfortunately on line 8 you are telling C call a function called meow but that does not exist in cs50's header file that does not exist in standard io's header file it exists at the bottom of my file at which point it's too late because I'm trying to use it before it exists so I could just undo that and put this meow function at the top of the file but you're going to eventually get into a perverse scenario where you can't put all of your functions above all of your functions like you got to pick a lane at some point so the solution to this albe it a little weird and the one time in cs50 in programming that it is encouraged and necessary to copy paste is what you can do at the top of your code be above main is just copy paste the first line of your own function this is the so-called prototype of the function and it simply describes how to use the function and funny enough we actually saw this earlier but I sort of uh I kind of um swept it under the rug a moment ago or a bit ago when we looked at standard i.h and we looked at the print de function in the manual pages I highlighted the header file but I also glossed over the so-called prototype which is sorry the first line of the print F function just as this is the first line of my meow function this is like a little clue this is like saying to see hey there's going to be a function called meow that takes no input has no input takes no input has no output just know that it exists eventually and that will satisfy the compiler because if I go back to my terminal rerun make cat it now knows on faith per line four that function will eventually exist and indeed once it gets to the bottom of my code line 14 onward there it in fact is so you just copy the one and only first line of your functions code to the top called a prototype and now if I doat I get finally meow meow meow yet again in this case questions on these here cats no all right then the LA last flourish before I keep promising cookies and I promise they exist so last flourish like just as we did in scratch so in scratch recall that we parameterized our meow function by letting us tell meow how many times to meow so that we didn't need to use our Loop inside of our when green flag clicked Block in other words if I want to actually have the cat meow a specific number of times I can actually go ahead and do that proactively with some of my own code such as this here in scratch when I edited my Now function last week in scratch I specified that I want it now to take an input called n which represents some number of times and I changed my repeat block not to be three perpetually but to actually have n generally baked in there instead or actually instead of just saying play sound meow I had a repeat block using n as the placeholder instead of a hard-coded three so how can I now use this in C in C it's almost the same it's still void at the beginning of my function name which means no output still it only has side effects but what did change visa the previous version of meow what has changed exactly instead of saying void a second time in parentheses it literally says int n inside of those parentheses which means in C this function called meow takes input it means the exact same thing as the pink on the left and again this is why we keep emphasizing the scratch blocks like no new ideas with a lot of these features it's just different syntax that you'll get used to over time so if I go back into vs code here and I change this function let's do that let's change my prototype to be int n where n represents some number of times let's change the actual function on line 14 to also have int n here and let's actually move the for loop from Main into the meow function such that I now have my curly braces here I have my print statement inside of those curly braces and now in main I can get rid of all of that code just say meow any number of times like three and just like I did with scratch let me hit enter an arbitrary number of times sort of out of sight out of mind now the essence of my program is like one real line of code meow three times because I've abstracted away the idea of meowing and told the cat instead exactly how many times to meow by way of that function okay I can't keep stringing along cookie so long let's go ahead and take a 10-minute break here and when we come back more cat that's more code all right so we are back and want to add one final flourish to this program because now more so than a lot of the examples like now the programs are starting to grow in length and indeed soon there'll be a few dozen lines of code which is not uncommon but let's suppose that we want to startop stop hardcoding three everywhere and actually prompt the user for some number of meows here well let me do this in vs code I'm going to go ahead and get rid of this one line for now and let's do something like this let's ask the user uh for an integer so int maybe n for number equals get int and we'll say something like just number to give a number of meows and then we'll go ahead and actually call meow passing in not three this time but passing in N so we are using the return value of get int to store it in a variable called n on line 8 and then we are passing in as the input or argument to the function called meow on line n and again the actual implementation of meow on line 22 onward like who cares out of sight out of mind once it exists we can sort of abstract it away mentally but I'll keep it uptight here anyway all right so let me go ahead and open my terminal window make CatCat number I can still type in three and it works or I can go ahead and type in five meow meow meow but hm it's not actually meowing five times why I didn't realize this either but there's a bug yeah exactly so the for Loop when I copy pasted it before before break I actually kind of got lazy and I forgot to change the three to an N so that it matches the name of the argument that's being passed into meow so that was a bug unintentional on my part but we have now fixed it here and now we are passing this in from Main to Meo so if I make cat do/ cat and type five this time I indeed get five meows but it's worth noting there's some subtleties here in my code in that I've used n a couple of times so this is actually deliberate that I've used n twice in this way to induce a bit of confusion but it turns out this n is actually not the same as this n um nor this one so what's going on here well it turns out in programming there's often this idea of scope and long story short generally speaking variables only exist in the scope in which you create them more to Earth variables only exist inside of the curly braces in which you define them so for instance suppose I got a little sloppy and suppose I didn't bother giving ma meow an input and I didn't bother giving its prototype an input and I just used n on line 14 because why well I already defined n on line 8 so this is just an alter alternate universe in which I'm not changing meow to take input I'm just using n in two different functions in Main on line 8 and nine Actually I don't even need that on line 8 and nine and also again on line 14 this code will not work like the compiler will not like this why because n does not exist inside of meow why per theistic I offered n exists only inside of the curly braces in which it was defined namely these curly braces here so n is in scope in main so to speak but it is not in scope in meow and that's why we kind of have to jump through these hoops and use inputs and outputs and inputs and outputs and pass things around among functions without sort of sharing things across functions instead now I could clarify this and maybe change my argument here from n to like times if I want to make clear that oh this is the number of times I want meow to be said I don't have to use n for both but just realize that if you do it's just a coincidence they are not usable in two different Scopes all right let's do one one other thing though let's not keep uh let's not only prompt the user for the number here let's make sure that it makes sense what number they give us so if I do make cat just to clean things upcat suppose I type zero okay I I suppose that's correct if I say meow zero times and it doesn't meow at all that's arguably correct but if I type in something like neg five it ignores me which I guess is better than crashing or freezing or something but like ideally it might be nice to handle this situation and if they give me a negative number prompt them again for a positive number prompt them again for a positive number like make the program make sense so how could we do that well a couple of ways if I go back into my code here I could do this I could maybe do something like a a loop May or let's see so if I get n so if n is less than one then it makes no sense so what do I want to do if n is less than one well I could just prompt the user again and I say okay let's get n again and then I can say if n is less than one what what do I want to do I guess we could ask the user again and then if n is less than one I could just again like I can give them like three tries four tries to get this right like this is obviously stupid like I'm copying and pasting I'm repeating myself there's no end in sight like I can't do this forever surely so this just feels like the wrong solution so there are different ways to solve this problem and funny enough like a while loop is not really the best way a do while loop is damn it a while loop is not the best way a four Loop is not the best way it turns out there's one other type of loop that we want to introduce that's super useful for getting user input potentially again and again and again so that the user cooperates specifically what I'm going to do is this I'm going to literally say do the following while something is true so it's more of a mouthful it's I'm spreading it out over multiple lines but what am I going to put inside of the doe block here I'm going to say int n equals get int and ask for that number as before close quote colon and I'm going to keep asking while sorry accidental enter while n is less than one semicolon so notice the semantics of this even though it's a little weird looking it does read in English do the following okay get an in stored in n and keep doing that while n is less than one but this code AS written is not quite going to work yet let me try opening my terminal window make cat enter oh damn it like you use of Undeclared identifier n well here's where the line number is helpful the line number is indicated here 12 and it's repeated here 12 so I clearly screwed up at line 12 there's not that much going on at line 12 why is n Undeclared in line 12 even though I literally just declared it in line 10 exactly because I declared and inside the scope of the do block so to speak inside the curly braces on lines 9 and 11 that variable n no longer exists by the time we get to line 12 it'd be great if it did but it doesn't because it violates that heuristic I proposed which is that variables only exist in the scope of the curly braces in which they were defined so how do I fix this well it turns out you can declare a variable in advance outside of one scope but then Define it that is initialize it elsewhere so the solution here is actually this inside of the loop just set equal to the return value of get int but per theistic you've got to declare n make it exist inside of the outermost scope of this function so it's a little weird and we're kind of breaking this down into two steps but this is valid recommended correct C code you declare a variable without giving it any value initially and then in line 11 you proceed to give it a value potentially again and again and again now what's useful about a do while loop so a do while loop as the name implies will do something no matter what but it will potentially do it again and again and again while some question is true like n being less than one in this case all right as an aside why did we not do a while loop well let's think about that while n is less than one but wait a minute n doesn't have a value okay so I guess we have to go back to doing get int number colon semicolon okay but while n is less than one we're back to the same problem where we have to like repeat ourselves again so this is why four Loops while Loops not the right solution when you want to do something at least once but potentially again and again so the right solution here again is this new and final looping construct I'm just hitting contrl z a lot whereby we've done it as follows all right let's try this clear the screen make cat enter cat let's type in five still works let's type in negative five and notice it doesn't just ignore me it prompts again and again and again even if I type in zero I've got to at least give it a positive integer well this actually seems like kind of a common Paradigm like what if we want to prompt the user for a positive number in other programs too you know we're nearing the point already even after just week one it'd be nice to like write our own reusable functions that solve common problems and eventually me eventually maybe we can put them in header files as well but for now let's go ahead and do this I'm going to actually copy all of this code and I'm going to create one more function in this file below Main called get positive int for integer and I'm going to specify that it doesn't need any inputs because the only thing this function is going to do is that exact same thing so notice that I've just moved my code from Main into a function that's named describes what it does get positive int I'm declaring n here I'm doing this again and again and I'm doing that while n is less than one and what am I going to do up here I can do something like this give me a variable called times for How many times do you want to me and just call get positive int semicolon so now again we've abstracted things away and just like in scratch our final example which recall looked a little something like this where we just called a function to meow three times now we're calling a function to get text if I hit enter an arbitrary dramatic number of times out of sight out of mind I now have two functions in this world get positive int and meow that are collectively implementing this entire program but it's not quite correct there's one one mistake here still notice that get positive in is written slightly differently from the meow function and just to be clear too let me copy its prototype to the top of the file just so we don't make that same mistake I made earlier where I didn't put the Prototype at top so see didn't know what it was what is different about these two prototypes at a glance yeah okay so get positive in apparently and we''ve not talked much about this apparent apparently does have an output of type integer it's supposed to return an in hand me back an INT it doesn't have any input that's what the void in parentheses meant no input but yes output and meow funny enough is the opposite yes input no output why because it has a side effect the visual thing where it prints something to the screen but doesn't hand me any useful value back like the ask function or the ask puzzle piece did so these are sort of opposite in functionality which means I actually need to return an integer from this function so whatever function wants to use it so if I want the assignment operator to work here on line N I need to do what all this time get in get string and other cs50 functions have been doing I need to in my own function return that value literally with a new keyword called return and this is why I keep sticking out my hand when you want a function to like hand you back a value you literally use return and then that value that's why we have return value as a term of art literally the return keyword so if I open my terminal window now make cat enter huh I did screw up accidentally how yeah yeah so on lines nine and 10 I made a quick change I changed my variable to times but I stupidly didn't change this that's fine that's why n was Undeclared in that context Let Me Clear My terminal make cat once more okay that worked do/ cat let's type in five and it's still working so again even though the code feels like it's sorry even though the code is kind of growing and growing and growing it's the exact same program we wrote super simply before break but now we're sort of modularizing it we're creating reusable functions and this is why functions like get string exist get int exist like cs50 wrote those years ago and we realized why are we copying and pasting these functions in all of these different cs-50 programs let's factor out that functionality into a function of our own get int get string just like here I'm proposing to factor out this functionality get a positive integer that gives you even more precise functionality so theoretically you could use and reuse it in other programs too by not even just putting it here we could go put it in a file of your own name and include it in future programs as well like that's all a library is someone realized gez other people including myself might find this function useful again and again let's package it up in our own custom functions just like our custom meow puzzle piece last week so we can indeed use it again and again and the takeaways for now is that unlike scratch which was a little more userfriendly in C you have to specify if you want your functions to have inputs and you must specify if you want them to have outputs as well but more on that syntax to come so where does that bring us so after all this discussion of code like at the end of the day like this is what's important in the world of programming um not surprisingly it's like what's important when it comes to grading and evaluating the quality of code one and first and foremost is correctness like if the code does not do what it's supposed to do what was the point of writing the codes so correctness sort of goes without saying design again is much more qualitative it's like getting feedback again on an English essay or reasonable people might disagree you can make your argument better you can structure the paper better you can structure the code better in the case of programming and style is purely athetic does it look good is it pretty printed so to speak can other people colleagues future and classmates present actually read and understand it that's what we mean by style nicely enough within cs50's programming environment you will have tools to evaluate the quality of all three of these axes so to speak so in problem set one onward you'll be introduced to a command line tool that you type its name at the prompt called check 50 that will check for you the correctness of your code not necessarily exhaustively like there might be mistakes you've made that we don't catch which doesn't make your code correct but it is a tool for finding many of the mistakes in your code in the real world you would have colleagues or yourself would write tests for code you wrote or someone else wrote so like testing code is not just a grading thing it is real world thing to ensure that systems are designed correctly we saw the style 50 tool in vs code already you click the style 50 button there is now thanks to the duck a design 50 button too also in that top right hand corner whereby once your code is correct and working like several of my programs have been you can click design 50 and the duck will not just quack but give you qualitative advice if it can on how you can make that code even better even before you submit and of course there's all of us humans in the room and online that you can ask these same questions of as well so let's now solve some sort of real world but still simple problems as opposed to emphasizing small bite siiz as we have thus far so the first of these programs falls into this category it's having side effects so let's Implement one or more functions that takes an arguments inputs and as its output produces these visual side effects we'll draw inspiration from Super Mario Brothers not surprisingly perhaps here the original one which was very two-dimensional Sid scroller left to right Mario or Luigi move from left to right and have to like jump over things like pyramids or other shapes on the screen so how might we go about implementing some of the screens from Super Mario Brothers albeit textually well we'll make it a little black and white and asky art so to speak here using just our keyboard but suppose we want to write a program called mario.c that just prints out four question marks it's not going to be nearly as pretty as what's on the screen here but the logic is going to be the exact same as what Nintendo presumably did years ago so let me open vs code my terminal window let's code a program called mario.c in mario.c I'm going to kind of start with some boiler plate I know I want to print so even if I don't know how to do this yet I'm going to include standard i.h for today's purposes I'm going to copy paste or type out that same line again and again in main void and inside of my main function akin to the green flag being clicked I want to go ahead and print out four question marks well honestly the simplest way I can think of doing this is with print F question mark question mark question mark question mark maybe back SL n to move the cursor and that's it so that is arguably correct so let's do make Mario in the terminal do/ Mario and it's not quite as pretty as the game version of it but it is in fact the exact same idea but here's sort of an opportunity stepping stone to do better design like this game changes over time and not all of the screens have just four question marks it might be five six or even more so what's the right programming construct with which we could generalize how many question marks are printing here like what feature of C do we want a like a loop like a for Loop a while loop or something like that and there's different ways to do this but honestly I've proposed earlier that we get into the habit of reaching for four Loops as just very conventional so let's do that four in I equal 0 I less then four because that's how many I want for the moment i++ and then inside of my curly braces there let's go ahead and print out quote unquote a single question mark but no new line let me now go ahead and make mark iio and can you anticipate a arguably aesthetic bug when I hit enter it's not going to move the cursor to the next line but the solution here is a little nonobvious I don't think this helps me if I put the backslash n there and I do make Mario again in/ Mario what is this outbut going to look like instead yeah like a vertical column of question marks which while nice enough is not the goal at hand the goal is these horizontal ones so someone else what's the fix here if clearly putting the back slash in inside of line seven is wrong yeah so put it after the loop and not after the print F line specifically after and thus outside of the loop so that after that Loop is finished executing three total times it's totally fine to just print nothing other than a back slash n so long as we now recompile the code make Mario do/ Mario and voila now we have four in a row it's a little generalized Okay so we've have plucked off a fairly easy problem well let's go back to the world of Mario and try something that is in fact vertical like this so this is another scene with like three bricks here instead of using question marks we'll use hash symbols to represent bricks this actually is the Incarnation of my mistake a moment ago so let me undo this by getting rid of that printf let me change the inside one from a question mark to a hash symbol which looks the most similar in asky to a brick and let's go ahead and put in back sln after that if I do go ahead and do make Mario Mario it's not that interesting but and it's actually not that correct cuz I wanted three so no big deal I can of course go back to my code and change the four to a three or better yet I could use get int or my new get positive int function and just generalize this further so that I can print out any number of them but for now/ Mario gives me three all right so we've plucked off the second of two problems let's now let things escalate a bit so it turns out once you get to like world two and Beyond there's some underground part parts of Mario where you actually have bigger more solid Bricks Like These here and just by eyeballing it this is like a 3X3 grid bricks like nine of them total will conjecture so how can I go about implementing this well now is where the program gets a little more interesting and the sort of not correct well the poorly designed way to do this would be like print F hashash back sln semicolon and then maybe print F print F like that's kind of like correct but not welld designed so make Mario do Mario you know it's it doesn't look like a square just because these hashes are more vertical than they are horizontal but they it is correct this example but it's not very generalizable and this is like literally hard coding I copy paste it I'm just doing a lot of bad practices here so what could I do instead well it turns out we can combine today's ideas including Loops to do things again and again so what is this grid of bricks it's a 3X3 so that's like you know it's it's like a row and a row and a row and then within each row there's like column column column so it is like an old timey typewriter that sort of prints one line then the next line then the next line and so forth so how can we conjure that in code well let me go ahead and do this I think a print approach would work is like this for in I equals z i Less Than 3 I ++ cuz I know I want to do something three times but what do I want to do three times this Loop kind of represents in my mind's eye row row row so in fact I could be more pedantic if I want my eye to mean something Beyond int I could say row equals 0 row less than three row Plus+ just to help me think about it and then what do I want to do on each row what do I want to print like column column column so brick brick brick so how do I print three bricks or any number of bricks well I could kind of cheat and just do printf has back sln but again I can't generalize I can't take an input from the user and print four or five or six bricks so that's going to get me into trouble eventually so maybe I could use a loop so I could do like for in IAL 0 I Less Than 3 I ++ inside of my Loop and then in here I could print out one hash and that's kind of on the right direction the right path because now I'm just using the simple building block or brick but reusing it again and again and it's totally fine to have nested these columns in this way I used I out of habit but what would a better name be well maybe column or maybe just C call for short so that my code is sort of saying what it does for me and I don't have to use row or column explicitly I don't need to print them but I am using them as counters one after the other so let me go ahead and run make Mario Mario and I'm feeling good about this but damn it there's nine bricks but they're not really laid out right why what's the fix yeah yeah I never went to a new line and let me do what I think you're not going to suggest I do let me just go the obvious place all right well let's put one right after the brick but of course if I do make Mario Mario I'm making the same mistake as before I'm printing out too many new lines so in between what lines do I actually want to print a new line between yeah yeah so 10 and 11 so outside of the inner loop but inside of the outer loop so it happens again and again so let's just print out as before a single back sln semicolon now let's do make Mario Mario enter ah now it's generalized as I see fit and if I really wanted to dwell on this I could go in and I could prompt the user with get int or with get positive int figure out what row Andor column should be we can make any size brick that we want but now we have sort of a nice starting point but there's another way to think about this because I dare say especially for like your first cs50 problem set if you're trying to print bricks and the world of Mario in this way it's probably not going to be obvious to come up with loops like this and just magically get it working after like 45 seconds in total like it'll be a struggle at first but there are some patterns to follow so one it's pretty conventional nonetheless to use just I and then J and then K and then L and if you've got nested nested nested nested for Loops at some point nesting you're probably writing bad code it's not welld designed but one or two or maybe three nestings could be an okay thing but you cannot use and reuse I again and again why because if you're counting I here but then you're changing I here to do your columns left to right you're going to get all of your math out of sync so you need two separate variables I and J are conventional or row and column would work too but if we go back to this idea of rows and columns well let me actually Factor something out here and this might help you instead suppose that you set out on this problem you know you want to do something like three times but you don't quite understand how to print those rows we take a baby step a bite out of the problem and maybe do this create a function with no output just a side effect whose purpose in life is to print a row and how many rows well maybe n for some number of row for some number of bricks rather how do you print a row of bricks well let me just think about this in isolation how do I print a single row of bricks that's easy for in I equals 0 I is less than n if I'm generalizing I Plus plus and then whoops i++ and then inside of my curly braces go ahead and just print out a single hash and at the end as you suggested print out a single new line in other words abstract away the idea of printing a single row and in fact at this point in the story especially if you're struggling to get started you don't even need to start with main like take a bite out of the problem that makes sense to you that's smaller than the whole problem printing a single row because then you can come in and iterate then you can go in and say okay now let's write my actual main function so in main void as always and now what do I want to do I want to print out a whole bunch of rows how do I print out a whole bunch of rows oh my God it's like the same idea 4 in I equals z i is less than let's call it three for now but we can generalize that i++ and what do I want to do on each iteration of this Loop my gosh just print row with three bricks and then we're sort of done right again out of sight out of mind this function can go away and never be seen before cuz once print row exists that's what it in fact does for me now this isn't a 100% correct I still need my prototype because if I've made my own function I need to tell uh C in advance that it shall exist so I need to copy and paste that one line of code if I were really being pedantic this is bad design uh in general when you have the same number in multiple places in a program a programmer would call this a magic number like how is that working like you're just a honor System that you're using the same number again and again so a better solution here even if you're not going to take user input would be to do this int Nal 3 and then use n here and then use n here or you could call it anything you want but now you've specified three in one and only one place and we can go one step further it turns out in C and in other languages you can protect yourself against yourself if you know that a variable should never change its value it should always stay three in this case you can use what's called a constant where you can specifically say I don't want just n to be an INT I want it to be a const int const for short for constant and this means even if I try to change n in my code the compiler will not let me so I can protect myself from myself or in the real world you can use a variable that none of your colleagues can foolishly change on you without you realizing that it has happened so a lot of programming honestly is just you know not trusting yourself the next morning when you've forgotten what code you wrote let alone the next month the next year when you're writing code in the real world so constants just give us a feature to defend against ourselves there's another feature that's useful too especially when you wake up the next day and you're like oh my God like what how does this code work what does it do well there's comments in code and some of you might have used this in scratch you could add little yellow sticky notes in scratch for comments in code you can do something like this you can if you want to put an English reminder to yourself or if you speak some other human language uh comment in Spanish or any other human language you can write it with a SL slash at the start of the line and then you can say something like print n rows um and then this tells you in a comment what those subsequent lines of code are doing it's sort of a note to self it has no functionality for the computer's sake it just is a note to yourself or you can say something like this like never change n because you're making clear that it's indeed constant but that too is a little pedantic since const says the same but comments are notes to self to help you remember what is something is doing or why you did it this way questions now on any of these Mario problems that we have solved no all right so one final set of examples that push the limit of like what computers can actually do thus far we've solved like every problem I proposed that's because I've kind of been skirting some of the underlying challenges so it turns out that we have not only functions that give us side effects like visually on the screen we again have functions that have return values so let's focus on those and where things that can where things can go wrong and let's use a bunch of other operators as well suffice it to say computers got their start by being really good calculators so Computers support addition subtraction multiplication division uh remainder operators represented by the percent sign here which says take the remainder of something over something else and there's even more operators than this so let's go ahead and Implement our own calculator of sorts that actually has some bugs along the way let me go back over to vs code here I'll close mario.c open my terminal and code up one final file called calculator. C and in this calculator file let's go ahead and do something super simple initially let's go ahead and include cs50.h let's include standard i.h let's do int main void as always all boilerplate thus far and now let's do something more interesting int x equals get int and we'll prompt the US user for an x value in y prompt the user for a yalue as we've done previously for comparing numbers and let's just do something super simple let's give myself another variable int Z equals x + y and then let's print out the sum so print F per quote unquote and I don't want percent s here if I want to print out a number someone said it earlier we want percent s for string but percent I for integer back slash n and print out the value of Z so it's a little silly this calculator it just adds two numbers together but it's going to demonstrate some points so make calculator enter so far so good calculator let's just say x is 1 Y is 2 Z is going to be three this code is correct simple though it is is there an opportunity for marginally better design could we tighten this up make it shorter fewer lines means less lower probability of bugs probably yeah yeah we don't really need a separate variable Z I mean it's fine if it's clear to you if it's clearer to your TF if it's clearer to your colleagues but honestly this is so relatively simple I think we just get rid of Z and just say something like X+ y here which is totally reasonable as well but you don't want to take this to an extreme Heck if we don't need Z do we really need X and Y well we could do something like this let me actually whoops let me actually delete these lines of code and claim we can do this all in one one very pretty oneliner uh we could do say get int X Plus get in y and notice now kind of like the join example last time I'm calling get int once get int twice both of them return a value which is like going to be one and two respectively based on what I typed earlier then I'm doing 1 + 2 that's going into print f as the second argument like this is actually correct and will work it's is just stupid like don't do this like we've crossed some IL defined line where this is just harder now to read and so even though the variables aren't strictly necessary I would argue and I think most programmers would argue this is just much more readable each line is doing a little bit less work there's less chance for error it just makes a little more sense but reasonable people will disagree so therefore this will this is to say over time too like you and your TF might disagree you and your colleagues might disagree and at that point is when the sort of religious debates kick in as to which way is the right way all right so that's one calculator let's do something else that maybe just like doubles a number here so let me change this uh to just get one integer from the user let's just call it X and let's just double it quite simply so print F uh percent I back sln uh x * 2 we'll quite simply double it the star operator is indeed multiplication in this case so that's going to go ahead and double my number so make calculator again/ calulator enter and let's go ahead and type in one and I get get back two let's run it again type in two I get back four type it again let's type in three I get back six and so forth all right so that's not uh bad in this case here but what if we actually want to write a a proper program here in fact um yeah let's see it's this is a sort of a meme that comes and goes let me see if you recognize this I'm going to go ahead and say another variable not X let's be more specific like in dollars equals one and then let me deliberately induce an infinite Loop sometimes it is use to induce an infinite Loop so long as you eventually break out of it somehow if you don't want the program to run forever I'm going to ask the user a question asking them for a Char C using get Char and I'm going to ask them quote unquote here's percent i period double it and give it to the next person question mark this is ringing a bell and then we can pass in to get your the dollars value there so actually this looks a little cryptic already I'm going to put a dollar sign in in front of it as though we're actually dealing with US currency and what do we want to do how about if the user says uh why for yes double it and give it to the next person then let's go ahead and do dollars and let's double dollars so I can do dollars equals dollars * 2 or recall the trick for plus and minus I can also do times equals 2 which just doubles it in one line as well just little syntactic sugar as programmers call it that just tighten up your code even though it's the exact same thing but what if the user does not type why and they want to keep the money well we have an El condition at that point you don't want to keep asking asking asking asking them with get Char let's just break out of this Loop instead so break is another keyword that if you're inside of a for Loop a while loop a do while loop you can forcibly break out of the loop early if and when you want to and so this sort of satisfies the goal of making sure that this doesn't run forever but it is going to run again and again and again while we keep prompting the user with this question so let's see now what happens um except at the end let's go ahead and make sure the user knows like how much money they're walking away with here's dollar sign percent I back sln dollar so we will see at the end of this whatever dollar amount the person ends up with make calculator enter docal and let me increase my terminal window size so here we go here's $1 double it and give it to the next person yes here's $2 double it and give it to the next person yes yes yes yes yes so you know the Instagram reels aren't that long but if like you keep doubling it again and again this is called exponentiation which will make you quite wealthy quite quickly because notice we're already in the thousands of dollars by just saying yes and yes and yes it's an interesting sort of societal question as to what dollar amount you would keep the money and no longer double it and pass it on but for now we'll just keep doubling it because this is just getting bigger and bigger seemingly infinitely large in the C program but oh my God like apparently the Instagram reels cut off the meme too short because eventually it goes negative and then zero like what's actually going on here like the code is actually correct but we're bumping up against a different kind of problem any Instinct for what is actually going wrong here it's not doubling forever yeah there's not bits to yeah there's not enough bits to store bigger and bigger numbers recall with 32 bits which happens to be how big most ins are you can count as high as 4 billion if you start at zero or roughly as high as two billion if you want to handle negative numbers as well negative2 billion to positive two billion So eventually once I get to like two billion or $1 billion it goes negative and then it just goes to zero altogether this is because of something called integer overflow whereby if you only have a finite number of bits and you keep incrementing them incrementing them incrementing them eventually you can't just carry the one because there's no 33rd bit so all of the other bits wrap around from ones to zeros and it looks like all 32 of your bits are zero because the 33rd bit was supposed to be the one but it's not there they don't have enough memory so this is a fundamental problem with computers whereby if you count high enough things will just start to break at least if you're using C or C++ or certain other languages that don't anticipate this and there's a very real implication of this so here's a screen here's a photograph of something we'll look at more in time to come like of memory inside of your computer or phone or any electronic device device suffice it to say there's only a finite amount of memory and if you're only using 32 bits then or heck even three bits you will eventually overflow we used three bits last week so here's an example in binary if you're only using three bits per the white digits here I've put in Gray the fourth just to show you what carry we might want to have here's 0o 1 2 3 4 5 six seven just like last week and just like last week someone said how do we get to eight we need another bit but if that bit is grayed out because it doesn't exist we've just overflowed this tiny integer and gotten back to zero just like my money went to 0 instead so how do we actually avoid that you know one way to do this is this let me hit control C to break out of the program or I could just type no let me shrink my terminal window and clear it here I could actually do this it turns out that ins use 32 bits typically but there's another data type that was on the slide before called long which is a longer version of an INT which is 64 bits which is crazy big um there's not that many dollars in the world but it's still finite even though I can't pronounce a number that big but if we change all of our inss to Longs and we change our placeholder from percent I to percent Li for long int I can actually count higher and higher so case in point let me actually go back to my terminal make calculator enter make it larger again do SL calculator and I'm just going to keep saying yes but faster this time the sequence is exactly the same but recall that once we got into the billions it started to wrap to negative and then zero this is a lot of money now like Longs are indeed longer and I could do this probably all day long oh interesting no I shouldn't have said that uh can't do this all day long because eventually a long two will overflow I just didn't think it was going to happen that fast so a long two will overflow because we'll need a 65th bit but the computer has not alloc ated it so that too becomes an issue of overflow to read an excerpt like these are very real world issues and in fact here's a photograph of a a Boeing 787 years ago that actually had issues beyond the most recent issues with Boeing airplanes whereby after 248 days the Boeing 787 years ago can lose all of its electrical power due to the generator control unit simultaneously going into fail safe mood whatever that means but if you dig into this it turns out that there was a software counter in these airplanes years ago that would overflow after 248 days of continuous power 248 days why well Boeing was using a 32-bit integer and they were using it to count tenths of seconds and it turns out if you do the math after 248 days you have used too many tenths such that you overflow the size of a 32-bit integer the plane would essentially have this integer this tiny stupid little variable overflow but generally speaking when your numbers suddenly go negative or zero bad things happen the plane could literally lose its power mid-flight or on the ground and if you can believe it anyone want to guess what Boeing's workaround was till they fixed the actual software what's that not even reboot the plane like they were told every few days certainly every 248 days turn the power off turn it back on which stupidly is what all of us have been told for years with our Macs and PCs and phones why because some times because of bugs and software computers get into funky states which is a you know colloquial way of saying like some programmer made a mistake and some counter overflowed or some condition wasn't handled and just weird unexpected things happen so rebooting just resets all of your variables back to their original values and sorts of gives you more time more runway in this case no pun intended there are others in fact one of the most famous ones from like the 1980s was the original Pac-Man game only had support for 255 levels why they were using eight bits recall that 8 Bits gives you 256 but if you start counting at zero you can only go to 255 so the crazy kids who were so good at Pac-Man that they got to level 256 the makers of Pac-Man did not anticipate that anyone was going to win that many levels and just weird stuff happened on the screen all of the fruits sort of started overwriting everything because they didn't have enough memory allocated to the level nor did they have a condition that says if level equals equals 255 you win like there was just nothing handling that corner case so to speak so these things abound even these days thankfully in some languages there are better Solutions where you can use big integers and you'll just use 64 maybe 128 maybe 256 bits but you need to use a language or a library that allows you to grow and shrink the amount of memory being used and many if not most languages do not do that for us so there's a few final problems to see that we've been taking for granted thus far and they also involve numbers and memory so let's go back into our calculator let's throw away all of this meme code here and instead let's go ahead and do something simple again int x equals get int and prompt the user for a variable X int y equals get int prompt the user for a variable Y and this time instead of addition instead of doubling let's do division so print F quote unquote percent I back sln and then plug in x / y so you use a single forward for division let me go ahead and make calculator down here/ calulator and let's go ahead and do 1 / uh three which should in fact be it's not really zero right it's like 0.333 let's try this again how about do/ calculator 3 / 2 should be 1.5 nope computer thinks it's one well what's happening here well it turns out when you're using integers in a program you are vulnerable to what's called truncation an integer plus an integer gives you an integer an integer divided by an integer funny enough gives you an integer so even if the answer is supposed to be 333 or 1.5 everything in the world of integers throws away the decimal point onward and you only get the integer part of the value so it's not even rounding it's truncating everything after the decimal so this program is just not correct but there are solutions potentially for instance if I go back into my code here and I use a different format code we haven't used yet we had s for string I for INT there's also f for float and a float was like a real number something with a decimal point in it by definition we just haven't used it yet I could tell the computer to print this as a float so let me do make calculator again and now hm it's specifying type double there's an error here the problem is that I can't just tell the computer to format this number as a float I need to convert the number x / y to a float and I can do this in a couple of ways one I could literally change all of this to floats and just avoid the problem Al together use float use get float use percent F and I'm done but if I want to use ins for whatever reason because I want the user to type in integers but I want to show them real numbers with decimal points for correct math I can do what's called casting a value I can in parentheses which is a weird new use of parenthesis I can say hey computer please treat the following foll in integer as a float instead thereby avoiding truncation do not truncate for me so if I now run make calculator again/ calulator and type in for instance one for x three for y now I get an actual floating point value I'm formatting it as such and I'm telling the computer to actually arithmetically calculate it as such as well but here too I'm kind of cheating you of a reality it turns out let me clear this screen here and it turns out that there are fancy ways in printf to tell it how many digits to show you how many um significant digits and the syntax is very weird I have to look it up constantly but instead of just saying percent F you literally put some numbers in between there and you say uh 0 five and that will say it's weird syntax hey print F format this to five digits instead so let me go ahead and do make calculator again calulator and let's do 1 divid 3 and indeed I get five significant digits there but suppose I get a little crazy and I want 50 significant digits well according to grade school I should just see more like threes but watch this make calculator do/ calculator and it turns out that whoever taught you grade school math was kind of telling you some white lies because if you really do it with a powerful Mac or PC or phone 1/3 is actually 33 3 3 3 3 3 3 43 2674 4 4079 who's right Mr and Mrs so and so from grade school or like the internet what's going on here what explains this it all comes down somehow to weak zeros zeros and ones why is this floating Point number imprecise so to speak what's the intuition yeah yes similar in spirit just as ins only use 32 bits floats also use only 32 bits if you want more just as int has long floats have something called double so I could kind of avoid some of the problem by switching to double but that's still going to be finite and if you think about this intuitively if you're using a finite number of bits be it 32 or 64 you can only represent literally so many patterns and thus so many floating Point values so many real numbers but how many real numbers are there in the world like literally infin itely many is the challenge of real numbers you can just keep adding numbers after the digit so how could a computer Mac PC or otherwise possibly represent every floating point value super precisely if there's not enough patterns to represent every number in the world moreover the way that computers use to represent numbers sometimes do not allow them to represent numbers so precisely we can get more significant digits maybe but not 100% Perfection or Precision so floating Point precision too is a fundamental problem with computers today and unless again you're using a specialized language or library that understands for scientific Computing the implications of overflow or imprecision your code will have mistakes much like Boeing discovered much like Pac-Man discovered as well and in fact just to end on a a gloom and doom note it turns out there's another problem like this on the horizon already so back in my day everyone was really worried about the Y 2K problem the year 2000 problem why because for decades when computers were invented most systems were used just two digits independent of bits two digits to represent years why computers came out you know a few decades ago who'd think that a computer still going to be running decades later turns out they were especially in government and corporations and the like but if you're only using two digits to represent years and the Millennium comes around and it's 1999 about to roll over about to roll over what comes after 1999 well if you're only using two digits ideally 2000 but if you're only using two digits the year zero comes after the year 1999 and the whole world truly you can look it up nowadays on Wikipedia was freaking out because there was so much old software in the world that could have had this mistake and who knows planes falling out of the sky um computers rebooting freezing like no one really knew because this was an unhandled situation in code so thankfully the world actually got its act together the world did not end in the year 2000 and most systems were updated in time without crazy horror stories but we're going to have this happen again because it turns out just a few few years from now at this point um computers for years have been using 32-bit integers to keep track of time in the sense of like what time of day it is and the uh point in time they decided years ago was hey like hey everyone let's just keep track of how many seconds have passed since January 1st 1970 and we can relatively compute time anytime thereafter so that's great that gives us a lot of decades worth but 32 bits eventually maxes out at like 4 billion positive or two billion if you want negative and positive and it turns out if you count the number of seconds between 1970 on up on the day n January 19 2038 the world might again end because all of these clocks are going to overflow and we're going to end up in the year zero or negative something now what's the solution there I mean my God it's the exact same thing like stop using so few bits use more bits but bits and memory and computers used to be expensive nowadays storage is so much more available but among the things we'll discuss then is how you can throw both hardware and software at this problem but for now maybe set a Google Calendar reminder for January 19th 2038 and hopefully we'll see you next week [Applause] [Music]