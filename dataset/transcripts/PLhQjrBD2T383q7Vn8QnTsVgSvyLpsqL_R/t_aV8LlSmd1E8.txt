[Music] [Applause] [Music] [Music] [Music] oh all right this is cs50 and this is already week five uh this is our last week on C and it's also reputed generally to be the the most challenging perhaps of weeks whereby we sort of climax with the material we've been exploring thus far sort of metaphorically it's like we've been going up this this hill and I know it's felt like a lift each and every step but now things kind of plateau out I dare say and even though it's not going to feel like we're suddenly going downhill or things get marketly easy I do think you'll be able to catch your breath and start to apply a lot of the lessons learned over the past few weeks so everything that lies ahead and among the things that lie ahead are exactly these data structures which we've only touched on briefly so far we had this look at arrays way back in week two already and we've used those in a few different ways but arrays are a super simple data structure data structure meaning it's a way to structure your data in the computer's memory in so far as they have to be generally the same data type but most importantly back to back to back and the catch with arrays recall is that you have to decide in advance how big the array is going to be do you want size three do you want size 30 300 but you do indeed have to decide in advance but there's other things in life not only the virtual world but the real world that we might consider a bit more abstractly and in fact you're going to start to notice after today ideally that the world is filled also with abstract data types whereby they these uh ways of structuring information but that don't depend necessarily on the underlying implementation details that is to say you can Implement certain features in life in code but there's Bunches of different ways to actually Implement them at a lower level whether it's using arrays or in fact as we'll see today other data structures as well so while data structures are something very concrete involving variables and pointers and functions and the like abstract data data types are a little more broadly descriptive for instance there are in the world these things called cu's turns out there's things in the computer world called Q's to but in the real world a q is like what where might you see Q's in the real world definitely in the UK because they're typically called this there like a line a movie theater like lining up for dinner or lunch or any kind of line you have cues now cu's have some kind of ordering often of people but certainly in the virtual world you might have cues as well in fact this isn't as common nomenclature anymore but if you're printing a bunch of things to a printer those documents are generally stored in a queue so that they all print out in that precise order and we can actually see this in the real world so we wonderfully have three Brave volunteers if you three wouldn't mind coming on up first up we have here come on over here if you'd like to introduce yourself to the world hi everyone my name is AE and I'm a freshman in Canada welcome and if a you want to line up first right over here in the center of stage hi everyone I'm Jeffrey and I'm a freshman in the which is better than Canada okay welcome if you want to line up second place behind him hi I'm Jack I am a freshman in Matthews which as Professor M would agree is the best freshman house okay yes thank you Matthews over there okay wonderful go ahead and hop in third place behind there so these guys have formed what I would argue as a Quee they've sort of lined up wonderfully uh in order to receive their sort of thank you prizes and so in fact if I hand these out in the order in which they kindly volunteered we have one thank you here thanks very much we have two thank yous here thank you very much and three thank yous maybe a round of applause for how easy that was for our volunteers so was sort of Equitable all around and notice that the que actually if we kind of geek out about this actually had some operations associated with it and I dare say we would somehow implement it in code as well so a q or a line in the real world as we know it is actually an example of a fifo data type first in first out so that's sort of a property of this structure no matter how you implement it that describe sort of the equity of how you put the data in and get it out or in this case the human volunteers the first one to line up at the front there a got his prize first because he was indeed first in line and then the second person and the third person so not all that interesting you would kind of Hope or expect that that's how life works when people line up or cue but let's make this now a little more granular in the worth of coding so if you were to implement that same structure in code be it for a printer or some kind of Ticket Master type scenario where you want to ensure a fifo property you would generally have two functions or two fundamental operations NQ which means to put someone into the Q on DQ which means the opposite to take someone out and just as fifo implies like the first in is the first one NQ uh but they're also the first one out to be DQ so just some terminology now how could we make this in code well if we suppose for the sake of discussion that you want to have a Q like a line that can fit 50 things or 50 people in total a capacity of 50 we could declare an INT and make it a const so it can't actually change and initialize that to 50 and then we could use that elsewhere in our code and we could create our own structure using typed def as well that includes this many people in an array called exactly that people each one of whom is of type person so recall from weeks past we used the struct keyword already we used the type def keyword already to invent our own data type called person so let's just assume for the moment that now exists but notice that you can actually encapsulate data types inside of data types even if you've made both yourself so the world starts to get more interesting when you structure things in this way but I also have inside of this new struct which indeed I'm going to call a q in code also size why is it that I need to keep track of the total capacity of a q in code but also apparently I constantly have to keep track of the size of the Q it's a subtle difference but these two words mean something very distinct capacity is and always will be cuz it's a const but size is different how just intuitively yeah yeah so size is going to be the current number of people or things in the queue and it stands for reason you've got to keep track of both because otherwise you might have like 50 garbage values in memory if you want to keep track of how many of those values are valid and represent in this case uh persons or people well you need to know if there's zero people there or one or 49 or 50 or anywhere in between so this is how we might in code and we won't go down this road further how we might in code implement the idea of a que using familiar syntax by kind of layering some of these ideas we've seen already all right but it turns out you don't always want q's and you specifically don't always want fifo so there also exist in the world these things called stacks for instance if playfully I propose that I actually do own different colored clothes in fact I've got like a red sweater I've got a blue sweater but if at home in my drawer or closet I store all of my sweaters in literally a stack like this one here well it stands to reason that if I'm doing sort of laundry frequently enough I might wear this on Monday this on Tuesday this on Wednesday then I might do a load of laundry and so they're they're back on top of the stack and I never actually get to the bottom of the stack here so this is a very different operation it's not Equitable in the same way our Q was because it would seem that the last sweater I put in is going to be the first sweater I take out now this sort of stands to reason that that's obviously how the real world works when you stack clothes together but these things called Stacks are everywhere too like in the dining hall in anenberg hall there's a whole bunch of trays presumably and unless the dining hall is really busy there could be one really dirty nasty tray at the very bottom of the stack that never gets used because people are constantly taking the ones higher up until they finally refresh them and clean them in the world of technology like your inbox if you use Gmail I mean that's actually a stack in and of itself why because when you get new males where do they typically visually end up well sort of at the top at the top at the top and if you're like me if you get lots of emails that you don't really necessarily get to all of them you might reply to someone who wrote you most recently and completely blow off someone who wrote you earlier because they've been pushed further and further down so to speak in the stack so these data structures or these rather data types are really everywhere and stacks therefore suffice it to say are not fifo first in first out they're what the world called lifo last in first out because the last sweater into the stack is the first one that I actually pull back and so we can see this even more clearly with three more volunteers if you three wouldn't mind coming on up exhibiting a lifeo property here if you want to introduce yourselves one at a time here we go hi my name is Michelle and I'm a freshman in greo welcome Michelle if you want to come over here first by the table hi my name is Sophie and I'm also a freshman in Greeno all right Sophie if you want to come over here hi I'm Alex I'm a freshman in Wigglesworth Wigglesworth nice Wigglesworth nice if you want to come in front here so these three have clearly stacked themselves into exactly this data structure a stack which is actually too bad cuz I only have like two prizes this time so I think I can offer you your prize and we can offer you your prize and unfortunately we can just give you a round of applause because you were the first one into the staff okay all right we actually have a third but point is hopefully made so thank you to these three volunteers that's all we needed you for but a lifo then is a data type that indeed has that property which you might want in some context like your Gmail inbox you might kind of have to tolerate in the physical world just because of gravity and how closets and drawers work but it isn't necessarily a property that you want of all data types for instance case in point in the world of printers would be kind of obnoxious if a lot of people in an office or university are printing to a common shared printer but only the person who printed most recently is the one that gets their document first so you'll see in the real world not only cu's but potentially Stacks especially when things maybe get unfair when you're in a store and the cashier isn't necessarily honoring the first in first out property but as for operations these two have some vernacular and so instead of NQ and DQ in the world of stacks we actually generally say push which means to push something on top of the stack and pop which means to remove something from the top of the stack but top of the stack is the operative word you're not sort of sliding the blue sweater out from under everything else you're only operating at the top of the data structure but it turns out if we think now about Stacks as being this abstract idea that have these operations associated with them in code we could actually Implement them pretty much the same so notice here the only difference on this screen here is that I'm calling this structure a stack but the stack still has some capacity it still has some size but if you sort of Imagine in your mind's Z how a stack differs in code from a que whatever Loop you're using whatever conditionals you're using you're probably removing things from a stack from a different part of the array than you would from a q so if you just imagine maybe you start removing things from the front instead of the back at the end of the day you can Implement these abstract types using similar code here but you're going to have to tweak the operations to give the property that you want fifo or lifo so again the overarching goal of just introducing stacks and cues at this point is that there is this distinction between an abstract data type like some way of organizing information that has certain properties certain operations but you don't necessarily need to know or care how it's implemented in code because clearly you can implement it one way or the other and the actual data structures with which you are building those abstractions so one's high level one's low level and indeed that's the whole purpose of abstraction so our friend Professor Shannon Duval at Elon University actually brought this same idea to life with a short video in which Jack learns the facts about cues and stacks so we thought we for a moment to hammer this home would dim the lights and hit play on this short film once upon a time there was a guy named Jack when it came to making friends Jack did not have the Knack so Jack went to talk to the most popular guy he knew he went up to Lou and asked what do I do Lou saw that his friend was really distressed well Lou began just look how you're dressed don't you have any clothes with a different look yes said Jack I sure do come to my house and I'll show them to you so they went off to Jacks and Jack showed Lou the box where he kept all his shirts and his pants at his socks L said I see you have all your clothes in a pile why don't you wear some others once in a while Jack said well when I remove clothes and socks I wash them and put them away in the box then comes the next morning and up I hop I go to the box and get my clothes off the top Lou quickly realized the problem with Jack he kept clothes CDs and books in a stack when he reached for something to read or to wear he chose a top book or underwear then when he was done he would put it right back back it would go on top of the stack I know the solution said a triumphant Lou you need to learn to start using a queue Lou took Jack's clothes and hung them in a closet and when he had emptied the box he just tossed it then he said now Jack at the end of the day put your clothes in the left when you put them away then tomorrow morning when you see the Sunshine get your clothes from the right from the end of the line don't you see said Lou it will be so nice you'll wear everything once before you wear something twice and with everything in cues in his closet and shelf ja started to feel quite sure of himself oh thanks to Lou and his wonderful queue all right so hopefully now that reinforces really what these stacks and cues are let's actually transition now to building things and building on top of where we started and week two with arrays and really reach a peak today of sophistication when it comes to using last week's concept that of pointers to kind of stitch together in a computer's memory really any kind of structure that we want but recall first that arrays indeed had this key property that everything was contiguous back to back to back so for instance if in week two onward we wanted to store like three integers in memory it might look abstractly a little something like this where we might put one and two and three but the catch with the razor call is that you have to decide in advance as per those square brackets like how big the thing is going to be and so if you decide in advance with square brackets that you want an array of size three but later you realize oh darn I want to have a fourth integer or a fifth one you might have actually metaphorically painted yourself into a corner ideally you would put the number four for instance right here but again in the context of the computer's whole memory per last week there's other stuff going on so for instance these might not necessarily all be freely available to use because if you've got one two three multiple variables and lots of functions in your program well these other memory locations might be filled with actual values and as well as garbage Valu so as per Oscar the Grouch here assume that anything with him just represents a garbage value where sure we can use that location in memory but there might actually be valid strings like hello comma world back sl0 and I've kind of grayed out because it's separate from the one the two and the three but there could be another variable in your program that's storing hello world and just by chance because you created that variable after the array you ended up with an H immediately after the three so it would seem that you've indeed painted yourself into this corner in that unless you sacrifice that H and wreck that whole string there's no room for the four but is there I mean obviously there's a lot of room for the number four not to mention the one the two and the three because all of those garbage values don't mean you have to respect them you can reuse those locations they're garbage in the sense that you use them already but you're no longer using them so I could put this 1 2 3 and four somewhere up here someone somewhere here maybe even somewhere down here so how could I then accept the fact that I do want to grow this array well I could just say fine I'm going to have to uh sort of bite my lip and just copy the One the two to three to a brand new location that actually has room for our fourth value as well and we can put the one the two the three and we can now have room for the four and then we can get rid of the original array somehow so this is a solvable problem even though we haven't had to do it in code yet but what's a downside of this solution to growing an array to store more data after you first create it it takes up more space it takes up more well it takes up more space in a good way at the moment I think it's not so much space that we're worried about here sorry yeah you have to keep doing this again and again so if I can put words in your mouth it takes more time because now just to insert one value like the number four instead of just jumping to a free location and putting it there in constant time I kind of have to incur linear time to copy the original array into a slightly bigger array and then add that new fourth value so you're just kind of wasting your own time now there's a potential alternative what could we do well I could have just allocated more space than I need from the GetGo so even though I asked the compiler for three integers maybe it could be a little generous and just give me four secretly or or 500 or heck 5,000 so that I never deal with this problem in the future that way everything would be super fast cuz I never have to waste time moving things but what would be the downside of that approach sort of over allocating memory for an array sorry so it's it's a waste of space I mean there's only a finite amount of memory in your Mac your PC your phone why are you going to write code that's sort of designed intentionally that way but arguably poorly designed because you're just throwing me away that no one can actually use none of your other programs or apps can actually use because you just want to make sure you can grow this array in case you ever need it so that too doesn't really feel like a compelling trade-off but here is really a theme now that we'll see really throughout the semester and throughout Computing there's always going to be some trade-off and it's very often between time and space But as we've discussed in the past it might be a trade-off between the complexity of your code I mean honestly imagine in your mind the the sort of for Loop or the while loop that now you have to write code for to copy all of that from old to new array like that's added complexity we're wasting my human time we're introducing more lines of code that increases theoretically the probability that one of them has a bug so there's just lots of trade-offs of solving problems in this or really any other way so what might we do well what if we could structure our data a little more intelligently rather than just use this super simple data structure called an array where everything has to be back and back and back uh could we instead sort of treat the computer's memory kind of like a canvas such that if there's free space over here fine I'm going to put something over here if there's free space over here fine I'm going to put it over here can I just then Stitch these things together somehow and I'm using that word deliberately because last week we saw pointers which are just addresses but maybe I can sort of metaphorically and as per the arrows I drew on the screen last week maybe I can just kind of connect the locations and memory that are available so that I no longer need to care if my data is back to back to back in memory I can just sort of follow arrows from one piece of data to another and all we need for this is some mostly familiar syntax one we have struct which is the keyword with which we can create a structure our own data type along with type def there's dot which we haven't used that much but we did see uh a while back where by using the dot operator you can go inside of a structure to get at the name or the number field for instance in a person and then of course we spend last week really focused on the star operator so the asterisk whereby you can use pointers in some way so using just these three we can actually build most anything we want structurally in our computer's memory and in fact the only new piece of syntax today is going to be this an arrow which is just a hyphen and a greater than sign which as we'll see is the exact same thing of using a period and a star together we'll see what that means in just a bit so how can we go about implementing an alternative to arrays that actually allows us to grow and even shrink them if we want without having to move everything that already exists in memory around in some way well let's see where we might begin with arrays alone let me go ahead and create a file called list. C and in list. say let's include uh standard i.h at the top let's declare int main with no command line arguments and then let's super simply do int list three to give myself an array called list of size three and just for the sake of discussion let's go ahead and put at the zeroth location that is the first the number one at the location one the number two and at location two the number three so even though the array recall is zero indexed I'm going to use some human numbers like 1 two and three in sequence like this and then let's just do something mildly interesting like for in I equals z i Less Than 3 i++ and then inside of my Loop let's just print out those numbers just to make sure that they they are printing as I would expect all right so if I scroll up to the top of this code there's not all that much going on other than I'm creating an array of size three with the numbers 1 two 3 and then I'm printing them out with a simple Loop all right let's do make list so far so good/ list and there we go one two and three all right so that works perfectly fine so far but let's actually see what would be involved if we are using arrays alone to grow and shrink this array so let me go back into my same program let me throw pretty much all of this array for the all of this away for the moment and let me propose that we're going to create the link the array in a different way in a way that we haven't done before I'm going to say int star list equals the return value of Malo whereby I want three times the size of an INT so I've not actually created in class at least an array in this way but if an array is just a sequence of values contiguous in memory and malok we saw last week is just a function that gives you a chunk of contiguous memory I could kind of do things the oldfashioned way and use malok to give myself a chunk of memory and then treat the first part of it as space for an INT the second part as space for another int the third part as space for a third int I'm just kind of doing things at a lower conceptual level of course to use malok we needed to include last week's standard live i.h so that gives me access to that and recall that sometimes things can go wrong what does Malo return if like there's no memory available anymore no so Nu l two L's in the context of memory so if this list value happens to equal equal null well there's nothing interesting to do here let's just return one and exit the program all together but if we don't have that error let's assume that I did get back a chunk of memory that's big enough for three integers based on whatever their size is on the computer I'm using so let's now initialize this array list bracket Z gets one list bracket 1 gets two and list bracket two gets three so just as before I'm initializing it in the same way but now let's suppose that like time passes and I decide that oh darn it I really wish I had allocated space for a fourth integer now obviously I can just change this code quickly but let's assume that this is a much more complicated program it's running all the time and maybe it's up to the user to say when they are ready to give me a fourth integer so this is a simplification but at this point in my story after some time has passed let me propose that ah darn it I've painted myself into that corner let's reallocate a new array that's a little bigger well how can I do that well let me go ahead and temporarily give myself a variable called temp TMP for short set that equal to the return value of malok whereby I'm asking now for four times the size of an in so I'm just sort of changing my mind later on in this program I actually want an array of size four okay I still have to check that nothing went wrong so if temp equals equals null then let's go ahead and return one um then let me go ahead and copy everything from the old array into the new array so how do I do that well I can do four in I equal 0 I Less Than 3 I ++ just like I was printing the thing out earlier and I can say put into the temporary array at location I whatever is in the original array at location I as well so this is kind of like the string copying program we wrote last week where I did everything manually by copying one into the other now I'm just doing it more generically for integers into two arrays then if I want to go ahead and add a fourth number to this array I can literally do temp bracket 3 gets four and I'm saying gets to me an assignment here and that's just adding now the fourth value to the array just like I did a moment AG go by plopping the four into the bigger chunk of memory all right I'm almost done here but I do need to do some cleanup after I have created this new array of size 4 I don't think I need the original array of size three so recall from last week I can free the original list and that just hands it back to the operating system and then if I want to keep this new chunk of memory around you know what I'd rather call it list instead of temp so because both of those are just variables I can simply say list equals temp and this just sort of renames that new bigger chunk of memory to be the actual list that I care about so that moving forward in this program I can continue to use that array instead of the original and Heck if I want to now print this thing out I can do four in I equals 0 I is less than 4 i++ and then inside of this loop I can print out using print F and percent I back sln whatever is at list bracket I which can now go up to index 4 not through but up to index 4 because there's four possibilities there and then at the very end of this program I should probably be a good citizen so maybe time passes again but it eventually I should free that list itself I already freed the temporary the original list now I want to free the new bigger list as well and now I can just return successfully zero all right if I didn't mess this up let me open my terminal do make list again/ list and I should see 1 2 3 4 and I think this is now correct but notice that just to make this simple idea I mean 44 lines of code just to make an array slightly bigger if you will and there's actually a subtle bug this is super subtle but it's the kind of thing you need to start thinking about whenever you're manipulating memory and I'll draw I'll call this one out myself so notice that at the very beginning of this program when I initialized space for three integers I realized something could go wrong because list could be null and okay I'm going to exit immediately by returning one but there's another subtlety here which I didn't fix yet and valand eventually might catch this for me notice here I again use malok and I did realize here oh shoot something could go wrong and Malo could again here return null so I do check for that but notice that I return before cleaning up the memory that I already asked for so this is super subtle but what I should really do at this second use of malok is if I didn't have a valid return value for malok that's fine but I had better free the successful value of malok that I got earlier otherwise this is the definition of a memory leak if you've allocated memory here you're exiting your program here but you never actually give this memory back like that's a memory leak and to be fair the operating system will eventually like reclaim that memory for you but if we use this as sort of a working principle you should always always always free memory that you yourself have allocated whether it's in cases of error like this or intentionally like down here all right let me go ahead and just make sure I didn't break anything make listlist and voila we have now one two three and four all right let me propose that this is not actually as annoying as it needs to be when you want to grow a list of size three into a list that's slightly bigger of size four there's actually one other function we can introduce today that will make our lives a little easier let me go back to vs code hide my terminal window and let me propose that what we could do is actually this after some time has passed inside of Maine instead of allocating a brand new array like this of size four we can actually do this instead we can use a function that we've not seen before called realloc and just ask really C to do the reallocation for me and this is nice because what C is going to do is if we get lucky and it is not the case that we painted oursel into a corner so to speak and there's no hello world right after the 1 two 3 realloc is going to be smart and if it can leave the one the two and the three in their current locations but just give you a little more memory to the right of that array so to speak realloc is going to do exactly that and give you back the same chunk of but a slightly bigger version of that memory so you therefore do not need to move everything around in the computer's memory yourself now in order for real to do all of that we actually do need to tell it what the address is of that original chunk of memory so unlike malok which takes only one argument real alloc actually takes two the first of which should indeed be the address of the chunk of memory that we are trying to resize now just like malok Realo might also return null in the event that maybe not enough memory is available so we still need to check for that return value immediately freeing the original list and returning one as needed but what we don't need anymore is this chunk of code here wherein we were previously copying from the old chunk of memory to the new chunk of memory all of those values because that too is among the features that Realo provides for us but my God I mean still like what now we're down to like 40 lines of code instead of 44 like it's not a huge gain so is there perhaps a better way to go about this process of actually resizing arrays if and when we need more memory and yes now that we have access to pointers from last week functions like malok now realloc as well as free we can actually build a memory structure a data structure that doesn't need everything being moved around ever we can leave everything where we put it in the first place by way of a structure called now a linked list so what then is a linked list well let me propose that a linked list is a list whereby you're just using pointers to link things together in the computer's memory so for instance if here is our canvas of memory and there's a lot of places that things could end up in this story suppose that I want to store the number one first well that location happens to be available and so I PL the number one there we know from last week that every in a computer can be uniquely addressed just like this building is 45 Quincy Street this is maybe bite number ox123 using last week's hexad decimal notation now suppose for the sake of discussion that maybe this space is uh being used this space is being used this space is being used so there's no room at the moment immediately next to this number one that's okay why don't I go ahead and plop the number two where there is room which is maybe over here maybe that location for the sake of discussion is Ox 456 where do I put the three well maybe it ends up over over here and that happens to be location Ox 789 so no longer are these three integers contiguous back to back to back they're sort of all over the place in memory but that's okay because if I can somehow connect these dots by pointing one to the other one to the other maybe I can kind of stitch together a data structure in the computer's memory and I can if we use last week's building block of pointers let me waste a little bit of space by using another bite or technically it might be as many as eight more bytes so this is not drawn to scale but pointers recall typically take up eight bytes or 64 bits nowadays but I want to draw these things more cleanly as simple rectangles here so here's still an INT here's still an INT here's still an INT but let me propose that if for every integer in this list let me also allocate a pointer a pointer and a pointer so each one can point to another location so what should this pointer point to well ideally it should point to o4 O x45 what should this one point to ideally Ox 789 what should this point to well if this is the end of the list we need some kind of special Sentinel value and in the world of memory like what's the only Sentinel value we've seen thus far that can kind of signify the buck stops here there's no more list so null so Ox zero really so just arbitrarily but universally we decide to use zero as a special V uh a special address that just means there are no more uh numbers in this list AKA null as we saw last week now this is all fine and good memory address memory address memory address and we're stitching things together in this way but you don't need to think at this low level recall from last week you can think of pointers as for the sake of discussion like last week you can think of pointers as really just pointing from one location to another and so we can kind of abstract this away and just get rid of all of that and use some basic arrows instead so how do we keep track of a linked list well uh a length list of numbers while we store the numbers themselves wherever there's space in memory we use some extra pointers associated with each of those numbers to kind of link us from one to the other and then the link list itself it turns out we're going to spend one final pointer that just keeps track of where the start of or the so-called head of the list begins in memory so what's the upside here well the problem I claim we have solved is we no longer need to have things contiguous back to back in memory which means we can make much more efficient use of memory because we don't need a huge chunk of memory to be available all contiguously especially if the program's running over time you can just start plopping things wherever you have room now for those familiar that actually can lead to something called fragmentation of memory where your data structure is kind of fragmented all over the place but nowadays on Modern systems not really a big deal and these pointers allow us to get from one location to another but clearly even in this picture alone there is a downside there is a cost for for linking numbers together in this way with pointers what is the downside of linking them together here twice as many it looks like it's twice as much space and it frankly might be a little bigger than that if these pointers are particularly large you're spending space but you're gaining the flexibility of no longer needing to copy everything from one smaller location to one bigger location and if you've got lots going on in memory you can actually use all available memory as opposed to telling the user sorry I've got a lot of Bites available but some are here some are here some are here I just don't have them all contiguous for you that would be really obnoxious if the program can't proceed because you have enough memory but it's not all in one place and you don't want to spend linear time like shuffling everything around a linked list just gives you flexibility you can use what memory is available albeit at the cost of these pointers so it's not a win-win but it is a tradeoff depending on what feature is most important to you all right any questions on this here structure called the link list thus far any questions at all now all right so let's translate this to the simplest code that we can and it's actually not all that different from some of the syntax we've seen here is how I might remember implementing a couple of weeks back now a person whereby originally it was a string name and a string number we took away those training wheels and we revealed last week that it's Char star name and Char star number but this is indeed as a person but this allowed us using struct and type def together to create a new structure in memory that encapsulated information we cared about like a person's name and number well let me propose today that we actually introduce a new term of art node doesn't really have a technical definition as much as it is just a container for data in memory so node is very common in graphs and other types of structures but node is like a generic rectangle that stores some stuff for us what could I put inside of this data structure in C to Implement that concept of a rectangle with both a number and a pointer to another number well I can literally say int number so inside of every rectangle AKA node is going to be an integer called number and then this one's a little weird I'm also going to store a pointer called Next that points to another node so we've not seen this word node before but it's the same idea as Char star but instead of pointing to the address of a character this variable next is going to point to the address of another node and this is somewhat subtle and a little annoying but because C reads code top to bottom left to right there's a bit of a gacha here I am not allowed to use the word node here if it only technically exists once I get to the final line of this code so a little subtlety and see there is a fix though I didn't need this for person because persons did not involve linking things together in this way but if I add the word node here so it's a little more verbose type def struct node then I can change this to struct node Star as well so now I've seen them top to bottom this can stay the same that's the solution to that problem and this is how everyone does it in C it's not always necessary as with persons but here you just need to mention a little more verbosely what is the name you're giving to this thing so you can reuse it here from top to bottom so what does this do for us it just creates in code a definition for those yellow rectangles that we just drew onto the screen how can we now actually use these well let's take a look at the code via which we can start creating a linked list even though at a glance it might seem a little complicated but it's going to build on exactly what we did last week so let me go back to vs code here let me actually get rid of pretty much everything we just did effectively getting rid of our array based implementation at the top of my file let me go ahead and create with type Def and instruct and node exactly that data structure that has a number and inside of that is a struct node star next and then the name of this thing itself shall be more succinctly uh node just to be clear we could call node anything we want we could call it rectangle if that's simpler we could call next anything we want we could call it Arrow so these are just arbitrary but conventional choices to describe that yellow rectangle previously on the screen all right now what do I do in my program to create a linked list that looks ultimately a little something like this well first I'm going to create a pointer that is of type node star called list and set it equal to null what this means is that I have created on the screen over here the pointer at far left a single pointer that's pointing to the beginning of this list but I initialized it to null because there is no list of numbers just yet all right what do I then want to do well let me just do something three times just for the sake of discussion let me do four in IAL 0 I Less Than 3 I ++ but in the real world this should probably be more Dynamic and I don't just hardcode the number three but what do I want to do well if I want to achieve this picture I think what I need to do is ultimately use malok to create a node put a number in there and then do it again for another node put a number in there and then do it a third time put a number in there and then somehow Stitch these things together so how can I go about doing that well let me propose to do it this way inside of this Loop because I want to do this three times in total let me create a pointer called n for node and set it equal to the return value of Malo whereby I want enough memory to fit the size of a node so I keep using size of so that the computer can just tell me how much memory I actually need for a node recall as always Malo Returns the address of a chunk of memory hence I must assign it to a pointer but what is that chunk of memory going to represent a node so that's why now today I'm using node star instead of char star because last week I wanted a string of memory a AKA charar this week I want a uh memory for a node instead so otherwise it's behaving the same way quick sanity check so if n equals equals null something bad has happened and so I should just go ahead and return one at this point to signify error and I'll come back to the issue of potentially leaking memory later on all right here now I have the opportunity to actually go into that chunk of memory and give it a number so how do I do that well recall that if n contains the address of a chunk of memory just like s was the address of a string if I want to go to that address I can do star n and that goes to the address to the chunk of memory I just created if I want to then go inside of that chunk of memory and access specifically something like the number field as in my struct here well I can use the dot operator which we used in the past so my DOT operator would allow me to do this Dot uh number equals and let's just use get in to keep things simple simple today even though that's from the cs50 library I can go ahead and set that equal to whatever number the human types in now syntactically I need to make a little tweak here because of order of operations I want to make super clear that I want to go to that address first then go inside of that chunk of memory and set the number to whatever the human types in then I'm going to go to that same chunk of memory a little redundantly I'm going to change its next feel to at least be some safe value that I know about like null I don't want it to be a garbage value I want to just create this rectangle in memory and know that there's nothing there just yet what have I now built in memory let's do this a little more slowly a little more methodically by visualizing what it is we've just built so at the top of the screen here we're going to see one line of code at a time and on the bottom part of the screen we're going to see what I'm building in memory step by step the first line of code could be this just give me a a variable called list that eventually is going to point to this list I don't like this though because it means that it technically contains a garbage value right from the GetGo so who knows where this link list is in memory and that's why in my actual code I said no no no let's not tolerate a garbage value there even though this does give me a variable called list let's initialize that to null so that this isn't pointing to some random location I'm just going to use blank to indicate that it's null so this is how I might begin the story of creating this linked list all right what was my next line of code that I did well I indeed used malok to allocate enough memory for the size of a node I claim that Malo always returns the address of that chunk of memory so I stor it in a variable called n for short for node so where is that on the screen that's like getting a variable called n whose value initially is a garbage value as any variable is but as soon as I call maloc that's like giving me a rectangle of memory over here and so I just have to change the number field and the next field to be the values I care about so what did I do after this recall here that one after doing the assignment from right to left that effectively means that n points to that chunk of memory I could use ox12 3 ox4 56 but who cares let's just use arrows for now to keep things visually more uh simpler so this variable n is pointing to that chunk of memory then I went to that address following the arrow and went inside of that structure how did I do that star n do number gets one and that's like actually changing the number one there and it turns out there's actually a a simplification of this this is not pleasant looking code it looks cryptic you have to remember all of the symbols I bet we could simplify it using that one new piece of syntax today the arrow operator that I showed on the screen earlier simply means do all of this with the parenthesis and the star in the dot but do it in a way that kind of reads more cleanly from left to right and it kind of does if this is n and You Follow the arrow and you go to number you get to exactly that location in memory start at end Follow the arrow and voila you are right at that location in memory for both number and next so most people would actually use this syntax so just to be consistent let me go back quickly to vs code and just make that subtle change instead of parentheses star n dot let's just say more simply n arrow number and down here n arrow next and that's kind of tightening up the code already all right what happens after this well I should probably initialize this next pointer to be some known value so that it's not pointing at some garbage value still how did I do this n arrow next equals null just as you saw a moment ago nvs code so Oscar goes away and that's effectively null now so this isn't complete this is now really a newly allocated list of size one but notice we haven't updated the original list so this is actually a step I haven't done yet in code I think I want to set list equal to n which sounds a little weird but if n is an address and list will want should be an address all I'm doing is copying whatever the memory address is here Ox something into list which is like duplicating the arrow and pointing it from left to right as well and then heck I don't need the temporary node anymore in my story because I've just created the first number in memory so let's actually go back to vs code for just a moment and add that final flourish at the bottom of this for Loop when I am ready to insert this node into the list what I think I'm going to do is I'm going to say list equals n the problem with this Approach at the moment is that if I'm doing this in a loop I am going to constantly update list to point to the very node I just allocated so if we keep going through this Li this loop three times I'm going to create a very a node for two and then a node for three but based on that line of code I'm always just going to point list at the most recently created node and there's going to be no arrows linking the three to the two to the one and so I actually need to be a little more clever about this and so in vs code here what I'm going to do at the bottom of this Loop here is instead I'm going to do the following I'm going to specify that whatever n's next field is should actually be the same thing as the list and then I'm going to say the list should point at n so I technically don't need this line of cod here anymore what instead I'm going to do is this if I go back to the picture over here and I create now a second node let's see what actually happens if I create a new note here with malok and I get some other chunk of memory here I eventually want to Point N at that just as I did before as the same line of code does the second time through my Loop if I want to change that garbage value to the number two I go to n Follow the arrow set it equal to two then I go to n Follow the arrow set next equal to null this still isn't a length list because notice the one and the two are not yet connected but the code I just wrote inside of my Loop here proposes to update the currently created node ends next field to be that of list and then update the list itself to point at this new node so what this means concretely even though we're crisscrossing some lines here is the following if my next step is going to be set list equal to n as it was a a moment ago that's bad because watch what happens if I immediately set list equal to whatever n is and N is pointing here that's like doing this and this is bad as per the red on the screen why this does not link the list together why yeah yeah I've like lost track literally of the very first node and in Computing speak I have orphaned the very first node because no one is pointing at it anymore and this is actually a really bad memory leak because if you have no variables pointing to that chunk of memory you literally cannot free it later on in your code so it's never going to be freed and you'll just gradually leak more and more and more memory by something as simple as this and so that's why I indeed deleted that line of code and I propose now most recently in vs code to do this take the new node follow its arrow and change its next field to be whatever the list itself is currently pointing at so what does that mean go to n Follow the arrow and update this box here to be whatever the value of list is and here again it's a little weird because what I don't want to copy the whole list but list l i s is just a variable containing a memory address and that memory address is whatever the address of this first node is so that's like saying this box should point to the same thing that list points at which is like adding an arrow in memory this way now that's not the finished work there's one last line of code that I did just add to VSS code where now it is safe to update list to equal the address of the new node because the new node is here pointing at this chunk of memory so if I set list equal to that address ah now we're linking things together takes a few steps and in fact let's get rid of the temporary memory that I created to make all of this happen now I'm creating a linked list and if we were to go through this one more time around same exact code inside of that for Loop for the third and final time I would then have this structure for instance in memory now I've deliberately artistically written it sort of left to right so it kind of flows in a pretty way but technically the three the two the one could be all over in the computer's memory but these arrows would just curve a lot and point to those locations but I haven't quite built up the same list of numbers as before I kind of screwed this up what have I done wrong it would seem here Visa V the array that contained these same numbers like that code is correct it links numbers together but what have I built in memory that's a little different damn it it's backwards right like it's 3 2 1 if I read it from left to right which I should because this is where the start of the list is the so-called head of the list and indeed three to two to one now technically I could probably come up with some way of reversing that process but these arrows literally point in Only One Direction and because in fact what I've actually built is what computer scientists would call a singly linked list whereby each node points to another node but there's no way to go in the other direction that would be What's called the doubly length list and I could do that I could build rectangles or nodes in memory that have three locations one of which points this way the other of which points that way then I can go back and forth and back and forth and solve that same problem but at the moment without some fancy code I don't think I can print these numbers from left to right in exactly the same way so I built this darn thing backwards it would seem with this code so while the code itself is correct it doesn't maintain the property that I wanted of keeping these things perhaps in order so what's the implication then or how do I actually go about recovering from this well let's actually see how the list prints in practice let me focus on the slide here here's that same memory suppose that I give myself a temporary variable we'll call it pointer for short which is what a lot of programmers would do when using pointers PTR and if I created a variable in memory called pointer and I initialized it to the first element of the list I could use printf and print it out I could then follow that node's own arrow and effectively point at the second location and print its number out then I could update that Arrow to point to the last location and print its number out so this idea of having PTR this variable loop from left to write is actually something I could translate pretty readily into code here in fact let me do that in my vs code here instead of leaving this as is let me go outside of this for Loop and propose that time passes maybe there's some other code that I've written there but what I really care about now is printing those numbers so how can I do that well I need to create sort of my you know sort of foam finger in computer in the computer's memory which I'll call PTR so I can do node star PTR and I can set that equal initially to well how do I begin this let me go back to the diagram I want PTR to point to three first the very first node in the list so in code what should I set PTR to equal how do I access the head of the list I don't have too many options when it comes to variables in this program well could I set PTR to equal well there's only one variable in the computer's memory that technically points at anything at this point so the answer is on line 12 still nothing list that's correct so I could set PTR equal to list because just like this diagram if I want PTR to start at the point of the to start to point at the start of the list that does not mean that I want it to point to this thing this is just a variable that I'm using to keep track of where the first node is but again if we were to take away these arrows as an abstraction this just contains an address like ox something so what I really want to do is put into the PTR variable that I just created the same Ox something so that it's pointing at the first node in the list so that's like saying PTR equals list semicolon so that PTR effectively points at that same first element and again this is the annoying part of pointers because they are variables but they're really addresses to other variables that kind of things so you kind of have to pause sometimes and think about all right what is it I'm actually moving around in the computer's memory in this case it's just the address of that first node in the link list all right if I go back to vs code here the rest of the code is actually fairly straightforward and we can use for instance a while loop so while that pointer value is not null so while I still am pointing at valid memory and I have not reached the end of the list go ahead and print out using printf percent I back sln and print out the current nodes number field so again PTR just per this diagram is pointing at this node this node and this node so in code what we're going to do is literally dreference PTR with the arrow operator follow that Arrow get the number field and print it out the only bit of complexity now is inside of this while loop how do I update the arrow to go from one node to the next well this too is a little mind-bending at first but what I really want PTR to equal the next time through the loop is to point at this node well how do I do that I think after one iteration I can set PTR to be the exact same thing as the first nodes next field so if PTR is pointing at this node well then PTR Arrow next is the address I want because it points to the second node so even though this looks a little weird at first glance this is the canonical way to sort of iterate through a link list I just want to set PTR now equal to whatever PTR is now and its next field so this is just like following the arrow following the arrow following the arrow and if after all of this I open my terminal window and I do make list again enter there is going to be an error which I promis I knew was coming but how do I fix this Undeclared function get int kind of need those training wheels back we just need the cs50 library and that's fine I just didn't want to use scan F and like complicate things unnecessarily today I just wanted to get a simple integer to play this game so I'm going to include cs50.h at the top reopen my terminal window rerun make list enter now we're good/ list and I'm going to manually do the exact same thing as I did with the array 1 2 3 enter h that's it's backwards but at least it is built up in memory and we can indeed see that what I have built is exactly this structure here the side though of having built it backwards is actually arguably a little bit efficient in fact what I've actually done here can leads us to kind of a discussion of like the running time of these link lists like arrays were super fast because they were contiguous and we could search them from left to the right in linear time or per week uh Zer and two if we sorted the elements we could even achieve logarithmic time log of n because we could do binary search again and again and again but let's consider link list here's kind of of our cheat sheet of some common running times but not all of the running times in the world how much time does it take right now to search a linked list from left to right for some value Big O of n why is that well you have to start at the start of the list the head of the list and if you're looking for any value whether it's sorted or not worst case you might have to go from left to right all the way to the end aka the tail of the list in this case so yes Big O of n exactly describes the running time of search what about insertion the process of adding a node adding a node adding a node here's where I actually did something arguably clever even though it kind of backfired in the sense that things came out backwards what's the running time per this cheat sheet of inserting a new node into the link list as we've done it so far it's not oen oen would have implied that we're constantly going from left to right and adding it to the end but I wasn't adding it to the end I was adding it to the beginning which means big o of it's actually Big O of one because the beginning of the list is always perfectly accessible to me it doesn't matter how long the list gets if it has three elements or 300 elements the start of the list is always right there in front of me via that list variable now technically it doesn't take literally one step I think if I did the pointer I might have to use like two or three steps in total but it's constant and that's what Big O of one means constant time and so indeed I can kind of see that here if this is my list originally and the whole thing is empty and I insert the number three that only took one step really or that took rather a constant number of steps whether it's one or two or three whatever it wasn't end steps how do I insert the two well my picture looked briefly like this that two has no dependency on how long the list already is because I'm just prepending it to the list and the number three prepending it to the list so even if this thing is getting longer and longer and longer there's no reason for me to walk or search the thing from left to right so the upside then of this algorithm th fall of prepending elements is that I can achieve sure Big O of n for searching but Big O of one inserting and if I'm doing a lot of inserting into this data structure like that is compelling as constant time always is the catch though of course is that things end up backwards if I care about the order in which I insert them and maybe I do as per our discussion of stacks and cues which are fundamentally separate from this topic now we're talking about low-level implementation details but I might have accidentally now created a lifo structure and of a fifo structure which might indeed be Germain so how can I sort of work around this well maybe I could do something a little differently instead instead of prepending well let me see how much effort it would be to actually do a um uh maybe an app pending to this list instead so once I build the list with the first node I da plop it here second node over there third node maybe over there I can maintain sorted order which is great if I do in fact care about a fifo property because now first one in could be the first one out cuz it's always readily accessible but I think I just shot myself in the foot here let let me quickly pull up some code for this and let me propose that uh my code now might look a little different let me open up uh VSS code here and in VSS code let me go ahead and propose that if I want to append instead that I go ahead and do this let me hide my terminal window let me scroll down to the bottom here and I think what's going to have to change is this stuff here I can't just blindly insert the new element at the start of the list and that's really what was happening with these two lines of code here so how do I do this well it turns out the codee's going to get a little more complicated as a result first I'm going to initialize my next field here to null just to make sure that it's not a garbage value as originally did but then decided ah it's not necessary if I'm immediately prepending it to the list but now I actually have to consider two scenarios and this is where sort of building things in memory gets a little annoying because you might have Corner cases things that don't happen all of the time but might sometimes happen and what's a potential Corner case when building a data structure like this well maybe at the very beginning of the process there is no list so you can't just blindly append it to something that doesn't exist you have to kind of special case the start of the process so what do I mean by that well in code here here I might do this if my list variable which keeps track of the whole thing equals null as it will at the start of the story when no nodes are in the list well this is easy I'm going to store the address of the new node I just created so I'm going to put a comment to myself to make clear if list is empty I am going to do this special case here but a pending is indeed going to evolve some kind of loop so else I'm going to go ahead and do this and I'll add a comment here uh if list has numbers already the second case that I want to handle is going to look a little different I'm going to iterate from left to right over this structure in the following way and I won't dwell on this code because it's perhaps more detailed than we need right now but one way I could do this is as follows uh four node star pointer equals list pointer not equal to null pointer equals pointer next now that's a mouthful but we'll come back to what that means in just a moment inside of this Loop I'm going to say the following if at end of list I am going to uh so if pointer next equals equals null then I am going to assign the next field of this thing equal to n and then I'm going to break out of this entirely all right so this is a mouthful but what do I actually want to do here well well if this is my empty data structure initially and I want to add one that's easy I just set list equal to one but then things get more generalizable for the second the third the fourth the fifth node because as follows if I want to insert this next node two what I really want to do is start at the beginning of the list and a moment ago look for the end of the list and as soon as I find the end of the list as indicated by this being null okay now I can append it how do I insert the third element well I start at the beginning of the list I iterate through it I look for the null element and then I can append that to the end of the list so even though this code very admittedly is probably the most complicated that we've seen thus far it actually achieves that same idea as per my comments so if the list variable itself is null there's no list already that's a super easy case just set list equal to the address of this new node done the harder part is every other case where we're appending to the end of the list now here I'm using a for Loop which is a convention I could use a while loop as I did for printing but let's just think about what this does this creates like any for Loop a variable in this case called pointer and it sets it equal initially to the start of the list because that's where I want my finger to point from left to right then I keep doing this so long as the pointer itself is not null and then on every pass through this Loop just like with my while loop I want to set pointer equal to pointer next that's like moving my L fan to point to the next node to the next node to the next node and I want to do this so long as the pointer is not null because once it is null then I've gone too far so how do I do this here I am inside of that Loop and I'm asking if I'm pointing at a node whose next field is null that means I'm at the end of the list because that's the one node initially then the two node and so forth so if the thing I'm pointing at next field is null there's nothing more to go so what do I want to do I want to change that null value to be the address of the new node and then I'm just going to hit break and break out of this whole Loop because I'm done so it's a mouthful syntactically even though we're using all of the same stuff we saw last week like stars Here and Now arrows here but this is just asking the question as I point from left to right left to right am I pointing at a null ending of the list if so just tack on one more node please and that's it and again if you're comfortable at least with the concept of what we're doing here appending that's really the current goal at hand and in fact what I can do now is let me go into vs code here and I can actually change uh that version of my printing to be very similar if it's helpful to see one side by side so in fact if instead of using a while loop at the end of this code as I did before to print this thing out let me actually change this to be quite similar instead let me go in here and say four node star pointer equals list pointer not equal to null pointer equals pointer next and then inside of this Loop just as before or let's just print out percent I back sln the number in the current field semicolon and then down here heck I'll return zero so in other words what I did with a for Loop is identical conceptually to what I did with a Y Loop if I undo I'm hitting control Z again and again and again I'm just undoing all of this code the exact same thing as this but just as we saw in week one you know four Loops tend to be a little more concise fewer lines of code than the equivalent while loop so that's all I'm doing here is is rewriting this using the same for Loop syntax any questions on what we just did here even though I know this is complex yeah a really good question if list and if n are Vari are um if list and N are addresses then where are the names of these things being stored the compile is actually taking care of that for us inside of the program long story short there's a symbol table and those symbols map to corresponding locations in memory you don't have to worry about that in your own code that's one of the things the compiler is doing for you and in fact the names of these variables at the end of the day don't even matter but they help the compiler keep track of where all of your usable memory is to me that yes that is correct let me rewind to where we built this here so this is why keep emphasizing think about what the variables actually are in this world now of pointers what list is is the address of a node what n is is the address of a node so when we say list equals n that doesn't mean anything related to the names of these things that means go into memory and grab this address and copy it over here as well so that they are fundamentally pointing at the same thing the names have nothing to do with it but again today I encourage you when we're talking about addresses think about what's actually inside the box it's not just a number per se it's an address it's an address a good question all right so let's clean up one other detail here let me propose whoops spoiler let me propose that we consider this question so we've just built up a link list now that is appending nodes to the list upside of which is that we're actually preserving that first in first out property potentially if we care about that because it's one two three now instead of 321 however have we made a dent in the running time I don't think so because if anything it's gotten worse no longer are we inserting in constant time now all of our appens require Big O of end time just like our searches because we have to constantly search from left to right search from left to right now admittedly we could do a minor optimization we could just have another variable that just always keeps track of the tail of the list and that is a perfectly valid solution it's going to cost us a little more memory but that's valid but in general when you're pending something to a list and you're implementing the list as minimalistically as you can with just one pointer called list that points to the beginning of the thing then arguably it is going to be Big O of n but if that matters is really a question for the problem you're trying to decide but I think there's one thing we should still do before we move on past this code now I have a program that indeed builds a linked list by keeping everything uh in the same order in which we inserted it however I have not not yet done anything about actually freeing the memory that I've actually been allocating all this time so let me propose to the bottom of this program before I return zero and say I'm done successfully let's just propose that some more time passes in the sense that maybe there's more code going on that's more interesting but if and when I do want to free this link list it's actually fairly straightforward I can specify that I want a temporary pointer called PTR again for instance set that equal to the start of the list while that pointer is not equal to null what I want to do is this and this is where you can potentially get into trouble I could free the current pointer and then I can update pointer equals pointer Arrow next in other words if I want to free these elements I could simply iterate whoops I can simply iterate over all of these addresses from left to right freeing the pointer and then updating it freeing the pointer and then updating it and that's how I move my my hand my finger from left to right this is a problem though it's subtle but as soon as you have freed an address in memory you may not touch it again you can think of it as the operating system immediately might do something with it and it's not yours to touch anymore therefore online 59 at the moment it is not allowed for me to go to that address check the next value and actually update pointer accordingly it's too late for that because in 958 I already said operating system I'm done with PTR the address therein but there is an Simple Solution even though it might feel like things are kind of escalating if I'm not allowed to touch pointer after I have freed it but I really do need that next address that's fine you can simply create another pointer called Next for instance set it equal proactively to the next field then free pointer as you intend but don't touch pointer again just touch the temporary variable that you created so when you free fre pointer free is not super powerful whereby it's just going to iterate over the entire data structure you've you've created it is simply going to undo one of your moks each time you call it undo one undo one so if you want to undo all of them that's up to you and me with our while loop here to iterate from left to right freeing the node then moving on to the next freeing the node move on to the next until we hit the end of the list and we don't need to go any further so there's still one bug and I'm going to wave my hands at this one but up here recall we did use Malo before and it might have been the case that this very first call to Malo failed in which case okay fine we return one and we're all done but if you imagine in your mind what if the first call to maloc succeeds the second one succeeds and the third one fails you can't just abort the program on line 20 and be like oh well I'm out of memory at this point technically before you return I should free any memory already Malo and I'm not going to bother doing this now because this is going to add undo complexity but that's the sort of subtlety that starts to get involved when it comes to memory and memory management and in fact among the motivations in a couple of weeks time when we transition to another language called python is that if like you're kind of you're you're just getting confused by this you're zoning out it's getting way too complex like a lot of people in the world feel that way and it's so easy to write buggy code it's so easy to write dangerous code in see that among the reasons for other languages like Python and JavaScript and the like to exist is that we can abstract away all of this memory stuff that you and I only have to struggle with for one more week but even these details will still be there but someone else will have done that heavy lifting and you'll just use languages that take care of all of this complexity for you so hang in there for this one week when we do sort of cap things off with these Concepts but rest assured that we'll soon be able to abstract those away as well any questions then on what we've just done done here by freeing the memory we allocated all right rather than type this one out I'm going to show one final version of this length list implementation that's actually going to be a little smarter still so if you imagine a scenario in which you don't really care about you don't want the thing reversed but you don't really care about the order in which things were inserted what you really care about is sorted order so that no matter what order you insert integers in you want them to be sorted from smallest to largest and you want the code to just figure out where to insert them at the beginning or at the end or heck maybe even in the middle so for instance if we have a link list that starts with the number two I want it to look like this in memory if though I then insert the number one I want it to go before the number two so that the thing is kept sorted if I then insert the number four I want that to be appended so it REM retains sorted order and lastly if I insert three I want that one inserted in the middle and this is one that I'm going to sort of pull out of the oven already made because this is where code just gets to be a pain in the neck why because my God there's so many different cases to consider if I rewind here there's the first case where the list is empty and thankfully that's actually pretty easy just plop it at the beginning of the list prepending also relatively easy we saw that before I can just prepend it to the start of the list app pending is not that hard but now I'm doing three things so I'm sort of combining all of these past examples into one so I can append it to the end of the list the one piece of code we haven't written yet is how do I deal with like inserting the three in between the two and the four without orphaning the four so to speak well let me just reveal how we would do this even though you yourselves won't strictly have to leverage this in your own code let me go in a moment back to VSS code and what I'm going to open up here is another version that already has some comments in place just to help guide us so it's almost the same from the start whereby in main I initialize list to equal null I then in my Loop am going to proceed to build a list of size three just for the sake of discussion I have the same code as before whereby I maloc one of those nodes make sure that it's not null before proceeding to get a number from the user and then proactively initializing the next field to be null also so there's no garbage values in this world but here is the beginning of those several cases that we just saw pictorially on the screen if the list is empty easy peasy I can just set list equal to n as we did earlier so I've plucked that one off but notice now I've got an else if why well if the number I'm trying to insert belongs at the beginning of the list that is if I want to prepend this thing okay I can steal some code from earlier update this node's next field to be whatever the current list is pointing at and then change the list to be this new node so that's a same logic as before whereby I want to prepend a node so this is like starting with just the number two I want I notice that oh shoot one is less than two so I want to put the one there AKA prepended all right there's another else here and inside of this else is actually a loop with its own conditional and this is again why I'm not doing this one live so else it's got to be at the end of the list or it's going to be in the middle somewhere depending on what number is inserted so let's start a for Loop whereby we iterate over this whole existing list this one's actually pretty easy if we have reached the end of the list as would be indicated by finding a next pointer equaling null okay this one too is fairly straightforward then change the next field to be the address of this new node and then break out of this mess all together because we are done this is like in our picture here having one and two in place and realizing oh four is bigger than two and one so it should be appended to the end of the list it's the middle case that's kind of a headache and that's the final flourish here if I'm in the middle of the list what do I want to do well here I'm checking this logically if the current nodes if the new nodes number is less than the next nodes number so I kind of have to look ahead to realize okay I found my location in memory I want to change the new nodes next field to point at the current nodes next field that's like in this picture here updating the three to point at the four and then in code update the current nodes next field to point at n that's like updating the two to point at the three and then then thankfully break I can get out of this mess again because I've handled the fourth and final situation so again with time with comfort with practice like you too could like write code like this but it really speaks to the complexity of trying to build up a fairly sophisticated data structure correctly in a way that uses all of these building blocks but doesn't run a foul of leaking memory orphaning memory and this is why memory is just hard because you have to worry about all of these little details questions then on any of these particulars up until now okay I'm happy to say that everything here on out is going to be much more conceptual and much less code oriented but in the meantime we have some delicious Halloween candy and we'll see you in 10 all right so we are back and I admit that like the code that we just wrote to build a link list absolutely complicated but representative of how you can indeed Stitch things together in memory and build more interesting structures and so here on out today let me propose that if you're at least on board with this idea a that with some kind of complicated code but with the building blocks of pointers and the C syntax we've seen you can stitch together data structures in memory as you see fit let's just take for granted then that we could implement the underlying implementation details for the following alternative structures and indeed let's see if now we can draw some inspiration from the world of arrays which we're really appealing now in retrospect because they're simple they're fast they're contiguous like it was pretty straightforward way back in week two but let's kind of match Mash together arrays with this idea of linked list or at least more generally stitching things together because maybe we can kind of get the best of both worlds because Ray arrays recall give us contiguousness that means we can potentially do binary search especially if the if the data is already sorted but of course we paint ourselves into a corner with arrays because they might not be big enough for future data so then we introduce link list and Link lists are wonderfully Dynamic we can make use very creatively of memory but with the catch with link list of course is that we're using extra space the code got more complicated so it's sort of the Seesaw going back and forth as to what we actually care about well what turns out that a very common data structure in Computing is that known as a tree sort of like a family tree which we've mentioned before where you sort of have this upside down tree structure where a root is so-called up here and then you might have children and grandchildren and so forth so it sort of grows on the screen top to bottom much like a real tree sort of grows bottom up but a tree as we'll soon see is sort of a two two dimensional data structure whereas everything we've seen thus far is pretty much onedimensional like an array is just left to right and even though yeah link list can kind of go up and down and around in memory at the end of the day it's still a left to right linear or one-dimensional data structure so what if we start to use a second axis so to speak well it turns out there's specifically a type of tree in the world called a binary search tree which is this two-dimensional tree like structure that you can actually perform binary search on because we did pay a price to with link lists you can't do binary search on them even though you get all the upsides we' discussed the flexibility the dynamism why can you not do binary search on link lists might you think based on how we've drawn them thus far yeah exactly because there this long string like data structure that you can't just go backwards on I said like unless it's a doubly link list you can't go left and right and there's no mechanism for jumping to the middle right no matter if you have arrows left or right the only way to get to the middle is to sort of Traverse frankly the whole thing figure out how long it is then do it again 50% is much time to get to the middle so that doesn't seem like very instant constant time access so long story short onlink list you cannot do binary search which means the best we're really going to do for most of those operations is Big go of n unless we do the whole prepending thing and achieve some constant time access but that would seem to get us in trouble by slowing down other operations eventually all right so what is a binary search tree well here's an array as we've seen in the past this one with seven doors if you will but I've deliberately drawn it very one-dimensional but let me color code this a little bit so as to highlight where the middle is where the middle of the middles are and where the middles of the middles of the middles are in this case so we now have three different colors on the screen here whereby the four was the first middle the two and the six were potentially the left middle or the right middle and then the one the three the five the seven are similarly in the middle depending on whether you go left or right but I'm going to draw it this way because let me propose that this is an array at the moment so we do have the ability to do binary search but we don't have the ability to grow or let alone shrink this structure but suppose that's a goal we'd like this thing to be able to grow and grow and grow and maybe shrink over time well what if I redraw this array by using some pointers in memory kind of like this I've just kind of exploded it vertically so that you can see more clearly that we actually kind of do have like a family tree like structure here if we think of four as the root and two and six as the children of that root and 1 3 five and S as the grandchildren of that route so to speak and in fact if I draw some lines to make this more clear I indeed think that's what we have now at the moment I've drawn things more abstractly I'm just using simple squares now I'm not drawing rectangles with numbers and pointers but these arrows do imply that each of these nodes containing a number also contains not not even one but two pointers now and in fact that's where we get our second dimension suppose that each of these nodes these containers for data contain not just a single pointer but two pointers one for a left child so to speak one for a right child so to speak that would seem to give us the ability to build this thing up sort of two-dimensionally in memory and what's the implication of having built this up in this way well how much time does it take to search this data structure now well I can still do binary search even though pointers are involved because so long as you keep track of the root of the tree always with like one special pointer called root by convention well I can decide whether the number five is in this tree by starting at the root and I know that five is obviously larger so I can follow instead of jumping to the middle of the middle I can literally just follow the arrow to the right child now I know five is less than six so I can just follow the arrow to the left child and voila there is the number five or maybe it's a dead end in which case five might not be there but I can Implement binary search not even with doing arithmetic like in the case of arrays I can just literally follow these arrows so long as I've built the data structure in this way now how could I do this in code well here we're not going to write actual code with vs code but here is how I might Implement a data structure for this in memory well I could redefine the notion of a node as being no longer a number and a single pointer to a next field this was how we defined earlier a node for a linked list but let's reuse the notion of a node as just a container for data and instead build a node for a binary search tree as we've just shown let me make a little more room vertically there and let me propose that a node in a binary search tree that looks like the colorful picture should have one pointer called left another pointer called right that are going to literally point to other such nodes and if it's null that just means you're a leaf of the tree which means you're at the very bottommost level with no additional children so this is indeed exactly how you could build using the same building blocks as before break a more complicated two-dimensional structure in memory but gain back the ability to use binary search which means now our running times are back in play such that a data structure like this can finally give us whoops can finally give us Big O of log and running time but what's the downside if I'm now pitching this is like you want binary search trees now instead of just arrays or just link list because you get back binary search but you still have the dynamism the grow ability of a link list what's the downside of what we've just done yeah yeah I'm just wasting more and more memory it takes up more memory because I have not one but two pointers now for every node which might be problematic might not it's really a design decision ultimately but I will stipulate that this is very common design when you do have a structure in memory where you do want this kind of ordering to it and you don't want to waste time like we saw with the Rays Co cop uh constantly copying or moving things back and forth around in memory what's nice too about two-dimensional data structures like the binary search tree and binary search tree just means to be clear that you can do binary search on it why it means that every node's left child is less than the root and every node's right child is greater than the root or equal to technically would be allowed as well and that's in fact a recursive definition because why I can apply it here the left child of this node is smaller the right child of this node is smaller the left child of this note is smaller the right child sorry I said meant to say larger before the left child of this note is smaller the right child of this note is larger so that is true for every Noe including the leaves that just happens to have no children so it certainly doesn't violate that same definition so anytime you have this sort of recursive structure just like the Mario bricks a while back so can you use recursion in code so I'm going to show code but we're not going to write code we're not going to run code but here's code using recursion to search a b Ary search tree so think of this as the implementation of binary search but on a two-dimensional tree structure instead of an array if you pass in a pointer to the tree itself so a pointer to the so-called root and you give me a number you're looking for here is how I could search a two-dimensional binary search tree that someone else has already built I can first pluck off the easy base case if the tree you've handed me is null well I'm just going to return false obviously the number is not in this tree because there is no tree that's easy else if the number I'm looking for is less than the current node's own number think about that root so it might have been that first number in the tree like number uh like that's like the number four think of that as the starting point so if the number we're looking for is less than the roots number well then let's go ahead and search the left sub tree for that same number else if the number we're looking for is greater than the current nodes number well search the right sub tree for that same number else final case if the number you're looking for equals the number in the tree the node that you've been handed then just immediately return true you found it and this is an unnecessary piece of logic that can just be our else condition there so just like the phone book back in week zero where we were dividing and conquering dividing and conquering by splitting the thing again and again and again that's literally what we're doing here even though I'm using search here and here in my search function AKA writing a recursive function and every tree I'm passing in is getting smaller and smaller and smaller so if we rewind to the picture it's start it's like starting here and then deciding oh wait a minute I'm looking for something over here so let me just kind of snip that sube and focus only on this one and then snip snip snip and you're essentially having the size of the tree each time just like we were having the size of the foam book so we're already starting to sort of reuse ideas from back there in week zero well what more can we do here well let me propose that with binary search trees we now have the ability to not only gain back uh binary search but to trip over ourselves Again by introducing a new problem like it seems straightforward that my binary search tree as of a moment ago was beautifully balanced like this is a nice logarithmic data structure and in fact there in lies the having because you are uh splitting each node into two children two children that's like pulling up these nodes much closer to the root than they would be if it was just a long stringy array or a long stringy length list the height of this tree in other words is log base 2 of n where n is the total number of nodes in the structure but I had to go to Great Lengths in making this slide but also in code if we were to write the code we'd actually have to jump through some hoops to make sure that when we insert numbers into this structure and when we delete numbers from this structure that everything stays nicely balanced in this way but let's consider sort of a perverse Corner case whereby the numbers you insert one after the other just happen to be an unlucky ordering for instance suppose I insert the number two first okay easy it's the root of the tree suppose then I insert the number one that's easy I I it gets to the left then I assert the number three I'm getting really really lucky so far so good that would lead to a very balanced uh tree of height log n because everything's nicely balanced but what if it's not that simple simple and indeed we have this perverse case whereby I insert the number one okay no big deal it becomes the root okay I insert the number two okay no big deal I don't have a third node yet but that's not problematic but what if the next number I insert is a three well if I want to maintain the binary search tree property that every node's left child is less than and every node's right child is greater than the value in the node I can't put three here just to keep the thing balanced like that would throw everything off so three has to go there and in your mind's eye continue this logic I insert four and then five and then six just because I get unlucky and I get the sequence of numbers or the user being difficult and giving me the worst case scenario what is my binary search tree effectively devolving into a linked list and so the catch with binary search trees is that even though if they are nicely and beautifully balanced do allow you to do binary search and Achieve log base and base and running log base 2 FN running time you have to put in some effort to ensure that it actually does in fact stay balanced so in the worst case inserting into a binary search tree could actually be linear because it just gets long and long and long and stringy with just one perverse Branch unless you're smart about it and in fact with that previous picture you know there's there's clearly a solution here like what would you do if this is what your tree was devolving into you know I'd kind of get in there and like kind of like rotate it around there so that two becomes the new rote and then one's a left child three is a right child but you can kind of Imagine from before break like oh now someone's got to implement that code and people have and that's actually a discussion for higher level algorithms classes how you can maintain balanced trees but it does involve some cleverness with the pointers and updating things and essentially rotating the tree around if it starts to get too long and stringy and so in general with binary search trees if you do make that optimization and you maintain balance it does not devolve ultimately into Big O ofan you can ensure that it stays in log ofan for not only searching about insertion and deletion as well so long as you don't just blindly stick it in but you kind of rejigger things as needed to keep things nicely balanced okay so another data structure is that of a dictionary and a dictionary is actually something with which we're all familiar within the human world whether it's in English or any other human language that Associates words with definitions you can kind of think of a dictionary as being like this two column chart whereby you've got a word on the left and its definition on the right word definition word definition turns out that this is actually a wonderfully useful data structure to have access to Beyond lists Beyond arrays Beyond trees even the ability in code to associate words with definitions or more generally what we'll call keys and values is just super useful why you can Implement a phone book as what really is a dictionary instead of thinking of it as a word and a definition think of it as a name and a number and throughout the world there's just such a common need for associating something with something else a dictionary lets you do that associate keys with values the keys are very often strings like someone's name for instance or a word the values are very often also strings or maybe numbers phone numbers or the like or even structures like persons that have not just names and numbers but email addresses and student IDs and bunches of other information as well in fact in a few weeks time when we focus on databases we'll return to this Paradigm of having keys and values to get at interesting data that we care about well where do you see these well phone books whether it's physical or virtual in a phone book of course we've got like names ideally alphabetized by first name or last name and then the value might be John Harvard's for instance actual number therein so dictionaries are sort of everywhere even though you might not in the real world think of them as such but indeed if you were to implement a phone book as a dictionary it's sort of like these two columns name and then a number um the catch though with or rather the appeal of a dictionary really is that you ideally want it to be super fast and that was the goal of the phone book too I could either do the linear search one page at a time I could do slightly more intelligently two pages at a time plus an extra step to double back if need be but log in as of week zero was like as good as it got when actually searching for information but it's what if I told you that there's maybe a way to implement this idea of a dictionary otherwise known as an abstract data type that just has keys and values but I could implement it with a data structure an actual data structure that maybe actually gives me constant time like that's sort of the Holy Grail of algorithms and data structures can you build it so cleverly that there's no dependency on N you can just get at data super super fast constant time maybe not one step maybe two or three but super super fast and that's in fact where we'll focus for the remainder of today can we find this Holy Grail of a data structure and algorithm that gives us constant time access and all we have to play with is time and space and maybe pointers and memory I think we have all of the building blocks thus far so how might we set out on this particular goal to achieve that well let me give us one new building block or ingredient which is this notion of hashing so hashing relates to what's known as a hash function and a hash function like any function takes input and produces output and the idea of a hash function ultimately is that it allows you to decide where some value goes in memory so for instance here are by Design four buckets on stage for the four uh suits of a deck of playing cards for instance so we have the Spades the hearts uh the clubs and the Diamonds here and if you had a deck of cards like 52 cards here we got the jumbo version online um how much you go about like sorting these in order from like two three four on up to Jack queen king with the ace either at the top of the bottom depending on what you prefer how could you go about sorting these well you could kind of just like you know spread them all out and start making a mess of things and figure it out and it takes some number of steps to get through all the cards but you know a lot of us myself included would probably bucke tize the values just to make the pro a big problem uh the same as like four smaller problems like give me all the hearts all the diamonds and the other two suits in separate piles and buckets is actually a term of Art in Computing to bucke tize something means to put it in put a uh an input into a a location so what do I mean by this well here we have uh the four of clubs so we'll put this in here the Queen of Clubs in here eight of spades here and as I do this of course I'm sort of making the problem smaller and smaller so that at the end of the day it's going to be easier to sort like 13 of these cards instead of all 52 so here we have the six of diamonds we have a bug so like this this like program would crash if you don't actually have a bucket for it so that's sort of an exception uh here we have another two and a 10 and even though this is still going to take me 52 steps I bet you if you timed me I could sort four buckets of 13 faster than I could sort one bucket of 52 and that's sort of the general idea bucketization helps sort of uh qu uh take an infinite or a very large domain and map it to a smaller range of values so from 52 possible inputs or 53 into four possible range values so that's actually a building block an idea that we can use and hash functions are simply math or code that does exactly that takes as input some value and spits out as output some other value but the key is that you go from a large or an infinite domain any possible number of inputs to a very well- defined finite range of values for in this case uh for instance and it turns out that if you're on board with this idea of using hash functions code or math functions that take as input this and produces output that we can actually build something that are called hash tables using that and a hash table as we're about to see is essentially like The Offspring of a half of a array and linked list together it's somehow a combination of the two so for discussion sake I'm actually going to draw an array vertically which we don't normally do but who really cares these are just artist Renditions anyway so here is an array with 26 buckets for instance and suppose that I'm implementing a hash table that I want to ultimately store names of people for instance so that I can Implement a dictionary key value pairs or more specifically a phone book so again here we see the distinction between a dictionary is this abstract data type that just has keys and values a phone book is a specific example thereof but a hashtable is one way to implement a dictionary another way to implement a dictionary would just be a really long array and you just put all the names and numbers in one long array or you use a link list you put all the names and numbers in one long list the downside of those of course is that maybe it's Big O of n maybe it's big big O of log n maybe it's Big O of n but I'm talking about constant time now I'm trying to take a step toward a data structure that maybe somehow leverages the both Best of Both Worlds arrays and Link lists and gets me closer to constant time constant time using hashing is one technique to get there so here are 26 buckets drawn vertically and let me propose that this location zero represents the letter A this location 25 represents the letter Z so depending on someone's name they're going to end up over here over here or somewhere in between like that's not all that that's not all that new but it's an incarnation of uh bucketization instead of of four buckets I've got 26 buckets and I'm going to use a person's name as input specifically the first letter of their name as input so how might this work well here I've numbered them for the sake of discussion now let's more concretely use their asky letters that correspond A through Z and suppose now that once you're on board with that model I want to insert someone like Mario into this well I think I'm going to put this at location 0er 1 2 3 4 5 6 7 8 9 10 11 12 even though it's the 13th letter it's index so Mario with an M ends up in this bucket here so to speak more specifically in this array location everything else for the moment is null then maybe we insert Luigi well L comes before M so Luigi goes in this location 11 here instead maybe then we have Peach who goes in this location here because her name starts with p instead so this actually seems like a great system so far we've got Mario Luigi Peach and maybe all of the other Nintendo characters in here ultimately how many steps does it take to look someone up it's already constant time right because if you give me Mario I just know okay M I can do the asky value trick that we did weeks ago that's 12 boom I can jump in an array with constant time to a specific location just using square brackets you give me Luigi I figure out L boom there's Luigi Peach P got it there's her number so already I seem to have a system because I'm hashing on not the suit of a card but the first letter in a name that's given to me as a string as input I can find you that name and presumably number in constant time but this is going to mess up quickly especially if you're a Nintendo fan what could go wrong with this model with 26 buckets like this yeah yeah I mean what's going to happen as soon as I have two characters whose names start with the same letter in the Nintendo Universe this is eventually surely going to happen so far I've gotten lucky with all of these other characters but I do think indeed before long I'm going to have what we're going to call Collis whereby here two L names somehow Collide and I need to deal with this in some way now one way to deal with a collision in this sense was okay I want to put it here okay Mario space is taken up I can put it where the N names would end up going but that's a little stupid because now I'm just going to make a mess of things eventually if I just resort to Randomness or first available spot and I'm definitely not going to get constant time that's going to quickly devolve into linear time because it might be all the way down here if that was the first available spot but what I could do if I keep going link for instance just added in no pun intended I could kind of Link all of the similarly named uh names together using a linked list here and so this is why I say hashtable is like an array of linked lists because here's the array it's kind of like your quick cheat sheet your buckets for getting into some of the data quickly but then if you do have collisions okay okay let's deal with it by just having any length list that can dynamically grow and even shrink as you add add or delete people from this address book here why a link list well I could use an array I could use a massive two-dimensional array but in your mind's eye you can just imagine how much space you're wasting if you're pre-allocating 26 time 26 locations here or something like that just to fill just to have enough room from the gecko for these names let me go ahead and add a whole bunch of others from the Nintendo Universe collisions are actually going to happen pretty commonly and there's actually this principle in statistics known as uh the birthday problem whereby if we surveyed everyone's uh birthday in this room essentially with a small number of people in the room we would have a very high probability of collisions and so here too even if you don't recognize some of these names pretty quickly do you end up having collisions in a world where you're just looking at for instance the first letter in someone's name so unfortunately this is not a great outcome why because imagine the perversion of this scenario suppose that we get really unlucky and every darn name in this world starts with L well it doesn't matter that you have this array and it doesn't matter matter that you're calling it a hash table at the end of the day this algorithm for a hash table could still reduce to Big O of n because in the most perverse case all n names are in the same bucket and the link list at that location so who really cares that you're calling it a a hash table you're not using 25 for instance of the locations but that's sort of a theoretical risk is that really going to happen in practice now definitely with Nintendo there's a lot of collisions here but that's because my hash function is actually pretty naive I chose a fairly simplistic hash function but maybe I could be a little more clever about that and in code I could take into account more than just the first letter so for instance if I want to get closer to this Holy Grail of constant time access let's just think a little harder and implement this data structure a little more intelligently well first and foremost it doesn't take that much effort to implement the code for this here again as we've seen for a couple of weeks now is how you might Implement a structure for a person well how might we go about implementing a hash table using type Def and struck and pointers as we've now seen well I would propose that we could Implement a node for people as having a name and a number just like always but also a pointer to the next one so in the picture you saw earlier where we had Mario and Luigi and Peach each of them was this rectangle as I drew it you can think of each of those rectangles as a person structure but in addition to having a name and somewhere in there a number there was also a little bit of space left over for the next pointer to someone else whose name starts with the same letter so implementing this in code is actually not all that hard and in fact if you want to have a hash table of size 26 no big deal just say you want a table or whatever you want to call this thing of 26 node pointers in other words that vertical that I drew had 26 locations each of those was initially null I propose because the hash table was empty but it was really a list it was an array of 26 point pointers because each of those could be the pointer to the beginning of a link list so this is how you can Implement a hash table and code sort of one line at least At a Glance you still need all of the functions to insert and uh Delete and so forth but this would really just be a hash table using all of the same ideas as in recent weeks but what if we get a little smarter indeed about the hash function so here's how we describe problem solving all this time a hash function is just sort of the algorithm in the middle in this story so if we input Mario as input the output should be 12 if we input Luigi as input the output should be 11 and so forth but if that's the problem we keep returning 12 and 11 and other such numbers a lot well let's not look at the first letter alone why don't we look at the first two the first three letters and I bet probabilistically we can drive down the probability of these collisions because there's not that many people whose names in the Nintendo Universe start with l a k or l i n or Lu UI that really lowers the probability of collision by increasing in this way the number of buckets and I haven't even drawn them all dot dot dot just means there's other combinations permutations of English letters there but I can just increase the number of buckets instead of four instead of 26 I could actually increase it to 177,000 plus if I do it in this way looking at the first three letters that would seem to really really help it doesn't make the code all that more complicated here for instance is how you might Implement in see pretty simple if naive hash function given a word AKA a string you want to return an integer like 0 or 1 or two or 11 or 12 or so forth so we've seen two upper before in the ctype library just look at the first letter in word uh convert it to uppercase just so the math is simple subtract capital A which we know is already 65 and this function as is will always return a number from 0 to 25 so you could imagine in your mind we won't do it on the screen but you could imagine just maybe looking at word zero and word one and word two and doing some similar math and returning a number between zero and roughly 17,000 instead to get back a much larger data uh much larger hash table instead what's the downside there because I'm proposing that the code's not that hard it's like a couple extra lines what's the downside of having a bigger hash table wherein much less likely to have collisions but a little louder yeah you're reserving much more space up front in fact the dot dot dots on the screen were really because I didn't want to draw a microscopic array with 177,000 locations which most of which are not actually going to get used you start wasting space at that point and it becomes a little silly because in the world of Nintendo it's a probably a pretty sparse universe so to speak whereby you don't have any names to my knowledge that start with a AA let alone a A or a a c or BBB I mean there's thousands of uh permutations that just are not going to be useful so that maybe isn't the best solution instead um as an aside you can also specify that these inputs are constant because as an optimization you know that the words coming in are not going to change and as an aside let me propose that with an actual hash function if you know the array is zero indexed you don't need to even return an in you might as well return an unsigned value so that it's zero on up no negative sign which would be an optimization here but that still doesn't change the fundamental reality that adding more complexity Beyond this is going to certainly increase it would seem the amount of memory that we actually use so maybe the pro fundamental problem is that just looking naively at the first letter in someone's name is maybe not the best solution anyway and in fact at the risk of disappointing the whole hash table even when we use three letters of a person's name you know technically speaking theoretically speaking it is still Big O of n because even though it's unlikely you could imagine a perverse scenario where all of the names you insert somehow start with the same first three letters there's no guarantee in this model that you're going to avoid that what then is the appeal of a hash table to begin with well if you've got 26 buckets or heck 17,000 buckets let's call it K as a constant well really if we get into the weeds you know if you have a uniform distribution of inputs that is to say if you have a bunch of random names that are not all perversely starting with the same letters you know technically those link lists that I described as coming out of the array are going to be probably on average n divided by K because if You' got K buckets again whether it's four or 26 or 177,000 on average hopefully each of those link lists AKA chains is going to be n divided K now we know from our discussion of Big O in the past that like if you have a constant value like a number or a lower order term like who cares that's still really big O of n but here is now in week five where we see kind of a dichotomy between the theoretical running time of an algorithm and the actual wall clock time of an algorithm like the reality is if you take the size of your data and divide it by 26 let alone 17,000 it is going to be way faster if you look at the clock on the wall or the time on your wrist than it would be if it were actually running in N steps alone so yes hash tables technically are in N divided K which is really just Big O of n but in practice if you are smart and if you are clever about the hash function you use and ideally use something that's more clever than just looking at the first letter you can probably create in the best case an a um an ideal hash function that somehow magically it would seem ensures that you never have collisions because if you can find that ideal hash function or at least a really good hash function the probability of collisions is probably going to be so low that even if occasionally the thing devolves into linear time most of the time it's going to be indeed constant time aka Big O of one so in short hash tables not really constant time but with a good hash function they can be pretty darn close to constant time but there's one final data structure we thought thought we'd introduce today this one pictorially for the most part and that's known as a try which is somehow short for retrieval even though that's pronounced somewhat differently but try just means it's a data structure for retrieving data it is an alternative data structure via which again we can Implement dat uh dictionaries key value Pairs and to be clear again you can Implement a dictionary with array a link list now a hash table now a try as well but we get different running times based on those various structures so a try is a tree of arrays you can think of it as so frankly all we're doing now is just kind of mashing together things we've already talked about and seeing what kind of weird Frankenstein data structure we come up with but in this case it's actually going to give us I think true constant time but with a downside so here's the beginning of a try and a try is indeed a tree of arrays and each of those arrays represents a letter of the alphabet typically A through Z so there let me stipulate there's 26 boxes here written horizontally because I just want it to fit on the screen more like a typical array and the way you use the arrays in a try is to have an array of pointers and if the person's name starts with a you sort of use one of those pointers to point at another node which is just another array for the second letter and then a third array for the third letter a fourth array for the fourth letter and essentially you use arrays for each of the letters in your input strings so what do I mean by that well here might be that array of size 26 A through Z suppose that we want to insert uh like Toadette into this data structure initially or maybe shorter toad for instance one of the characters from Nintendo so here is T location here and I've just highlighted it because if I have a word that starts with t I'm going to actually change this null value to be a pointer to another array and that second array shall be used to represent the second letter in this person's name like o and that letter is going to map to another array whereby this location a in toad points to finally a fourth array whereby now at the dation we have some kind of Sentinel value some kind of uh variable that says x marks the spot a name ends here so there's a way to do that in memory but we're using four arrays one for each letter to map out the person's name but we can go further suppose that there's another character in this universe like Toadette which is a super string of this string so it's a longer version thereof that's fine we can just add a pointer from the D location to another array then from that array's e location to another array then from that t location to another array and from that uh that arrays e loc from that sorry from that array's t location to a final array e so in other words each of these arrays is just an array of 26 pointers or really 26 structures of some sort and somehow in green we're just indicating that a name ends here and with the e a name ends here and we can do this again if we have Tom for instance as a third name we don't need any of these arrays we can actually encapsulate t o m in the first three of those arrays now suffice it to say this is a lot of arrays but what have we gained well if you imagine this data structure getting crazy large with lots and lots of names and lots and lots of arrays inside of it it turns out that the amount of time required to look up someone's name or to insert someone's name has no dependency on how many names are already in the structure case in point when I added Tom a moment ago there was all of this bulk in the data structure already but we didn't have to Traverse any of that because we just go t m and we don't depend on how big the data structure already is it does not depend on N technically how much time does it take to insert or to delete or to um to search for someone's name in this it would seem to depend only on the length of the person's name so t o a d e t t so I think that is eight steps total for finding Toadette four steps total for finding toad three steps total for finding Tom those are really small numbers and if you imagine there's surely some upper bound on how many characters are in the longest name in the world I don't know if it's like 10 or 20 or 50 or whatever but it is finite it has nothing to do with the total number of words in this tree in this this tree and so the implication then is that the amount of time it takes to search for to insert to delete an a name in a try is by definition constant time Big O of one maybe it's Big O of two maybe it's Big O of 50 but it's not dependent on N because as massive as this structure gets 1 2 3 1 2 3 4 1 2 3 4 5 6 7 8 that's all the steps it takes to find any of those names it's dependent only on the length of the name itself which itself which has some kind of upper bound so how might we implement this there's this is probably the most common way we just redefine a node in the world of tries to now be a structure like this that contains one in Array of 26 more pointers Each of which points to a node and then we need some other value I'm calling it charar number because I want this try to be storing people's names implicitly and numbers explicitly so if I want to store something like plus1 949 465 2750 like John Harvard's number I'm just going to store it as a string inside of the same structure so a moment ago when I had the little green dots the green dots in the array just meant that this string is not null it's someone's actual number which means if you see a non-null number well there's Toad's number there's toadette's number there's Tom's number instead this is a sufficient data structure to implement that notion of a try all we need of course is one pointer to the root of the whole darn thing and so ultimately like we found our Holy Grail like tries are by definition constant time because no matter how big the data structure gets there's no dependency on how many elements are already inside of it it has no effect on the running time per se but it must come at a cost what's the tradeoff then for a try space what what space all arays yeah the space to store all of those arrays this is like the logical extension of not using three letters of a person's name but every letter of a person's name and the math there just means a massive amount of memory because you need an array for every possible letter of the alphabet would seem even if most of those letters are not actually used because there's just no name that needs those particular letters so by significantly using more memory or space you can significantly decrease time and so that too is potentially a trade-off you may or may not want to make so today was ultimately about introducing a bit more complexity the last of our complexity in C and these building blocks of pointers and memory to sort of Stitch these things together and I'll stipulate ultimately that the kinds of data structures we've talked about today whether it's cues and stacks at the beginning or linked lists in some form or dictionaries key value pairs phone books and the like they're s sort of everywhere and even hash tables you can find in like Harvard Square or in New Haven as well for instance this is a photograph from this morning of a certain uh takeaway restaurant with which some of you might be familiar anyone know what place we're looking at Sweet green so sweet green a little salad shop in Harvard Square what are you looking at like this is a photograph of the shelves they use to distribute salads when you order them in advance online but what really is this like all your friends will be very impressed that you now see hash tables everywhere right this is effectively a hash table why because when someone has a salad with their name on it that came out of the computer they're going to put it in a specific location this is location a through e this is f through J K through n o through Z and so they're hashing it to one of these four locations not unlike one of these four buckets of course here they're not using really an array of linked lists that can grow endlessly this is is actually sort of like an array of arrays because I can only imagine storing like so many salads on this shelf and just imagine I'm sure this happens during the busiest times if you go at like 12:30 p.m. and lots of online orders have come in if they run out of space for instance in the a through e section where do they probably put the next salad even if that person's name starts with a through e you know maybe over here maybe over here like to my point earlier you can kind of just pop things anywhere and so the real world like this data structure might indeed devolve but I do dare say after today you'll start to to see hash tables and trees and tries and all of these structures in different places and hopefully what we've given you now in a CS class is sort of a mental model for the upsides and downsides of these structures but also the technical skills with which you too can build them virtually as well that's it for today and we'll see you for python next [Music]